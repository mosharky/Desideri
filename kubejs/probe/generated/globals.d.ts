class Block {
    static getMaterial(): Map<string, Internal.MaterialJS>
    static getTaggedIds(tag: ResourceLocation): Internal.List<string>
    static getBlock(id: ResourceLocation): Internal.Block
    static custom(predicate: Internal.BlockPredicate): Internal.BlockPredicate
    static getTypeList(): Internal.List<string>
    static getFacing(): Map<string, Internal.Direction>
    static id(id: ResourceLocation, properties: Map<string, object>): Internal.BlockIDPredicate
    static id(id: ResourceLocation): Internal.BlockIDPredicate
    static entity(id: ResourceLocation): Internal.BlockEntityPredicate
    get material(): Map<string, Internal.MaterialJS>;
    get typeList(): Internal.List<string>;
    get facing(): Map<string, Internal.Direction>;
}
class JsonIO {
    static writeJsonHash(stream: Internal.DataOutputStream, element: Internal.JsonElement): void
    static toPrimitive(element: Internal.JsonElement): object
    static read(path: Internal.Path): Internal.MapJS
    static getJsonHashBytes(json: Internal.JsonElement): number[]
    static parse(string: string): object
    static primitiveOf(o: object): Internal.JsonPrimitive
    static of(o: object): Internal.JsonElement
    static toArray(element: Internal.JsonElement): Internal.JsonArray
    static parseRaw(string: string): Internal.JsonElement
    static toPrettyString(json: Internal.JsonElement): string
    static toString(json: Internal.JsonElement): string
    static toObject(json: Internal.JsonElement): object
    static copy(element: Internal.JsonElement): Internal.JsonElement
    static write(path: Internal.Path, json: Internal.JsonElement): void
    static readonly GSON : Internal.Gson;
}
interface NBTIO {
    static read(path: Internal.Path): Internal.CompoundTag
    static write(path: Internal.Path, nbt: Internal.CompoundTag): void
}
declare const NBTIO: NBTIO;
class BlockPos extends Vec3i {
    compareTo(arg0: object): number
}
class Vec3 implements Internal.Position {
    hashCode(): number
    equals(arg0: object): boolean
    toString(): string
    readonly x : number;
    readonly y : number;
    readonly z : number;
}
class LootType extends Internal.Enum<LootType> {
    static valueOf(arg0: string): LootType
    static values(): LootType[]
    static readonly CHEST : LootType;
    static readonly ADVANCEMENT_ENTITY : LootType;
    static readonly GIFT : LootType;
    static readonly ENTITY : LootType;
    static readonly FISHING : LootType;
    static readonly PIGLIN_BARTER : LootType;
    static readonly BLOCK : LootType;
    static readonly UNKNOWN : LootType;
    static readonly ADVANCEMENT_REWARD : LootType;
}
class Fluid {
    static lava(): Internal.FluidStackJS
    static lava(amount: number): Internal.FluidStackJS
    static getType(id: ResourceLocation): Internal.Fluid
    static getEmpty(): Internal.FluidStackJS
    static of(o: Internal.FluidStackJS): Internal.FluidStackJS
    static of(o: Internal.FluidStackJS, amount: number, nbt: Internal.CompoundTag): Internal.FluidStackJS
    static of(o: Internal.FluidStackJS, nbt: Internal.CompoundTag): Internal.FluidStackJS
    static of(o: Internal.FluidStackJS, amount: number): Internal.FluidStackJS
    static exists(id: ResourceLocation): boolean
    static getTypes(): Internal.List<string>
    static water(amount: number): Internal.FluidStackJS
    static water(): Internal.FluidStackJS
    static readonly LAVA_ID : ResourceLocation;
    static readonly WATER_ID : ResourceLocation;
    get empty(): Internal.FluidStackJS;
    get types(): Internal.List<string>;
}
interface BlockStatePredicate {
    test(arg0: Internal.BlockState): boolean
    getBlockStates(): Internal.Collection<Internal.BlockState>
    static of(o: object): BlockStatePredicate
    getBlocks(): Internal.Collection<Internal.Block>
    static fromString(s: string): BlockStatePredicate
    check(targetStates: Internal.List<Internal.OreConfiguration$TargetBlockState>): boolean
    getBlockIds(): Internal.Set<ResourceLocation>
    asRuleTest(): Internal.RuleTest
    static ruleTestOf(o: object): Internal.RuleTest
    static readonly AIR_ID : ResourceLocation;
    get blockStates(): Internal.Collection<Internal.BlockState>;
    get blocks(): Internal.Collection<Internal.Block>;
    get blockIds(): Internal.Set<ResourceLocation>;
}
declare const BlockStatePredicate: BlockStatePredicate;
class Item {
    static clearListCache(): void
    static getList(): Internal.ListJS
    static getEmpty(): Internal.ItemStackJS
    static of(in_: Internal.ItemStackJS, count: number, nbt: Internal.CompoundTag): Internal.ItemStackJS
    static of(in_: Internal.ItemStackJS, tag: Internal.CompoundTag): Internal.ItemStackJS
    static of(in_: Internal.ItemStackJS, count: number): Internal.ItemStackJS
    static of(in_: Internal.ItemStackJS): Internal.ItemStackJS
    static getTypeList(): Internal.ListJS
    static isItem(o: object): boolean
    static findGroup(id: string): Internal.CreativeModeTab
    static getItem(id: ResourceLocation): Internal.Item
    static exists(id: ResourceLocation): boolean
    static withChance(in_: Internal.ItemStackJS, c: number): Internal.ItemStackJS
    static fireworks(properties: Map<string, object>): Internal.FireworksJS
    static withNBT(in_: Internal.ItemStackJS, nbt: Internal.CompoundTag): Internal.ItemStackJS
    get list(): Internal.ListJS;
    get empty(): Internal.ItemStackJS;
    get typeList(): Internal.ListJS;
}
interface UUID {
    static digits(sb: Internal.StringBuilder, val: number, digits: number): void
    static toString(id: Internal.UUID): string
    static fromString(o: object): Internal.UUID
}
declare const UUID: UUID;
class Ingredient {
    static customNBT(in_: Internal.IngredientJS, predicate: (arg0: Internal.CompoundTag) => boolean): Internal.IngredientJS
    static getAll(): Internal.IngredientJS
    static matchAny(objects: object): Internal.IngredientJS
    static isIngredient(o: object): boolean
    static custom(in_: Internal.IngredientJS, predicate: (arg0: Internal.ItemStackJS) => boolean): Internal.IngredientJS
    static custom(predicate: (arg0: Internal.ItemStackJS) => boolean): Internal.IngredientJS
    static of(object: object, count: number): Internal.IngredientJS
    static of(object: object): Internal.IngredientJS
    static registerCustomIngredientAction(id: string, callback: Internal.CustomIngredientActionCallback): void
    static getNone(): Internal.IngredientJS
    get all(): Internal.IngredientJS;
    get none(): Internal.IngredientJS;
}
interface NBT {
    static longArrayTag(v: number[]): net.minecraft.nbt.Tag
    static byteArrayTag(v: number[]): net.minecraft.nbt.Tag
    static b(v: number): net.minecraft.nbt.Tag
    static fromTag(t: net.minecraft.nbt.Tag): object
    static listTag(): net.minecraft.nbt.Tag
    static listTag(list: Internal.List<object>): net.minecraft.nbt.Tag
    static d(v: number): net.minecraft.nbt.Tag
    static f(v: number): net.minecraft.nbt.Tag
    static compoundTag(map: Map<string, object>): net.minecraft.nbt.Tag
    static compoundTag(): net.minecraft.nbt.Tag
    static toTag(v: object): net.minecraft.nbt.Tag
    static i(v: number): net.minecraft.nbt.Tag
    static shortTag(v: number): net.minecraft.nbt.Tag
    static l(v: number): net.minecraft.nbt.Tag
    static floatTag(v: number): net.minecraft.nbt.Tag
    static s(v: number): net.minecraft.nbt.Tag
    static la(v: number[]): net.minecraft.nbt.Tag
    static longTag(v: number): net.minecraft.nbt.Tag
    static intArrayTag(v: number[]): net.minecraft.nbt.Tag
    static ia(v: number[]): net.minecraft.nbt.Tag
    static intTag(v: number): net.minecraft.nbt.Tag
    static doubleTag(v: number): net.minecraft.nbt.Tag
    static byteTag(v: number): net.minecraft.nbt.Tag
    static stringTag(v: string): net.minecraft.nbt.Tag
    static ba(v: number[]): net.minecraft.nbt.Tag
}
declare const NBT: NBT;
class EquipmentSlot extends Internal.Enum<EquipmentSlot> {
    static valueOf(arg0: string): EquipmentSlot
    static values(): EquipmentSlot[]
    static readonly CHEST : EquipmentSlot;
    static readonly HEAD : EquipmentSlot;
    static readonly OFFHAND : EquipmentSlot;
    static readonly MAINHAND : EquipmentSlot;
    static readonly LEGS : EquipmentSlot;
    static readonly FEET : EquipmentSlot;
}
class CarvingGenerationStep extends Internal.Enum<CarvingGenerationStep> implements Internal.StringRepresentable {
    static valueOf(arg0: string): CarvingGenerationStep
    static values(): CarvingGenerationStep[]
    static readonly LIQUID : CarvingGenerationStep;
    static readonly AIR : CarvingGenerationStep;
}
class DecorationGenerationStep extends Internal.Enum<DecorationGenerationStep> {
    static valueOf(arg0: string): DecorationGenerationStep
    static values(): DecorationGenerationStep[]
    static readonly RAW_GENERATION : DecorationGenerationStep;
    static readonly UNDERGROUND_STRUCTURES : DecorationGenerationStep;
    static readonly LOCAL_MODIFICATIONS : DecorationGenerationStep;
    static readonly TOP_LAYER_MODIFICATION : DecorationGenerationStep;
    static readonly UNDERGROUND_DECORATION : DecorationGenerationStep;
    static readonly LAKES : DecorationGenerationStep;
    static readonly SURFACE_STRUCTURES : DecorationGenerationStep;
    static readonly STRONGHOLDS : DecorationGenerationStep;
    static readonly FLUID_SPRINGS : DecorationGenerationStep;
    static readonly VEGETAL_DECORATION : DecorationGenerationStep;
    static readonly UNDERGROUND_ORES : DecorationGenerationStep;
}
interface Facing {
    static readonly ALL : Map<string, Internal.Direction>;
    static readonly DOWN : Internal.Direction;
    static readonly south : Internal.Direction;
    static readonly north : Internal.Direction;
    static readonly WEST : Internal.Direction;
    static readonly down : Internal.Direction;
    static readonly east : Internal.Direction;
    static readonly NORTH : Internal.Direction;
    static readonly west : Internal.Direction;
    static readonly up : Internal.Direction;
    static readonly UP : Internal.Direction;
    static readonly SOUTH : Internal.Direction;
    static readonly EAST : Internal.Direction;
}
declare const Facing: Facing;
class Rarity {
    static readonly RARE : Rarity;
    static readonly EPIC : Rarity;
    static readonly UNCOMMON : Rarity;
    static readonly COMMON : Rarity;
    readonly rarity : Internal.Rarity;
}
interface AABB {
    static ofBlock(pos: BlockPos): Internal.AABB
    static ofSize(x: number, y: number, z: number): Internal.AABB
    static ofSize(vec3: Vec3, x: number, y: number, z: number): Internal.AABB
    static of(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.AABB
    static wrap(o: object): Internal.AABB
    static ofBlocks(pos1: BlockPos, pos2: BlockPos): Internal.AABB
    static readonly CUBE : Internal.AABB;
    static readonly EMPTY : Internal.AABB;
}
declare const AABB: AABB;
class BiomeDictionary {
    static printTags(biome: ResourceLocation): void
    static getBiomeType(o: object): Internal.BiomeDictionary$Type
    static printBiomes(type: Internal.BiomeDictionary$Type): void
    static addTypes(biomes: ResourceLocation[], tags: Internal.BiomeDictionary$Type[]): void
}
class Vec3i implements Internal.Comparable<Vec3i> {
    getX(): number
    getY(): number
    getZ(): number
    hashCode(): number
    equals(arg0: object): boolean
    toString(): string
    compareTo(arg0: object): number
    compareTo(arg0: Vec3i): number
    get x(): number;
    get y(): number;
    get z(): number;
}
class JavaMath {
    static multiplyFull(arg0: number, arg1: number): number
    static copySign(arg0: number, arg1: number): number
    static copySign(arg0: number, arg1: number): number
    static log1p(arg0: number): number
    static expm1(arg0: number): number
    static cos(arg0: number): number
    static rint(arg0: number): number
    static atan(arg0: number): number
    static nextUp(arg0: number): number
    static nextUp(arg0: number): number
    static sqrt(arg0: number): number
    static decrementExact(arg0: number): number
    static decrementExact(arg0: number): number
    static absExact(arg0: number): number
    static absExact(arg0: number): number
    static exp(arg0: number): number
    static atan2(arg0: number, arg1: number): number
    static signum(arg0: number): number
    static signum(arg0: number): number
    static tan(arg0: number): number
    static sinh(arg0: number): number
    static toDegrees(arg0: number): number
    static acos(arg0: number): number
    static ceil(arg0: number): number
    static getExponent(arg0: number): number
    static getExponent(arg0: number): number
    static addExact(arg0: number, arg1: number): number
    static addExact(arg0: number, arg1: number): number
    static multiplyHigh(arg0: number, arg1: number): number
    static ulp(arg0: number): number
    static ulp(arg0: number): number
    static scalb(arg0: number, arg1: number): number
    static scalb(arg0: number, arg1: number): number
    static floorMod(arg0: number, arg1: number): number
    static floorMod(arg0: number, arg1: number): number
    static floorMod(arg0: number, arg1: number): number
    static log(arg0: number): number
    static log10(arg0: number): number
    static nextAfter(arg0: number, arg1: number): number
    static nextAfter(arg0: number, arg1: number): number
    static multiplyExact(arg0: number, arg1: number): number
    static multiplyExact(arg0: number, arg1: number): number
    static multiplyExact(arg0: number, arg1: number): number
    static cbrt(arg0: number): number
    static random(): number
    static tanh(arg0: number): number
    static min(arg0: number, arg1: number): number
    static min(arg0: number, arg1: number): number
    static min(arg0: number, arg1: number): number
    static min(arg0: number, arg1: number): number
    static negateExact(arg0: number): number
    static negateExact(arg0: number): number
    static hypot(arg0: number, arg1: number): number
    static pow(arg0: number, arg1: number): number
    static sin(arg0: number): number
    static floor(arg0: number): number
    static subtractExact(arg0: number, arg1: number): number
    static subtractExact(arg0: number, arg1: number): number
    static max(arg0: number, arg1: number): number
    static max(arg0: number, arg1: number): number
    static max(arg0: number, arg1: number): number
    static max(arg0: number, arg1: number): number
    static toIntExact(arg0: number): number
    static nextDown(arg0: number): number
    static nextDown(arg0: number): number
    static toRadians(arg0: number): number
    static cosh(arg0: number): number
    static IEEEremainder(arg0: number, arg1: number): number
    static abs(arg0: number): number
    static abs(arg0: number): number
    static abs(arg0: number): number
    static abs(arg0: number): number
    static round(arg0: number): number
    static round(arg0: number): number
    static floorDiv(arg0: number, arg1: number): number
    static floorDiv(arg0: number, arg1: number): number
    static floorDiv(arg0: number, arg1: number): number
    static incrementExact(arg0: number): number
    static incrementExact(arg0: number): number
    static asin(arg0: number): number
    static fma(arg0: number, arg1: number, arg2: number): number
    static fma(arg0: number, arg1: number, arg2: number): number
    static readonly E : 2.718281828459045;
    static readonly PI : 3.141592653589793;
}
class Text {
    static green(text: object): Internal.Text
    static string(text: object): Internal.Text
    static darkGreen(text: object): Internal.Text
    static lightPurple(text: object): Internal.Text
    static black(text: object): Internal.Text
    static yellow(text: object): Internal.Text
    static darkBlue(text: object): Internal.Text
    static translate(key: string, objects: object[]): Internal.Text
    static translate(key: string): Internal.Text
    static darkAqua(text: object): Internal.Text
    static gold(text: object): Internal.Text
    static red(text: object): Internal.Text
    static aqua(text: object): Internal.Text
    static gray(text: object): Internal.Text
    static blue(text: object): Internal.Text
    static white(text: object): Internal.Text
    static darkRed(text: object): Internal.Text
    static keybind(keybind: string): Internal.Text
    static of(object: object): Internal.Text
    static darkGray(text: object): Internal.Text
    static darkPurple(text: object): Internal.Text
    static join(separator: Internal.Text, texts: Internal.Iterable<Internal.Text>): Internal.Text
}
class ResourceLocation implements Internal.Comparable<ResourceLocation>, Internal.SpecialEquality {
    getNamespace(): string
    hashCode(): number
    compareNamespaced(arg0: ResourceLocation): number
    equals(arg0: object): boolean
    getPath(): string
    toString(): string
    compareTo(arg0: object): number
    compareTo(arg0: ResourceLocation): number
    specialEquals(o: object, shallow: boolean): boolean
    get namespace(): string;
    get path(): string;
}
interface Utils {
    static getSystemTime(): number
    static listOrSelf(o: object): Internal.ListJS
    static getStat(id: ResourceLocation): Internal.Stat<ResourceLocation>
    static parseDouble(object: object, def: number): number
    static emptyList<T>(): Internal.List<T>
    static getRandom(): Internal.Random
    static randomOf(random: Internal.Random, objects: Internal.Collection<object>): object
    static emptyMap<K, V>(): Map<K, V>
    static copy(o: object): object
    static id(namespace: string, path: string): ResourceLocation
    static id(id: ResourceLocation): ResourceLocation
    static listOf(o: object): Internal.ListJS
    static rollChestLoot(id: ResourceLocation): Internal.ListJS
    static rollChestLoot(id: ResourceLocation, entity: Internal.EntityJS): Internal.ListJS
    static getServer(): Internal.ServerJS
    static newCountingMap(): Internal.CountingMap
    static createConsole(name: string): Internal.ConsoleJS
    static newMap(): Internal.MapJS
    static newList(): Internal.ListJS
    static getClientLevel(): Internal.LevelJS
    static parseInt(object: object, def: number): number
    static getLevel(level: Internal.Level): Internal.LevelJS
    static isWrapped(o: object): boolean
    static regex(s: object): Internal.Pattern
    static regex(pattern: string, flags: number): Internal.Pattern
    static newRandom(seed: number): Internal.Random
    static queueIO(runnable: Internal.Runnable): void
    static toTitleCase(s: string): string
    static mapOf(o: object): Internal.MapJS
    static getSound(id: ResourceLocation): Internal.SoundEvent
    get systemTime(): number;
    get random(): Internal.Random;
    get server(): Internal.ServerJS;
    get clientLevel(): Internal.LevelJS;
}
declare const Utils: Utils;
class Hand extends Internal.Enum<Hand> {
    static valueOf(arg0: string): Hand
    static values(): Hand[]
    static readonly MAIN_HAND : Hand;
    static readonly OFF_HAND : Hand;
}
class Platform {
    static isDevelopmentEnvironment(): boolean
    static isClientEnvironment(): boolean
    static getName(): string
    static getInfo(modID: string): Internal.PlatformWrapper$ModInfo
    static getMods(): Map<string, Internal.PlatformWrapper$ModInfo>
    static getList(): Internal.Set<string>
    static isForge(): boolean
    static getModVersion(): string
    static isLoaded(modId: string): boolean
    static getMcVersion(): string
    static isFabric(): boolean
    get name(): string;
    get mods(): Map<string, Internal.PlatformWrapper$ModInfo>;
    get list(): Internal.Set<string>;
    get modVersion(): string;
    get mcVersion(): string;
}
interface Color {
    static rgba(r: number, g: number, b: number, a: number): Internal.Color
    static of(o: object): Internal.Color
    static createMapped(o: object, names: string[]): Internal.Color
    static readonly BLUE_DYE : Internal.Color;
    static readonly GOLD : Internal.Color;
    static readonly GRAY : Internal.Color;
    static readonly MAGENTA_DYE : Internal.Color;
    static readonly BLUE : Internal.Color;
    static readonly DARK_AQUA : Internal.Color;
    static readonly TEXT : Map<string, Internal.ChatFormatting>;
    static readonly DYE : Map<string, Internal.DyeColor>;
    static readonly WHITE_DYE : Internal.Color;
    static readonly DARK_RED : Internal.Color;
    static readonly LIGHT_PURPLE : Internal.Color;
    static readonly BROWN_DYE : Internal.Color;
    static readonly BLACK : Internal.Color;
    static readonly GRAY_DYE : Internal.Color;
    static readonly NONE : Internal.Color;
    static readonly LIGHT_BLUE_DYE : Internal.Color;
    static readonly AQUA : Internal.Color;
    static readonly WHITE : Internal.Color;
    static readonly LIGHT_GRAY_DYE : Internal.Color;
    static readonly BLACK_DYE : Internal.Color;
    static readonly RED_DYE : Internal.Color;
    static readonly PURPLE_DYE : Internal.Color;
    static readonly GREEN_DYE : Internal.Color;
    static readonly PINK_DYE : Internal.Color;
    static readonly DARK_BLUE : Internal.Color;
    static readonly GREEN : Internal.Color;
    static readonly CYAN_DYE : Internal.Color;
    static readonly RED : Internal.Color;
    static readonly DARK_PURPLE : Internal.Color;
    static readonly ORANGE_DYE : Internal.Color;
    static readonly YELLOW_DYE : Internal.Color;
    static readonly DARK_GREEN : Internal.Color;
    static readonly YELLOW : Internal.Color;
    static readonly LIME_DYE : Internal.Color;
    static readonly DARK_GRAY : Internal.Color;
    static readonly MAP : Map<string, Internal.Color>;
}
declare const Color: Color;
namespace me.jellysquid.mods.lithium.mixin.ai.nearby_entity_tracking {
    interface ServerWorldAccessor {
        getEntityManager(): Internal.PersistentEntitySectionManager<Internal.Entity>
        get entityManager(): Internal.PersistentEntitySectionManager<Internal.Entity>;
    }
}
namespace Internal {
    interface FilenameFilter {
        accept(arg0: Internal.File, arg1: string): boolean
    }
    class LocalPlayer extends Internal.AbstractClientPlayer {
        updateSyncFields(arg0: Internal.LocalPlayer): void
        handler$bfk000$noSwimmingWithHeavyBootsOn(arg0: Internal.CallbackInfoReturnable<any>): void
        backpackedMoved : boolean;
        backpackedInventory : Internal.BackpackInventory;
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
    }
    class Exception extends Internal.Throwable {
    }
    class AccessMode extends Internal.Enum<Internal.AccessMode> {
        static valueOf(arg0: string): Internal.AccessMode
        static values(): Internal.AccessMode[]
        static readonly READ : Internal.AccessMode;
        static readonly EXECUTE : Internal.AccessMode;
        static readonly WRITE : Internal.AccessMode;
    }
    interface MatchResult {
        groupCount(): number
        start(arg0: number): number
        start(): number
        end(arg0: number): number
        end(): number
        group(): string
        group(arg0: number): string
    }
    interface ItemHandler implements Internal.Iterable<Internal.ItemStack> {
        getHeight(): number
        iterator(): Internal.Iterator<Internal.ItemStack>
        spliterator(): Internal.Spliterator<T>
        extractItem(arg0: number, arg1: number, arg2: boolean): Internal.ItemStack
        forEach(arg0: (arg0: T) => void): void
        getSlotLimit(arg0: number): number
        isItemValid(arg0: number, arg1: Internal.ItemStack): boolean
        getStackInSlot(arg0: number): Internal.ItemStack
        getWidth(): number
        getSlots(): number
        insertItem(arg0: number, arg1: Internal.ItemStack, arg2: boolean): Internal.ItemStack
        get height(): number;
        get width(): number;
        get slots(): number;
    }
    interface Int2FloatFunction implements Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: Internal.Float2ShortFunction): Internal.Int2ShortFunction
        composeByte(arg0: Internal.Byte2IntFunction): Internal.Byte2FloatFunction
        andThenInt(arg0: Internal.Float2IntFunction): Internal.Int2IntFunction
        composeReference<T>(arg0: Internal.Reference2IntFunction<T>): Internal.Reference2FloatFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Float2DoubleFunction): Internal.Int2DoubleFunction
        andThenObject<T>(arg0: Internal.Float2ObjectFunction<T>): Internal.Int2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Float2LongFunction): Internal.Int2LongFunction
        composeLong(arg0: Internal.Long2IntFunction): Internal.Long2FloatFunction
        andThenByte(arg0: Internal.Float2ByteFunction): Internal.Int2ByteFunction
        andThenFloat(arg0: Internal.Float2FloatFunction): Internal.Int2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2IntFunction): Internal.Int2FloatFunction
        clear(): void
        composeFloat(arg0: Internal.Float2IntFunction): Internal.Float2FloatFunction
        andThenChar(arg0: Internal.Float2CharFunction): Internal.Int2CharFunction
        composeObject<T>(arg0: Internal.Object2IntFunction<T>): Internal.Object2FloatFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2IntFunction): Internal.Short2FloatFunction
        andThenReference<T>(arg0: Internal.Float2ReferenceFunction<T>): Internal.Int2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2IntFunction): Internal.Char2FloatFunction
        composeDouble(arg0: Internal.Double2IntFunction): Internal.Double2FloatFunction
    }
    class Products$P7 <F, T1, T2, T3, T4, T5, T6, T7> {
        t4(): Internal.App<F, T4>
        t5(): Internal.App<F, T5>
        t6(): Internal.App<F, T6>
        t7(): Internal.App<F, T7>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, Internal.Function7<T1, T2, T3, T4, T5, T6, T7, R>>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.Function7<T1, T2, T3, T4, T5, T6, T7, R>): Internal.App<F, R>
        and<T8>(arg0: Internal.App<F, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        t1(): Internal.App<F, T1>
        t2(): Internal.App<F, T2>
        t3(): Internal.App<F, T3>
    }
    interface LongUnaryOperator {
        applyAsLong(arg0: number): number
        compose(arg0: Internal.LongUnaryOperator): Internal.LongUnaryOperator
        static identity(): Internal.LongUnaryOperator
        andThen(arg0: Internal.LongUnaryOperator): Internal.LongUnaryOperator
    }
    class RuntimeException extends Internal.Exception {
    }
    class VariantBlockStateGenerator$Model {
        toJson(): Internal.JsonObject
        uvlock(): Internal.VariantBlockStateGenerator$Model
        x(_x: number): Internal.VariantBlockStateGenerator$Model
        y(_y: number): Internal.VariantBlockStateGenerator$Model
        model(s: string): Internal.VariantBlockStateGenerator$Model
    }
    interface AsynchronousChannel implements java_.nio.channels.Channel {
        isOpen(): boolean
        close(): void
    }
    class EntityPredicateBuilderJS implements Internal.ExtendedEntityFlagsPredicate$IBuilder<Internal.EntityPredicate> {
        isBaby(arg0: boolean): Internal.EntityPredicateBuilderJS
        isBaby(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>
        nbt(arg0: Internal.CompoundTag): Internal.EntityPredicateBuilderJS
        isIllegarMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>
        isIllegarMob(arg0: boolean): Internal.EntityPredicateBuilderJS
        isSwimming(arg0: boolean): Internal.EntityPredicateBuilderJS
        isSwimming(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>
        isInWater(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>
        isInWater(arg0: boolean): Internal.EntityPredicateBuilderJS
        anyType(arg0: string[]): Internal.EntityPredicateBuilderJS
        isWaterMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>
        isWaterMob(arg0: boolean): Internal.EntityPredicateBuilderJS
        isCrouching(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>
        isCrouching(arg0: boolean): Internal.EntityPredicateBuilderJS
        isUnderWater(arg0: boolean): Internal.EntityPredicateBuilderJS
        isUnderWater(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>
        isSprinting(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>
        isSprinting(arg0: boolean): Internal.EntityPredicateBuilderJS
        catType(arg0: ResourceLocation): Internal.EntityPredicateBuilderJS
        isUndeadMob(arg0: boolean): Internal.EntityPredicateBuilderJS
        isUndeadMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>
        matchFluid(arg0: string): Internal.EntityPredicateBuilderJS
        isCreature(arg0: boolean): Internal.EntityPredicateBuilderJS
        isCreature(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>
        build(): Internal.EntityPredicate
        build(): object
        isMonster(arg0: boolean): Internal.EntityPredicateBuilderJS
        isMonster(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>
        isOnFire(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>
        isOnFire(arg0: boolean): Internal.EntityPredicateBuilderJS
        matchMount(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.EntityPredicateBuilderJS
        matchBlock(arg0: string, arg1: Map<string, string>): Internal.EntityPredicateBuilderJS
        matchBlock(arg0: string): Internal.EntityPredicateBuilderJS
        isOnGround(arg0: boolean): Internal.EntityPredicateBuilderJS
        isOnGround(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>
        isArthropodMob(arg0: boolean): Internal.EntityPredicateBuilderJS
        isArthropodMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>
        matchSlot(arg0: EquipmentSlot, arg1: Internal.IngredientJS): Internal.EntityPredicateBuilderJS
        hasEffect(arg0: Internal.MobEffect, arg1: number): Internal.EntityPredicateBuilderJS
        hasEffect(arg0: Internal.MobEffect): Internal.EntityPredicateBuilderJS
        matchTargetedEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.EntityPredicateBuilderJS
    }
    class DirectMethodHandleDesc$Kind extends Internal.Enum<Internal.DirectMethodHandleDesc$Kind> {
        static valueOf(arg0: number, arg1: boolean): Internal.DirectMethodHandleDesc$Kind
        static valueOf(arg0: string): Internal.DirectMethodHandleDesc$Kind
        static valueOf(arg0: number): Internal.DirectMethodHandleDesc$Kind
        static values(): Internal.DirectMethodHandleDesc$Kind[]
        static readonly INTERFACE_SPECIAL : Internal.DirectMethodHandleDesc$Kind;
        readonly refKind : number;
        static readonly SETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly SPECIAL : Internal.DirectMethodHandleDesc$Kind;
        static readonly STATIC : Internal.DirectMethodHandleDesc$Kind;
        static readonly GETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly STATIC_GETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly INTERFACE_VIRTUAL : Internal.DirectMethodHandleDesc$Kind;
        static readonly STATIC_SETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly CONSTRUCTOR : Internal.DirectMethodHandleDesc$Kind;
        readonly isInterface : boolean;
        static readonly INTERFACE_STATIC : Internal.DirectMethodHandleDesc$Kind;
        static readonly VIRTUAL : Internal.DirectMethodHandleDesc$Kind;
    }
    interface Comparator <T> {
        static comparingDouble<T>(arg0: Internal.ToDoubleFunction<T>): Internal.Comparator<T>
        static naturalOrder<T>(): Internal.Comparator<T>
        compare(arg0: T, arg1: T): number
        thenComparingInt(arg0: Internal.ToIntFunction<T>): Internal.Comparator<T>
        static comparingLong<T>(arg0: Internal.ToLongFunction<T>): Internal.Comparator<T>
        thenComparingDouble(arg0: Internal.ToDoubleFunction<T>): Internal.Comparator<T>
        static reverseOrder<T>(): Internal.Comparator<T>
        static comparing<T, U>(arg0: (arg0: T) => U): Internal.Comparator<T>
        static comparing<T, U>(arg0: (arg0: T) => U, arg1: Internal.Comparator<U>): Internal.Comparator<T>
        thenComparingLong(arg0: Internal.ToLongFunction<T>): Internal.Comparator<T>
        static nullsLast<T>(arg0: Internal.Comparator<T>): Internal.Comparator<T>
        thenComparing(arg0: Internal.Comparator<T>): Internal.Comparator<T>
        thenComparing<U>(arg0: (arg0: T) => U, arg1: Internal.Comparator<U>): Internal.Comparator<T>
        thenComparing<U>(arg0: (arg0: T) => U): Internal.Comparator<T>
        equals(arg0: object): boolean
        static comparingInt<T>(arg0: Internal.ToIntFunction<T>): Internal.Comparator<T>
        static nullsFirst<T>(arg0: Internal.Comparator<T>): Internal.Comparator<T>
        reversed(): Internal.Comparator<T>
    }
    interface RecipeSerializer <T> implements Internal.IForgeRegistryEntry<Internal.RecipeSerializer<object>> {
        getRegistryType(): Internal.Class<V>
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): V
        get registryType(): Internal.Class<V>;
        get registryName(): ResourceLocation;
        set registryName(arg0: ResourceLocation);
    }
    class AbstractObjectCollection <K> extends Internal.AbstractCollection<K> implements Internal.ObjectCollection<K> {
        iterator(): Internal.ObjectIterator<K>
        iterator(): Internal.Iterator<any>
        spliterator(): Internal.ObjectSpliterator<K>
        spliterator(): Internal.Spliterator<any>
        toString(): string
    }
    class ImmutableMultimap$Builder <K, V> {
        orderKeysBy(arg0: Internal.Comparator<K>): Internal.ImmutableMultimap$Builder<K, V>
        build(): Internal.ImmutableMultimap<K, V>
        orderValuesBy(arg0: Internal.Comparator<V>): Internal.ImmutableMultimap$Builder<K, V>
        putAll(arg0: Internal.Multimap<K, V>): Internal.ImmutableMultimap$Builder<K, V>
        putAll(arg0: K, arg1: V[]): Internal.ImmutableMultimap$Builder<K, V>
        putAll(arg0: K, arg1: Internal.Iterable<V>): Internal.ImmutableMultimap$Builder<K, V>
        putAll(arg0: Internal.Iterable<Internal.Map$Entry<K, V>>): Internal.ImmutableMultimap$Builder<K, V>
        put(arg0: Internal.Map$Entry<K, V>): Internal.ImmutableMultimap$Builder<K, V>
        put(arg0: K, arg1: V): Internal.ImmutableMultimap$Builder<K, V>
    }
    interface IFluidHandler {
        getFluidInTank(arg0: number): Internal.FluidStack
        getTankCapacity(arg0: number): number
        fill(arg0: Internal.FluidStack, arg1: Internal.IFluidHandler$FluidAction): number
        getTanks(): number
        isFluidValid(arg0: number, arg1: Internal.FluidStack): boolean
        drain(arg0: number, arg1: Internal.IFluidHandler$FluidAction): Internal.FluidStack
        drain(arg0: Internal.FluidStack, arg1: Internal.IFluidHandler$FluidAction): Internal.FluidStack
        get tanks(): number;
    }
    interface LevelWriter {
    }
    class WrapFactory {
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, javaObject: object, staticType: Internal.Class<object>): Internal.Scriptable
        wrapJavaClass(cx: Internal.Context, scope: Internal.Scriptable, javaClass: Internal.Class<object>): Internal.Scriptable
        setJavaPrimitiveWrap(value: boolean): void
        isJavaPrimitiveWrap(): boolean
        wrapNewObject(cx: Internal.Context, scope: Internal.Scriptable, obj: object): Internal.Scriptable
        wrap(cx: Internal.Context, scope: Internal.Scriptable, obj: object, staticType: Internal.Class<object>): object
        set javaPrimitiveWrap(value: boolean);
    }
    class CompletableFuture <T> implements Internal.Future<T>, Internal.CompletionStage<T> {
        cancel(arg0: boolean): boolean
        obtrudeValue(arg0: T): void
        exceptionallyAsync(arg0: java_.util.function_.Function<any, any>, arg1: Internal.Executor): Internal.CompletionStage<any>
        exceptionallyAsync(arg0: (arg0: Internal.Throwable) => T, arg1: Internal.Executor): Internal.CompletableFuture<T>
        exceptionallyAsync(arg0: (arg0: Internal.Throwable) => T): Internal.CompletableFuture<T>
        exceptionallyAsync(arg0: java_.util.function_.Function<any, any>): Internal.CompletionStage<any>
        static failedStage<U>(arg0: Internal.Throwable): Internal.CompletionStage<U>
        runAfterBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletionStage<any>
        runAfterBothAsync(arg0: Internal.CompletionStage<object>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletableFuture<void>
        runAfterBothAsync(arg0: Internal.CompletionStage<object>, arg1: Internal.Runnable): Internal.CompletableFuture<void>
        runAfterBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<any>
        obtrudeException(arg0: Internal.Throwable): void
        thenAcceptBoth(arg0: Internal.CompletionStage<any>, arg1: Internal.BiConsumer<any, any>): Internal.CompletionStage<any>
        thenAcceptBoth<U>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => void): Internal.CompletableFuture<void>
        exceptionallyCompose(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>): Internal.CompletableFuture<T>
        exceptionallyCompose(arg0: java_.util.function_.Function<any, any>): Internal.CompletionStage<any>
        join(): T
        isCompletedExceptionally(): boolean
        applyToEither(arg0: Internal.CompletionStage<any>, arg1: java_.util.function_.Function<any, any>): Internal.CompletionStage<any>
        applyToEither<U>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U): Internal.CompletableFuture<U>
        completeAsync(arg0: () => T, arg1: Internal.Executor): Internal.CompletableFuture<T>
        completeAsync(arg0: () => T): Internal.CompletableFuture<T>
        thenApply<U>(arg0: (arg0: T) => U): Internal.CompletableFuture<U>
        thenApply(arg0: java_.util.function_.Function<any, any>): Internal.CompletionStage<any>
        thenRun(arg0: Internal.Runnable): Internal.CompletionStage<any>
        thenRun(arg0: Internal.Runnable): Internal.CompletableFuture<void>
        orTimeout(arg0: number, arg1: Internal.TimeUnit): Internal.CompletableFuture<T>
        getNow(arg0: T): T
        exceptionally(arg0: (arg0: Internal.Throwable) => T): Internal.CompletableFuture<T>
        exceptionally(arg0: java_.util.function_.Function<any, any>): Internal.CompletionStage<any>
        handle(arg0: Internal.BiFunction<any, any, any>): Internal.CompletionStage<any>
        handle<U>(arg0: (arg0: T, arg1: Internal.Throwable) => U): Internal.CompletableFuture<U>
        thenCompose(arg0: java_.util.function_.Function<any, any>): Internal.CompletionStage<any>
        thenCompose<U>(arg0: (arg0: T) => Internal.CompletionStage<U>): Internal.CompletableFuture<U>
        static failedFuture<U>(arg0: Internal.Throwable): Internal.CompletableFuture<U>
        thenCombineAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.BiFunction<any, any, any>, arg2: Internal.Executor): Internal.CompletionStage<any>
        thenCombineAsync<U, V>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => V, arg2: Internal.Executor): Internal.CompletableFuture<V>
        thenCombineAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.BiFunction<any, any, any>): Internal.CompletionStage<any>
        thenCombineAsync<U, V>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => V): Internal.CompletableFuture<V>
        static completedFuture<U>(arg0: U): Internal.CompletableFuture<U>
        getNumberOfDependents(): number
        whenCompleteAsync(arg0: (arg0: T, arg1: Internal.Throwable) => void): Internal.CompletableFuture<T>
        whenCompleteAsync(arg0: Internal.BiConsumer<any, any>): Internal.CompletionStage<any>
        whenCompleteAsync(arg0: (arg0: T, arg1: Internal.Throwable) => void, arg1: Internal.Executor): Internal.CompletableFuture<T>
        whenCompleteAsync(arg0: Internal.BiConsumer<any, any>, arg1: Internal.Executor): Internal.CompletionStage<any>
        toCompletableFuture(): Internal.CompletableFuture<T>
        thenApplyAsync<U>(arg0: (arg0: T) => U): Internal.CompletableFuture<U>
        thenApplyAsync(arg0: java_.util.function_.Function<any, any>): Internal.CompletionStage<any>
        thenApplyAsync<U>(arg0: (arg0: T) => U, arg1: Internal.Executor): Internal.CompletableFuture<U>
        thenApplyAsync(arg0: java_.util.function_.Function<any, any>, arg1: Internal.Executor): Internal.CompletionStage<any>
        thenAcceptAsync(arg0: Internal.Consumer<any>, arg1: Internal.Executor): Internal.CompletionStage<any>
        thenAcceptAsync(arg0: (arg0: T) => void, arg1: Internal.Executor): Internal.CompletableFuture<void>
        thenAcceptAsync(arg0: Internal.Consumer<any>): Internal.CompletionStage<any>
        thenAcceptAsync(arg0: (arg0: T) => void): Internal.CompletableFuture<void>
        static runAsync(arg0: Internal.Runnable, arg1: Internal.Executor): Internal.CompletableFuture<void>
        static runAsync(arg0: Internal.Runnable): Internal.CompletableFuture<void>
        thenRunAsync(arg0: Internal.Runnable): Internal.CompletionStage<any>
        thenRunAsync(arg0: Internal.Runnable): Internal.CompletableFuture<void>
        thenRunAsync(arg0: Internal.Runnable, arg1: Internal.Executor): Internal.CompletableFuture<void>
        thenRunAsync(arg0: Internal.Runnable, arg1: Internal.Executor): Internal.CompletionStage<any>
        static allOf(arg0: Internal.CompletableFuture<object>[]): Internal.CompletableFuture<void>
        applyToEitherAsync<U>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U): Internal.CompletableFuture<U>
        applyToEitherAsync(arg0: Internal.CompletionStage<any>, arg1: java_.util.function_.Function<any, any>): Internal.CompletionStage<any>
        applyToEitherAsync<U>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U, arg2: Internal.Executor): Internal.CompletableFuture<U>
        applyToEitherAsync(arg0: Internal.CompletionStage<any>, arg1: java_.util.function_.Function<any, any>, arg2: Internal.Executor): Internal.CompletionStage<any>
        newIncompleteFuture<U>(): Internal.CompletableFuture<U>
        acceptEitherAsync(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void): Internal.CompletableFuture<void>
        acceptEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Consumer<any>): Internal.CompletionStage<any>
        acceptEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Consumer<any>, arg2: Internal.Executor): Internal.CompletionStage<any>
        acceptEitherAsync(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void, arg2: Internal.Executor): Internal.CompletableFuture<void>
        runAfterEitherAsync(arg0: Internal.CompletionStage<object>, arg1: Internal.Runnable): Internal.CompletableFuture<void>
        runAfterEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<any>
        runAfterEitherAsync(arg0: Internal.CompletionStage<object>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletableFuture<void>
        runAfterEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletionStage<any>
        acceptEither(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void): Internal.CompletableFuture<void>
        acceptEither(arg0: Internal.CompletionStage<any>, arg1: Internal.Consumer<any>): Internal.CompletionStage<any>
        get(): T
        get(arg0: number, arg1: Internal.TimeUnit): T
        copy(): Internal.CompletableFuture<T>
        runAfterEither(arg0: Internal.CompletionStage<object>, arg1: Internal.Runnable): Internal.CompletableFuture<void>
        runAfterEither(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<any>
        thenComposeAsync(arg0: java_.util.function_.Function<any, any>): Internal.CompletionStage<any>
        thenComposeAsync<U>(arg0: (arg0: T) => Internal.CompletionStage<U>): Internal.CompletableFuture<U>
        thenComposeAsync<U>(arg0: (arg0: T) => Internal.CompletionStage<U>, arg1: Internal.Executor): Internal.CompletableFuture<U>
        thenComposeAsync(arg0: java_.util.function_.Function<any, any>, arg1: Internal.Executor): Internal.CompletionStage<any>
        thenAccept(arg0: (arg0: T) => void): Internal.CompletableFuture<void>
        thenAccept(arg0: Internal.Consumer<any>): Internal.CompletionStage<any>
        isCancelled(): boolean
        runAfterBoth(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<any>
        runAfterBoth(arg0: Internal.CompletionStage<object>, arg1: Internal.Runnable): Internal.CompletableFuture<void>
        static anyOf(arg0: Internal.CompletableFuture<object>[]): Internal.CompletableFuture<object>
        defaultExecutor(): Internal.Executor
        completeOnTimeout(arg0: T, arg1: number, arg2: Internal.TimeUnit): Internal.CompletableFuture<T>
        handleAsync<U>(arg0: (arg0: T, arg1: Internal.Throwable) => U): Internal.CompletableFuture<U>
        handleAsync(arg0: Internal.BiFunction<any, any, any>): Internal.CompletionStage<any>
        handleAsync<U>(arg0: (arg0: T, arg1: Internal.Throwable) => U, arg1: Internal.Executor): Internal.CompletableFuture<U>
        handleAsync(arg0: Internal.BiFunction<any, any, any>, arg1: Internal.Executor): Internal.CompletionStage<any>
        static supplyAsync<U>(arg0: () => U): Internal.CompletableFuture<U>
        static supplyAsync<U>(arg0: () => U, arg1: Internal.Executor): Internal.CompletableFuture<U>
        completeExceptionally(arg0: Internal.Throwable): boolean
        isDone(): boolean
        thenAcceptBothAsync<U>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => void, arg2: Internal.Executor): Internal.CompletableFuture<void>
        thenAcceptBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.BiConsumer<any, any>, arg2: Internal.Executor): Internal.CompletionStage<any>
        thenAcceptBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.BiConsumer<any, any>): Internal.CompletionStage<any>
        thenAcceptBothAsync<U>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => void): Internal.CompletableFuture<void>
        whenComplete(arg0: (arg0: T, arg1: Internal.Throwable) => void): Internal.CompletableFuture<T>
        whenComplete(arg0: Internal.BiConsumer<any, any>): Internal.CompletionStage<any>
        static delayedExecutor(arg0: number, arg1: Internal.TimeUnit): Internal.Executor
        static delayedExecutor(arg0: number, arg1: Internal.TimeUnit, arg2: Internal.Executor): Internal.Executor
        exceptionallyComposeAsync(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>, arg1: Internal.Executor): Internal.CompletableFuture<T>
        exceptionallyComposeAsync(arg0: java_.util.function_.Function<any, any>, arg1: Internal.Executor): Internal.CompletionStage<any>
        exceptionallyComposeAsync(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>): Internal.CompletableFuture<T>
        exceptionallyComposeAsync(arg0: java_.util.function_.Function<any, any>): Internal.CompletionStage<any>
        thenCombine(arg0: Internal.CompletionStage<any>, arg1: Internal.BiFunction<any, any, any>): Internal.CompletionStage<any>
        thenCombine<U, V>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => V): Internal.CompletableFuture<V>
        toString(): string
        minimalCompletionStage(): Internal.CompletionStage<T>
        complete(arg0: T): boolean
        static completedStage<U>(arg0: U): Internal.CompletionStage<U>
        get numberOfDependents(): number;
    }
    interface Type {
        getTypeName(): string
        get typeName(): string;
    }
    class PrintStream extends Internal.FilterOutputStream implements Internal.Appendable, Internal.Closeable {
        print(arg0: boolean): void
        print(arg0: string): void
        print(arg0: string[]): void
        print(arg0: number): void
        print(arg0: number): void
        print(arg0: number): void
        print(arg0: string): void
        print(arg0: number): void
        print(arg0: object): void
        println(arg0: string): void
        println(arg0: object): void
        println(arg0: number): void
        println(arg0: number): void
        println(arg0: string[]): void
        println(arg0: boolean): void
        println(): void
        println(arg0: string): void
        println(arg0: number): void
        println(arg0: number): void
        writeBytes(arg0: number[]): void
        flush(): void
        format(arg0: string, arg1: object[]): Internal.PrintStream
        format(arg0: Internal.Locale, arg1: string, arg2: object[]): Internal.PrintStream
        checkError(): boolean
        close(): void
        write(arg0: number[], arg1: number, arg2: number): void
        write(arg0: number): void
        write(arg0: number[]): void
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.PrintStream
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.PrintStream
        append(arg0: string): Internal.Appendable
        append(arg0: string): Internal.PrintStream
        printf(arg0: Internal.Locale, arg1: string, arg2: object[]): Internal.PrintStream
        printf(arg0: string, arg1: object[]): Internal.PrintStream
    }
    interface Reference2IntFunction <K> implements Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: number): number
        andThenShort(arg0: Internal.Int2ShortFunction): Internal.Reference2ShortFunction<K>
        composeByte(arg0: Internal.Byte2ReferenceFunction<K>): Internal.Byte2IntFunction
        andThenInt(arg0: Internal.Int2IntFunction): Internal.Reference2IntFunction<K>
        composeReference<T>(arg0: (arg0: T) => K): Internal.Reference2IntFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: K) => T
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: object, arg1: object): object
        remove(arg0: object): number
        remove(arg0: object): object
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: Internal.Int2DoubleFunction): Internal.Reference2DoubleFunction<K>
        andThenObject<T>(arg0: Internal.Int2ObjectFunction<T>): (arg0: K) => T
        get(arg0: object): object
        get(arg0: object): number
        andThenLong(arg0: Internal.Int2LongFunction): Internal.Reference2LongFunction<K>
        composeLong(arg0: Internal.Long2ReferenceFunction<K>): Internal.Long2IntFunction
        andThenByte(arg0: Internal.Int2ByteFunction): Internal.Reference2ByteFunction<K>
        andThenFloat(arg0: Internal.Int2FloatFunction): Internal.Reference2FloatFunction<K>
        applyAsInt(arg0: K): number
        removeInt(arg0: object): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ReferenceFunction<K>): Internal.Int2IntFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ReferenceFunction<K>): Internal.Float2IntFunction
        andThenChar(arg0: Internal.Int2CharFunction): Internal.Reference2CharFunction<K>
        getInt(arg0: object): number
        composeObject<T>(arg0: (arg0: T) => K): Internal.Object2IntFunction<T>
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ReferenceFunction<K>): Internal.Short2IntFunction
        andThenReference<T>(arg0: Internal.Int2ReferenceFunction<T>): (arg0: K) => T
        composeChar(arg0: Internal.Char2ReferenceFunction<K>): Internal.Char2IntFunction
        composeDouble(arg0: Internal.Double2ReferenceFunction<K>): Internal.Double2IntFunction
    }
    class SimpleJsonResourceReloadListener extends Internal.SimplePreparableReloadListener<Map<ResourceLocation, Internal.JsonElement>> {
    }
    class EventObject implements Internal.Serializable {
        getSource(): object
        toString(): string
        get source(): object;
    }
    class CommandSourceStack implements Internal.SharedSuggestionProvider, Internal.IForgeCommandSourceStack {
        getAdvancement(arg0: ResourceLocation): Internal.Advancement
        getRecipeManager(): Internal.RecipeManager
        getUnsidedLevel(): Internal.Level
        getScoreboard(): Internal.Scoreboard
        get recipeManager(): Internal.RecipeManager;
        get unsidedLevel(): Internal.Level;
        get scoreboard(): Internal.Scoreboard;
    }
    interface Int2IntMap implements Internal.Int2IntFunction, Map<number, number> {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        getOrDefault(arg0: object, arg1: number): number
        replace(arg0: number, arg1: number, arg2: number): boolean
        replace(arg0: number, arg1: number, arg2: number): boolean
        replace(arg0: number, arg1: number): number
        replace(arg0: number, arg1: number): number
        replace(arg0: object, arg1: object): object
        replace(arg0: object, arg1: object, arg2: object): boolean
        composeByte(arg0: Internal.Byte2IntFunction): Internal.Byte2IntFunction
        composeReference<T>(arg0: Internal.Reference2IntFunction<T>): Internal.Reference2IntFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        containsValue(arg0: number): boolean
        containsValue(arg0: object): boolean
        put(arg0: number, arg1: number): number
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        mergeInt(arg0: number, arg1: number, arg2: Internal.IntBinaryOperator): number
        mergeInt(arg0: number, arg1: number, arg2: java_.util.function_.IntBinaryOperator): number
        compute(arg0: object, arg1: Internal.BiFunction<any, any, any>): object
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenObject<T>(arg0: Internal.Int2ObjectFunction<T>): Internal.Int2ObjectFunction<T>
        merge(arg0: object, arg1: object, arg2: Internal.BiFunction<any, any, any>): object
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number
        composeLong(arg0: Internal.Long2IntFunction): Internal.Long2IntFunction
        applyAsInt(arg0: number): number
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, number>>
        entrySet(): Internal.Set<any>
        containsKey(arg0: number): boolean
        containsKey(arg0: object): boolean
        composeObject<T>(arg0: Internal.Object2IntFunction<T>): Internal.Object2IntFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2IntFunction): Internal.Short2IntFunction
        composeChar(arg0: Internal.Char2IntFunction): Internal.Char2IntFunction
        composeDouble(arg0: Internal.Double2IntFunction): Internal.Double2IntFunction
        computeIfAbsent(arg0: number, arg1: Internal.IntUnaryOperator): number
        computeIfAbsent(arg0: object, arg1: java_.util.function_.Function<any, any>): object
        computeIfAbsent(arg0: number, arg1: (arg0: number) => number): number
        computeIfAbsent(arg0: number, arg1: Internal.Int2IntFunction): number
        values(): Internal.Collection<any>
        values(): Internal.IntCollection
        andThenShort(arg0: Internal.Int2ShortFunction): Internal.Int2ShortFunction
        computeIfAbsentPartial(arg0: number, arg1: Internal.Int2IntFunction): number
        replaceAll(arg0: (arg0: K, arg1: V) => V): void
        andThenInt(arg0: Internal.Int2IntFunction): Internal.Int2IntFunction
        remove(arg0: number, arg1: number): boolean
        remove(arg0: object): object
        remove(arg0: object): number
        remove(arg0: object, arg1: object): boolean
        remove(arg0: number): number
        int2IntEntrySet(): Internal.ObjectSet<Internal.Int2IntMap$Entry>
        andThenDouble(arg0: Internal.Int2DoubleFunction): Internal.Int2DoubleFunction
        hashCode(): number
        putAll(arg0: Map<K, V>): void
        get(arg0: object): object
        get(arg0: object): number
        get(arg0: number): number
        andThenLong(arg0: Internal.Int2LongFunction): Internal.Int2LongFunction
        keySet(): Internal.Set<any>
        keySet(): Internal.IntSet
        andThenByte(arg0: Internal.Int2ByteFunction): Internal.Int2ByteFunction
        andThenFloat(arg0: Internal.Int2FloatFunction): Internal.Int2FloatFunction
        apply(arg0: K): V
        computeIfAbsentNullable(arg0: number, arg1: Internal.IntFunction<number>): number
        forEach(arg0: (arg0: number, arg1: number) => void): void
        composeInt(arg0: Internal.Int2IntFunction): Internal.Int2IntFunction
        isEmpty(): boolean
        clear(): void
        composeFloat(arg0: Internal.Float2IntFunction): Internal.Float2IntFunction
        andThenChar(arg0: Internal.Int2CharFunction): Internal.Int2CharFunction
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        computeIfPresent(arg0: object, arg1: Internal.BiFunction<any, any, any>): object
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        equals(arg0: object): boolean
        andThenReference<T>(arg0: Internal.Int2ReferenceFunction<T>): Internal.Int2ReferenceFunction<T>
        putIfAbsent(arg0: object, arg1: object): object
        putIfAbsent(arg0: number, arg1: number): number
        putIfAbsent(arg0: number, arg1: number): number
    }
    interface WatchKey {
        cancel(): void
        pollEvents(): Internal.List<Internal.WatchEvent<object>>
        watchable(): Internal.Watchable
        isValid(): boolean
        reset(): boolean
    }
    interface OpenOption {
    }
    class IntervalJS {
        matchesSqr(arg0: number): boolean
        static ofInt(arg0: object): Internal.MinMaxBounds$Ints
        min(arg0: number): Internal.IntervalJS
        max(arg0: number): Internal.IntervalJS
        getVanillaInt(): Internal.MinMaxBounds$Ints
        getVanillaDoubles(): Internal.MinMaxBounds$Doubles
        toString(): string
        matches(arg0: number): boolean
        between(arg0: number, arg1: number): Internal.IntervalJS
        static ofDoubles(arg0: object): Internal.MinMaxBounds$Doubles
        get vanillaInt(): Internal.MinMaxBounds$Ints;
        get vanillaDoubles(): Internal.MinMaxBounds$Doubles;
    }
    interface Spliterator$OfLong implements Internal.Spliterator$OfPrimitive<number, Internal.LongConsumer, Internal.Spliterator$OfLong> {
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>
        trySplit(): Internal.Spliterator<any>
        trySplit(): Internal.Spliterator$OfLong
        characteristics(): number
        tryAdvance(arg0: Internal.LongConsumer): boolean
        tryAdvance(arg0: (arg0: number) => void): boolean
        tryAdvance(arg0: object): boolean
        getComparator(): Internal.Comparator<T>
        getExactSizeIfKnown(): number
        estimateSize(): number
        hasCharacteristics(arg0: number): boolean
        forEachRemaining(arg0: object): void
        forEachRemaining(arg0: Internal.LongConsumer): void
        forEachRemaining(arg0: (arg0: number) => void): void
        static readonly NONNULL : 256;
        static readonly SUBSIZED : 16384;
        static readonly ORDERED : 16;
        static readonly DISTINCT : 1;
        static readonly SIZED : 64;
        static readonly IMMUTABLE : 1024;
        static readonly CONCURRENT : 4096;
        static readonly SORTED : 4;
        get comparator(): Internal.Comparator<T>;
        get exactSizeIfKnown(): number;
    }
    interface Char2ShortFunction implements Internal.Function<string, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: string, arg1: number): number
        andThenShort(arg0: Internal.Short2ShortFunction): Internal.Char2ShortFunction
        composeByte(arg0: Internal.Byte2CharFunction): Internal.Byte2ShortFunction
        andThenInt(arg0: Internal.Short2IntFunction): Internal.Char2IntFunction
        composeReference<T>(arg0: Internal.Reference2CharFunction<T>): Internal.Reference2ShortFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: string) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: string, arg1: number): number
        put(arg0: string, arg1: number): number
        remove(arg0: string): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Short2DoubleFunction): Internal.Char2DoubleFunction
        andThenObject<T>(arg0: Internal.Short2ObjectFunction<T>): Internal.Char2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: string): number
        andThenLong(arg0: Internal.Short2LongFunction): Internal.Char2LongFunction
        composeLong(arg0: Internal.Long2CharFunction): Internal.Long2ShortFunction
        andThenByte(arg0: Internal.Short2ByteFunction): Internal.Char2ByteFunction
        andThenFloat(arg0: Internal.Short2FloatFunction): Internal.Char2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: string): boolean
        composeInt(arg0: Internal.Int2CharFunction): Internal.Int2ShortFunction
        clear(): void
        composeFloat(arg0: Internal.Float2CharFunction): Internal.Float2ShortFunction
        andThenChar(arg0: Internal.Short2CharFunction): Internal.Char2CharFunction
        composeObject<T>(arg0: Internal.Object2CharFunction<T>): Internal.Object2ShortFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => string): (arg0: T) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2CharFunction): Internal.Short2ShortFunction
        andThenReference<T>(arg0: Internal.Short2ReferenceFunction<T>): Internal.Char2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2CharFunction): Internal.Char2ShortFunction
        composeDouble(arg0: Internal.Double2CharFunction): Internal.Double2ShortFunction
    }
    interface ChronoLocalDate implements Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.ChronoLocalDate> {
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDate
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDate
        toEpochDay(): number
        isEqual(arg0: Internal.ChronoLocalDate): boolean
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        compareTo(arg0: object): number
        compareTo(arg0: Internal.ChronoLocalDate): number
        lengthOfYear(): number
        lengthOfMonth(): number
        getEra(): Internal.Era
        hashCode(): number
        get(arg0: Internal.TemporalField): number
        static from(arg0: Internal.TemporalAccessor): Internal.ChronoLocalDate
        getChronology(): Internal.Chronology
        query<R>(arg0: Internal.TemporalQuery<R>): R
        format(arg0: Internal.DateTimeFormatter): string
        isLeapYear(): boolean
        isSupported(arg0: Internal.TemporalUnit): boolean
        isSupported(arg0: Internal.TemporalField): boolean
        isBefore(arg0: Internal.ChronoLocalDate): boolean
        plus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDate
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDate
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        getLong(arg0: Internal.TemporalField): number
        atTime(arg0: Internal.LocalTime): Internal.ChronoLocalDateTime<object>
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.ChronoLocalDate
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalField, arg1: number): Internal.ChronoLocalDate
        equals(arg0: object): boolean
        static timeLineOrder(): Internal.Comparator<Internal.ChronoLocalDate>
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        until(arg0: Internal.ChronoLocalDate): Internal.ChronoPeriod
        toString(): string
        isAfter(arg0: Internal.ChronoLocalDate): boolean
        get era(): Internal.Era;
        get chronology(): Internal.Chronology;
    }
    interface Object2DoubleFunction <K> implements Internal.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: number): number
        applyAsDouble(arg0: K): number
        andThenShort(arg0: Internal.Double2ShortFunction): Internal.Object2ShortFunction<K>
        getDouble(arg0: object): number
        composeByte(arg0: Internal.Byte2ObjectFunction<K>): Internal.Byte2DoubleFunction
        andThenInt(arg0: Internal.Double2IntFunction): Internal.Object2IntFunction<K>
        composeReference<T>(arg0: (arg0: T) => K): Internal.Reference2DoubleFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: K) => T
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: object, arg1: object): object
        remove(arg0: object): number
        remove(arg0: object): object
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: Internal.Double2DoubleFunction): Internal.Object2DoubleFunction<K>
        andThenObject<T>(arg0: Internal.Double2ObjectFunction<T>): (arg0: K) => T
        get(arg0: object): object
        get(arg0: object): number
        andThenLong(arg0: Internal.Double2LongFunction): Internal.Object2LongFunction<K>
        composeLong(arg0: Internal.Long2ObjectFunction<K>): Internal.Long2DoubleFunction
        andThenByte(arg0: Internal.Double2ByteFunction): Internal.Object2ByteFunction<K>
        andThenFloat(arg0: Internal.Double2FloatFunction): Internal.Object2FloatFunction<K>
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ObjectFunction<K>): Internal.Int2DoubleFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ObjectFunction<K>): Internal.Float2DoubleFunction
        andThenChar(arg0: Internal.Double2CharFunction): Internal.Object2CharFunction<K>
        composeObject<T>(arg0: (arg0: T) => K): Internal.Object2DoubleFunction<T>
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        removeDouble(arg0: object): number
        composeShort(arg0: Internal.Short2ObjectFunction<K>): Internal.Short2DoubleFunction
        andThenReference<T>(arg0: Internal.Double2ReferenceFunction<T>): (arg0: K) => T
        composeChar(arg0: Internal.Char2ObjectFunction<K>): Internal.Char2DoubleFunction
        composeDouble(arg0: Internal.Double2ObjectFunction<K>): Internal.Double2DoubleFunction
    }
    interface Function14 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, (arg0: T13, arg1: T14) => R>
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function5<T10, T11, T12, T13, T14, R>>
        curry13(): Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, (arg0: T14) => R>
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13, arg13: T14): R
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function7<T8, T9, T10, T11, T12, T13, T14, R>>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function6<T9, T10, T11, T12, T13, T14, R>>
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function4<T11, T12, T13, T14, R>>
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function3<T12, T13, T14, R>>
        curry(): (arg0: T1) => Internal.Function13<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function9<T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function8<T7, T8, T9, T10, T11, T12, T13, T14, R>>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function11<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function10<T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function12<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>
    }
    class MetalPressRecipeJS extends Internal.IERecipeJS {
        serialize(): void
        create(args: Internal.ListJS): void
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<object>;
        readonly inputFluids : Internal.List<Internal.FluidTagInput>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        serializeInputs : boolean;
    }
    interface EntityGetter {
    }
    class VarHandle$AccessMode extends Internal.Enum<Internal.VarHandle$AccessMode> {
        static valueOf(arg0: string): Internal.VarHandle$AccessMode
        static valueFromMethodName(arg0: string): Internal.VarHandle$AccessMode
        static values(): Internal.VarHandle$AccessMode[]
        methodName(): string
        static readonly WEAK_COMPARE_AND_SET : Internal.VarHandle$AccessMode;
        static readonly GET_VOLATILE : Internal.VarHandle$AccessMode;
        static readonly SET : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_OR_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_ADD : Internal.VarHandle$AccessMode;
        static readonly GET_AND_SET : Internal.VarHandle$AccessMode;
        static readonly GET_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_ADD_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_AND_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_XOR_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_ADD_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_OR_RELEASE : Internal.VarHandle$AccessMode;
        static readonly SET_OPAQUE : Internal.VarHandle$AccessMode;
        static readonly WEAK_COMPARE_AND_SET_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_SET : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_EXCHANGE_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_AND : Internal.VarHandle$AccessMode;
        static readonly SET_VOLATILE : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_EXCHANGE_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_XOR : Internal.VarHandle$AccessMode;
        static readonly WEAK_COMPARE_AND_SET_PLAIN : Internal.VarHandle$AccessMode;
        static readonly SET_RELEASE : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_EXCHANGE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_OR : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_AND_RELEASE : Internal.VarHandle$AccessMode;
        static readonly WEAK_COMPARE_AND_SET_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_SET_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET : Internal.VarHandle$AccessMode;
        static readonly GET_AND_SET_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_XOR_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_OPAQUE : Internal.VarHandle$AccessMode;
    }
    class OptionalDynamic <T> extends Internal.DynamicLike<T> {
        getElementGeneric(arg0: T): Internal.DataResult<T>
        asLongStreamOpt(): Internal.DataResult<Internal.LongStream>
        asByteBufferOpt(): Internal.DataResult<Internal.ByteBuffer>
        orElseEmptyMap(): Internal.Dynamic<T>
        orElseEmptyList(): Internal.Dynamic<T>
        asStreamOpt(): Internal.DataResult<Internal.Stream<Internal.Dynamic<T>>>
        asNumber(): Internal.DataResult<Internal.Number>
        asMapOpt(): Internal.DataResult<Internal.Stream<com.mojang.datafixers.util.Pair<Internal.Dynamic<T>, Internal.Dynamic<T>>>>
        getGeneric(arg0: T): Internal.DataResult<T>
        decode<A>(arg0: Internal.Decoder<A>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
        asIntStreamOpt(): Internal.DataResult<Internal.IntStream>
        flatMap<U>(arg0: (arg0: Internal.Dynamic<T>) => Internal.DataResult<U>): Internal.DataResult<U>
        result(): Internal.Optional<Internal.Dynamic<T>>
        into<V>(arg0: (arg0: Internal.Dynamic<T>) => V): Internal.DataResult<V>
        getElement(arg0: string): Internal.DataResult<T>
        get(arg0: string): Internal.OptionalDynamic<T>
        get(): Internal.DataResult<Internal.Dynamic<T>>
        asString(): Internal.DataResult<string>
        map<U>(arg0: (arg0: Internal.Dynamic<T>) => U): Internal.DataResult<U>
    }
    interface ChannelProgressiveFuture implements Internal.ChannelFuture, Internal.ProgressiveFuture<void> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelProgressiveFuture
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelFuture
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.ProgressiveFuture<V>
        getNow(): V
        channel(): Internal.Channel
        cause(): Internal.Throwable
        awaitUninterruptibly(): Internal.ChannelProgressiveFuture
        awaitUninterruptibly(): Internal.ChannelFuture
        awaitUninterruptibly(): io.netty.util.concurrent.Future<V>
        awaitUninterruptibly(): Internal.ProgressiveFuture<V>
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelProgressiveFuture
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelFuture
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.ProgressiveFuture<V>
        isDone(): boolean
        sync(): Internal.ChannelProgressiveFuture
        sync(): Internal.ChannelFuture
        sync(): io.netty.util.concurrent.Future<V>
        sync(): Internal.ProgressiveFuture<V>
        isVoid(): boolean
        syncUninterruptibly(): Internal.ChannelProgressiveFuture
        syncUninterruptibly(): Internal.ChannelFuture
        syncUninterruptibly(): io.netty.util.concurrent.Future<V>
        syncUninterruptibly(): Internal.ProgressiveFuture<V>
        get(arg0: number, arg1: Internal.TimeUnit): V
        get(): V
        isCancellable(): boolean
        await(): Internal.ChannelProgressiveFuture
        await(): Internal.ChannelFuture
        await(): io.netty.util.concurrent.Future<V>
        await(): Internal.ProgressiveFuture<V>
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelProgressiveFuture
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelFuture
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.ProgressiveFuture<V>
        isSuccess(): boolean
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelProgressiveFuture
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelFuture
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.ProgressiveFuture<V>
        get now(): V;
    }
    class TextColor implements Internal.Color {
        getRgbKJS(): number
        hashCode(): number
        equals(arg0: object): boolean
        createTextColorKJS(): Internal.TextColor
        getHexKJS(): string
        getArgbKJS(): number
        toString(): string
        getFireworkColorKJS(): number
        getSerializeKJS(): string
        specialEquals(o: object, shallow: boolean): boolean
        get rgbKJS(): number;
        get hexKJS(): string;
        get argbKJS(): number;
        get fireworkColorKJS(): number;
        get serializeKJS(): string;
    }
    class NativeJavaObject implements Internal.Scriptable, Internal.SymbolScriptable, Internal.Wrapper, Internal.Serializable {
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: object) => void): boolean
        hasInstance(value: Internal.Scriptable): boolean
        setParentScope(m: Internal.Scriptable): void
        static canConvert(cx: Internal.Context, fromObj: object, to: Internal.Class<object>): boolean
        getIds(): object[]
        addCustomProperty(name: string, getter: Internal.CustomProperty): void
        getAllIds(): object[]
        delete(index: number): void
        delete(name: string): void
        delete(key: Internal.Symbol): void
        put(index: number, start: Internal.Scriptable, value: object): void
        put(symbol: Internal.Symbol, start: Internal.Scriptable, value: object): void
        put(name: string, start: Internal.Scriptable, value: object): void
        unwrap(): object
        getDefaultValue(hint: Internal.Class<object>): object
        setPrototype(m: Internal.Scriptable): void
        getPrototype(): Internal.Scriptable
        get(name: string, start: Internal.Scriptable): object
        get(key: Internal.Symbol, start: Internal.Scriptable): object
        get(index: number, start: Internal.Scriptable): object
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: object) => void): boolean
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean
        has(index: number, start: Internal.Scriptable): boolean
        has(name: string, start: Internal.Scriptable): boolean
        getClassName(): string
        getParentScope(): Internal.Scriptable
        static readonly NOT_FOUND : object;
        set parentScope(m: Internal.Scriptable);
        get ids(): object[];
        get allIds(): object[];
        set prototype(m: Internal.Scriptable);
        get prototype(): Internal.Scriptable;
        get className(): string;
        get parentScope(): Internal.Scriptable;
    }
    interface Function5 <T1, T2, T3, T4, T5, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5): R
        curry3(): Internal.Function3<T1, T2, T3, (arg0: T4, arg1: T5) => R>
        curry4(): Internal.Function4<T1, T2, T3, T4, (arg0: T5) => R>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function3<T3, T4, T5, R>
        curry(): (arg0: T1) => Internal.Function4<T2, T3, T4, T5, R>
    }
    class Advancement {
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
    }
    interface PrivilegedExceptionAction <T> {
        run(): T
    }
    interface IBlockRenderProperties {
        getFogColor(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity, arg4: Internal.Vector3d, arg5: number): Internal.Vector3d
        addDestroyEffects(arg0: Internal.BlockState, arg1: Internal.Level, arg2: BlockPos, arg3: Internal.ParticleEngine): boolean
        addHitEffects(arg0: Internal.BlockState, arg1: Internal.Level, arg2: Internal.HitResult, arg3: Internal.ParticleEngine): boolean
        static readonly DUMMY : Internal.IBlockRenderProperties;
    }
    interface Decoder$Simple <A> {
        decoder(): Internal.Decoder<A>
        decode<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<A>
    }
    class Direction extends Internal.Enum<Internal.Direction> implements Internal.StringRepresentable {
        getYaw(): number
        getHorizontalIndex(): number
        getX(): number
        getY(): number
        getPitch(): number
        getIndex(): number
        getZ(): number
        static valueOf(arg0: string): Internal.Direction
        static values(): Internal.Direction[]
        getCounterClockWise(): Internal.Direction
        getOpposite(): Internal.Direction
        toString(): string
        getClockWise(): Internal.Direction
        static readonly DOWN : Internal.Direction;
        static readonly NORTH : Internal.Direction;
        static readonly WEST : Internal.Direction;
        static readonly UP : Internal.Direction;
        static readonly SOUTH : Internal.Direction;
        static readonly EAST : Internal.Direction;
        get yaw(): number;
        get horizontalIndex(): number;
        get x(): number;
        get y(): number;
        get pitch(): number;
        get index(): number;
        get z(): number;
        get counterClockWise(): Internal.Direction;
        get opposite(): Internal.Direction;
        get clockWise(): Internal.Direction;
    }
    class GenericLootEventJS extends Internal.LootEventJS {
        addGeneric(id: ResourceLocation, b: (arg0: Internal.LootBuilder) => void): void
        getType(): string
        getDirectory(): string
        get type(): string;
        get directory(): string;
    }
    interface Tags$IOptionalNamedTag <T> implements Internal.Tag$Named<T> {
        isDefaulted(): boolean
    }
    class UnboundedMapCodec <K, V> implements Internal.BaseMapCodec<K, V>, Internal.Codec<Map<K, V>> {
        encode(arg0: object, arg1: Internal.DynamicOps<any>, arg2: object): Internal.DataResult<any>
        encode<T>(arg0: Map<K, V>, arg1: Internal.DynamicOps<T>, arg2: T): Internal.DataResult<T>
        encode<T>(arg0: Map<K, V>, arg1: Internal.DynamicOps<T>, arg2: Internal.RecordBuilder<T>): Internal.RecordBuilder<T>
        flatComapMap<S>(arg0: (arg0: A) => S, arg1: (arg0: S) => Internal.DataResult<A>): Internal.Codec<S>
        dispatch<E>(arg0: (arg0: E) => A, arg1: (arg0: A) => Internal.Codec<E>): Internal.Codec<E>
        dispatch<E>(arg0: string, arg1: (arg0: E) => A, arg2: (arg0: A) => Internal.Codec<E>): Internal.Codec<E>
        deprecated(arg0: number): Internal.Codec<A>
        simple(): Internal.Decoder$Simple<A>
        dispatchMap<E>(arg0: (arg0: E) => A, arg1: (arg0: A) => Internal.Codec<E>): Internal.MapCodec<E>
        dispatchMap<E>(arg0: string, arg1: (arg0: E) => A, arg2: (arg0: A) => Internal.Codec<E>): Internal.MapCodec<E>
        comapFlatMap<S>(arg0: (arg0: A) => Internal.DataResult<S>, arg1: (arg0: S) => A): Internal.Codec<S>
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<com.mojang.datafixers.util.Pair<Map<K, V>, T>>
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: Internal.MapLike<T>): Internal.DataResult<Map<K, V>>
        decode<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
        promotePartial(arg0: Internal.Consumer<any>): Internal.Decoder<any>
        promotePartial(arg0: (arg0: string) => void): Internal.Codec<A>
        flatXmap<S>(arg0: (arg0: A) => Internal.DataResult<S>, arg1: (arg0: S) => Internal.DataResult<A>): Internal.Codec<S>
        hashCode(): number
        comap<B>(arg0: (arg0: B) => A): Internal.Encoder<B>
        fieldOf(arg0: string): Internal.MapEncoder<any>
        fieldOf(arg0: string): Internal.MapDecoder<any>
        fieldOf(arg0: string): Internal.MapCodec<A>
        xmap<S>(arg0: (arg0: A) => S, arg1: (arg0: S) => A): Internal.Codec<S>
        listOf(): Internal.Codec<Internal.List<A>>
        map<B>(arg0: (arg0: A) => B): Internal.Decoder<B>
        encodeStart<T>(arg0: Internal.DynamicOps<T>, arg1: A): Internal.DataResult<T>
        optionalFieldOf(arg0: string, arg1: Internal.Lifecycle, arg2: A, arg3: Internal.Lifecycle): Internal.MapCodec<A>
        optionalFieldOf(arg0: string, arg1: A): Internal.MapCodec<A>
        optionalFieldOf(arg0: string): Internal.MapCodec<Internal.Optional<A>>
        optionalFieldOf(arg0: string, arg1: A, arg2: Internal.Lifecycle): Internal.MapCodec<A>
        flatComap<B>(arg0: (arg0: B) => Internal.DataResult<A>): Internal.Encoder<B>
        keyCodec(): Internal.Codec<K>
        partialDispatch<E>(arg0: string, arg1: (arg0: E) => Internal.DataResult<A>, arg2: (arg0: A) => Internal.DataResult<Internal.Codec<E>>): Internal.Codec<E>
        terminal(): Internal.Decoder$Terminal<A>
        parse<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<A>
        parse<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<A>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Encoder<any>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Decoder<any>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Codec<A>
        orElse(arg0: A): Internal.Codec<A>
        orElse(arg0: (arg0: string) => void, arg1: A): Internal.Codec<A>
        orElse(arg0: Internal.UnaryOperator<string>, arg1: A): Internal.Codec<A>
        flatMap<B>(arg0: (arg0: A) => Internal.DataResult<B>): Internal.Decoder<B>
        elementCodec(): Internal.Codec<V>
        boxed(): Internal.Decoder$Boxed<A>
        dispatchStable<E>(arg0: (arg0: E) => A, arg1: (arg0: A) => Internal.Codec<E>): Internal.Codec<E>
        orElseGet(arg0: (arg0: string) => void, arg1: () => A): Internal.Codec<A>
        orElseGet(arg0: () => A): Internal.Codec<A>
        orElseGet(arg0: Internal.UnaryOperator<string>, arg1: () => A): Internal.Codec<A>
        stable(): Internal.Codec<A>
        equals(arg0: object): boolean
        mapResult(arg0: Internal.Codec$ResultFunction<A>): Internal.Codec<A>
        toString(): string
        static readonly FLOAT : Internal.PrimitiveCodec<number>;
        static readonly INT : Internal.PrimitiveCodec<number>;
        static readonly SHORT : Internal.PrimitiveCodec<number>;
        static readonly PASSTHROUGH : Internal.Codec<Internal.Dynamic<object>>;
        static readonly BOOL : Internal.PrimitiveCodec<boolean>;
        static readonly BYTE_BUFFER : Internal.PrimitiveCodec<Internal.ByteBuffer>;
        static readonly INT_STREAM : Internal.PrimitiveCodec<Internal.IntStream>;
        static readonly BYTE : Internal.PrimitiveCodec<number>;
        static readonly LONG_STREAM : Internal.PrimitiveCodec<Internal.LongStream>;
        static readonly STRING : Internal.PrimitiveCodec<string>;
        static readonly DOUBLE : Internal.PrimitiveCodec<number>;
        static readonly EMPTY : Internal.MapCodec<Internal.Unit>;
        static readonly LONG : Internal.PrimitiveCodec<number>;
    }
    class BlendingData {
    }
    class WorldPainterObject extends Internal.PainterObject {
        preDraw(event: Internal.WorldPaintEventJS): void
        draw(arg0: Internal.WorldPaintEventJS): void
        parent : Internal.PainterObjectStorage;
        visible : boolean;
        d : number;
        w : number;
        x : number;
        h : number;
        y : number;
        z : number;
        id : string;
    }
    class IsoEra extends Internal.Enum<Internal.IsoEra> implements Internal.Era {
        getLong(arg0: Internal.TemporalField): number
        getValue(): number
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        static valueOf(arg0: string): Internal.IsoEra
        query<R>(arg0: Internal.TemporalQuery<R>): R
        get(arg0: Internal.TemporalField): number
        static of(arg0: number): Internal.IsoEra
        static values(): Internal.IsoEra[]
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        isSupported(arg0: Internal.TemporalField): boolean
        static readonly CE : Internal.IsoEra;
        static readonly BCE : Internal.IsoEra;
        get value(): number;
    }
    interface BlockStateLightInfoAccess {
        getLightInfo(): Internal.BlockStateLightInfo
        get lightInfo(): Internal.BlockStateLightInfo;
    }
    interface CustomProperty {
        get(): object
    }
    interface Matrix4fExtended {
        rotate(arg0: Internal.Quaternion): void
        transformVecZ(arg0: number, arg1: number, arg2: number): number
        transformVecY(arg0: number, arg1: number, arg2: number): number
        transformVecX(arg0: number, arg1: number, arg2: number): number
        translate(arg0: number, arg1: number, arg2: number): void
    }
    interface Context$ClassShutterSetter {
        setClassShutter(arg0: Internal.ClassShutter): void
        getClassShutter(): Internal.ClassShutter
        set classShutter(arg0: Internal.ClassShutter);
        get classShutter(): Internal.ClassShutter;
    }
    interface Closeable implements Internal.AutoCloseable {
        close(): void
    }
    class ModuleLayer {
        findModule(arg0: string): Internal.Optional<Internal.Module>
        static defineModulesWithManyLoaders(arg0: Internal.Configuration, arg1: Internal.List<Internal.ModuleLayer>, arg2: Internal.ClassLoader): Internal.ModuleLayer$Controller
        defineModulesWithManyLoaders(arg0: Internal.Configuration, arg1: Internal.ClassLoader): Internal.ModuleLayer
        findLoader(arg0: string): Internal.ClassLoader
        configuration(): Internal.Configuration
        toString(): string
        static defineModulesWithOneLoader(arg0: Internal.Configuration, arg1: Internal.List<Internal.ModuleLayer>, arg2: Internal.ClassLoader): Internal.ModuleLayer$Controller
        defineModulesWithOneLoader(arg0: Internal.Configuration, arg1: Internal.ClassLoader): Internal.ModuleLayer
        static boot(): Internal.ModuleLayer
        modules(): Internal.Set<Internal.Module>
        defineModules(arg0: Internal.Configuration, arg1: (arg0: string) => Internal.ClassLoader): Internal.ModuleLayer
        static defineModules(arg0: Internal.Configuration, arg1: Internal.List<Internal.ModuleLayer>, arg2: (arg0: string) => Internal.ClassLoader): Internal.ModuleLayer$Controller
        parents(): Internal.List<Internal.ModuleLayer>
        static empty(): Internal.ModuleLayer
    }
    class VariantBlockStateGenerator$Variant {
        toJson(): Internal.JsonElement
        model(s: string): Internal.VariantBlockStateGenerator$Model
    }
    interface Tag$Named <T> implements Internal.Tag<T> {
    }
    class Model {
    }
    class ParsePosition {
        getIndex(): number
        setIndex(arg0: number): void
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        setErrorIndex(arg0: number): void
        getErrorIndex(): number
        get index(): number;
        set index(arg0: number);
        set errorIndex(arg0: number);
        get errorIndex(): number;
    }
    class JsonWriter implements Internal.Closeable, Internal.Flushable {
        setSerializeNulls(arg0: boolean): void
        setHtmlSafe(arg0: boolean): void
        jsonValue(arg0: string): Internal.JsonWriter
        isLenient(): boolean
        endArray(): Internal.JsonWriter
        nullValue(): Internal.JsonWriter
        setLenient(arg0: boolean): void
        endObject(): Internal.JsonWriter
        beginArray(): Internal.JsonWriter
        flush(): void
        beginObject(): Internal.JsonWriter
        getSerializeNulls(): boolean
        setIndent(arg0: string): void
        name(arg0: string): Internal.JsonWriter
        isHtmlSafe(): boolean
        close(): void
        value(arg0: boolean): Internal.JsonWriter
        value(arg0: number): Internal.JsonWriter
        value(arg0: number): Internal.JsonWriter
        value(arg0: boolean): Internal.JsonWriter
        value(arg0: string): Internal.JsonWriter
        value(arg0: Internal.Number): Internal.JsonWriter
        set serializeNulls(arg0: boolean);
        set htmlSafe(arg0: boolean);
        set lenient(arg0: boolean);
        get serializeNulls(): boolean;
        set indent(arg0: string);
    }
    class Pose extends Internal.Enum<Internal.Pose> {
        static valueOf(arg0: string): Internal.Pose
        static values(): Internal.Pose[]
        static readonly SLEEPING : Internal.Pose;
        static readonly FALL_FLYING : Internal.Pose;
        static readonly LONG_JUMPING : Internal.Pose;
        static readonly DYING : Internal.Pose;
        static readonly CROUCHING : Internal.Pose;
        static readonly STANDING : Internal.Pose;
        static readonly SWIMMING : Internal.Pose;
        static readonly SPIN_ATTACK : Internal.Pose;
    }
    class ClassInstanceMultiMap <T> extends Internal.AbstractCollection<T> implements Internal.ClassGroupFilterableList {
        add(arg0: T): boolean
        contains(arg0: object): boolean
        iterator(): Internal.Iterator<T>
        size(): number
        localvar$zlc000$remove(o: object): object
        getAllOfGroupType(type: Internal.EntityClassGroup): Internal.Collection<any>
        remove(arg0: object): boolean
        localvar$zlc000$add(entity: object): object
    }
    class HashMap <K, V> extends Internal.AbstractMap<K, V> implements Map<K, V>, Internal.Cloneable, Internal.Serializable {
        getOrDefault(arg0: object, arg1: V): V
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>
        containsKey(arg0: object): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V
        values(): Internal.Collection<V>
        replace(arg0: K, arg1: V): V
        replace(arg0: K, arg1: V, arg2: V): boolean
        isEmpty(): boolean
        clear(): void
        replaceAll(arg0: (arg0: K, arg1: V) => V): void
        containsValue(arg0: object): boolean
        put(arg0: K, arg1: V): V
        remove(arg0: object, arg1: object): boolean
        remove(arg0: object): V
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        size(): number
        putAll(arg0: Map<K, V>): void
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        get(arg0: object): V
        clone(): object
        keySet(): Internal.Set<K>
        putIfAbsent(arg0: K, arg1: V): V
    }
    interface INBTSerializable <T> {
        serializeNBT(): T
        deserializeNBT(arg0: T): void
    }
    interface Consumer <T> {
        andThen(arg0: (arg0: T) => void): (arg0: T) => void
        accept(arg0: T): void
    }
    interface Channel implements Internal.AttributeMap, Internal.ChannelOutboundInvoker, Internal.Comparable<Internal.Channel> {
        disconnect(): Internal.ChannelFuture
        disconnect(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        parent(): Internal.Channel
        metadata(): Internal.ChannelMetadata
        newProgressivePromise(): Internal.ChannelProgressivePromise
        eventLoop(): Internal.EventLoop
        compareTo(arg0: T): number
        isWritable(): boolean
        isActive(): boolean
        unsafe(): Internal.Channel$Unsafe
        writeAndFlush(arg0: object): Internal.ChannelFuture
        writeAndFlush(arg0: object, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        bind(arg0: Internal.SocketAddress): Internal.ChannelFuture
        bind(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        flush(): Internal.Channel
        flush(): Internal.ChannelOutboundInvoker
        bytesBeforeWritable(): number
        id(): Internal.ChannelId
        attr<T>(arg0: Internal.AttributeKey<T>): io.netty.util.Attribute<T>
        close(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        close(): Internal.ChannelFuture
        write(arg0: object): Internal.ChannelFuture
        write(arg0: object, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress, arg2: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress): Internal.ChannelFuture
        remoteAddress(): Internal.SocketAddress
        newPromise(): Internal.ChannelPromise
        read(): Internal.Channel
        read(): Internal.ChannelOutboundInvoker
        bytesBeforeUnwritable(): number
        deregister(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        deregister(): Internal.ChannelFuture
        newFailedFuture(arg0: Internal.Throwable): Internal.ChannelFuture
        hasAttr<T>(arg0: Internal.AttributeKey<T>): boolean
        pipeline(): Internal.ChannelPipeline
        isOpen(): boolean
        newSucceededFuture(): Internal.ChannelFuture
        voidPromise(): Internal.ChannelPromise
        closeFuture(): Internal.ChannelFuture
        localAddress(): Internal.SocketAddress
        isRegistered(): boolean
        alloc(): Internal.ByteBufAllocator
        config(): Internal.ChannelConfig
    }
    interface ParticleOptions {
    }
    interface Long2CharFunction implements Internal.Function<number, string>, Internal.LongToIntFunction {
        getOrDefault(arg0: object, arg1: string): string
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: string): string
        andThenShort(arg0: Internal.Char2ShortFunction): Internal.Long2ShortFunction
        composeByte(arg0: Internal.Byte2LongFunction): Internal.Byte2CharFunction
        andThenInt(arg0: Internal.Char2IntFunction): Internal.Long2IntFunction
        composeReference<T>(arg0: Internal.Reference2LongFunction<T>): Internal.Reference2CharFunction<T>
        andThen<T>(arg0: (arg0: string) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: string): string
        put(arg0: number, arg1: string): string
        remove(arg0: number): string
        remove(arg0: object): object
        remove(arg0: object): string
        defaultReturnValue(): string
        defaultReturnValue(arg0: string): void
        andThenDouble(arg0: Internal.Char2DoubleFunction): Internal.Long2DoubleFunction
        andThenObject<T>(arg0: Internal.Char2ObjectFunction<T>): Internal.Long2ObjectFunction<T>
        get(arg0: object): string
        get(arg0: object): object
        get(arg0: number): string
        andThenLong(arg0: Internal.Char2LongFunction): Internal.Long2LongFunction
        composeLong(arg0: Internal.Long2LongFunction): Internal.Long2CharFunction
        andThenByte(arg0: Internal.Char2ByteFunction): Internal.Long2ByteFunction
        andThenFloat(arg0: Internal.Char2FloatFunction): Internal.Long2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2LongFunction): Internal.Int2CharFunction
        clear(): void
        composeFloat(arg0: Internal.Float2LongFunction): Internal.Float2CharFunction
        andThenChar(arg0: Internal.Char2CharFunction): Internal.Long2CharFunction
        composeObject<T>(arg0: Internal.Object2LongFunction<T>): Internal.Object2CharFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => string
        composeShort(arg0: Internal.Short2LongFunction): Internal.Short2CharFunction
        andThenReference<T>(arg0: Internal.Char2ReferenceFunction<T>): Internal.Long2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2LongFunction): Internal.Char2CharFunction
        composeDouble(arg0: Internal.Double2LongFunction): Internal.Double2CharFunction
    }
    class CodeSource implements Internal.Serializable {
        getLocation(): Internal.URL
        getCodeSigners(): Internal.CodeSigner[]
        hashCode(): number
        equals(arg0: object): boolean
        getCertificates(): Internal.Certificate[]
        toString(): string
        implies(arg0: Internal.CodeSource): boolean
        get location(): Internal.URL;
        get codeSigners(): Internal.CodeSigner[];
        get certificates(): Internal.Certificate[];
    }
    class Capability <T> {
        orEmpty<R>(arg0: Internal.Capability<R>, arg1: Internal.LazyOptional<T>): Internal.LazyOptional<R>
        getName(): string
        isRegistered(): boolean
        addListener(arg0: (arg0: Internal.Capability<T>) => void): Internal.Capability<T>
        get name(): string;
    }
    interface CustomJavaObjectWrapper {
        wrapAsJavaObject(arg0: Internal.Context, arg1: Internal.Scriptable, arg2: Internal.Class<object>): Internal.Scriptable
    }
    interface Recipe <C> {
    }
    class ModelProperty <T> implements Internal.Predicate<T> {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        test(arg0: T): boolean
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
    }
    class ItemBuilder extends Internal.BuilderBase {
        maxStackSize(v: number): Internal.ItemBuilder
        color(index: number, c: number): Internal.ItemBuilder
        getBuilderType(): string
        texture(tex: string): Internal.ItemBuilder
        maxDamage(v: number): Internal.ItemBuilder
        tooltip(text: Internal.Component): Internal.ItemBuilder
        containerItem(id: string): Internal.ItemBuilder
        type(t: Internal.ItemType): Internal.ItemBuilder
        miningSpeed(f: number): Internal.ItemBuilder
        getMiningSpeed(): number
        food(b: (arg0: Internal.FoodBuilder) => void): Internal.ItemBuilder
        subtypes(fn: (arg0: Internal.ItemStackJS) => Internal.Collection<Internal.ItemStackJS>): Internal.ItemBuilder
        unstackable(): Internal.ItemBuilder
        tier(t: string): Internal.ItemBuilder
        getAttackDamage(): number
        getAttackSpeed(): number
        burnTime(v: number): Internal.ItemBuilder
        attackSpeed(f: number): Internal.ItemBuilder
        parentModel(m: string): Internal.ItemBuilder
        glow(v: boolean): Internal.ItemBuilder
        createItemProperties(): Internal.Item$Properties
        rarity(v: Rarity): Internal.ItemBuilder
        attackDamage(f: number): Internal.ItemBuilder
        group(g: string): Internal.ItemBuilder
        translationKey : string;
        toolTier : Internal.Tier;
        displayName : string;
        foodBuilder : Internal.FoodBuilder;
        defaultTags : Internal.Set<ResourceLocation>;
        armorTier : Internal.ArmorMaterial;
        modelJson : Internal.JsonObject;
        static readonly ARMOR_TIERS : Map<string, Internal.ArmorMaterial>;
        readonly id : ResourceLocation;
        item : Internal.Item;
        attackSpeedBaseline : number;
        static readonly TOOL_TIERS : Map<string, Internal.Tier>;
        attackDamageBaseline : number;
        get builderType(): string;
    }
    class ModuleDescriptor$Requires implements Internal.Comparable<Internal.ModuleDescriptor$Requires> {
        compiledVersion(): Internal.Optional<Internal.ModuleDescriptor$Version>
        hashCode(): number
        equals(arg0: object): boolean
        rawCompiledVersion(): Internal.Optional<string>
        name(): string
        toString(): string
        compareTo(arg0: object): number
        compareTo(arg0: Internal.ModuleDescriptor$Requires): number
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Requires$Modifier>
    }
    interface ItemKJS {
        setFoodPropertiesKJS(arg0: Internal.FoodProperties): void
        setFireResistantKJS(arg0: boolean): void
        setMaxDamageKJS(arg0: number): void
        setItemBuilderKJS(arg0: Internal.ItemBuilder): void
        setCraftingRemainderKJS(arg0: Internal.Item): void
        setBurnTimeKJS(arg0: number): void
        setRarityKJS(arg0: Internal.Rarity): void
        getItemBuilderKJS(): Internal.ItemBuilder
        setMaxStackSizeKJS(arg0: number): void
        set foodPropertiesKJS(arg0: Internal.FoodProperties);
        set fireResistantKJS(arg0: boolean);
        set maxDamageKJS(arg0: number);
        set itemBuilderKJS(arg0: Internal.ItemBuilder);
        set craftingRemainderKJS(arg0: Internal.Item);
        set burnTimeKJS(arg0: number);
        set rarityKJS(arg0: Internal.Rarity);
        get itemBuilderKJS(): Internal.ItemBuilder;
        set maxStackSizeKJS(arg0: number);
    }
    interface Multiset$Entry <E> {
        getElement(): E
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        getCount(): number
        get element(): E;
        get count(): number;
    }
    interface IItemRenderProperties {
        getItemStackRenderer(): Internal.BlockEntityWithoutLevelRenderer
        getBaseArmorModel(arg0: Internal.LivingEntity, arg1: Internal.ItemStack, arg2: EquipmentSlot, arg3: Internal.HumanoidModel<object>): Internal.Model
        getFont(arg0: Internal.ItemStack): Internal.Font
        getArmorModel(arg0: Internal.LivingEntity, arg1: Internal.ItemStack, arg2: EquipmentSlot, arg3: Internal.HumanoidModel<object>): Internal.HumanoidModel<object>
        renderHelmetOverlay(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: number, arg3: number, arg4: number): void
        static readonly DUMMY : Internal.IItemRenderProperties;
        get itemStackRenderer(): Internal.BlockEntityWithoutLevelRenderer;
    }
    interface EventLoopGroup implements Internal.EventExecutorGroup {
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<object>
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<object>
        next(): Internal.EventLoop
        next(): Internal.EventExecutor
        terminationFuture(): io.netty.util.concurrent.Future<object>
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit): io.netty.util.concurrent.Future<object>
        shutdownGracefully(): io.netty.util.concurrent.Future<object>
        submit<T>(arg0: Internal.Runnable, arg1: T): io.netty.util.concurrent.Future<T>
        submit<T>(arg0: Internal.Runnable, arg1: T): Internal.Future<T>
        submit<T>(arg0: java_.util.concurrent.Callable<T>): io.netty.util.concurrent.Future<T>
        submit<T>(arg0: java_.util.concurrent.Callable<T>): Internal.Future<T>
        submit(arg0: Internal.Runnable): io.netty.util.concurrent.Future<object>
        submit(arg0: Internal.Runnable): Internal.Future<object>
        spliterator(): Internal.Spliterator<T>
        isTerminated(): boolean
        forEach(arg0: (arg0: T) => void): void
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<object>
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<object>
        invokeAll<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<Internal.Future<T>>
        invokeAll<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>): Internal.List<Internal.Future<T>>
        execute(arg0: Internal.Runnable): void
        isShuttingDown(): boolean
        schedule<V>(arg0: java_.util.concurrent.Callable<V>, arg1: number, arg2: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<V>
        schedule<V>(arg0: java_.util.concurrent.Callable<V>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<object>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<object>
        iterator(): Internal.Iterator<Internal.EventExecutor>
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean
        invokeAny<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>): T
        invokeAny<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>, arg1: number, arg2: Internal.TimeUnit): T
        shutdownNow(): Internal.List<Internal.Runnable>
        shutdown(): void
        isShutdown(): boolean
        register(arg0: Internal.Channel, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        register(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        register(arg0: Internal.Channel): Internal.ChannelFuture
    }
    interface BlockEntityGetter {
        getLoadedExistingBlockEntity(arg0: BlockPos): Internal.BlockEntity
    }
    class MobEffectInstance implements Internal.Comparable<Internal.MobEffectInstance>, Internal.IForgeMobEffectInstance {
        writeCurativeItems(arg0: Internal.CompoundTag): void
        addCurativeItem(arg0: Internal.ItemStack): void
        setCurativeItems(arg0: Internal.List<Internal.ItemStack>): void
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        compareTo(arg0: object): number
        compareTo(arg0: Internal.MobEffectInstance): number
        isCurativeItem(arg0: Internal.ItemStack): boolean
        getCurativeItems(): Internal.List<Internal.ItemStack>
        set curativeItems(arg0: Internal.List<Internal.ItemStack>);
        get curativeItems(): Internal.List<Internal.ItemStack>;
    }
    class Products$P1 <F, T1> {
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: (arg0: T1) => R): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, (arg0: T1) => R>): Internal.App<F, R>
        and<T2, T3, T4, T5, T6, T7>(arg0: Internal.Products$P6<F, T2, T3, T4, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        and<T2, T3, T4, T5, T6, T7, T8>(arg0: Internal.Products$P7<F, T2, T3, T4, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        and<T2, T3, T4, T5>(arg0: Internal.Products$P4<F, T2, T3, T4, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>
        and<T2, T3>(arg0: Internal.Products$P2<F, T2, T3>): Internal.Products$P3<F, T1, T2, T3>
        and<T2, T3, T4>(arg0: Internal.Products$P3<F, T2, T3, T4>): Internal.Products$P4<F, T1, T2, T3, T4>
        and<T2>(arg0: Internal.App<F, T2>): Internal.Products$P2<F, T1, T2>
        and<T2, T3, T4, T5, T6>(arg0: Internal.Products$P5<F, T2, T3, T4, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>
        t1(): Internal.App<F, T1>
    }
    class MinMaxBounds <T> {
    }
    interface PrimitiveCodec <A> implements Internal.Codec<A> {
        encode<T>(arg0: A, arg1: Internal.DynamicOps<T>, arg2: T): Internal.DataResult<T>
        flatComapMap<S>(arg0: (arg0: A) => S, arg1: (arg0: S) => Internal.DataResult<A>): Internal.Codec<S>
        dispatch<E>(arg0: (arg0: E) => A, arg1: (arg0: A) => Internal.Codec<E>): Internal.Codec<E>
        dispatch<E>(arg0: string, arg1: (arg0: E) => A, arg2: (arg0: A) => Internal.Codec<E>): Internal.Codec<E>
        deprecated(arg0: number): Internal.Codec<A>
        simple(): Internal.Decoder$Simple<A>
        dispatchMap<E>(arg0: (arg0: E) => A, arg1: (arg0: A) => Internal.Codec<E>): Internal.MapCodec<E>
        dispatchMap<E>(arg0: string, arg1: (arg0: E) => A, arg2: (arg0: A) => Internal.Codec<E>): Internal.MapCodec<E>
        comapFlatMap<S>(arg0: (arg0: A) => Internal.DataResult<S>, arg1: (arg0: S) => A): Internal.Codec<S>
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
        decode<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
        promotePartial(arg0: Internal.Consumer<any>): Internal.Decoder<any>
        promotePartial(arg0: (arg0: string) => void): Internal.Codec<A>
        flatXmap<S>(arg0: (arg0: A) => Internal.DataResult<S>, arg1: (arg0: S) => Internal.DataResult<A>): Internal.Codec<S>
        comap<B>(arg0: (arg0: B) => A): Internal.Encoder<B>
        fieldOf(arg0: string): Internal.MapEncoder<any>
        fieldOf(arg0: string): Internal.MapDecoder<any>
        fieldOf(arg0: string): Internal.MapCodec<A>
        xmap<S>(arg0: (arg0: A) => S, arg1: (arg0: S) => A): Internal.Codec<S>
        listOf(): Internal.Codec<Internal.List<A>>
        map<B>(arg0: (arg0: A) => B): Internal.Decoder<B>
        write<T>(arg0: Internal.DynamicOps<T>, arg1: A): T
        encodeStart<T>(arg0: Internal.DynamicOps<T>, arg1: A): Internal.DataResult<T>
        optionalFieldOf(arg0: string, arg1: Internal.Lifecycle, arg2: A, arg3: Internal.Lifecycle): Internal.MapCodec<A>
        optionalFieldOf(arg0: string, arg1: A): Internal.MapCodec<A>
        optionalFieldOf(arg0: string): Internal.MapCodec<Internal.Optional<A>>
        optionalFieldOf(arg0: string, arg1: A, arg2: Internal.Lifecycle): Internal.MapCodec<A>
        flatComap<B>(arg0: (arg0: B) => Internal.DataResult<A>): Internal.Encoder<B>
        read<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<A>
        partialDispatch<E>(arg0: string, arg1: (arg0: E) => Internal.DataResult<A>, arg2: (arg0: A) => Internal.DataResult<Internal.Codec<E>>): Internal.Codec<E>
        terminal(): Internal.Decoder$Terminal<A>
        parse<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<A>
        parse<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<A>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Encoder<any>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Decoder<any>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Codec<A>
        orElse(arg0: A): Internal.Codec<A>
        orElse(arg0: (arg0: string) => void, arg1: A): Internal.Codec<A>
        orElse(arg0: Internal.UnaryOperator<string>, arg1: A): Internal.Codec<A>
        flatMap<B>(arg0: (arg0: A) => Internal.DataResult<B>): Internal.Decoder<B>
        boxed(): Internal.Decoder$Boxed<A>
        dispatchStable<E>(arg0: (arg0: E) => A, arg1: (arg0: A) => Internal.Codec<E>): Internal.Codec<E>
        orElseGet(arg0: (arg0: string) => void, arg1: () => A): Internal.Codec<A>
        orElseGet(arg0: () => A): Internal.Codec<A>
        orElseGet(arg0: Internal.UnaryOperator<string>, arg1: () => A): Internal.Codec<A>
        stable(): Internal.Codec<A>
        mapResult(arg0: Internal.Codec$ResultFunction<A>): Internal.Codec<A>
        static readonly FLOAT : Internal.PrimitiveCodec<number>;
        static readonly INT : Internal.PrimitiveCodec<number>;
        static readonly SHORT : Internal.PrimitiveCodec<number>;
        static readonly PASSTHROUGH : Internal.Codec<Internal.Dynamic<object>>;
        static readonly BOOL : Internal.PrimitiveCodec<boolean>;
        static readonly BYTE_BUFFER : Internal.PrimitiveCodec<Internal.ByteBuffer>;
        static readonly INT_STREAM : Internal.PrimitiveCodec<Internal.IntStream>;
        static readonly BYTE : Internal.PrimitiveCodec<number>;
        static readonly LONG_STREAM : Internal.PrimitiveCodec<Internal.LongStream>;
        static readonly STRING : Internal.PrimitiveCodec<string>;
        static readonly DOUBLE : Internal.PrimitiveCodec<number>;
        static readonly EMPTY : Internal.MapCodec<Internal.Unit>;
        static readonly LONG : Internal.PrimitiveCodec<number>;
    }
    interface ChannelOutboundInvoker {
        disconnect(): Internal.ChannelFuture
        disconnect(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        newProgressivePromise(): Internal.ChannelProgressivePromise
        read(): Internal.ChannelOutboundInvoker
        deregister(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        deregister(): Internal.ChannelFuture
        newFailedFuture(arg0: Internal.Throwable): Internal.ChannelFuture
        writeAndFlush(arg0: object): Internal.ChannelFuture
        writeAndFlush(arg0: object, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        bind(arg0: Internal.SocketAddress): Internal.ChannelFuture
        bind(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        newSucceededFuture(): Internal.ChannelFuture
        voidPromise(): Internal.ChannelPromise
        flush(): Internal.ChannelOutboundInvoker
        close(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        close(): Internal.ChannelFuture
        write(arg0: object): Internal.ChannelFuture
        write(arg0: object, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress, arg2: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress): Internal.ChannelFuture
        newPromise(): Internal.ChannelPromise
    }
    interface IReadonly {
        isReadonly(): boolean
    }
    interface Instance {
        getWorldPosition(): BlockPos
        get worldPosition(): BlockPos;
    }
    class DataResult$PartialResult <R> {
        flatMap<R2>(arg0: (arg0: R) => Internal.DataResult$PartialResult<R2>): Internal.DataResult$PartialResult<R2>
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        message(): string
        map<R2>(arg0: (arg0: R) => R2): Internal.DataResult$PartialResult<R2>
    }
    interface MethodHandleInfo {
        static referenceKindToString(arg0: number): string
        getReferenceKind(): number
        getDeclaringClass(): Internal.Class<object>
        getName(): string
        isVarArgs(): boolean
        getMethodType(): Internal.MethodType
        reflectAs<T>(arg0: Internal.Class<T>, arg1: Internal.MethodHandles$Lookup): T
        static toString(arg0: number, arg1: Internal.Class<object>, arg2: string, arg3: Internal.MethodType): string
        getModifiers(): number
        static readonly REF_getStatic : 2;
        static readonly REF_getField : 1;
        static readonly REF_putStatic : 4;
        static readonly REF_newInvokeSpecial : 8;
        static readonly REF_putField : 3;
        static readonly REF_invokeVirtual : 5;
        static readonly REF_invokeSpecial : 7;
        static readonly REF_invokeStatic : 6;
        static readonly REF_invokeInterface : 9;
        get referenceKind(): number;
        get declaringClass(): Internal.Class<object>;
        get name(): string;
        get methodType(): Internal.MethodType;
        get modifiers(): number;
    }
    interface ImmutableBox {
        hasPowerOf2Sides(): boolean
        intersect(arg0: Internal.ImmutableBox): Internal.GridAlignedBB
        intersects(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean
        intersects(arg0: Internal.ImmutableBox): boolean
        getMaxX(): number
        forEachContained(arg0: Internal.CoordinateConsumer): void
        getMaxY(): number
        union(arg0: Internal.ImmutableBox): Internal.ImmutableBox
        getMaxZ(): number
        empty(): boolean
        volume(): number
        sizeX(): number
        contains(arg0: Internal.ImmutableBox): boolean
        contains(arg0: number, arg1: number, arg2: number): boolean
        isContainedBy(arg0: Internal.GridAlignedBB): boolean
        toAABB(): Internal.AABB
        copy(): Internal.GridAlignedBB
        getMinZ(): number
        sizeY(): number
        getMinX(): number
        sizeZ(): number
        sameAs(arg0: Internal.AABB): boolean
        sameAs(arg0: Internal.ImmutableBox): boolean
        getMinY(): number
        get maxX(): number;
        get maxY(): number;
        get maxZ(): number;
        get minZ(): number;
        get minX(): number;
        get minY(): number;
    }
    interface TemporalAdjuster {
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
    }
    class LinkOption extends Internal.Enum<Internal.LinkOption> implements Internal.OpenOption, Internal.CopyOption {
        static valueOf(arg0: string): Internal.LinkOption
        static values(): Internal.LinkOption[]
        static readonly NOFOLLOW_LINKS : Internal.LinkOption;
    }
    interface ChannelPromise implements Internal.ChannelFuture, Internal.Promise<void> {
        cancel(arg0: boolean): boolean
        unvoid(): Internal.ChannelPromise
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelPromise
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelFuture
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.Promise<V>
        getNow(): V
        channel(): Internal.Channel
        cause(): Internal.Throwable
        awaitUninterruptibly(): Internal.ChannelPromise
        awaitUninterruptibly(): Internal.ChannelFuture
        awaitUninterruptibly(): io.netty.util.concurrent.Future<V>
        awaitUninterruptibly(): Internal.Promise<V>
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelPromise
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelFuture
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.Promise<V>
        tryFailure(arg0: Internal.Throwable): boolean
        isDone(): boolean
        sync(): Internal.ChannelPromise
        sync(): Internal.ChannelFuture
        sync(): io.netty.util.concurrent.Future<V>
        sync(): Internal.Promise<V>
        setSuccess(): Internal.ChannelPromise
        setSuccess(arg0: void): Internal.ChannelPromise
        setSuccess(arg0: V): Internal.Promise<V>
        setFailure(arg0: Internal.Throwable): Internal.ChannelPromise
        setFailure(arg0: Internal.Throwable): Internal.Promise<V>
        isVoid(): boolean
        trySuccess(): boolean
        trySuccess(arg0: V): boolean
        syncUninterruptibly(): Internal.ChannelPromise
        syncUninterruptibly(): Internal.ChannelFuture
        syncUninterruptibly(): io.netty.util.concurrent.Future<V>
        syncUninterruptibly(): Internal.Promise<V>
        get(arg0: number, arg1: Internal.TimeUnit): V
        get(): V
        isCancellable(): boolean
        await(): Internal.ChannelPromise
        await(): Internal.ChannelFuture
        await(): io.netty.util.concurrent.Future<V>
        await(): Internal.Promise<V>
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelPromise
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelFuture
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.Promise<V>
        setUncancellable(): boolean
        isSuccess(): boolean
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelPromise
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelFuture
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.Promise<V>
        get now(): V;
        set success(arg0: void);
        set success(arg0: V);
        set failure(arg0: Internal.Throwable);
        set failure(arg0: Internal.Throwable);
    }
    class BlockIDPredicate implements Internal.BlockPredicate {
        getBlockProperties(): Internal.List<Internal.BlockIDPredicate$PropertyObject>
        with(key: string, value: string): Internal.BlockIDPredicate
        checkState(state: Internal.BlockState): boolean
        toString(): string
        check(b: Internal.BlockContainerJS): boolean
        getBlockState(): Internal.BlockState
        get blockProperties(): Internal.List<Internal.BlockIDPredicate$PropertyObject>;
        get blockState(): Internal.BlockState;
    }
    class ValueRange implements Internal.Serializable {
        getMaximum(): number
        getSmallestMaximum(): number
        isIntValue(): boolean
        getLargestMinimum(): number
        isValidValue(arg0: number): boolean
        hashCode(): number
        static of(arg0: number, arg1: number): Internal.ValueRange
        static of(arg0: number, arg1: number, arg2: number, arg3: number): Internal.ValueRange
        static of(arg0: number, arg1: number, arg2: number): Internal.ValueRange
        equals(arg0: object): boolean
        getMinimum(): number
        checkValidIntValue(arg0: number, arg1: Internal.TemporalField): number
        checkValidValue(arg0: number, arg1: Internal.TemporalField): number
        toString(): string
        isFixed(): boolean
        isValidIntValue(arg0: number): boolean
        get maximum(): number;
        get smallestMaximum(): number;
        get largestMinimum(): number;
        get minimum(): number;
    }
    class ImmutableMultiset$Builder <E> extends Internal.ImmutableCollection$Builder<E> {
        add(arg0: object): Internal.ImmutableCollection$Builder<any>
        add(arg0: E): Internal.ImmutableMultiset$Builder<E>
        add(arg0: object[]): Internal.ImmutableCollection$Builder<any>
        add(arg0: E[]): Internal.ImmutableMultiset$Builder<E>
        build(): Internal.ImmutableCollection<any>
        build(): Internal.ImmutableMultiset<E>
        addAll(arg0: Internal.Iterable<any>): Internal.ImmutableCollection$Builder<any>
        addAll(arg0: Internal.Iterable<E>): Internal.ImmutableMultiset$Builder<E>
        addAll(arg0: Internal.Iterator<any>): Internal.ImmutableCollection$Builder<any>
        addAll(arg0: Internal.Iterator<E>): Internal.ImmutableMultiset$Builder<E>
        addCopies(arg0: E, arg1: number): Internal.ImmutableMultiset$Builder<E>
        setCount(arg0: E, arg1: number): Internal.ImmutableMultiset$Builder<E>
    }
    class Explosion$BlockInteraction extends Internal.Enum<Internal.Explosion$BlockInteraction> {
        static valueOf(arg0: string): Internal.Explosion$BlockInteraction
        static values(): Internal.Explosion$BlockInteraction[]
        static readonly DESTROY : Internal.Explosion$BlockInteraction;
        static readonly BREAK : Internal.Explosion$BlockInteraction;
        static readonly NONE : Internal.Explosion$BlockInteraction;
    }
    interface StorableItemStack {
        unregisterFromInventory(arg0: Internal.LithiumStackList): void
        registerToInventory(arg0: Internal.LithiumStackList, arg1: number): void
    }
    class RoundingMode extends Internal.Enum<Internal.RoundingMode> {
        static valueOf(arg0: string): Internal.RoundingMode
        static valueOf(arg0: number): Internal.RoundingMode
        static values(): Internal.RoundingMode[]
        static readonly DOWN : Internal.RoundingMode;
        static readonly FLOOR : Internal.RoundingMode;
        static readonly UNNECESSARY : Internal.RoundingMode;
        static readonly CEILING : Internal.RoundingMode;
        static readonly HALF_EVEN : Internal.RoundingMode;
        static readonly UP : Internal.RoundingMode;
        static readonly HALF_UP : Internal.RoundingMode;
        static readonly HALF_DOWN : Internal.RoundingMode;
    }
    class UUID implements Internal.Serializable, Internal.Comparable<Internal.UUID> {
        static nameUUIDFromBytes(arg0: number[]): Internal.UUID
        compareTo(arg0: object): number
        compareTo(arg0: Internal.UUID): number
        getLeastSignificantBits(): number
        version(): number
        node(): number
        getMostSignificantBits(): number
        hashCode(): number
        equals(arg0: object): boolean
        variant(): number
        static randomUUID(): Internal.UUID
        toString(): string
        static fromString(arg0: string): Internal.UUID
        clockSequence(): number
        timestamp(): number
        get leastSignificantBits(): number;
        get mostSignificantBits(): number;
    }
    class MinecraftServer extends Internal.ReentrantBlockableEventLoop<Unknown> implements Internal.CommandSource, Internal.AutoCloseable, Internal.MinecraftServerKJS {
        getServerResourcesKJS(): Internal.ServerResources
        forgeGetWorldMap(): Map<Internal.ResourceKey<Internal.Level>, Internal.ServerLevel>
        markWorldsDirty(): void
        getServerResources(): Internal.ServerResources
        getTickTime(arg0: Internal.ResourceKey<Internal.Level>): number[]
        close(): void
        asKJS(): object
        get serverResourcesKJS(): Internal.ServerResources;
        get serverResources(): Internal.ServerResources;
    }
    class AbstractInt2IntFunction implements Internal.Int2IntFunction, Internal.Serializable {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Int2ShortFunction): Internal.Int2ShortFunction
        composeByte(arg0: Internal.Byte2IntFunction): Internal.Byte2IntFunction
        andThenInt(arg0: Internal.Int2IntFunction): Internal.Int2IntFunction
        composeReference<T>(arg0: Internal.Reference2IntFunction<T>): Internal.Reference2IntFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: Internal.Int2DoubleFunction): Internal.Int2DoubleFunction
        andThenObject<T>(arg0: Internal.Int2ObjectFunction<T>): Internal.Int2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Int2LongFunction): Internal.Int2LongFunction
        composeLong(arg0: Internal.Long2IntFunction): Internal.Long2IntFunction
        andThenByte(arg0: Internal.Int2ByteFunction): Internal.Int2ByteFunction
        andThenFloat(arg0: Internal.Int2FloatFunction): Internal.Int2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2IntFunction): Internal.Int2IntFunction
        clear(): void
        composeFloat(arg0: Internal.Float2IntFunction): Internal.Float2IntFunction
        andThenChar(arg0: Internal.Int2CharFunction): Internal.Int2CharFunction
        composeObject<T>(arg0: Internal.Object2IntFunction<T>): Internal.Object2IntFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2IntFunction): Internal.Short2IntFunction
        andThenReference<T>(arg0: Internal.Int2ReferenceFunction<T>): Internal.Int2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2IntFunction): Internal.Char2IntFunction
        composeDouble(arg0: Internal.Double2IntFunction): Internal.Double2IntFunction
    }
    class MappedByteBuffer extends Internal.ByteBuffer {
        compact(): Internal.MappedByteBuffer
        compact(): Internal.ByteBuffer
        clear(): Internal.Buffer
        clear(): Internal.MappedByteBuffer
        clear(): Internal.ByteBuffer
        duplicate(): Internal.MappedByteBuffer
        duplicate(): Internal.Buffer
        duplicate(): Internal.ByteBuffer
        isLoaded(): boolean
        rewind(): Internal.MappedByteBuffer
        rewind(): Internal.Buffer
        rewind(): Internal.ByteBuffer
        load(): Internal.MappedByteBuffer
        slice(arg0: number, arg1: number): Internal.ByteBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.MappedByteBuffer
        slice(): Internal.ByteBuffer
        slice(): Internal.MappedByteBuffer
        slice(): Internal.Buffer
        limit(arg0: number): Internal.Buffer
        limit(arg0: number): Internal.ByteBuffer
        limit(arg0: number): Internal.MappedByteBuffer
        reset(): Internal.Buffer
        reset(): Internal.MappedByteBuffer
        reset(): Internal.ByteBuffer
        force(): Internal.MappedByteBuffer
        force(arg0: number, arg1: number): Internal.MappedByteBuffer
        position(arg0: number): Internal.ByteBuffer
        position(arg0: number): Internal.MappedByteBuffer
        position(arg0: number): Internal.Buffer
        flip(): Internal.Buffer
        flip(): Internal.ByteBuffer
        flip(): Internal.MappedByteBuffer
        mark(): Internal.MappedByteBuffer
        mark(): Internal.ByteBuffer
        mark(): Internal.Buffer
    }
    class Timestamp implements Internal.Serializable {
        getSignerCertPath(): Internal.CertPath
        getTimestamp(): Internal.Date
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        get signerCertPath(): Internal.CertPath;
        get timestamp(): Internal.Date;
    }
    class Configuration {
        findModule(arg0: string): Internal.Optional<Internal.ResolvedModule>
        resolve(arg0: Internal.ModuleFinder, arg1: Internal.ModuleFinder, arg2: Internal.Collection<string>): Internal.Configuration
        static resolve(arg0: Internal.ModuleFinder, arg1: Internal.List<Internal.Configuration>, arg2: Internal.ModuleFinder, arg3: Internal.Collection<string>): Internal.Configuration
        toString(): string
        static resolveAndBind(arg0: Internal.ModuleFinder, arg1: Internal.List<Internal.Configuration>, arg2: Internal.ModuleFinder, arg3: Internal.Collection<string>): Internal.Configuration
        resolveAndBind(arg0: Internal.ModuleFinder, arg1: Internal.ModuleFinder, arg2: Internal.Collection<string>): Internal.Configuration
        modules(): Internal.Set<Internal.ResolvedModule>
        parents(): Internal.List<Internal.Configuration>
        static empty(): Internal.Configuration
    }
    interface Function9 <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9): R
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, (arg0: T8, arg1: T9) => R>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, (arg0: T9) => R>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function4<T6, T7, T8, T9, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function3<T7, T8, T9, R>>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function6<T4, T5, T6, T7, T8, T9, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function5<T5, T6, T7, T8, T9, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function7<T3, T4, T5, T6, T7, T8, T9, R>
        curry(): (arg0: T1) => Internal.Function8<T2, T3, T4, T5, T6, T7, T8, T9, R>
    }
    interface ArmorMaterial {
    }
    class NearbyEntityListenerMulti implements Internal.NearbyEntityListener {
        getEntityClass(): Internal.Class<Internal.Entity>
        getChunkRange(): Internal.Range6Int
        onSectionLeftRange<T>(entityTrackingSection: object, collection: Internal.ClassInstanceMultiMap<T>): void
        onSectionEnteredRange<T>(entityTrackingSection: object, collection: Internal.ClassInstanceMultiMap<T>): void
        onEntityLeftRange(entity: Internal.Entity): void
        toString(): string
        forEachChunkInRangeChange(entityCache: Internal.EntitySectionStorage<Internal.EntityAccess>, prevCenterPos: Internal.SectionPos, newCenterPos: Internal.SectionPos): void
        removeListener(listener: Internal.NearbyEntityListener): void
        onEntityEnteredRange(entity: Internal.Entity): void
        addListener(listener: Internal.NearbyEntityListener): void
        static readonly EMPTY_RANGE : Internal.Range6Int;
        get entityClass(): Internal.Class<Internal.Entity>;
        get chunkRange(): Internal.Range6Int;
    }
    interface OffsetVoxelShapeCache {
        getOffsetSimplifiedShape(arg0: number, arg1: Internal.Direction): Internal.VoxelShape
        setShape(arg0: number, arg1: Internal.Direction, arg2: Internal.VoxelShape): void
    }
    class ServerPlayerDataJS extends Internal.PlayerDataJS<Internal.ServerPlayer, Internal.ServerPlayerJS> {
        getServer(): Internal.ServerJS
        getPlayer(): Internal.PlayerJS<any>
        getPlayer(): Internal.ServerPlayerJS
        getMinecraftPlayer(): Internal.ServerPlayer
        getMinecraftPlayer(): Internal.Player
        getName(): string
        getProfile(): Internal.GameProfile
        hasClientMod(): boolean
        getId(): Internal.UUID
        getOverworld(): Internal.LevelJS
        get server(): Internal.ServerJS;
        get player(): Internal.PlayerJS<any>;
        get player(): Internal.ServerPlayerJS;
        get minecraftPlayer(): Internal.ServerPlayer;
        get minecraftPlayer(): Internal.Player;
        get name(): string;
        get profile(): Internal.GameProfile;
        get id(): Internal.UUID;
        get overworld(): Internal.LevelJS;
    }
    interface ParticleProvider <T> {
    }
    interface Watchable {
        register(arg0: Internal.WatchService, arg1: Internal.WatchEvent$Kind<object>[], arg2: Internal.WatchEvent$Modifier[]): Internal.WatchKey
        register(arg0: Internal.WatchService, arg1: Internal.WatchEvent$Kind<object>[]): Internal.WatchKey
    }
    class ListenerStatus extends Internal.Enum<Internal.ListenerStatus> {
        shouldRemove(): boolean
        static valueOf(arg0: string): Internal.ListenerStatus
        isOk(): boolean
        static values(): Internal.ListenerStatus[]
        static readonly OKAY : Internal.ListenerStatus;
        static readonly REMOVE : Internal.ListenerStatus;
        static readonly UPDATE : Internal.ListenerStatus;
    }
    class ByteBuffer extends Internal.Buffer implements Internal.Comparable<Internal.ByteBuffer> {
        asIntBuffer(): Internal.IntBuffer
        compact(): Internal.ByteBuffer
        asLongBuffer(): Internal.LongBuffer
        putDouble(arg0: number, arg1: number): Internal.ByteBuffer
        putDouble(arg0: number): Internal.ByteBuffer
        getDouble(): number
        getDouble(arg0: number): number
        getFloat(arg0: number): number
        getFloat(): number
        compareTo(arg0: object): number
        compareTo(arg0: Internal.ByteBuffer): number
        putLong(arg0: number, arg1: number): Internal.ByteBuffer
        putLong(arg0: number): Internal.ByteBuffer
        asReadOnlyBuffer(): Internal.ByteBuffer
        put(arg0: Internal.ByteBuffer): Internal.ByteBuffer
        put(arg0: number, arg1: number): Internal.ByteBuffer
        put(arg0: number, arg1: Internal.ByteBuffer, arg2: number, arg3: number): Internal.ByteBuffer
        put(arg0: number[]): Internal.ByteBuffer
        put(arg0: number, arg1: number[]): Internal.ByteBuffer
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuffer
        put(arg0: number): Internal.ByteBuffer
        put(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer
        asDoubleBuffer(): Internal.DoubleBuffer
        slice(): Internal.ByteBuffer
        slice(): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.ByteBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        array(): number[]
        array(): object
        hashCode(): number
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuffer
        get(arg0: number): number
        get(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer
        get(): number
        get(arg0: number, arg1: number[]): Internal.ByteBuffer
        get(arg0: number[]): Internal.ByteBuffer
        limit(arg0: number): Internal.Buffer
        limit(arg0: number): Internal.ByteBuffer
        arrayOffset(): number
        putShort(arg0: number): Internal.ByteBuffer
        putShort(arg0: number, arg1: number): Internal.ByteBuffer
        flip(): Internal.Buffer
        flip(): Internal.ByteBuffer
        order(): Internal.ByteOrder
        order(arg0: Internal.ByteOrder): Internal.ByteBuffer
        asFloatBuffer(): Internal.FloatBuffer
        asCharBuffer(): Internal.CharBuffer
        static allocateDirect(arg0: number): Internal.ByteBuffer
        hasArray(): boolean
        putInt(arg0: number, arg1: number): Internal.ByteBuffer
        putInt(arg0: number): Internal.ByteBuffer
        getShort(arg0: number): number
        getShort(): number
        putChar(arg0: number, arg1: string): Internal.ByteBuffer
        putChar(arg0: string): Internal.ByteBuffer
        clear(): Internal.ByteBuffer
        clear(): Internal.Buffer
        duplicate(): Internal.ByteBuffer
        duplicate(): Internal.Buffer
        getLong(arg0: number): number
        getLong(): number
        putFloat(arg0: number): Internal.ByteBuffer
        putFloat(arg0: number, arg1: number): Internal.ByteBuffer
        getInt(): number
        getInt(arg0: number): number
        getChar(): string
        getChar(arg0: number): string
        alignmentOffset(arg0: number, arg1: number): number
        static allocate(arg0: number): Internal.ByteBuffer
        rewind(): Internal.Buffer
        rewind(): Internal.ByteBuffer
        mismatch(arg0: Internal.ByteBuffer): number
        equals(arg0: object): boolean
        reset(): Internal.ByteBuffer
        reset(): Internal.Buffer
        toString(): string
        position(arg0: number): Internal.ByteBuffer
        position(arg0: number): Internal.Buffer
        alignedSlice(arg0: number): Internal.ByteBuffer
        isDirect(): boolean
        static wrap(arg0: number[]): Internal.ByteBuffer
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer
        asShortBuffer(): Internal.ShortBuffer
        mark(): Internal.Buffer
        mark(): Internal.ByteBuffer
        get double(): number;
        get float(): number;
        get short(): number;
        get long(): number;
        get int(): number;
        get char(): string;
    }
    class ContinuationPending extends Internal.RuntimeException {
        getContinuation(): object
        setApplicationState(applicationState: object): void
        getApplicationState(): object
        setContinuation(continuation: Internal.NativeContinuation): void
        get continuation(): object;
        set applicationState(applicationState: object);
        get applicationState(): object;
        set continuation(continuation: Internal.NativeContinuation);
    }
    interface MapEncoder <A> implements Internal.Keyable {
        encode<T>(arg0: A, arg1: Internal.DynamicOps<T>, arg2: Internal.RecordBuilder<T>): Internal.RecordBuilder<T>
        flatComap<B>(arg0: (arg0: B) => Internal.DataResult<A>): Internal.MapEncoder<B>
        compressedBuilder<T>(arg0: Internal.DynamicOps<T>): Internal.RecordBuilder<T>
        keys<T>(arg0: Internal.DynamicOps<T>): Internal.Stream<T>
        comap<B>(arg0: (arg0: B) => A): Internal.MapEncoder<B>
        static makeCompressedBuilder<T>(arg0: Internal.DynamicOps<T>, arg1: Internal.KeyCompressor<T>): Internal.RecordBuilder<T>
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapEncoder<A>
        encoder(): Internal.Encoder<A>
        compressor<T>(arg0: Internal.DynamicOps<T>): Internal.KeyCompressor<T>
    }
    class Minecraft extends Internal.ReentrantBlockableEventLoop<Internal.Runnable> implements Internal.WindowEventHandler, Internal.IForgeMinecraft, Internal.PausedPartialTickAccessor, Internal.MinecraftAccess {
        getSearchTreeManager(): Internal.SearchRegistry
        getFontManager(): Internal.FontManager
        flywheel$getPartialTicksPaused(): number
        handler$beg000$createLevel(arg0: string, arg1: Internal.LevelSettings, arg2: Internal.RegistryAccess$RegistryHolder, arg3: Internal.WorldGenSettings, arg4: Internal.CallbackInfo): void
        popGuiLayer(): void
        getItemColors(): Internal.ItemColors
        close(): void
        pushGuiLayer(arg0: Internal.Screen): void
        get searchTreeManager(): Internal.SearchRegistry;
        get fontManager(): Internal.FontManager;
        get itemColors(): Internal.ItemColors;
    }
    class ForwardingMultimap <K, V> extends Internal.ForwardingObject implements Internal.Multimap<K, V> {
        containsEntry(arg0: object, arg1: object): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        asMap(): Map<K, Internal.Collection<V>>
        keys(): Internal.Multiset<K>
        containsKey(arg0: object): boolean
        values(): Internal.Collection<V>
        isEmpty(): boolean
        clear(): void
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.Collection<V>
        containsValue(arg0: object): boolean
        put(arg0: K, arg1: V): boolean
        remove(arg0: object, arg1: object): boolean
        removeAll(arg0: object): Internal.Collection<V>
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>
        size(): number
        hashCode(): number
        putAll(arg0: Internal.Multimap<K, V>): boolean
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean
        equals(arg0: object): boolean
        get(arg0: K): Internal.Collection<V>
        keySet(): Internal.Set<K>
    }
    class ImmutableMap <K, V> implements Map<K, V>, Internal.Serializable {
        getOrDefault(arg0: object, arg1: V): V
        static ofEntries<K, V>(arg0: Internal.Map$Entry<K, V>[]): Internal.ImmutableMap<K, V>
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V
        values(): Internal.Collection<any>
        values(): Internal.ImmutableCollection<V>
        replace(arg0: K, arg1: V, arg2: V): boolean
        replace(arg0: K, arg1: V): V
        replaceAll(arg0: (arg0: K, arg1: V) => V): void
        containsValue(arg0: object): boolean
        put(arg0: K, arg1: V): V
        remove(arg0: object, arg1: object): boolean
        remove(arg0: object): V
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        static toImmutableMap<T, K, V>(arg0: (arg0: T) => K, arg1: (arg0: T) => V, arg2: Internal.BinaryOperator<V>): Internal.Collector<T, object, Internal.ImmutableMap<K, V>>
        static toImmutableMap<T, K, V>(arg0: (arg0: T) => K, arg1: (arg0: T) => V): Internal.Collector<T, object, Internal.ImmutableMap<K, V>>
        hashCode(): number
        putAll(arg0: Map<K, V>): void
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): Internal.ImmutableMap<K, V>
        static of<K, V>(): Internal.ImmutableMap<K, V>
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): Internal.ImmutableMap<K, V>
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): Internal.ImmutableMap<K, V>
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): Internal.ImmutableMap<K, V>
        static of<K, V>(arg0: K, arg1: V): Internal.ImmutableMap<K, V>
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): Internal.ImmutableMap<K, V>
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): Internal.ImmutableMap<K, V>
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): Internal.ImmutableMap<K, V>
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): Internal.ImmutableMap<K, V>
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): Internal.ImmutableMap<K, V>
        get(arg0: object): V
        static builder<K, V>(): Internal.ImmutableMap$Builder<K, V>
        keySet(): Internal.ImmutableSet<K>
        keySet(): Internal.Set<any>
        entrySet(): Internal.Set<any>
        entrySet(): Internal.ImmutableSet<Internal.Map$Entry<K, V>>
        forEach(arg0: (arg0: K, arg1: V) => void): void
        containsKey(arg0: object): boolean
        isEmpty(): boolean
        clear(): void
        static copyOf<K, V>(arg0: Internal.Iterable<Internal.Map$Entry<K, V>>): Internal.ImmutableMap<K, V>
        static copyOf<K, V>(arg0: Map<K, V>): Internal.ImmutableMap<K, V>
        static builderWithExpectedSize<K, V>(arg0: number): Internal.ImmutableMap$Builder<K, V>
        asMultimap(): Internal.ImmutableSetMultimap<K, V>
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        size(): number
        equals(arg0: object): boolean
        toString(): string
        putIfAbsent(arg0: K, arg1: V): V
    }
    interface Double2IntFunction implements Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Int2ShortFunction): Internal.Double2ShortFunction
        composeByte(arg0: Internal.Byte2DoubleFunction): Internal.Byte2IntFunction
        andThenInt(arg0: Internal.Int2IntFunction): Internal.Double2IntFunction
        composeReference<T>(arg0: Internal.Reference2DoubleFunction<T>): Internal.Reference2IntFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Int2DoubleFunction): Internal.Double2DoubleFunction
        andThenObject<T>(arg0: Internal.Int2ObjectFunction<T>): Internal.Double2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Int2LongFunction): Internal.Double2LongFunction
        composeLong(arg0: Internal.Long2DoubleFunction): Internal.Long2IntFunction
        andThenByte(arg0: Internal.Int2ByteFunction): Internal.Double2ByteFunction
        andThenFloat(arg0: Internal.Int2FloatFunction): Internal.Double2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2DoubleFunction): Internal.Int2IntFunction
        clear(): void
        composeFloat(arg0: Internal.Float2DoubleFunction): Internal.Float2IntFunction
        andThenChar(arg0: Internal.Int2CharFunction): Internal.Double2CharFunction
        composeObject<T>(arg0: Internal.Object2DoubleFunction<T>): Internal.Object2IntFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2DoubleFunction): Internal.Short2IntFunction
        andThenReference<T>(arg0: Internal.Int2ReferenceFunction<T>): Internal.Double2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2DoubleFunction): Internal.Char2IntFunction
        composeDouble(arg0: Internal.Double2DoubleFunction): Internal.Double2IntFunction
    }
    interface RandomAccess {
    }
    interface ScatteringByteChannel implements Internal.ReadableByteChannel {
        isOpen(): boolean
        read(arg0: Internal.ByteBuffer[], arg1: number, arg2: number): number
        read(arg0: Internal.ByteBuffer[]): number
        read(arg0: Internal.ByteBuffer): number
        close(): void
    }
    interface Codec$ResultFunction <A> {
        apply<T>(arg0: Internal.DynamicOps<T>, arg1: T, arg2: Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
        coApply<T>(arg0: Internal.DynamicOps<T>, arg1: A, arg2: Internal.DataResult<T>): Internal.DataResult<T>
    }
    interface FieldNamingStrategy {
        translateName(arg0: Internal.Field): string
    }
    interface LevelSimulatedRW implements Internal.LevelSimulatedReader, Internal.LevelWriter {
    }
    class EntityJS implements Internal.MessageSender, Internal.WrappedJS {
        setY(y: number): void
        setX(x: number): void
        isOnScoreboardTeam(teamID: string): boolean
        isLiving(): boolean
        isSprinting(): boolean
        getItem(): Internal.ItemStackJS
        getTags(): Internal.Set<string>
        setGlowing(glowing: boolean): void
        setZ(z: number): void
        setInvisible(invisible: boolean): void
        getHasCustomName(): boolean
        runCommandSilent(command: string): number
        getDistanceSq(pos: BlockPos): number
        getDistanceSq(x: number, y: number, z: number): number
        isBoss(): boolean
        isGlowing(): boolean
        getHorizontalFacing(): Internal.Direction
        getServer(): Internal.ServerJS
        setMotion(x: number, y: number, z: number): void
        getProfile(): Internal.GameProfile
        setRotation(yaw: number, pitch: number): void
        isOnSameTeam(e: Internal.EntityJS): boolean
        isAnimal(): boolean
        getDisplayName(): Internal.Text
        getType(): string
        setCustomNameAlwaysVisible(b: boolean): void
        addMotion(x: number, y: number, z: number): void
        isInvisible(): boolean
        isUnderWater(): boolean
        getEyeHeight(): number
        getFallDistance(): number
        setOnFire(seconds: number): void
        removePassengers(): void
        attack(source: string, hp: number): void
        attack(hp: number): void
        playSound(id: Internal.SoundEvent, volume: number, pitch: number): void
        playSound(id: Internal.SoundEvent): void
        getDistance(pos: BlockPos): number
        getDistance(x: number, y: number, z: number): number
        setStatusMessage(message: Internal.Component): void
        isSwimming(): boolean
        getCustomName(): Internal.Text
        getStepHeight(): number
        mergeFullNBT(tag: Internal.CompoundTag): Internal.EntityJS
        kill(): void
        getRidingEntity(): Internal.EntityJS
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void
        getLevel(): Internal.LevelJS
        getPitch(): number
        getPassengers(): Internal.EntityArrayList
        isMonster(): boolean
        setPitch(pitch: number): void
        getFacing(): Internal.Direction
        isOnGround(): boolean
        toString(): string
        isSilent(): boolean
        isPassenger(e: Internal.EntityJS): boolean
        getRecursivePassengers(): Internal.EntityArrayList
        getNbt(): Internal.CompoundTag
        setFallDistance(fallDistance: number): void
        getName(): Internal.Text
        setCustomName(name: Internal.Component): void
        setStepHeight(stepHeight: number): void
        tell(message: Internal.Component): void
        getTeamId(): string
        isWaterCreature(): boolean
        setNoClip(noClip: boolean): void
        setPosition(block: Internal.BlockContainerJS): void
        setPosition(x: number, y: number, z: number): void
        extinguish(): void
        setInvulnerable(invulnerable: boolean): void
        setFullNBT(nbt: Internal.CompoundTag): void
        setYaw(yaw: number): void
        getFullNBT(): Internal.CompoundTag
        getNoClip(): boolean
        getYaw(): number
        isAlive(): boolean
        setNoGravity(noGravity: boolean): void
        isPlayer(): boolean
        isCrouching(): boolean
        getId(): Internal.UUID
        getTicksExisted(): number
        setSilent(isSilent: boolean): void
        isFrame(): boolean
        startRiding(e: Internal.EntityJS, force: boolean): boolean
        runCommand(command: string): number
        getCustomNameAlwaysVisible(): boolean
        setMotionZ(z: number): void
        setMotionY(y: number): void
        getBlock(): Internal.BlockContainerJS
        setMotionX(x: number): void
        isInWater(): boolean
        dismountRidingEntity(): void
        isAmbientCreature(): boolean
        rayTrace(distance: number): Internal.RayTraceResultJS
        isInvulnerable(): boolean
        getX(): number
        spawn(): void
        getY(): number
        getZ(): number
        isPeacefulCreature(): boolean
        getMotionZ(): number
        getMotionX(): number
        getNoGravity(): boolean
        getMotionY(): number
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftEntity : Internal.Entity;
        set y(y: number);
        set x(x: number);
        get item(): Internal.ItemStackJS;
        get tags(): Internal.Set<string>;
        set glowing(glowing: boolean);
        set z(z: number);
        set invisible(invisible: boolean);
        get hasCustomName(): boolean;
        get horizontalFacing(): Internal.Direction;
        get server(): Internal.ServerJS;
        get profile(): Internal.GameProfile;
        get displayName(): Internal.Text;
        get type(): string;
        set customNameAlwaysVisible(b: boolean);
        get eyeHeight(): number;
        get fallDistance(): number;
        set onFire(seconds: number);
        set statusMessage(message: Internal.Component);
        get customName(): Internal.Text;
        get stepHeight(): number;
        get ridingEntity(): Internal.EntityJS;
        get level(): Internal.LevelJS;
        get pitch(): number;
        get passengers(): Internal.EntityArrayList;
        set pitch(pitch: number);
        get facing(): Internal.Direction;
        get recursivePassengers(): Internal.EntityArrayList;
        get nbt(): Internal.CompoundTag;
        set fallDistance(fallDistance: number);
        get name(): Internal.Text;
        set customName(name: Internal.Component);
        set stepHeight(stepHeight: number);
        get teamId(): string;
        set noClip(noClip: boolean);
        set position(block: Internal.BlockContainerJS);
        set invulnerable(invulnerable: boolean);
        set fullNBT(nbt: Internal.CompoundTag);
        set yaw(yaw: number);
        get fullNBT(): Internal.CompoundTag;
        get noClip(): boolean;
        get yaw(): number;
        set noGravity(noGravity: boolean);
        get id(): Internal.UUID;
        get ticksExisted(): number;
        set silent(isSilent: boolean);
        get customNameAlwaysVisible(): boolean;
        set motionZ(z: number);
        set motionY(y: number);
        get block(): Internal.BlockContainerJS;
        set motionX(x: number);
        get x(): number;
        get y(): number;
        get z(): number;
        get motionZ(): number;
        get motionX(): number;
        get noGravity(): boolean;
        get motionY(): number;
    }
    interface ToDoubleFunction <T> {
        applyAsDouble(arg0: T): number
    }
    interface MessageSizeEstimator {
        newHandle(): Internal.MessageSizeEstimator$Handle
    }
    interface Int2IntFunction implements Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Int2ShortFunction): Internal.Int2ShortFunction
        composeByte(arg0: Internal.Byte2IntFunction): Internal.Byte2IntFunction
        andThenInt(arg0: Internal.Int2IntFunction): Internal.Int2IntFunction
        composeReference<T>(arg0: Internal.Reference2IntFunction<T>): Internal.Reference2IntFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Int2DoubleFunction): Internal.Int2DoubleFunction
        andThenObject<T>(arg0: Internal.Int2ObjectFunction<T>): Internal.Int2ObjectFunction<T>
        static identity(): Internal.Int2IntFunction
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Int2LongFunction): Internal.Int2LongFunction
        composeLong(arg0: Internal.Long2IntFunction): Internal.Long2IntFunction
        andThenByte(arg0: Internal.Int2ByteFunction): Internal.Int2ByteFunction
        andThenFloat(arg0: Internal.Int2FloatFunction): Internal.Int2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2IntFunction): Internal.Int2IntFunction
        clear(): void
        composeFloat(arg0: Internal.Float2IntFunction): Internal.Float2IntFunction
        andThenChar(arg0: Internal.Int2CharFunction): Internal.Int2CharFunction
        composeObject<T>(arg0: Internal.Object2IntFunction<T>): Internal.Object2IntFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2IntFunction): Internal.Short2IntFunction
        andThenReference<T>(arg0: Internal.Int2ReferenceFunction<T>): Internal.Int2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2IntFunction): Internal.Char2IntFunction
        composeDouble(arg0: Internal.Double2IntFunction): Internal.Double2IntFunction
    }
    interface Temporal implements Internal.TemporalAccessor {
        getLong(arg0: Internal.TemporalField): number
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        query<R>(arg0: Internal.TemporalQuery<R>): R
        get(arg0: Internal.TemporalField): number
        range(arg0: Internal.TemporalField): Internal.ValueRange
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        isSupported(arg0: Internal.TemporalUnit): boolean
        isSupported(arg0: Internal.TemporalField): boolean
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
    }
    interface RecvByteBufAllocator$Handle {
        continueReading(): boolean
        incMessagesRead(arg0: number): void
        allocate(arg0: Internal.ByteBufAllocator): Internal.ByteBuf
        guess(): number
        reset(arg0: Internal.ChannelConfig): void
        readComplete(): void
        attemptedBytesRead(): number
        attemptedBytesRead(arg0: number): void
        lastBytesRead(): number
        lastBytesRead(arg0: number): void
    }
    interface MaterialManager {
        defaultCutout(): Internal.MaterialGroup
        solid(arg0: Internal.RenderType): Internal.MaterialGroup
        defaultSolid(): Internal.MaterialGroup
        cutout(arg0: Internal.RenderType): Internal.MaterialGroup
        defaultTransparent(): Internal.MaterialGroup
        state(arg0: Internal.RenderLayer, arg1: Internal.RenderType): Internal.MaterialGroup
        transparent(arg0: Internal.RenderType): Internal.MaterialGroup
        getOriginCoordinate(): Vec3i
        get originCoordinate(): Vec3i;
    }
    class ImmutableSet$Builder <E> extends Internal.ImmutableCollection$Builder<E> {
        add(arg0: E): Internal.ImmutableSet$Builder<E>
        add(arg0: object): Internal.ImmutableCollection$Builder<any>
        add(arg0: E[]): Internal.ImmutableSet$Builder<E>
        add(arg0: object[]): Internal.ImmutableCollection$Builder<any>
        build(): Internal.ImmutableCollection<any>
        build(): Internal.ImmutableSet<E>
        addAll(arg0: Internal.Iterator<any>): Internal.ImmutableCollection$Builder<any>
        addAll(arg0: Internal.Iterator<E>): Internal.ImmutableSet$Builder<E>
        addAll(arg0: Internal.Iterable<any>): Internal.ImmutableCollection$Builder<any>
        addAll(arg0: Internal.Iterable<E>): Internal.ImmutableSet$Builder<E>
    }
    class PoseStack implements Internal.TransformStack {
        rotate(arg0: Internal.Direction, arg1: number): Self
        rotate(arg0: number, arg1: Internal.Direction$Axis): Self
        translateAll(arg0: number): Self
        scale(arg0: number, arg1: number, arg2: number): Internal.TransformStack
        scale(arg0: number, arg1: number, arg2: number): object
        scale(arg0: number): Self
        translate(arg0: number, arg1: number, arg2: number): Internal.TransformStack
        translate(arg0: number, arg1: number, arg2: number): object
        translate(arg0: Internal.Vector3f): Self
        translate(arg0: Vec3): Self
        translate(arg0: Vec3i): Self
        translateZ(arg0: number): Self
        mulNormal(arg0: Internal.Matrix3f): Self
        transform(arg0: Internal.PoseStack): Self
        transform(arg0: Internal.Matrix4f, arg1: Internal.Matrix3f): Self
        pushPose(): object
        pushPose(): Internal.TransformStack
        translateY(arg0: number): Self
        translateX(arg0: number): Self
        multiply(arg0: Internal.Quaternion): Internal.TransformStack
        multiply(arg0: Internal.Quaternion): object
        multiply(arg0: Internal.Vector3f, arg1: number): Self
        rotateX(arg0: number): Self
        rotateY(arg0: number): Self
        translateBack(arg0: Vec3): Self
        translateBack(arg0: Vec3i): Self
        translateBack(arg0: number, arg1: number, arg2: number): Self
        rotateZ(arg0: number): Self
        rotateToFace(arg0: Internal.Direction): Self
        nudge(arg0: number): Self
        rotateCentered(arg0: Internal.Direction, arg1: number): Self
        rotateCentered(arg0: Internal.Quaternion): Self
        centre(): Self
        multiplyRadians(arg0: Internal.Vector3f, arg1: number): Self
        rotateZRadians(arg0: number): Self
        mulPose(arg0: Internal.Matrix4f): Self
        rotateYRadians(arg0: number): Self
        rotateXRadians(arg0: number): Self
        popPose(): Internal.TransformStack
        popPose(): object
        unCentre(): Self
    }
    interface LootItemConditionMixin implements Internal.ILootHandler {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        test(arg0: T): boolean
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
    }
    class PermissionCollection implements Internal.Serializable {
        add(arg0: Internal.Permission): void
        elementsAsStream(): Internal.Stream<Internal.Permission>
        isReadOnly(): boolean
        elements(): Internal.Enumeration<Internal.Permission>
        toString(): string
        implies(arg0: Internal.Permission): boolean
        setReadOnly(): void
    }
    interface WatchService implements Internal.Closeable {
        take(): Internal.WatchKey
        poll(arg0: number, arg1: Internal.TimeUnit): Internal.WatchKey
        poll(): Internal.WatchKey
        close(): void
    }
    class OptionalDouble {
        isEmpty(): boolean
        isPresent(): boolean
        getAsDouble(): number
        orElse(arg0: number): number
        orElseThrow<X>(arg0: () => X): number
        orElseThrow(): number
        static empty(): Internal.OptionalDouble
        orElseGet(arg0: Internal.DoubleSupplier): number
        stream(): Internal.DoubleStream
        hashCode(): number
        ifPresentOrElse(arg0: Internal.DoubleConsumer, arg1: Internal.Runnable): void
        ifPresent(arg0: Internal.DoubleConsumer): void
        static of(arg0: number): Internal.OptionalDouble
        equals(arg0: object): boolean
        toString(): string
        get asDouble(): number;
    }
    interface SymbolScriptable {
        get(arg0: Internal.Symbol, arg1: Internal.Scriptable): object
        has(arg0: Internal.Symbol, arg1: Internal.Scriptable): boolean
        delete(arg0: Internal.Symbol): void
        put(arg0: Internal.Symbol, arg1: Internal.Scriptable, arg2: object): void
    }
    interface ChannelFuture implements io.netty.util.concurrent.Future<void> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelFuture
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        getNow(): V
        channel(): Internal.Channel
        cause(): Internal.Throwable
        awaitUninterruptibly(): Internal.ChannelFuture
        awaitUninterruptibly(): io.netty.util.concurrent.Future<V>
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelFuture
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        isDone(): boolean
        sync(): Internal.ChannelFuture
        sync(): io.netty.util.concurrent.Future<V>
        isVoid(): boolean
        syncUninterruptibly(): Internal.ChannelFuture
        syncUninterruptibly(): io.netty.util.concurrent.Future<V>
        get(arg0: number, arg1: Internal.TimeUnit): V
        get(): V
        isCancellable(): boolean
        await(): Internal.ChannelFuture
        await(): io.netty.util.concurrent.Future<V>
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelFuture
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        isSuccess(): boolean
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelFuture
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        get now(): V;
    }
    class IsoChronology extends Internal.AbstractChronology implements Internal.Serializable {
        localDateTime(arg0: Internal.TemporalAccessor): Internal.LocalDateTime
        localDateTime(arg0: Internal.TemporalAccessor): Internal.ChronoLocalDateTime<any>
        date(arg0: Internal.TemporalAccessor): Internal.LocalDate
        date(arg0: Internal.TemporalAccessor): Internal.ChronoLocalDate
        date(arg0: Internal.Era, arg1: number, arg2: number, arg3: number): Internal.LocalDate
        date(arg0: Internal.Era, arg1: number, arg2: number, arg3: number): Internal.ChronoLocalDate
        date(arg0: number, arg1: number, arg2: number): Internal.ChronoLocalDate
        date(arg0: number, arg1: number, arg2: number): Internal.LocalDate
        period(arg0: number, arg1: number, arg2: number): Internal.ChronoPeriod
        period(arg0: number, arg1: number, arg2: number): Internal.Period
        dateYearDay(arg0: Internal.Era, arg1: number, arg2: number): Internal.LocalDate
        dateYearDay(arg0: Internal.Era, arg1: number, arg2: number): Internal.ChronoLocalDate
        dateYearDay(arg0: number, arg1: number): Internal.ChronoLocalDate
        dateYearDay(arg0: number, arg1: number): Internal.LocalDate
        getCalendarType(): string
        resolveDate(arg0: Map<Internal.TemporalField, number>, arg1: Internal.ResolverStyle): Internal.LocalDate
        resolveDate(arg0: Map<any, any>, arg1: Internal.ResolverStyle): Internal.ChronoLocalDate
        isLeapYear(arg0: number): boolean
        range(arg0: Internal.ChronoField): Internal.ValueRange
        dateEpochDay(arg0: number): Internal.ChronoLocalDate
        dateEpochDay(arg0: number): Internal.LocalDate
        getId(): string
        dateNow(): Internal.ChronoLocalDate
        dateNow(): Internal.LocalDate
        dateNow(arg0: Internal.ZoneId): Internal.LocalDate
        dateNow(arg0: Internal.ZoneId): Internal.ChronoLocalDate
        dateNow(arg0: Internal.Clock): Internal.ChronoLocalDate
        dateNow(arg0: Internal.Clock): Internal.LocalDate
        eraOf(arg0: number): Internal.IsoEra
        eraOf(arg0: number): Internal.Era
        eras(): Internal.List<Internal.Era>
        prolepticYear(arg0: Internal.Era, arg1: number): number
        zonedDateTime(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.ChronoZonedDateTime<any>
        zonedDateTime(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.ZonedDateTime
        zonedDateTime(arg0: Internal.TemporalAccessor): Internal.ChronoZonedDateTime<any>
        zonedDateTime(arg0: Internal.TemporalAccessor): Internal.ZonedDateTime
        epochSecond(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.ZoneOffset): number
        static readonly INSTANCE : Internal.IsoChronology;
        get calendarType(): string;
        get id(): string;
    }
    interface Object2LongFunction <K> implements Internal.Function<K, number>, Internal.ToLongFunction<K> {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: number): number
        andThenShort(arg0: Internal.Long2ShortFunction): Internal.Object2ShortFunction<K>
        composeByte(arg0: Internal.Byte2ObjectFunction<K>): Internal.Byte2LongFunction
        andThenInt(arg0: Internal.Long2IntFunction): Internal.Object2IntFunction<K>
        composeReference<T>(arg0: (arg0: T) => K): Internal.Reference2LongFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: K) => T
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: object, arg1: object): object
        remove(arg0: object): number
        remove(arg0: object): object
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: Internal.Long2DoubleFunction): Internal.Object2DoubleFunction<K>
        andThenObject<T>(arg0: Internal.Long2ObjectFunction<T>): (arg0: K) => T
        removeLong(arg0: object): number
        get(arg0: object): object
        get(arg0: object): number
        andThenLong(arg0: Internal.Long2LongFunction): Internal.Object2LongFunction<K>
        composeLong(arg0: Internal.Long2ObjectFunction<K>): Internal.Long2LongFunction
        andThenByte(arg0: Internal.Long2ByteFunction): Internal.Object2ByteFunction<K>
        andThenFloat(arg0: Internal.Long2FloatFunction): Internal.Object2FloatFunction<K>
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ObjectFunction<K>): Internal.Int2LongFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ObjectFunction<K>): Internal.Float2LongFunction
        andThenChar(arg0: Internal.Long2CharFunction): Internal.Object2CharFunction<K>
        getLong(arg0: object): number
        applyAsLong(arg0: K): number
        composeObject<T>(arg0: (arg0: T) => K): Internal.Object2LongFunction<T>
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ObjectFunction<K>): Internal.Short2LongFunction
        andThenReference<T>(arg0: Internal.Long2ReferenceFunction<T>): (arg0: K) => T
        composeChar(arg0: Internal.Char2ObjectFunction<K>): Internal.Char2LongFunction
        composeDouble(arg0: Internal.Double2ObjectFunction<K>): Internal.Double2LongFunction
    }
    class ClickType extends Internal.Enum<Internal.ClickType> {
        static valueOf(arg0: string): Internal.ClickType
        static values(): Internal.ClickType[]
        static readonly QUICK_MOVE : Internal.ClickType;
        static readonly SWAP : Internal.ClickType;
        static readonly PICKUP_ALL : Internal.ClickType;
        static readonly THROW : Internal.ClickType;
        static readonly QUICK_CRAFT : Internal.ClickType;
        static readonly PICKUP : Internal.ClickType;
        static readonly CLONE : Internal.ClickType;
    }
    interface NonNullConsumer <T> {
        accept(arg0: T): void
    }
    class ItemType {
        applyDefaults(builder: Internal.ItemBuilder): void
        createItem(arg0: Internal.ItemBuilder): Internal.Item
        generateData(builder: Internal.ItemBuilder, generator: Internal.DataJsonGenerator): void
        generateAssets(builder: Internal.ItemBuilder, generator: Internal.AssetJsonGenerator): void
        readonly name : string;
    }
    interface ConditionContainer {
        survivesExplosion(): Internal.ConditionContainer
        entityScores(entity: Internal.LootContext$EntityTarget, scores: Map<string, object>): Internal.ConditionContainer
        killedByPlayer(): Internal.ConditionContainer
        randomChance(chance: number): Internal.ConditionContainer
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer
        addCondition(arg0: Internal.JsonObject): Internal.ConditionContainer
        entityProperties(entity: Internal.LootContext$EntityTarget, properties: Internal.JsonObject): Internal.ConditionContainer
    }
    class VarHandle$VarHandleDesc extends Internal.DynamicConstantDesc<Internal.VarHandle> {
        static ofStaticField(arg0: Internal.ClassDesc, arg1: string, arg2: Internal.ClassDesc): Internal.VarHandle$VarHandleDesc
        varType(): Internal.ClassDesc
        static ofArray(arg0: Internal.ClassDesc): Internal.VarHandle$VarHandleDesc
        toString(): string
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): object
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): Internal.VarHandle
        static ofField(arg0: Internal.ClassDesc, arg1: string, arg2: Internal.ClassDesc): Internal.VarHandle$VarHandleDesc
    }
    class AbstractInterruptibleChannel implements java_.nio.channels.Channel, Internal.InterruptibleChannel {
        isOpen(): boolean
        close(): void
    }
    interface ClientLevelExtension {
        static cast(arg0: Internal.ClientLevel): Internal.ClientLevelExtension
        flywheel$getAllLoadedEntities(): Internal.Iterable<Internal.Entity>
    }
    class SetTag <T> implements Internal.Tag<T> {
    }
    interface LongStream$LongMapMultiConsumer {
        accept(arg0: number, arg1: Internal.LongConsumer): void
    }
    class CharsetDecoder {
        averageCharsPerByte(): number
        charset(): Internal.Charset
        maxCharsPerByte(): number
        onUnmappableCharacter(arg0: Internal.CodingErrorAction): Internal.CharsetDecoder
        isCharsetDetected(): boolean
        decode(arg0: Internal.ByteBuffer): Internal.CharBuffer
        decode(arg0: Internal.ByteBuffer, arg1: Internal.CharBuffer, arg2: boolean): Internal.CoderResult
        isAutoDetecting(): boolean
        unmappableCharacterAction(): Internal.CodingErrorAction
        detectedCharset(): Internal.Charset
        malformedInputAction(): Internal.CodingErrorAction
        flush(arg0: Internal.CharBuffer): Internal.CoderResult
        onMalformedInput(arg0: Internal.CodingErrorAction): Internal.CharsetDecoder
        reset(): Internal.CharsetDecoder
        replacement(): string
        replaceWith(arg0: string): Internal.CharsetDecoder
    }
    class RecipeTypeJS {
        getMod(): string
        hashCode(): number
        equals(obj: object): boolean
        isCustom(): boolean
        getId(): string
        toString(): string
        getIdRL(): ResourceLocation
        readonly factory : () => Internal.RecipeJS;
        readonly serializer : Internal.RecipeSerializer<object>;
        get mod(): string;
        get id(): string;
        get idRL(): ResourceLocation;
    }
    interface Appendable {
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: string): Internal.Appendable
    }
    interface IngredientKJS implements Internal.AsKJS {
        getItemsKJS(): Internal.ItemStack[]
        asKJS(): object
        get itemsKJS(): Internal.ItemStack[];
    }
    class LazyOptional <T> {
        resolve(): Internal.Optional<T>
        isPresent(): boolean
        invalidate(): void
        orElse(arg0: T): T
        orElseThrow<X>(arg0: Internal.NonNullSupplier<X>): T
        static empty<T>(): Internal.LazyOptional<T>
        filter(arg0: Internal.NonNullPredicate<T>): Internal.Optional<T>
        cast<X>(): Internal.LazyOptional<X>
        orElseGet(arg0: Internal.NonNullSupplier<T>): T
        ifPresent(arg0: Internal.NonNullConsumer<T>): void
        static of<T>(arg0: Internal.NonNullSupplier<T>): Internal.LazyOptional<T>
        map<U>(arg0: Internal.NonNullFunction<T, U>): Internal.Optional<U>
        lazyMap<U>(arg0: Internal.NonNullFunction<T, U>): Internal.LazyOptional<U>
        addListener(arg0: Internal.NonNullConsumer<Internal.LazyOptional<T>>): void
    }
    interface IForgeFriendlyByteBuf {
        readRegistryIdSafe<T>(arg0: Internal.Class<T>): T
        readRegistryId<T>(): T
        readFluidStack(): Internal.FluidStack
        writeRegistryId<T>(arg0: T): void
        readRegistryIdUnsafe<T>(arg0: Internal.IForgeRegistry<T>): T
        writeFluidStack(arg0: Internal.FluidStack): void
        writeRegistryIdUnsafe(arg0: Internal.IForgeRegistry<object>, arg1: ResourceLocation): void
        writeRegistryIdUnsafe<T>(arg0: Internal.IForgeRegistry<T>, arg1: T): void
    }
    interface Spliterator <T> {
        trySplit(): Internal.Spliterator<T>
        tryAdvance(arg0: (arg0: T) => void): boolean
        characteristics(): number
        getComparator(): Internal.Comparator<T>
        getExactSizeIfKnown(): number
        estimateSize(): number
        hasCharacteristics(arg0: number): boolean
        forEachRemaining(arg0: (arg0: T) => void): void
        static readonly NONNULL : 256;
        static readonly SUBSIZED : 16384;
        static readonly ORDERED : 16;
        static readonly DISTINCT : 1;
        static readonly SIZED : 64;
        static readonly IMMUTABLE : 1024;
        static readonly CONCURRENT : 4096;
        static readonly SORTED : 4;
        get comparator(): Internal.Comparator<T>;
        get exactSizeIfKnown(): number;
    }
    interface ChunkRandomSource {
        getRandomPosInChunk(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.BlockPos$MutableBlockPos): void
    }
    interface EntityInLevelCallback {
    }
    interface LivingEntityKJS {
        foodEatenKJS(is: Internal.ItemStack): void
    }
    interface MinecraftServerKJS implements Internal.AsKJS {
        getServerResourcesKJS(): Internal.ServerResources
        asKJS(): object
        get serverResourcesKJS(): Internal.ServerResources;
    }
    interface EntityTargetKJS {
        getNameKJS(): string
        static getNameKJS(target: Internal.LootContext$EntityTarget): string
        get nameKJS(): string;
    }
    class EntityClassGroup {
        contains(entityClass: Internal.Class<object>): boolean
        clear(): void
        static readonly MINECART_BOAT_LIKE_COLLISION : Internal.EntityClassGroup;
    }
    class Products$P6 <F, T1, T2, T3, T4, T5, T6> {
        t4(): Internal.App<F, T4>
        t5(): Internal.App<F, T5>
        t6(): Internal.App<F, T6>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.Function6<T1, T2, T3, T4, T5, T6, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, Internal.Function6<T1, T2, T3, T4, T5, T6, R>>): Internal.App<F, R>
        and<T7>(arg0: Internal.App<F, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        and<T7, T8>(arg0: Internal.Products$P2<F, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        t1(): Internal.App<F, T1>
        t2(): Internal.App<F, T2>
        t3(): Internal.App<F, T3>
    }
    class DyeColor extends Internal.Enum<Internal.DyeColor> implements Internal.StringRepresentable, Internal.Color {
        getRgbKJS(): number
        static valueOf(arg0: string): Internal.DyeColor
        static values(): Internal.DyeColor[]
        createTextColorKJS(): Internal.TextColor
        getHexKJS(): string
        getArgbKJS(): number
        static getColor(arg0: Internal.ItemStack): Internal.DyeColor
        toString(): string
        getFireworkColorKJS(): number
        getSerializeKJS(): string
        getTag(): Internal.Tags$IOptionalNamedTag<Internal.Item>
        specialEquals(o: object, shallow: boolean): boolean
        static readonly WHITE : Internal.DyeColor;
        static readonly GRAY : Internal.DyeColor;
        static readonly BLUE : Internal.DyeColor;
        static readonly PURPLE : Internal.DyeColor;
        static readonly GREEN : Internal.DyeColor;
        static readonly RED : Internal.DyeColor;
        static readonly PINK : Internal.DyeColor;
        static readonly LIGHT_GRAY : Internal.DyeColor;
        static readonly LIGHT_BLUE : Internal.DyeColor;
        static readonly LIME : Internal.DyeColor;
        static readonly MAGENTA : Internal.DyeColor;
        static readonly BLACK : Internal.DyeColor;
        static readonly YELLOW : Internal.DyeColor;
        static readonly CYAN : Internal.DyeColor;
        static readonly BROWN : Internal.DyeColor;
        static readonly ORANGE : Internal.DyeColor;
        get rgbKJS(): number;
        get hexKJS(): string;
        get argbKJS(): number;
        get fireworkColorKJS(): number;
        get serializeKJS(): string;
        get tag(): Internal.Tags$IOptionalNamedTag<Internal.Item>;
    }
    interface ItemStackKJS implements Internal.AsKJS {
        removeTagKJS(): void
        asKJS(): object
    }
    interface Double2FloatFunction implements Internal.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: Internal.Float2ShortFunction): Internal.Double2ShortFunction
        composeByte(arg0: Internal.Byte2DoubleFunction): Internal.Byte2FloatFunction
        andThenInt(arg0: Internal.Float2IntFunction): Internal.Double2IntFunction
        composeReference<T>(arg0: Internal.Reference2DoubleFunction<T>): Internal.Reference2FloatFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Float2DoubleFunction): Internal.Double2DoubleFunction
        andThenObject<T>(arg0: Internal.Float2ObjectFunction<T>): Internal.Double2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Float2LongFunction): Internal.Double2LongFunction
        composeLong(arg0: Internal.Long2DoubleFunction): Internal.Long2FloatFunction
        andThenByte(arg0: Internal.Float2ByteFunction): Internal.Double2ByteFunction
        andThenFloat(arg0: Internal.Float2FloatFunction): Internal.Double2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2DoubleFunction): Internal.Int2FloatFunction
        clear(): void
        composeFloat(arg0: Internal.Float2DoubleFunction): Internal.Float2FloatFunction
        andThenChar(arg0: Internal.Float2CharFunction): Internal.Double2CharFunction
        composeObject<T>(arg0: Internal.Object2DoubleFunction<T>): Internal.Object2FloatFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        composeShort(arg0: Internal.Short2DoubleFunction): Internal.Short2FloatFunction
        andThenReference<T>(arg0: Internal.Float2ReferenceFunction<T>): Internal.Double2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2DoubleFunction): Internal.Char2FloatFunction
        composeDouble(arg0: Internal.Double2DoubleFunction): Internal.Double2FloatFunction
    }
    interface FuncSupplier$Func1 implements Internal.FuncSupplier {
        create(args: Internal.List<dev.latvian.mods.rhino.util.unit.Unit>): dev.latvian.mods.rhino.util.unit.Unit
        create1(arg0: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
    }
    interface ModuleFinder {
        static compose(arg0: Internal.ModuleFinder[]): Internal.ModuleFinder
        find(arg0: string): Internal.Optional<Internal.ModuleReference>
        static of(arg0: Internal.Path[]): Internal.ModuleFinder
        static ofSystem(): Internal.ModuleFinder
        findAll(): Internal.Set<Internal.ModuleReference>
    }
    interface BufferVertexConsumer implements Internal.VertexConsumer {
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer): number
        createSink(factory: Internal.VertexType<any>): Internal.VertexSink
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void
        applyBakedNormals(arg0: Internal.Vector3f, arg1: Internal.ByteBuffer, arg2: Internal.Matrix3f): void
    }
    interface Int2ReferenceFunction <V> implements Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: number, arg1: V): V
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Reference2ShortFunction<V>): Internal.Int2ShortFunction
        composeByte(arg0: Internal.Byte2IntFunction): Internal.Byte2ReferenceFunction<V>
        andThenInt(arg0: Internal.Reference2IntFunction<V>): Internal.Int2IntFunction
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: Internal.Reference2IntFunction<T>): (arg0: T) => V
        put(arg0: number, arg1: V): V
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: object): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: Internal.Reference2DoubleFunction<V>): Internal.Int2DoubleFunction
        andThenObject<T>(arg0: (arg0: V) => T): Internal.Int2ObjectFunction<T>
        get(arg0: object): V
        get(arg0: number): V
        andThenLong(arg0: Internal.Reference2LongFunction<V>): Internal.Int2LongFunction
        composeLong(arg0: Internal.Long2IntFunction): Internal.Long2ReferenceFunction<V>
        andThenByte(arg0: Internal.Reference2ByteFunction<V>): Internal.Int2ByteFunction
        andThenFloat(arg0: Internal.Reference2FloatFunction<V>): Internal.Int2FloatFunction
        apply(arg0: number): V
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2IntFunction): Internal.Int2ReferenceFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2IntFunction): Internal.Float2ReferenceFunction<V>
        andThenChar(arg0: Internal.Reference2CharFunction<V>): Internal.Int2CharFunction
        composeObject<T>(arg0: Internal.Object2IntFunction<T>): (arg0: T) => V
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => V
        composeShort(arg0: Internal.Short2IntFunction): Internal.Short2ReferenceFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): Internal.Int2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2IntFunction): Internal.Char2ReferenceFunction<V>
        composeDouble(arg0: Internal.Double2IntFunction): Internal.Double2ReferenceFunction<V>
    }
    class CreativeModeTab {
        getLabelColor(): number
        getSearchbarWidth(): number
        setBackgroundImage(arg0: ResourceLocation): Internal.CreativeModeTab
        getBackgroundImage(): ResourceLocation
        getSlotColor(): number
        static getGroupCountSafe(): number
        getTabsImage(): ResourceLocation
        getTabPage(): number
        hasSearchBar(): boolean
        get labelColor(): number;
        get searchbarWidth(): number;
        set backgroundImage(arg0: ResourceLocation);
        get backgroundImage(): ResourceLocation;
        get slotColor(): number;
        get groupCountSafe(): number;
        get tabsImage(): ResourceLocation;
        get tabPage(): number;
    }
    class Gson {
        getAdapter<T>(arg0: Internal.TypeToken<T>): Internal.TypeAdapter<T>
        getAdapter<T>(arg0: Internal.Class<T>): Internal.TypeAdapter<T>
        serializeNulls(): boolean
        fieldNamingStrategy(): Internal.FieldNamingStrategy
        excluder(): Internal.Excluder
        toJson(arg0: object): string
        toJson(arg0: Internal.JsonElement, arg1: Internal.JsonWriter): void
        toJson(arg0: object, arg1: Internal.Type, arg2: Internal.JsonWriter): void
        toJson(arg0: Internal.JsonElement, arg1: Internal.Appendable): void
        toJson(arg0: Internal.JsonElement): string
        toJson(arg0: object, arg1: Internal.Type, arg2: Internal.Appendable): void
        toJson(arg0: object, arg1: Internal.Type): string
        toJson(arg0: object, arg1: Internal.Appendable): void
        newJsonWriter(arg0: Internal.Writer): Internal.JsonWriter
        toJsonTree(arg0: object): Internal.JsonElement
        toJsonTree(arg0: object, arg1: Internal.Type): Internal.JsonElement
        fromJson<T>(arg0: Internal.Reader, arg1: Internal.Type): T
        fromJson<T>(arg0: Internal.Reader, arg1: Internal.Class<T>): T
        fromJson<T>(arg0: string, arg1: Internal.Type): T
        fromJson<T>(arg0: string, arg1: Internal.Class<T>): T
        fromJson<T>(arg0: Internal.JsonElement, arg1: Internal.Type): T
        fromJson<T>(arg0: Internal.JsonElement, arg1: Internal.Class<T>): T
        fromJson<T>(arg0: Internal.JsonReader, arg1: Internal.Type): T
        toString(): string
        newBuilder(): Internal.GsonBuilder
        getDelegateAdapter<T>(arg0: Internal.TypeAdapterFactory, arg1: Internal.TypeToken<T>): Internal.TypeAdapter<T>
        htmlSafe(): boolean
        newJsonReader(arg0: Internal.Reader): Internal.JsonReader
    }
    interface PackResources implements Internal.AutoCloseable, Internal.IForgePackResources {
        close(): void
        isHidden(): boolean
    }
    class Package extends Internal.NamedPackage implements Internal.AnnotatedElement {
        isSealed(arg0: Internal.URL): boolean
        isSealed(): boolean
        static getPackage(arg0: string): Internal.Package
        getName(): string
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        getSpecificationTitle(): string
        getImplementationTitle(): string
        isCompatibleWith(arg0: string): boolean
        getAnnotations(): Internal.Annotation[]
        getSpecificationVendor(): string
        getDeclaredAnnotations(): Internal.Annotation[]
        getAnnotationsByType<A>(arg0: Internal.Class<A>): A[]
        getDeclaredAnnotationsByType<A>(arg0: Internal.Class<A>): A[]
        getAnnotation<A>(arg0: Internal.Class<A>): A
        hashCode(): number
        static getPackages(): Internal.Package[]
        getDeclaredAnnotation<A>(arg0: Internal.Class<A>): A
        toString(): string
        getSpecificationVersion(): string
        getImplementationVendor(): string
        getImplementationVersion(): string
        get name(): string;
        get specificationTitle(): string;
        get implementationTitle(): string;
        get annotations(): Internal.Annotation[];
        get specificationVendor(): string;
        get declaredAnnotations(): Internal.Annotation[];
        get packages(): Internal.Package[];
        get specificationVersion(): string;
        get implementationVendor(): string;
        get implementationVersion(): string;
    }
    class URLStreamHandler {
    }
    interface AbstractContainerScreenAccessor {
        setSkipNextRelease(arg0: boolean): void
        setIsQuickCrafting(arg0: boolean): void
        getQuickCraftingButton(): number
        invokeSlotClicked(arg0: Internal.Slot, arg1: number, arg2: number, arg3: Internal.ClickType): void
        getIsQuickCrafting(): boolean
        invokeFindSlot(arg0: number, arg1: number): Internal.Slot
        set skipNextRelease(arg0: boolean);
        set isQuickCrafting(arg0: boolean);
        get quickCraftingButton(): number;
        get isQuickCrafting(): boolean;
    }
    interface Decoder$Boxed <A> {
        decoder(): Internal.Decoder<A>
        decode<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
    }
    interface BiConsumer <T, U> {
        andThen(arg0: (arg0: T, arg1: U) => void): (arg0: T, arg1: U) => void
        accept(arg0: T, arg1: U): void
    }
    interface Stack <K> {
        pop(): K
        top(): K
        isEmpty(): boolean
        push(arg0: K): void
        peek(arg0: number): K
    }
    class HashSet <E> extends Internal.AbstractSet<E> implements Internal.Set<E>, Internal.Cloneable, Internal.Serializable {
        add(arg0: E): boolean
        contains(arg0: object): boolean
        iterator(): Internal.Iterator<E>
        size(): number
        spliterator(): Internal.Spliterator<E>
        toArray<T>(arg0: T[]): T[]
        toArray(): object[]
        isEmpty(): boolean
        clear(): void
        clone(): object
        remove(arg0: object): boolean
    }
    interface Function15 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, Internal.Function3<T13, T14, T15, R>>
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function6<T10, T11, T12, T13, T14, T15, R>>
        curry13(): Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, (arg0: T14, arg1: T15) => R>
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13, arg13: T14, arg14: T15): R
        curry14(): Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, (arg0: T15) => R>
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function8<T8, T9, T10, T11, T12, T13, T14, T15, R>>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function7<T9, T10, T11, T12, T13, T14, T15, R>>
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function5<T11, T12, T13, T14, T15, R>>
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function4<T12, T13, T14, T15, R>>
        curry(): (arg0: T1) => Internal.Function14<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function10<T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function9<T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function12<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function11<T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function13<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>
    }
    interface ConstantDesc {
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): object
    }
    class PropertyMap extends Internal.ForwardingMultimap<string, Unknown> {
    }
    class UpgradeData {
    }
    interface AutoCloseable {
        close(): void
    }
    class ScriptableObject implements Internal.Scriptable, Internal.SymbolScriptable, Internal.Serializable, Internal.ConstProperties {
        isSealed(): boolean
        setParentScope(m: Internal.Scriptable): void
        static redefineProperty(obj: Internal.Scriptable, name: string, isConst: boolean): void
        putConst(name: string, start: Internal.Scriptable, value: object): void
        static getTypedProperty<T>(s: Internal.Scriptable, name: string, type: Internal.Class<T>): T
        static getTypedProperty<T>(s: Internal.Scriptable, index: number, type: Internal.Class<T>): T
        getIds(): object[]
        static getArrayPrototype(scope: Internal.Scriptable): Internal.Scriptable
        getAllIds(): object[]
        put(key: Internal.Symbol, start: Internal.Scriptable, value: object): void
        put(name: string, start: Internal.Scriptable, value: object): void
        put(index: number, start: Internal.Scriptable, value: object): void
        getDefaultValue(typeHint: Internal.Class<object>): object
        static getDefaultValue(object: Internal.Scriptable, typeHint: Internal.Class<object>): object
        defineOwnProperties(cx: Internal.Context, props: Internal.ScriptableObject): void
        defineProperty(propertyName: string, value: object, attributes: number): void
        defineProperty(key: Internal.Symbol, value: object, attributes: number): void
        defineProperty(propertyName: string, delegateTo: object, getter: Internal.Method, setter: Internal.Method, attributes: number): void
        defineProperty(propertyName: string, clazz: Internal.Class<object>, attributes: number): void
        static defineProperty(destination: Internal.Scriptable, propertyName: string, value: object, attributes: number): void
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable, isSetter: boolean): void
        avoidObjectDetection(): boolean
        has(index: number, start: Internal.Scriptable): boolean
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean
        has(name: string, start: Internal.Scriptable): boolean
        getExternalArrayLength(): object
        getAttributes(index: number): number
        getAttributes(sym: Internal.Symbol): number
        getAttributes(name: string): number
        hasInstance(instance: Internal.Scriptable): boolean
        getAssociatedValue(key: object): object
        static getPropertyIds(obj: Internal.Scriptable): object[]
        static hasProperty(obj: Internal.Scriptable, index: number): boolean
        static hasProperty(obj: Internal.Scriptable, key: Internal.Symbol): boolean
        static hasProperty(obj: Internal.Scriptable, name: string): boolean
        getExternalArrayData(): Internal.ExternalArrayData
        size(): number
        defineOwnProperty(cx: Internal.Context, id: object, desc: Internal.ScriptableObject): void
        static getFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable
        getClassName(): string
        getParentScope(): Internal.Scriptable
        preventExtensions(): void
        setExternalArrayData(array: Internal.ExternalArrayData): void
        static callMethod(cx: Internal.Context, obj: Internal.Scriptable, methodName: string, args: object[]): object
        static callMethod(obj: Internal.Scriptable, methodName: string, args: object[]): object
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: object) => void): boolean
        getTypeOf(): string
        static getTopScopeValue(scope: Internal.Scriptable, key: object): object
        sealObject(): void
        setAttributes(key: Internal.Symbol, attributes: number): void
        setAttributes(index: number, attributes: number): void
        setAttributes(name: string, attributes: number): void
        static putProperty(obj: Internal.Scriptable, index: number, value: object): void
        static putProperty(obj: Internal.Scriptable, key: Internal.Symbol, value: object): void
        static putProperty(obj: Internal.Scriptable, name: string, value: object): void
        delete(index: number): void
        delete(name: string): void
        delete(key: Internal.Symbol): void
        associateValue(key: object, value: object): object
        static deleteProperty(obj: Internal.Scriptable, name: string): boolean
        static deleteProperty(obj: Internal.Scriptable, index: number): boolean
        getPrototype(): Internal.Scriptable
        static getObjectPrototype(scope: Internal.Scriptable): Internal.Scriptable
        isExtensible(): boolean
        isConst(name: string): boolean
        get(key: Internal.Symbol, start: Internal.Scriptable): object
        get(name: string, start: Internal.Scriptable): object
        get(index: number, start: Internal.Scriptable): object
        get(key: object): object
        static putConstProperty(obj: Internal.Scriptable, name: string, value: object): void
        getGetterOrSetter(name: string, index: number, isSetter: boolean): object
        static getTopLevelScope(obj: Internal.Scriptable): Internal.Scriptable
        static getProperty(obj: Internal.Scriptable, key: Internal.Symbol): object
        static getProperty(obj: Internal.Scriptable, index: number): object
        static getProperty(obj: Internal.Scriptable, name: string): object
        static defineClass<T>(scope: Internal.Scriptable, clazz: Internal.Class<T>): void
        static defineClass<T>(scope: Internal.Scriptable, clazz: Internal.Class<T>, sealed: boolean): void
        static defineClass<T>(scope: Internal.Scriptable, clazz: Internal.Class<T>, sealed: boolean, mapInheritance: boolean): string
        isEmpty(): boolean
        defineFunctionProperties(names: string[], clazz: Internal.Class<object>, attributes: number): void
        static getClassPrototype(scope: Internal.Scriptable, className: string): Internal.Scriptable
        setPrototype(m: Internal.Scriptable): void
        defineConst(name: string, start: Internal.Scriptable): void
        static defineConstProperty(destination: Internal.Scriptable, propertyName: string): void
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: object) => void): boolean
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : object;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        set parentScope(m: Internal.Scriptable);
        get ids(): object[];
        get allIds(): object[];
        get externalArrayLength(): object;
        get externalArrayData(): Internal.ExternalArrayData;
        get className(): string;
        get parentScope(): Internal.Scriptable;
        set externalArrayData(array: Internal.ExternalArrayData);
        get typeOf(): string;
        get prototype(): Internal.Scriptable;
        set prototype(m: Internal.Scriptable);
    }
    class GameRulesJS {
        getInt(rule: string): number
        set(rule: string, value: object): void
        getBoolean(rule: string): boolean
        getString(rule: string): string
    }
    interface ChannelInboundInvoker {
        fireChannelRead(arg0: object): Internal.ChannelInboundInvoker
        fireChannelInactive(): Internal.ChannelInboundInvoker
        fireChannelReadComplete(): Internal.ChannelInboundInvoker
        fireChannelWritabilityChanged(): Internal.ChannelInboundInvoker
        fireExceptionCaught(arg0: Internal.Throwable): Internal.ChannelInboundInvoker
        fireUserEventTriggered(arg0: object): Internal.ChannelInboundInvoker
        fireChannelActive(): Internal.ChannelInboundInvoker
        fireChannelRegistered(): Internal.ChannelInboundInvoker
        fireChannelUnregistered(): Internal.ChannelInboundInvoker
    }
    interface Guard {
        checkGuard(arg0: object): void
    }
    class Painter {
        getObject(key: string): Internal.PainterObject
        clear(): void
        setVariable(key: string, variable: dev.latvian.mods.rhino.util.unit.Unit): void
        paint(root: Internal.CompoundTag): void
        make(type: string): Internal.PainterObject
        readonly unitStorage : Internal.UnitStorage;
        static readonly LEFT : -1;
        static readonly RANDOM : Internal.Random;
        static readonly DRAW_INGAME : 1;
        static readonly INSTANCE : Internal.Painter;
        static readonly BOTTOM : 1;
        readonly screenHeightUnit : Internal.MutableUnit;
        static readonly DRAW_GUI : 2;
        static readonly CENTER : 0;
        readonly screenWidthUnit : Internal.MutableUnit;
        static readonly DRAW_ALWAYS : 0;
        static readonly TOP : -1;
        readonly mouseXUnit : Internal.MutableUnit;
        readonly mouseYUnit : Internal.MutableUnit;
        readonly deltaUnit : Internal.MutableUnit;
        static readonly RIGHT : 1;
    }
    interface BlittableVertexType <T> implements Internal.BufferVertexType<T> {
        getBufferVertexFormat(): Internal.BufferVertexFormat
        createFallbackWriter(arg0: Internal.VertexConsumer): T
        createBufferWriter(arg0: Internal.VertexBufferView, arg1: boolean): T
        createBufferWriter(buffer: Internal.VertexBufferView): T
        asBlittable(): Internal.BlittableVertexType<T>
        get bufferVertexFormat(): Internal.BufferVertexFormat;
    }
    interface Decoder$Terminal <A> {
        decoder(): Internal.Decoder<A>
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<A>
    }
    interface UnbakedModel {
    }
    class IntSummaryStatistics implements java_.util.function_.IntConsumer {
        getMin(): number
        getMax(): number
        toString(): string
        getAverage(): number
        getSum(): number
        getCount(): number
        andThen(arg0: java_.util.function_.IntConsumer): java_.util.function_.IntConsumer
        combine(arg0: Internal.IntSummaryStatistics): void
        accept(arg0: number): void
        get min(): number;
        get max(): number;
        get average(): number;
        get sum(): number;
        get count(): number;
    }
    interface ICapabilityProvider {
        getCapability<T>(arg0: Internal.Capability<T>, arg1: Internal.Direction): Internal.LazyOptional<T>
        getCapability<T>(arg0: Internal.Capability<T>): Internal.LazyOptional<T>
    }
    class DoubleSummaryStatistics implements Internal.DoubleConsumer {
        getMin(): number
        getMax(): number
        toString(): string
        getAverage(): number
        getSum(): number
        getCount(): number
        andThen(arg0: Internal.DoubleConsumer): Internal.DoubleConsumer
        combine(arg0: Internal.DoubleSummaryStatistics): void
        accept(arg0: number): void
        get min(): number;
        get max(): number;
        get average(): number;
        get sum(): number;
        get count(): number;
    }
    interface Double2ReferenceFunction <V> implements Internal.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: number, arg1: V): V
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Reference2ShortFunction<V>): Internal.Double2ShortFunction
        composeByte(arg0: Internal.Byte2DoubleFunction): Internal.Byte2ReferenceFunction<V>
        andThenInt(arg0: Internal.Reference2IntFunction<V>): Internal.Double2IntFunction
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: Internal.Reference2DoubleFunction<T>): (arg0: T) => V
        put(arg0: number, arg1: V): V
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: object): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: Internal.Reference2DoubleFunction<V>): Internal.Double2DoubleFunction
        andThenObject<T>(arg0: (arg0: V) => T): Internal.Double2ObjectFunction<T>
        get(arg0: object): V
        get(arg0: number): V
        andThenLong(arg0: Internal.Reference2LongFunction<V>): Internal.Double2LongFunction
        composeLong(arg0: Internal.Long2DoubleFunction): Internal.Long2ReferenceFunction<V>
        andThenByte(arg0: Internal.Reference2ByteFunction<V>): Internal.Double2ByteFunction
        andThenFloat(arg0: Internal.Reference2FloatFunction<V>): Internal.Double2FloatFunction
        apply(arg0: number): V
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2DoubleFunction): Internal.Int2ReferenceFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2DoubleFunction): Internal.Float2ReferenceFunction<V>
        andThenChar(arg0: Internal.Reference2CharFunction<V>): Internal.Double2CharFunction
        composeObject<T>(arg0: Internal.Object2DoubleFunction<T>): (arg0: T) => V
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => V
        composeShort(arg0: Internal.Short2DoubleFunction): Internal.Short2ReferenceFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): Internal.Double2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2DoubleFunction): Internal.Char2ReferenceFunction<V>
        composeDouble(arg0: Internal.Double2DoubleFunction): Internal.Double2ReferenceFunction<V>
    }
    class IdFunctionObject extends Internal.BaseFunction {
        getFunctionName(): string
        addAsProperty(target: Internal.Scriptable): void
        hasTag(tag: object): boolean
        initFunction(name: string, scope: Internal.Scriptable): void
        methodId(): number
        getTag(): object
        getArity(): number
        createObject(cx: Internal.Context, scope: Internal.Scriptable): Internal.Scriptable
        unknown(): Internal.RuntimeException
        getPrototype(): Internal.Scriptable
        call(cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: object[]): object
        markAsConstructor(prototypeProperty: Internal.Scriptable): void
        exportAsScopeProperty(): void
        getLength(): number
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : object;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get functionName(): string;
        get tag(): object;
        get arity(): number;
        get prototype(): Internal.Scriptable;
        get length(): number;
    }
    class BigInteger extends Internal.Number implements Internal.Comparable<Internal.BigInteger> {
        bitLength(): number
        getLowestSetBit(): number
        longValueExact(): number
        mod(arg0: Internal.BigInteger): Internal.BigInteger
        byteValueExact(): number
        gcd(arg0: Internal.BigInteger): Internal.BigInteger
        setBit(arg0: number): Internal.BigInteger
        compareTo(arg0: Internal.BigInteger): number
        compareTo(arg0: object): number
        shortValueExact(): number
        longValue(): number
        sqrtAndRemainder(): Internal.BigInteger[]
        not(): Internal.BigInteger
        shiftLeft(arg0: number): Internal.BigInteger
        min(arg0: Internal.BigInteger): Internal.BigInteger
        sqrt(): Internal.BigInteger
        and(arg0: Internal.BigInteger): Internal.BigInteger
        hashCode(): number
        pow(arg0: number): Internal.BigInteger
        clearBit(arg0: number): Internal.BigInteger
        xor(arg0: Internal.BigInteger): Internal.BigInteger
        divide(arg0: Internal.BigInteger): Internal.BigInteger
        multiply(arg0: Internal.BigInteger): Internal.BigInteger
        signum(): number
        add(arg0: Internal.BigInteger): Internal.BigInteger
        flipBit(arg0: number): Internal.BigInteger
        or(arg0: Internal.BigInteger): Internal.BigInteger
        max(arg0: Internal.BigInteger): Internal.BigInteger
        static valueOf(arg0: number): Internal.BigInteger
        intValue(): number
        subtract(arg0: Internal.BigInteger): Internal.BigInteger
        floatValue(): number
        isProbablePrime(arg0: number): boolean
        doubleValue(): number
        nextProbablePrime(): Internal.BigInteger
        testBit(arg0: number): boolean
        shiftRight(arg0: number): Internal.BigInteger
        abs(): Internal.BigInteger
        divideAndRemainder(arg0: Internal.BigInteger): Internal.BigInteger[]
        negate(): Internal.BigInteger
        toByteArray(): number[]
        equals(arg0: object): boolean
        toString(arg0: number): string
        toString(): string
        bitCount(): number
        static probablePrime(arg0: number, arg1: Internal.Random): Internal.BigInteger
        modPow(arg0: Internal.BigInteger, arg1: Internal.BigInteger): Internal.BigInteger
        remainder(arg0: Internal.BigInteger): Internal.BigInteger
        intValueExact(): number
        andNot(arg0: Internal.BigInteger): Internal.BigInteger
        modInverse(arg0: Internal.BigInteger): Internal.BigInteger
        static readonly ZERO : Internal.BigInteger;
        static readonly ONE : Internal.BigInteger;
        static readonly TEN : Internal.BigInteger;
        static readonly TWO : Internal.BigInteger;
        get lowestSetBit(): number;
        set bit(arg0: number);
    }
    class LocalDateTime implements Internal.Temporal, Internal.TemporalAdjuster, Internal.ChronoLocalDateTime<Internal.LocalDate>, Internal.Serializable {
        static ofEpochSecond(arg0: number, arg1: number, arg2: Internal.ZoneOffset): Internal.LocalDateTime
        plusHours(arg0: number): Internal.LocalDateTime
        isEqual(arg0: Internal.ChronoLocalDateTime<object>): boolean
        toLocalTime(): Internal.LocalTime
        compareTo(arg0: Internal.ChronoLocalDateTime<object>): number
        compareTo(arg0: object): number
        getDayOfWeek(): Internal.DayOfWeek
        plusSeconds(arg0: number): Internal.LocalDateTime
        getMinute(): number
        static from(arg0: Internal.TemporalAccessor): Internal.LocalDateTime
        getMonth(): Internal.Month
        plusNanos(arg0: number): Internal.LocalDateTime
        withHour(arg0: number): Internal.LocalDateTime
        plusMonths(arg0: number): Internal.LocalDateTime
        plusYears(arg0: number): Internal.LocalDateTime
        truncatedTo(arg0: Internal.TemporalUnit): Internal.LocalDateTime
        query<R>(arg0: Internal.TemporalQuery<R>): R
        minusNanos(arg0: number): Internal.LocalDateTime
        getNano(): number
        format(arg0: Internal.DateTimeFormatter): string
        isSupported(arg0: Internal.TemporalField): boolean
        isSupported(arg0: Internal.TemporalUnit): boolean
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDateTime<any>
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.LocalDateTime
        plus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDateTime<any>
        plus(arg0: Internal.TemporalAmount): Internal.LocalDateTime
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        getYear(): number
        toEpochSecond(arg0: Internal.ZoneOffset): number
        withDayOfMonth(arg0: number): Internal.LocalDateTime
        withMonth(arg0: number): Internal.LocalDateTime
        isAfter(arg0: Internal.ChronoLocalDateTime<object>): boolean
        static ofInstant(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.LocalDateTime
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDateTime<any>
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.LocalDateTime
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        minus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDateTime<any>
        minus(arg0: Internal.TemporalAmount): Internal.LocalDateTime
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minusHours(arg0: number): Internal.LocalDateTime
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        withYear(arg0: number): Internal.LocalDateTime
        plusMinutes(arg0: number): Internal.LocalDateTime
        minusMinutes(arg0: number): Internal.LocalDateTime
        plusDays(arg0: number): Internal.LocalDateTime
        hashCode(): number
        static now(): Internal.LocalDateTime
        static now(arg0: Internal.Clock): Internal.LocalDateTime
        static now(arg0: Internal.ZoneId): Internal.LocalDateTime
        static of(arg0: number, arg1: Internal.Month, arg2: number, arg3: number, arg4: number, arg5: number): Internal.LocalDateTime
        static of(arg0: number, arg1: Internal.Month, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Internal.LocalDateTime
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): Internal.LocalDateTime
        static of(arg0: number, arg1: Internal.Month, arg2: number, arg3: number, arg4: number): Internal.LocalDateTime
        static of(arg0: Internal.LocalDate, arg1: Internal.LocalTime): Internal.LocalDateTime
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Internal.LocalDateTime
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): Internal.LocalDateTime
        get(arg0: Internal.TemporalField): number
        getDayOfYear(): number
        plusWeeks(arg0: number): Internal.LocalDateTime
        getHour(): number
        getChronology(): Internal.Chronology
        withMinute(arg0: number): Internal.LocalDateTime
        getMonthValue(): number
        minusYears(arg0: number): Internal.LocalDateTime
        atOffset(arg0: Internal.ZoneOffset): Internal.OffsetDateTime
        minusWeeks(arg0: number): Internal.LocalDateTime
        withDayOfYear(arg0: number): Internal.LocalDateTime
        static parse(arg0: Internal.CharSequence): Internal.LocalDateTime
        static parse(arg0: Internal.CharSequence, arg1: Internal.DateTimeFormatter): Internal.LocalDateTime
        atZone(arg0: Internal.ZoneId): Internal.ZonedDateTime
        atZone(arg0: Internal.ZoneId): Internal.ChronoZonedDateTime<any>
        toInstant(arg0: Internal.ZoneOffset): Internal.Instant
        isBefore(arg0: Internal.ChronoLocalDateTime<object>): boolean
        minusDays(arg0: number): Internal.LocalDateTime
        withNano(arg0: number): Internal.LocalDateTime
        getLong(arg0: Internal.TemporalField): number
        minusMonths(arg0: number): Internal.LocalDateTime
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.ChronoLocalDateTime<any>
        with(arg0: Internal.TemporalAdjuster): Internal.LocalDateTime
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalField, arg1: number): Internal.LocalDateTime
        with(arg0: Internal.TemporalField, arg1: number): Internal.ChronoLocalDateTime<any>
        toLocalDate(): Internal.LocalDate
        toLocalDate(): Internal.ChronoLocalDate
        equals(arg0: object): boolean
        getSecond(): number
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        toString(): string
        getDayOfMonth(): number
        minusSeconds(arg0: number): Internal.LocalDateTime
        withSecond(arg0: number): Internal.LocalDateTime
        static readonly MIN : Internal.LocalDateTime;
        static readonly MAX : Internal.LocalDateTime;
        get dayOfWeek(): Internal.DayOfWeek;
        get minute(): number;
        get month(): Internal.Month;
        get nano(): number;
        get year(): number;
        get dayOfYear(): number;
        get hour(): number;
        get chronology(): Internal.Chronology;
        get monthValue(): number;
        get second(): number;
        get dayOfMonth(): number;
    }
    interface Script {
        exec(arg0: Internal.Context, arg1: Internal.Scriptable): object
    }
    class TimeUnit extends Internal.Enum<Internal.TimeUnit> {
        toChronoUnit(): Internal.ChronoUnit
        timedJoin(arg0: Internal.Thread, arg1: number): void
        timedWait(arg0: object, arg1: number): void
        static valueOf(arg0: string): Internal.TimeUnit
        static values(): Internal.TimeUnit[]
        convert(arg0: Internal.Duration): number
        convert(arg0: number, arg1: Internal.TimeUnit): number
        toSeconds(arg0: number): number
        sleep(arg0: number): void
        toNanos(arg0: number): number
        toMinutes(arg0: number): number
        toHours(arg0: number): number
        static of(arg0: Internal.ChronoUnit): Internal.TimeUnit
        toMillis(arg0: number): number
        toDays(arg0: number): number
        toMicros(arg0: number): number
        static readonly MILLISECONDS : Internal.TimeUnit;
        static readonly MICROSECONDS : Internal.TimeUnit;
        static readonly HOURS : Internal.TimeUnit;
        static readonly SECONDS : Internal.TimeUnit;
        static readonly NANOSECONDS : Internal.TimeUnit;
        static readonly DAYS : Internal.TimeUnit;
        static readonly MINUTES : Internal.TimeUnit;
    }
    interface EventLoop implements Internal.OrderedEventExecutor, Internal.EventLoopGroup {
        next(): Internal.EventExecutor
        next(): Internal.EventLoop
        terminationFuture(): io.netty.util.concurrent.Future<object>
        parent(): Internal.EventLoopGroup
        parent(): Internal.EventExecutorGroup
        newProgressivePromise<V>(): Internal.ProgressivePromise<V>
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit): io.netty.util.concurrent.Future<object>
        shutdownGracefully(): io.netty.util.concurrent.Future<object>
        submit<T>(arg0: Internal.Runnable, arg1: T): io.netty.util.concurrent.Future<T>
        submit<T>(arg0: Internal.Runnable, arg1: T): Internal.Future<T>
        submit<T>(arg0: java_.util.concurrent.Callable<T>): io.netty.util.concurrent.Future<T>
        submit<T>(arg0: java_.util.concurrent.Callable<T>): Internal.Future<T>
        submit(arg0: Internal.Runnable): io.netty.util.concurrent.Future<object>
        submit(arg0: Internal.Runnable): Internal.Future<object>
        isTerminated(): boolean
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<object>
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<object>
        inEventLoop(arg0: Internal.Thread): boolean
        inEventLoop(): boolean
        iterator(): Internal.Iterator<Internal.EventExecutor>
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean
        shutdownNow(): Internal.List<Internal.Runnable>
        newPromise<V>(): Internal.Promise<V>
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<object>
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<object>
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
        invokeAll<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<Internal.Future<T>>
        invokeAll<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>): Internal.List<Internal.Future<T>>
        newFailedFuture<V>(arg0: Internal.Throwable): io.netty.util.concurrent.Future<V>
        execute(arg0: Internal.Runnable): void
        isShuttingDown(): boolean
        schedule<V>(arg0: java_.util.concurrent.Callable<V>, arg1: number, arg2: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<V>
        schedule<V>(arg0: java_.util.concurrent.Callable<V>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<object>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<object>
        newSucceededFuture<V>(arg0: V): io.netty.util.concurrent.Future<V>
        invokeAny<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>): T
        invokeAny<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>, arg1: number, arg2: Internal.TimeUnit): T
        shutdown(): void
        register(arg0: Internal.Channel, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        register(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        register(arg0: Internal.Channel): Internal.ChannelFuture
        isShutdown(): boolean
    }
    interface VertexBufferView {
        ensureBufferCapacity(arg0: number): boolean
        flush(arg0: number, arg1: Internal.BufferVertexFormat): void
        getWriterPosition(): number
        getVertexFormat(): Internal.BufferVertexFormat
        getDirectBuffer(): Internal.ByteBuffer
        get writerPosition(): number;
        get vertexFormat(): Internal.BufferVertexFormat;
        get directBuffer(): Internal.ByteBuffer;
    }
    class SawmillRecipeJS extends Internal.IERecipeJS {
        serialize(): void
        create(args: Internal.ListJS): void
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        hasStripped : boolean;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        stripping : Internal.List<boolean>;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<object>;
        readonly inputFluids : Internal.List<Internal.FluidTagInput>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        serializeInputs : boolean;
    }
    class AtomicBoolean implements Internal.Serializable {
        setPlain(arg0: boolean): void
        weakCompareAndSetPlain(arg0: boolean, arg1: boolean): boolean
        set(arg0: boolean): void
        weakCompareAndSetRelease(arg0: boolean, arg1: boolean): boolean
        weakCompareAndSet(arg0: boolean, arg1: boolean): boolean
        compareAndExchange(arg0: boolean, arg1: boolean): boolean
        getAcquire(): boolean
        setOpaque(arg0: boolean): void
        getPlain(): boolean
        compareAndExchangeRelease(arg0: boolean, arg1: boolean): boolean
        getOpaque(): boolean
        compareAndSet(arg0: boolean, arg1: boolean): boolean
        compareAndExchangeAcquire(arg0: boolean, arg1: boolean): boolean
        get(): boolean
        lazySet(arg0: boolean): void
        setRelease(arg0: boolean): void
        toString(): string
        getAndSet(arg0: boolean): boolean
        weakCompareAndSetAcquire(arg0: boolean, arg1: boolean): boolean
        weakCompareAndSetVolatile(arg0: boolean, arg1: boolean): boolean
        set plain(arg0: boolean);
        get acquire(): boolean;
        set opaque(arg0: boolean);
        get plain(): boolean;
        get opaque(): boolean;
        set release(arg0: boolean);
    }
    class ResolverStyle extends Internal.Enum<Internal.ResolverStyle> {
        static valueOf(arg0: string): Internal.ResolverStyle
        static values(): Internal.ResolverStyle[]
        static readonly STRICT : Internal.ResolverStyle;
        static readonly LENIENT : Internal.ResolverStyle;
        static readonly SMART : Internal.ResolverStyle;
    }
    class ServerScriptManager {
        init(serverResources: Internal.ServerResources): void
        reloadScriptManager(resourceManager: Internal.ResourceManager): void
        resourcePackList(list0: Internal.List<Internal.PackResources>): Internal.List<Internal.PackResources>
        readonly scriptManager : Internal.ScriptManager;
        static instance : Internal.ServerScriptManager;
    }
    interface Position {
    }
    class Context {
        static throwAsScriptRuntimeEx(e: Internal.Throwable): Internal.RuntimeException
        isSealed(): boolean
        callFunctionWithContinuations(function_: Internal.Callable, scope: Internal.Scriptable, args: object[]): object
        executeScriptWithContinuations(script: Internal.Script, scope: Internal.Scriptable): object
        getClassShutterSetter(): Internal.Context$ClassShutterSetter
        createClassLoader(parent: Internal.ClassLoader): Internal.GeneratedClassLoader
        getApplicationClassLoader(): Internal.ClassLoader
        evaluateReader(scope: Internal.Scriptable, in_: Internal.Reader, sourceName: string, lineno: number, securityDomain: object): object
        getTypeWrappers(): Internal.TypeWrappers
        static javaToJS(value: object, scope: Internal.Scriptable): object
        compileReader(in_: Internal.Reader, sourceName: string, lineno: number, securityDomain: object): Internal.Script
        static toBoolean(value: object): boolean
        captureContinuation(): Internal.ContinuationPending
        static enter(): Internal.Context
        resumeContinuation(continuation: object, scope: Internal.Scriptable, functionResult: object): object
        static reportRuntimeError0(messageId: string): Internal.EvaluatorException
        static reportRuntimeError1(messageId: string, arg1: object): Internal.EvaluatorException
        static reportRuntimeError2(messageId: string, arg1: object, arg2: object): Internal.EvaluatorException
        static reportRuntimeError3(messageId: string, arg1: object, arg2: object, arg3: object): Internal.EvaluatorException
        static reportRuntimeError(message: string): Internal.EvaluatorException
        static reportRuntimeError(message: string, sourceName: string, lineno: number, lineSource: string, lineOffset: number): Internal.EvaluatorException
        getInstructionObserverThreshold(): number
        hasTypeWrappers(): boolean
        getThreadLocal(key: object): object
        removePropertyChangeListener(l: Internal.PropertyChangeListener): void
        static getUndefinedValue(): object
        putThreadLocal(key: object, value: object): void
        setClassShutter(shutter: Internal.ClassShutter): void
        static exit(): void
        setInstructionObserverThreshold(threshold: number): void
        getElements(object: Internal.Scriptable): object[]
        static reportRuntimeError4(messageId: string, arg1: object, arg2: object, arg3: object, arg4: object): Internal.EvaluatorException
        hasFeature(featureIndex: number): boolean
        initSafeStandardObjects(scope: Internal.ScriptableObject, sealed: boolean): Internal.ScriptableObject
        initSafeStandardObjects(scope: Internal.ScriptableObject): Internal.Scriptable
        initSafeStandardObjects(): Internal.ScriptableObject
        static toNumber(value: object): number
        setLocale(loc: Internal.Locale): Internal.Locale
        initStandardObjects(scope: Internal.ScriptableObject, sealed: boolean): Internal.ScriptableObject
        initStandardObjects(): Internal.ScriptableObject
        initStandardObjects(scope: Internal.ScriptableObject): Internal.Scriptable
        isStrictMode(): boolean
        setApplicationClassLoader(loader: Internal.ClassLoader): void
        getWrapFactory(): Internal.WrapFactory
        setGenerateObserverCount(generateObserverCount: boolean): void
        seal(sealKey: object): void
        setWrapFactory(wrapFactory: Internal.WrapFactory): void
        evaluateString(scope: Internal.Scriptable, source: string, sourceName: string, lineno: number, securityDomain: object): object
        compileFunction(scope: Internal.Scriptable, source: string, sourceName: string, lineno: number, securityDomain: object): dev.latvian.mods.rhino.Function
        setErrorReporter(reporter: Internal.ErrorReporter): Internal.ErrorReporter
        getClassShutter(): Internal.ClassShutter
        newObject(scope: Internal.Scriptable): Internal.Scriptable
        newObject(scope: Internal.Scriptable, constructorName: string): Internal.Scriptable
        newObject(scope: Internal.Scriptable, constructorName: string, args: object[]): Internal.Scriptable
        static jsToJava(value: object, desiredType: Internal.Class<object>): object
        static toObject(value: object, scope: Internal.Scriptable): Internal.Scriptable
        static getSourcePositionFromStack(linep: number[]): string
        addPropertyChangeListener(l: Internal.PropertyChangeListener): void
        static reportWarning(message: string): void
        static reportWarning(message: string, t: Internal.Throwable): void
        static reportWarning(message: string, sourceName: string, lineno: number, lineSource: string, lineOffset: number): void
        setLanguageVersion(version: number): void
        stringIsCompilableUnit(source: string): boolean
        removeThreadLocal(key: object): void
        static getCurrentContext(): Internal.Context
        newArray(scope: Internal.Scriptable, length: number): Internal.Scriptable
        newArray(scope: Internal.Scriptable, elements: object[]): Internal.Scriptable
        static reportError(message: string): void
        static reportError(message: string, sourceName: string, lineno: number, lineSource: string, lineOffset: number): void
        getFactory(): Internal.ContextFactory
        getErrorReporter(): Internal.ErrorReporter
        static call(factory: Internal.ContextFactory, callable: Internal.Callable, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: object[]): object
        getMaximumInterpreterStackDepth(): number
        setMaximumInterpreterStackDepth(max: number): void
        compileString(source: string, sourceName: string, lineno: number, securityDomain: object): Internal.Script
        static toString(value: object): string
        unseal(sealKey: object): void
        getLocale(): Internal.Locale
        static getContext(): Internal.Context
        static enterWithNewFactory(): Internal.Context
        getImplementationVersion(): string
        static readonly FEATURE_INTEGER_WITHOUT_DECIMAL_PLACE : 18;
        static readonly FEATURE_ENHANCED_JAVA_ACCESS : 13;
        static readonly FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER : 3;
        static readonly FEATURE_DYNAMIC_SCOPE : 7;
        static readonly FEATURE_LITTLE_ENDIAN : 19;
        static readonly FEATURE_THREAD_SAFE_OBJECTS : 17;
        generateObserverCount : boolean;
        static readonly FEATURE_STRICT_MODE : 11;
        static readonly FEATURE_WARNING_AS_ERROR : 12;
        static readonly FEATURE_STRICT_EVAL : 9;
        static readonly FEATURE_LOCATION_INFORMATION_IN_ERROR : 10;
        static readonly errorReporterProperty : "error reporter";
        static readonly FEATURE_V8_EXTENSIONS : 14;
        static readonly FEATURE_STRICT_VARS : 8;
        static readonly FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME : 2;
        static readonly FEATURE_PARENT_PROTO_PROPERTIES : 5;
        static readonly languageVersionProperty : "language version";
        static readonly emptyArgs : object[];
        get classShutterSetter(): Internal.Context$ClassShutterSetter;
        get applicationClassLoader(): Internal.ClassLoader;
        get typeWrappers(): Internal.TypeWrappers;
        get instructionObserverThreshold(): number;
        get undefinedValue(): object;
        set classShutter(shutter: Internal.ClassShutter);
        set instructionObserverThreshold(threshold: number);
        set locale(loc: Internal.Locale);
        set applicationClassLoader(loader: Internal.ClassLoader);
        get wrapFactory(): Internal.WrapFactory;
        set wrapFactory(wrapFactory: Internal.WrapFactory);
        set errorReporter(reporter: Internal.ErrorReporter);
        get classShutter(): Internal.ClassShutter;
        set languageVersion(version: number);
        get currentContext(): Internal.Context;
        get factory(): Internal.ContextFactory;
        get errorReporter(): Internal.ErrorReporter;
        get maximumInterpreterStackDepth(): number;
        set maximumInterpreterStackDepth(max: number);
        get locale(): Internal.Locale;
        get context(): Internal.Context;
        get implementationVersion(): string;
    }
    interface EquipmentEntity {
        lithiumOnEquipmentChanged(): void
    }
    interface ChannelHandlerContext implements Internal.AttributeMap, Internal.ChannelInboundInvoker, Internal.ChannelOutboundInvoker {
        disconnect(): Internal.ChannelFuture
        disconnect(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        handler(): Internal.ChannelHandler
        newProgressivePromise(): Internal.ChannelProgressivePromise
        fireChannelWritabilityChanged(): Internal.ChannelHandlerContext
        fireChannelWritabilityChanged(): Internal.ChannelInboundInvoker
        channel(): Internal.Channel
        fireExceptionCaught(arg0: Internal.Throwable): Internal.ChannelHandlerContext
        fireExceptionCaught(arg0: Internal.Throwable): Internal.ChannelInboundInvoker
        fireChannelActive(): Internal.ChannelHandlerContext
        fireChannelActive(): Internal.ChannelInboundInvoker
        writeAndFlush(arg0: object): Internal.ChannelFuture
        writeAndFlush(arg0: object, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        bind(arg0: Internal.SocketAddress): Internal.ChannelFuture
        bind(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        isRemoved(): boolean
        flush(): Internal.ChannelHandlerContext
        flush(): Internal.ChannelOutboundInvoker
        executor(): Internal.EventExecutor
        attr<T>(arg0: Internal.AttributeKey<T>): io.netty.util.Attribute<T>
        close(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        close(): Internal.ChannelFuture
        write(arg0: object): Internal.ChannelFuture
        write(arg0: object, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress, arg2: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress): Internal.ChannelFuture
        newPromise(): Internal.ChannelPromise
        fireChannelInactive(): Internal.ChannelHandlerContext
        fireChannelInactive(): Internal.ChannelInboundInvoker
        read(): Internal.ChannelHandlerContext
        read(): Internal.ChannelOutboundInvoker
        fireChannelReadComplete(): Internal.ChannelHandlerContext
        fireChannelReadComplete(): Internal.ChannelInboundInvoker
        deregister(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        deregister(): Internal.ChannelFuture
        newFailedFuture(arg0: Internal.Throwable): Internal.ChannelFuture
        hasAttr<T>(arg0: Internal.AttributeKey<T>): boolean
        fireChannelRegistered(): Internal.ChannelHandlerContext
        fireChannelRegistered(): Internal.ChannelInboundInvoker
        pipeline(): Internal.ChannelPipeline
        fireChannelRead(arg0: object): Internal.ChannelHandlerContext
        fireChannelRead(arg0: object): Internal.ChannelInboundInvoker
        newSucceededFuture(): Internal.ChannelFuture
        voidPromise(): Internal.ChannelPromise
        name(): string
        fireUserEventTriggered(arg0: object): Internal.ChannelHandlerContext
        fireUserEventTriggered(arg0: object): Internal.ChannelInboundInvoker
        alloc(): Internal.ByteBufAllocator
        fireChannelUnregistered(): Internal.ChannelHandlerContext
        fireChannelUnregistered(): Internal.ChannelInboundInvoker
    }
    class URI implements Internal.Comparable<Internal.URI>, Internal.Serializable {
        toASCIIString(): string
        resolve(arg0: string): Internal.URI
        resolve(arg0: Internal.URI): Internal.URI
        isOpaque(): boolean
        compareTo(arg0: Internal.URI): number
        compareTo(arg0: object): number
        getRawAuthority(): string
        hashCode(): number
        normalize(): Internal.URI
        getPath(): string
        static create(arg0: string): Internal.URI
        relativize(arg0: Internal.URI): Internal.URI
        getQuery(): string
        getHost(): string
        toURL(): Internal.URL
        getScheme(): string
        getAuthority(): string
        getRawFragment(): string
        getRawUserInfo(): string
        parseServerAuthority(): Internal.URI
        getRawSchemeSpecificPart(): string
        getRawQuery(): string
        getPort(): number
        equals(arg0: object): boolean
        isAbsolute(): boolean
        toString(): string
        getFragment(): string
        getRawPath(): string
        getUserInfo(): string
        getSchemeSpecificPart(): string
        get rawAuthority(): string;
        get path(): string;
        get query(): string;
        get host(): string;
        get scheme(): string;
        get authority(): string;
        get rawFragment(): string;
        get rawUserInfo(): string;
        get rawSchemeSpecificPart(): string;
        get rawQuery(): string;
        get port(): number;
        get fragment(): string;
        get rawPath(): string;
        get userInfo(): string;
        get schemeSpecificPart(): string;
    }
    interface Rotate <Self> {
        rotateZRadians(arg0: number): Self
        rotate(arg0: Internal.Direction, arg1: number): Self
        rotate(arg0: number, arg1: Internal.Direction$Axis): Self
        rotateYRadians(arg0: number): Self
        rotateXRadians(arg0: number): Self
        multiplyRadians(arg0: Internal.Vector3f, arg1: number): Self
        multiply(arg0: Internal.Vector3f, arg1: number): Self
        multiply(arg0: Internal.Quaternion): Self
        rotateX(arg0: number): Self
        rotateY(arg0: number): Self
        rotateZ(arg0: number): Self
        rotateToFace(arg0: Internal.Direction): Self
    }
    class CharBuffer extends Internal.Buffer implements Internal.Comparable<Internal.CharBuffer>, Internal.Appendable, Internal.CharSequence, Internal.Readable {
        compact(): Internal.CharBuffer
        compareTo(arg0: Internal.CharBuffer): number
        compareTo(arg0: object): number
        asReadOnlyBuffer(): Internal.CharBuffer
        put(arg0: Internal.CharBuffer): Internal.CharBuffer
        put(arg0: string, arg1: number, arg2: number): Internal.CharBuffer
        put(arg0: number, arg1: string[]): Internal.CharBuffer
        put(arg0: number, arg1: string): Internal.CharBuffer
        put(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.CharBuffer
        put(arg0: string[]): Internal.CharBuffer
        put(arg0: string[], arg1: number, arg2: number): Internal.CharBuffer
        put(arg0: number, arg1: Internal.CharBuffer, arg2: number, arg3: number): Internal.CharBuffer
        put(arg0: string): Internal.CharBuffer
        put(arg0: string): Internal.CharBuffer
        slice(): Internal.CharBuffer
        slice(): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.CharBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        array(): string[]
        array(): object
        hashCode(): number
        get(): string
        get(arg0: number): string
        get(arg0: string[], arg1: number, arg2: number): Internal.CharBuffer
        get(arg0: string[]): Internal.CharBuffer
        get(arg0: number, arg1: string[]): Internal.CharBuffer
        get(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.CharBuffer
        limit(arg0: number): Internal.CharBuffer
        limit(arg0: number): Internal.Buffer
        arrayOffset(): number
        flip(): Internal.CharBuffer
        flip(): Internal.Buffer
        codePoints(): Internal.IntStream
        order(): Internal.ByteOrder
        hasArray(): boolean
        read(arg0: Internal.CharBuffer): number
        isEmpty(): boolean
        clear(): Internal.CharBuffer
        clear(): Internal.Buffer
        length(): number
        duplicate(): Internal.CharBuffer
        duplicate(): Internal.Buffer
        subSequence(arg0: number, arg1: number): Internal.CharSequence
        subSequence(arg0: number, arg1: number): Internal.CharBuffer
        static allocate(arg0: number): Internal.CharBuffer
        rewind(): Internal.Buffer
        rewind(): Internal.CharBuffer
        mismatch(arg0: Internal.CharBuffer): number
        equals(arg0: object): boolean
        reset(): Internal.CharBuffer
        reset(): Internal.Buffer
        toString(): string
        position(arg0: number): Internal.Buffer
        position(arg0: number): Internal.CharBuffer
        isDirect(): boolean
        static wrap(arg0: string[], arg1: number, arg2: number): Internal.CharBuffer
        static wrap(arg0: string[]): Internal.CharBuffer
        static wrap(arg0: Internal.CharSequence): Internal.CharBuffer
        static wrap(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.CharBuffer
        mark(): Internal.Buffer
        mark(): Internal.CharBuffer
        chars(): Internal.IntStream
        charAt(arg0: number): string
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.CharBuffer
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.CharBuffer
        append(arg0: string): Internal.CharBuffer
        append(arg0: string): Internal.Appendable
    }
    class ThreadGroup implements Internal.Thread$UncaughtExceptionHandler {
        setMaxPriority(arg0: number): void
        suspend(): void
        activeCount(): number
        resume(): void
        getParent(): Internal.ThreadGroup
        getName(): string
        isDestroyed(): boolean
        destroy(): void
        parentOf(arg0: Internal.ThreadGroup): boolean
        list(): void
        checkAccess(): void
        setDaemon(arg0: boolean): void
        allowThreadSuspension(arg0: boolean): boolean
        getMaxPriority(): number
        stop(): void
        isDaemon(): boolean
        interrupt(): void
        activeGroupCount(): number
        uncaughtException(arg0: Internal.Thread, arg1: Internal.Throwable): void
        enumerate(arg0: Internal.ThreadGroup[], arg1: boolean): number
        enumerate(arg0: Internal.ThreadGroup[]): number
        enumerate(arg0: Internal.Thread[]): number
        enumerate(arg0: Internal.Thread[], arg1: boolean): number
        toString(): string
        set maxPriority(arg0: number);
        get parent(): Internal.ThreadGroup;
        get name(): string;
        set daemon(arg0: boolean);
        get maxPriority(): number;
    }
    interface Reference2CharFunction <K> implements Internal.Function<K, string>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: object, arg1: string): string
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: string): string
        andThenShort(arg0: Internal.Char2ShortFunction): Internal.Reference2ShortFunction<K>
        removeChar(arg0: object): string
        composeByte(arg0: Internal.Byte2ReferenceFunction<K>): Internal.Byte2CharFunction
        andThenInt(arg0: Internal.Char2IntFunction): Internal.Reference2IntFunction<K>
        composeReference<T>(arg0: (arg0: T) => K): Internal.Reference2CharFunction<T>
        andThen<T>(arg0: (arg0: string) => T): (arg0: K) => T
        put(arg0: K, arg1: string): string
        put(arg0: K, arg1: string): string
        put(arg0: object, arg1: object): object
        remove(arg0: object): object
        remove(arg0: object): string
        defaultReturnValue(arg0: string): void
        defaultReturnValue(): string
        andThenDouble(arg0: Internal.Char2DoubleFunction): Internal.Reference2DoubleFunction<K>
        andThenObject<T>(arg0: Internal.Char2ObjectFunction<T>): (arg0: K) => T
        get(arg0: object): string
        get(arg0: object): object
        andThenLong(arg0: Internal.Char2LongFunction): Internal.Reference2LongFunction<K>
        composeLong(arg0: Internal.Long2ReferenceFunction<K>): Internal.Long2CharFunction
        andThenByte(arg0: Internal.Char2ByteFunction): Internal.Reference2ByteFunction<K>
        andThenFloat(arg0: Internal.Char2FloatFunction): Internal.Reference2FloatFunction<K>
        applyAsInt(arg0: K): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ReferenceFunction<K>): Internal.Int2CharFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ReferenceFunction<K>): Internal.Float2CharFunction
        andThenChar(arg0: Internal.Char2CharFunction): Internal.Reference2CharFunction<K>
        getChar(arg0: object): string
        composeObject<T>(arg0: (arg0: T) => K): Internal.Object2CharFunction<T>
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ReferenceFunction<K>): Internal.Short2CharFunction
        andThenReference<T>(arg0: Internal.Char2ReferenceFunction<T>): (arg0: K) => T
        composeChar(arg0: Internal.Char2ReferenceFunction<K>): Internal.Char2CharFunction
        composeDouble(arg0: Internal.Double2ReferenceFunction<K>): Internal.Double2CharFunction
    }
    class ListJS extends Internal.ArrayList<object> implements Internal.StringBuilderAppendable, Internal.ChangeListener<object>, Internal.Copyable, Internal.JsonSerializable, Internal.NBTSerializable {
        add(index: number, value: object): void
        add(value: object): boolean
        static nbt(list: object): Internal.CollectionTag<object>
        appendString(builder: Internal.StringBuilder): void
        onChanged(o: object): void
        splice(pos: number, deleteCount: number, items: object[]): Internal.ListJS
        shift(): object
        clear(): void
        static ofArray(array: object): Internal.ListJS
        reverse(): Internal.ListJS
        push(o: object[]): Internal.ListJS
        remove(index: number): object
        remove(o: object): boolean
        pop(): object
        filter(predicate: (arg0: object) => boolean): Internal.ListJS
        toJson(): Internal.JsonElement
        toJson(): Internal.JsonArray
        toNBT(): Internal.CollectionTag<object>
        toNBT(): net.minecraft.nbt.Tag
        addAll(index: number, c: Internal.Collection<any>): boolean
        addAll(c: Internal.Collection<any>): boolean
        static of(o: object): Internal.ListJS
        static of(array: number[]): Internal.ListJS
        static of(array: number[]): Internal.ListJS
        static of(array: number[]): Internal.ListJS
        static of(array: number[]): Internal.ListJS
        static of(array: number[]): Internal.ListJS
        static of(array: string[]): Internal.ListJS
        static of(array: number[]): Internal.ListJS
        static orSelf(o: object): Internal.ListJS
        static json(array: object): Internal.JsonArray
        getLength(): number
        unshift(o: object[]): Internal.ListJS
        toString(): string
        copy(): Internal.ListJS
        copy(): Internal.Copyable
        map(transformer: (arg0: object) => object): Internal.ListJS
        changeListener : Internal.ChangeListener<Internal.ListJS>;
        get length(): number;
    }
    class SimplePreparableReloadListener <T> implements Internal.PreparableReloadListener {
    }
    class JsonElement {
        getAsFloat(): number
        getAsBigInteger(): Internal.BigInteger
        getAsByte(): number
        getAsJsonObject(): Internal.JsonObject
        getAsJsonNull(): Internal.JsonNull
        getAsBigDecimal(): Internal.BigDecimal
        getAsNumber(): Internal.Number
        isJsonNull(): boolean
        getAsCharacter(): string
        getAsString(): string
        isJsonArray(): boolean
        getAsDouble(): number
        getAsInt(): number
        isJsonPrimitive(): boolean
        deepCopy(): Internal.JsonElement
        getAsLong(): number
        getAsJsonArray(): Internal.JsonArray
        getAsJsonPrimitive(): Internal.JsonPrimitive
        isJsonObject(): boolean
        getAsBoolean(): boolean
        toString(): string
        getAsShort(): number
        get asFloat(): number;
        get asBigInteger(): Internal.BigInteger;
        get asByte(): number;
        get asJsonObject(): Internal.JsonObject;
        get asJsonNull(): Internal.JsonNull;
        get asBigDecimal(): Internal.BigDecimal;
        get asNumber(): Internal.Number;
        get asCharacter(): string;
        get asString(): string;
        get asDouble(): number;
        get asInt(): number;
        get asLong(): number;
        get asJsonArray(): Internal.JsonArray;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get asBoolean(): boolean;
        get asShort(): number;
    }
    class FireworkRocketEntity extends Internal.Projectile implements Internal.ItemSupplier, Internal.FireworkRocketEntityKJS {
        setLifetimeKJS(arg0: number): void
        backpackedMoved : boolean;
        set lifetimeKJS(arg0: number);
    }
    interface ClientConnectionEncryptionExtension {
        setupEncryption(arg0: Internal.SecretKey): void
        set upEncryption(arg0: Internal.SecretKey);
    }
    class CodeSigner implements Internal.Serializable {
        getSignerCertPath(): Internal.CertPath
        getTimestamp(): Internal.Timestamp
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        get signerCertPath(): Internal.CertPath;
        get timestamp(): Internal.Timestamp;
    }
    interface ToLongFunction <T> {
        applyAsLong(arg0: T): number
    }
    interface Readable {
        read(arg0: Internal.CharBuffer): number
    }
    interface TemporalUnit {
        isDurationEstimated(): boolean
        getDuration(): Internal.Duration
        isTimeBased(): boolean
        addTo<R>(arg0: R, arg1: number): R
        toString(): string
        isDateBased(): boolean
        between(arg0: Internal.Temporal, arg1: Internal.Temporal): number
        isSupportedBy(arg0: Internal.Temporal): boolean
        get duration(): Internal.Duration;
    }
    interface IRegistryDelegate <T> implements java_.util.function_.Supplier<T> {
        get(): T
        name(): ResourceLocation
        type(): Internal.Class<T>
    }
    interface ICapabilitySerializable <T> implements Internal.ICapabilityProvider, Internal.INBTSerializable<T> {
        serializeNBT(): T
        getCapability<T>(arg0: Internal.Capability<T>, arg1: Internal.Direction): Internal.LazyOptional<T>
        getCapability<T>(arg0: Internal.Capability<T>): Internal.LazyOptional<T>
        deserializeNBT(arg0: T): void
    }
    interface Constant <T> implements Internal.Comparable<T> {
        name(): string
        compareTo(arg0: T): number
        id(): number
    }
    class IFluidHandler$FluidAction extends Internal.Enum<Internal.IFluidHandler$FluidAction> {
        static valueOf(arg0: string): Internal.IFluidHandler$FluidAction
        static values(): Internal.IFluidHandler$FluidAction[]
        simulate(): boolean
        execute(): boolean
        static readonly EXECUTE : Internal.IFluidHandler$FluidAction;
        static readonly SIMULATE : Internal.IFluidHandler$FluidAction;
    }
    interface ProcessorHandle <Msg> implements Internal.AutoCloseable {
        close(): void
    }
    interface Stream$Builder <T> implements Internal.Consumer<T> {
        add(arg0: T): (arg0: T) => void
        build(): Internal.Stream<T>
        andThen(arg0: (arg0: T) => void): (arg0: T) => void
        accept(arg0: T): void
    }
    class MethodHandle implements Internal.Constable {
        asCollector(arg0: Internal.Class<object>, arg1: number): Internal.MethodHandle
        asCollector(arg0: number, arg1: Internal.Class<object>, arg2: number): Internal.MethodHandle
        asSpreader(arg0: number, arg1: Internal.Class<object>, arg2: number): Internal.MethodHandle
        asSpreader(arg0: Internal.Class<object>, arg1: number): Internal.MethodHandle
        withVarargs(arg0: boolean): Internal.MethodHandle
        invokeExact(arg0: object[]): object
        invoke(arg0: object[]): object
        type(): Internal.MethodType
        describeConstable(): Internal.Optional<Internal.MethodHandleDesc>
        bindTo(arg0: object): Internal.MethodHandle
        asVarargsCollector(arg0: Internal.Class<object>): Internal.MethodHandle
        asType(arg0: Internal.MethodType): Internal.MethodHandle
        invokeWithArguments(arg0: object[]): object
        invokeWithArguments(arg0: Internal.List<object>): object
        isVarargsCollector(): boolean
        asFixedArity(): Internal.MethodHandle
        toString(): string
    }
    interface DynamicOps <T> {
        updateGeneric(arg0: T, arg1: T, arg2: (arg0: T) => T): T
        listBuilder(): Internal.ListBuilder<T>
        createIntList(arg0: Internal.IntStream): T
        createLong(arg0: number): T
        createDouble(arg0: number): T
        createLongList(arg0: Internal.LongStream): T
        createShort(arg0: number): T
        mergeToList(arg0: T, arg1: Internal.List<T>): Internal.DataResult<T>
        mergeToList(arg0: T, arg1: T): Internal.DataResult<T>
        update(arg0: T, arg1: string, arg2: (arg0: T) => T): T
        createByteList(arg0: Internal.ByteBuffer): T
        getByteBuffer(arg0: T): Internal.DataResult<Internal.ByteBuffer>
        withDecoder<E>(arg0: Internal.Decoder<E>): (arg0: T) => Internal.DataResult<com.mojang.datafixers.util.Pair<E, T>>
        createBoolean(arg0: boolean): T
        remove(arg0: T, arg1: string): T
        getMapValues(arg0: T): Internal.DataResult<Internal.Stream<com.mojang.datafixers.util.Pair<T, T>>>
        empty(): T
        withParser<E>(arg0: Internal.Decoder<E>): (arg0: T) => Internal.DataResult<E>
        mergeToMap(arg0: T, arg1: Internal.MapLike<T>): Internal.DataResult<T>
        mergeToMap(arg0: T, arg1: Map<T, T>): Internal.DataResult<T>
        mergeToMap(arg0: T, arg1: T, arg2: T): Internal.DataResult<T>
        convertList<U>(arg0: Internal.DynamicOps<U>, arg1: T): U
        emptyList(): T
        getIntStream(arg0: T): Internal.DataResult<Internal.IntStream>
        getList(arg0: T): Internal.DataResult<(arg0: (arg0: T) => void) => void>
        getLongStream(arg0: T): Internal.DataResult<Internal.LongStream>
        get(arg0: T, arg1: string): Internal.DataResult<T>
        getMapEntries(arg0: T): Internal.DataResult<(arg0: (arg0: T, arg1: T) => void) => void>
        emptyMap(): T
        getBooleanValue(arg0: T): Internal.DataResult<boolean>
        createNumeric(arg0: Internal.Number): T
        getStream(arg0: T): Internal.DataResult<Internal.Stream<T>>
        convertMap<U>(arg0: Internal.DynamicOps<U>, arg1: T): U
        mergeToPrimitive(arg0: T, arg1: T): Internal.DataResult<T>
        getStringValue(arg0: T): Internal.DataResult<string>
        createList(arg0: Internal.Stream<T>): T
        withEncoder<E>(arg0: Internal.Encoder<E>): (arg0: E) => Internal.DataResult<T>
        set(arg0: T, arg1: string, arg2: T): T
        getGeneric(arg0: T, arg1: T): Internal.DataResult<T>
        createString(arg0: string): T
        convertTo<U>(arg0: Internal.DynamicOps<U>, arg1: T): U
        createMap(arg0: Map<T, T>): T
        createMap(arg0: Internal.Stream<com.mojang.datafixers.util.Pair<T, T>>): T
        mapBuilder(): Internal.RecordBuilder<T>
        getMap(arg0: T): Internal.DataResult<Internal.MapLike<T>>
        createByte(arg0: number): T
        createFloat(arg0: number): T
        createInt(arg0: number): T
        compressMaps(): boolean
        getNumberValue(arg0: T): Internal.DataResult<Internal.Number>
        getNumberValue(arg0: T, arg1: Internal.Number): Internal.Number
    }
    class NetworkEvent extends Internal.Event {
        getPayload(): Internal.FriendlyByteBuf
        getListenerList(): Internal.ListenerList
        getLoginIndex(): number
        getSource(): () => Internal.NetworkEvent$Context
        get payload(): Internal.FriendlyByteBuf;
        get listenerList(): Internal.ListenerList;
        get loginIndex(): number;
        get source(): () => Internal.NetworkEvent$Context;
    }
    class AbstractIntSet extends Internal.AbstractIntCollection implements Internal.Cloneable, Internal.IntSet {
        iterator(): Internal.IntIterator
        iterator(): Internal.Iterator<any>
        spliterator(): Internal.IntSpliterator
        spliterator(): Internal.Spliterator<any>
        hashCode(): number
        equals(arg0: object): boolean
        rem(arg0: number): boolean
        remove(arg0: number): boolean
    }
    interface ParticleEngineAccessor {
        create$getProviders(): Map<ResourceLocation, Internal.ParticleProvider<object>>
    }
    class Products$P5 <F, T1, T2, T3, T4, T5> {
        t4(): Internal.App<F, T4>
        t5(): Internal.App<F, T5>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.Function5<T1, T2, T3, T4, T5, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, Internal.Function5<T1, T2, T3, T4, T5, R>>): Internal.App<F, R>
        and<T6, T7>(arg0: Internal.Products$P2<F, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        and<T6, T7, T8>(arg0: Internal.Products$P3<F, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        and<T6>(arg0: Internal.App<F, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>
        t1(): Internal.App<F, T1>
        t2(): Internal.App<F, T2>
        t3(): Internal.App<F, T3>
    }
    interface Functor <F, Mu> implements Internal.Kind1<F, Mu> {
        static unbox<F, Mu>(arg0: Internal.App<Mu, F>): Internal.Functor<F, Mu>
        map<T, R>(arg0: (arg0: T) => R, arg1: Internal.App<F, T>): Internal.App<F, R>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>): Internal.Products$P11<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>): Internal.Products$P10<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>): Internal.Products$P9<F, T1, T2, T3, T4, T5, T6, T7, T8, T9>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>, arg13: Internal.App<F, T14>, arg14: Internal.App<F, T15>, arg15: Internal.App<F, T16>): Internal.Products$P16<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>, arg13: Internal.App<F, T14>, arg14: Internal.App<F, T15>): Internal.Products$P15<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>, arg13: Internal.App<F, T14>): Internal.Products$P14<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>): Internal.Products$P13<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>): Internal.Products$P12<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
        group<T1, T2, T3>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>): Internal.Products$P3<F, T1, T2, T3>
        group<T1, T2>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>): Internal.Products$P2<F, T1, T2>
        group<T1>(arg0: Internal.App<F, T1>): Internal.Products$P1<F, T1>
        group<T1, T2, T3, T4, T5, T6, T7, T8>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        group<T1, T2, T3, T4, T5, T6, T7>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        group<T1, T2, T3, T4, T5, T6>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>
        group<T1, T2, T3, T4, T5>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>
        group<T1, T2, T3, T4>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>): Internal.Products$P4<F, T1, T2, T3, T4>
    }
    class ImmutableMultiset <E> extends Internal.ImmutableMultisetGwtSerializationDependencies<E> implements Internal.Multiset<E> {
        add(arg0: E, arg1: number): number
        forEachEntry(arg0: Internal.ObjIntConsumer<E>): void
        static toImmutableMultiset<E>(): Internal.Collector<E, object, Internal.ImmutableMultiset<E>>
        static toImmutableMultiset<T, E>(arg0: (arg0: T) => E, arg1: Internal.ToIntFunction<T>): Internal.Collector<T, object, Internal.ImmutableMultiset<E>>
        entrySet(): Internal.Set<any>
        entrySet(): Internal.ImmutableSet<Internal.Multiset$Entry<E>>
        forEach(arg0: (arg0: E) => void): void
        count(arg0: object): number
        static copyOf<E>(arg0: Internal.Iterable<E>): Internal.ImmutableMultiset<E>
        static copyOf<E>(arg0: E[]): Internal.ImmutableMultiset<E>
        static copyOf<E>(arg0: Internal.Iterator<E>): Internal.ImmutableMultiset<E>
        asList(): Internal.ImmutableList<E>
        remove(arg0: object, arg1: number): number
        contains(arg0: object): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.UnmodifiableIterator<E>
        elementSet(): Internal.ImmutableSet<E>
        elementSet(): Internal.Set<any>
        hashCode(): number
        static of<E>(arg0: E): Internal.ImmutableMultiset<E>
        static of<E>(): Internal.ImmutableMultiset<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E[]): Internal.ImmutableMultiset<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): Internal.ImmutableMultiset<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E): Internal.ImmutableMultiset<E>
        static of<E>(arg0: E, arg1: E, arg2: E): Internal.ImmutableMultiset<E>
        static of<E>(arg0: E, arg1: E): Internal.ImmutableMultiset<E>
        equals(arg0: object): boolean
        static builder<E>(): Internal.ImmutableMultiset$Builder<E>
        toString(): string
        setCount(arg0: E, arg1: number): number
        setCount(arg0: E, arg1: number, arg2: number): boolean
    }
    class TransientEntitySectionManager <T> implements Internal.ClientEntityManagerAccessor {
        getCache(): Internal.EntitySectionStorage<any>
        get cache(): Internal.EntitySectionStorage<any>;
    }
    interface Future <V> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        get(arg0: number, arg1: Internal.TimeUnit): V
        get(): V
        isDone(): boolean
    }
    interface ResourceProvider {
    }
    class FluidStack {
        getRawFluid(): Internal.Fluid
        getOrCreateChildTag(arg0: string): Internal.CompoundTag
        getChildTag(arg0: string): Internal.CompoundTag
        static readFromPacket(arg0: Internal.FriendlyByteBuf): Internal.FluidStack
        containsFluid(arg0: Internal.FluidStack): boolean
        hashCode(): number
        setTag(arg0: Internal.CompoundTag): void
        copy(): Internal.FluidStack
        setAmount(arg0: number): void
        isFluidEqual(arg0: Internal.FluidStack): boolean
        isFluidEqual(arg0: Internal.ItemStack): boolean
        writeToNBT(arg0: Internal.CompoundTag): Internal.CompoundTag
        getAmount(): number
        removeChildTag(arg0: string): void
        isFluidStackIdentical(arg0: Internal.FluidStack): boolean
        grow(arg0: number): void
        static loadFluidStackFromNBT(arg0: Internal.CompoundTag): Internal.FluidStack
        hasTag(): boolean
        shrink(arg0: number): void
        getTranslationKey(): string
        isEmpty(): boolean
        getTag(): Internal.CompoundTag
        writeToPacket(arg0: Internal.FriendlyByteBuf): void
        getOrCreateTag(): Internal.CompoundTag
        getDisplayName(): Internal.Component
        equals(arg0: object): boolean
        getFluid(): Internal.Fluid
        static areFluidStackTagsEqual(arg0: Internal.FluidStack, arg1: Internal.FluidStack): boolean
        static readonly CODEC : Internal.Codec<Internal.FluidStack>;
        static readonly EMPTY : Internal.FluidStack;
        get rawFluid(): Internal.Fluid;
        set tag(arg0: Internal.CompoundTag);
        set amount(arg0: number);
        get amount(): number;
        get translationKey(): string;
        get tag(): Internal.CompoundTag;
        get orCreateTag(): Internal.CompoundTag;
        get displayName(): Internal.Component;
        get fluid(): Internal.Fluid;
    }
    class Products$P14 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> {
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>): Internal.App<F, R>
    }
    class FloatBuffer extends Internal.Buffer implements Internal.Comparable<Internal.FloatBuffer> {
        hasArray(): boolean
        compact(): Internal.FloatBuffer
        clear(): Internal.Buffer
        clear(): Internal.FloatBuffer
        duplicate(): Internal.FloatBuffer
        duplicate(): Internal.Buffer
        compareTo(arg0: object): number
        compareTo(arg0: Internal.FloatBuffer): number
        asReadOnlyBuffer(): Internal.FloatBuffer
        put(arg0: number[]): Internal.FloatBuffer
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.FloatBuffer
        put(arg0: number, arg1: number[]): Internal.FloatBuffer
        put(arg0: number[], arg1: number, arg2: number): Internal.FloatBuffer
        put(arg0: number, arg1: Internal.FloatBuffer, arg2: number, arg3: number): Internal.FloatBuffer
        put(arg0: Internal.FloatBuffer): Internal.FloatBuffer
        put(arg0: number, arg1: number): Internal.FloatBuffer
        put(arg0: number): Internal.FloatBuffer
        static allocate(arg0: number): Internal.FloatBuffer
        rewind(): Internal.Buffer
        rewind(): Internal.FloatBuffer
        slice(): Internal.Buffer
        slice(): Internal.FloatBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.FloatBuffer
        array(): number[]
        array(): object
        hashCode(): number
        mismatch(arg0: Internal.FloatBuffer): number
        equals(arg0: object): boolean
        get(): number
        get(arg0: number, arg1: number[]): Internal.FloatBuffer
        get(arg0: number): number
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.FloatBuffer
        get(arg0: number[], arg1: number, arg2: number): Internal.FloatBuffer
        get(arg0: number[]): Internal.FloatBuffer
        limit(arg0: number): Internal.FloatBuffer
        limit(arg0: number): Internal.Buffer
        reset(): Internal.Buffer
        reset(): Internal.FloatBuffer
        arrayOffset(): number
        toString(): string
        position(arg0: number): Internal.FloatBuffer
        position(arg0: number): Internal.Buffer
        flip(): Internal.Buffer
        flip(): Internal.FloatBuffer
        isDirect(): boolean
        static wrap(arg0: number[]): Internal.FloatBuffer
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.FloatBuffer
        mark(): Internal.Buffer
        mark(): Internal.FloatBuffer
        order(): Internal.ByteOrder
    }
    class ModuleLayer$Controller {
        addReads(arg0: Internal.Module, arg1: Internal.Module): Internal.ModuleLayer$Controller
        addExports(arg0: Internal.Module, arg1: string, arg2: Internal.Module): Internal.ModuleLayer$Controller
        addOpens(arg0: Internal.Module, arg1: string, arg2: Internal.Module): Internal.ModuleLayer$Controller
        layer(): Internal.ModuleLayer
    }
    interface Function <K, V> implements java_.util.function_.Function<K, V> {
        getOrDefault(arg0: object, arg1: V): V
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        get(arg0: object): V
        clear(): void
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        put(arg0: K, arg1: V): V
        remove(arg0: object): V
    }
    class DamageSource {
        toString(): string
    }
    interface BufferBuilderExtension {
        flywheel$getVertices(): number
        flywheel$injectForRender(arg0: Internal.ByteBuffer, arg1: Internal.VertexFormat, arg2: number): void
        flywheel$freeBuffer(): void
        flywheel$appendBufferUnsafe(arg0: Internal.ByteBuffer): void
    }
    class MixerRecipeJS extends Internal.IERecipeJS {
        serialize(): void
        create(args: Internal.ListJS): void
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<object>;
        readonly inputFluids : Internal.List<Internal.FluidTagInput>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        serializeInputs : boolean;
    }
    interface ExclusionStrategy {
        shouldSkipClass(arg0: Internal.Class<object>): boolean
        shouldSkipField(arg0: Internal.FieldAttributes): boolean
    }
    interface DirectMethodHandleDesc implements Internal.MethodHandleDesc {
        owner(): Internal.ClassDesc
        invocationType(): Internal.MethodTypeDesc
        kind(): Internal.DirectMethodHandleDesc$Kind
        equals(arg0: object): boolean
        refKind(): number
        isOwnerInterface(): boolean
        lookupDescriptor(): string
        methodName(): string
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): object
        asType(arg0: Internal.MethodTypeDesc): Internal.MethodHandleDesc
    }
    interface ExtendedAbstractBlockState {
        getOpacityIfCached(): number
        isConditionallyFullOpaque(): boolean
        get opacityIfCached(): number;
    }
    interface Double2CharFunction implements Internal.Function<number, string>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: object, arg1: string): string
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: string): string
        andThenShort(arg0: Internal.Char2ShortFunction): Internal.Double2ShortFunction
        composeByte(arg0: Internal.Byte2DoubleFunction): Internal.Byte2CharFunction
        andThenInt(arg0: Internal.Char2IntFunction): Internal.Double2IntFunction
        composeReference<T>(arg0: Internal.Reference2DoubleFunction<T>): Internal.Reference2CharFunction<T>
        andThen<T>(arg0: (arg0: string) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: string): string
        put(arg0: number, arg1: string): string
        remove(arg0: number): string
        remove(arg0: object): object
        remove(arg0: object): string
        defaultReturnValue(): string
        defaultReturnValue(arg0: string): void
        andThenDouble(arg0: Internal.Char2DoubleFunction): Internal.Double2DoubleFunction
        andThenObject<T>(arg0: Internal.Char2ObjectFunction<T>): Internal.Double2ObjectFunction<T>
        get(arg0: object): string
        get(arg0: object): object
        get(arg0: number): string
        andThenLong(arg0: Internal.Char2LongFunction): Internal.Double2LongFunction
        composeLong(arg0: Internal.Long2DoubleFunction): Internal.Long2CharFunction
        andThenByte(arg0: Internal.Char2ByteFunction): Internal.Double2ByteFunction
        andThenFloat(arg0: Internal.Char2FloatFunction): Internal.Double2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2DoubleFunction): Internal.Int2CharFunction
        clear(): void
        composeFloat(arg0: Internal.Float2DoubleFunction): Internal.Float2CharFunction
        andThenChar(arg0: Internal.Char2CharFunction): Internal.Double2CharFunction
        composeObject<T>(arg0: Internal.Object2DoubleFunction<T>): Internal.Object2CharFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => string
        composeShort(arg0: Internal.Short2DoubleFunction): Internal.Short2CharFunction
        andThenReference<T>(arg0: Internal.Char2ReferenceFunction<T>): Internal.Double2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2DoubleFunction): Internal.Char2CharFunction
        composeDouble(arg0: Internal.Double2DoubleFunction): Internal.Double2CharFunction
    }
    interface IForgeMobEffect {
        getCurativeItems(): Internal.List<Internal.ItemStack>
        getSortOrder(arg0: Internal.MobEffectInstance): number
        get curativeItems(): Internal.List<Internal.ItemStack>;
    }
    interface PrimitiveIterator$OfInt implements Internal.PrimitiveIterator<number, java_.util.function_.IntConsumer> {
        next(): object
        next(): number
        hasNext(): boolean
        nextInt(): number
        forEachRemaining(arg0: object): void
        forEachRemaining(arg0: java_.util.function_.IntConsumer): void
        forEachRemaining(arg0: (arg0: number) => void): void
        remove(): void
    }
    interface FrustumAdapter {
        static adapt(frustum: net.minecraft.client.renderer.culling.Frustum): Internal.Frustum
        sodium$createFrustum(): Internal.Frustum
    }
    class AdvancementJS {
        hasDisplay(): boolean
        getChildren(): Internal.Set<Internal.AdvancementJS>
        getParent(): Internal.AdvancementJS
        getTitle(): Internal.Text
        hashCode(): number
        equals(o: object): boolean
        getId(): ResourceLocation
        toString(): string
        id(): ResourceLocation
        getDisplayText(): Internal.Text
        addChild(a: Internal.AdvancementJS): void
        getDescription(): Internal.Text
        readonly advancement : Internal.Advancement;
        get children(): Internal.Set<Internal.AdvancementJS>;
        get parent(): Internal.AdvancementJS;
        get title(): Internal.Text;
        get displayText(): Internal.Text;
        get description(): Internal.Text;
    }
    class PartEntity <T> extends Internal.Entity {
        getParent(): T
        backpackedMoved : boolean;
        get parent(): T;
    }
    class Either$Mu <R> implements Internal.K1 {
    }
    interface ModuleReader implements Internal.Closeable {
        read(arg0: string): Internal.Optional<Internal.ByteBuffer>
        release(arg0: Internal.ByteBuffer): void
        find(arg0: string): Internal.Optional<Internal.URI>
        list(): Internal.Stream<string>
        close(): void
        open(arg0: string): Internal.Optional<Internal.InputStream>
    }
    class ModelManager extends Internal.SimplePreparableReloadListener<Internal.ModelBakery> implements Internal.AutoCloseable {
        getModel(arg0: ResourceLocation): Internal.BakedModel
        close(): void
    }
    interface WritableByteChannel implements java_.nio.channels.Channel {
        isOpen(): boolean
        close(): void
        write(arg0: Internal.ByteBuffer): number
    }
    interface InterruptibleChannel implements java_.nio.channels.Channel {
        isOpen(): boolean
        close(): void
    }
    class MutableUnit extends dev.latvian.mods.rhino.util.unit.Unit {
        set(v: number): void
        get(): number
        append(sb: Internal.StringBuilder): void
    }
    interface LevelSimulatedReader {
    }
    class CookingRecipeJS extends Internal.RecipeJS {
        serialize(): void
        xp(xp: number): Internal.CookingRecipeJS
        create(args: Internal.ListJS): void
        cookingTime(time: number): Internal.CookingRecipeJS
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<object>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
    }
    class ToolAction {
        static get(arg0: string): Internal.ToolAction
        name(): string
        static getActions(): Internal.Collection<Internal.ToolAction>
        toString(): string
        get actions(): Internal.Collection<Internal.ToolAction>;
    }
    interface IdFunctionCall {
        execIdCall(arg0: Internal.IdFunctionObject, arg1: Internal.Context, arg2: Internal.Scriptable, arg3: Internal.Scriptable, arg4: object[]): object
    }
    class AbstractConstant <T> implements Internal.Constant<T> {
        hashCode(): number
        equals(arg0: object): boolean
        name(): string
        toString(): string
        id(): number
        compareTo(arg0: T): number
        compareTo(arg0: object): number
    }
    interface BufferVertexType <T> implements Internal.VertexType<T> {
        getBufferVertexFormat(): Internal.BufferVertexFormat
        createFallbackWriter(arg0: Internal.VertexConsumer): T
        asBlittable(): Internal.BlittableVertexType<T>
        get bufferVertexFormat(): Internal.BufferVertexFormat;
    }
    interface Annotation {
        hashCode(): number
        equals(arg0: object): boolean
        annotationType(): Internal.Class<Internal.Annotation>
        toString(): string
    }
    interface ListBuilder <T> {
        withErrorsFrom(arg0: Internal.DataResult<object>): Internal.ListBuilder<T>
        add(arg0: Internal.DataResult<T>): Internal.ListBuilder<T>
        add(arg0: T): Internal.ListBuilder<T>
        add<E>(arg0: E, arg1: Internal.Encoder<E>): Internal.ListBuilder<T>
        mapError(arg0: Internal.UnaryOperator<string>): Internal.ListBuilder<T>
        ops(): Internal.DynamicOps<T>
        build(arg0: T): Internal.DataResult<T>
        build(arg0: Internal.DataResult<T>): Internal.DataResult<T>
        addAll<E>(arg0: Internal.Iterable<E>, arg1: Internal.Encoder<E>): Internal.ListBuilder<T>
    }
    interface BlockStateKJS {
        setDestroySpeedKJS(arg0: number): void
        setLightEmissionKJS(arg0: number): void
        setRequiresToolKJS(arg0: boolean): void
        setMaterialKJS(arg0: net.minecraft.world.level.material.Material): void
        set destroySpeedKJS(arg0: number);
        set lightEmissionKJS(arg0: number);
        set requiresToolKJS(arg0: boolean);
        set materialKJS(arg0: net.minecraft.world.level.material.Material);
    }
    class IntOpenHashSet extends Internal.AbstractIntSet implements Internal.Serializable, Internal.Cloneable, Internal.Hash {
        add(arg0: number): boolean
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.IntSpliterator
        forEach(arg0: java_.util.function_.IntConsumer): void
        isEmpty(): boolean
        clear(): void
        static toSetWithExpectedSize(arg0: Internal.IntStream, arg1: number): Internal.IntOpenHashSet
        remove(arg0: number): boolean
        static toSet(arg0: Internal.IntStream): Internal.IntOpenHashSet
        contains(arg0: number): boolean
        iterator(): Internal.IntIterator
        iterator(): Internal.Iterator<any>
        trim(): boolean
        trim(arg0: number): boolean
        size(): number
        addAll(arg0: Internal.IntCollection): boolean
        addAll(arg0: Internal.Collection<number>): boolean
        hashCode(): number
        static of(): Internal.IntOpenHashSet
        static of(arg0: number): Internal.IntOpenHashSet
        static of(arg0: number, arg1: number): Internal.IntOpenHashSet
        static of(arg0: number[]): Internal.IntOpenHashSet
        static of(arg0: number, arg1: number, arg2: number): Internal.IntOpenHashSet
        clone(): Internal.IntOpenHashSet
        clone(): object
        static readonly DEFAULT_GROWTH_FACTOR : 16;
        static readonly FAST_LOAD_FACTOR : 0.5;
        static readonly DEFAULT_INITIAL_SIZE : 16;
        static readonly DEFAULT_LOAD_FACTOR : 0.75;
        static readonly OCCUPIED : -1;
        static readonly VERY_FAST_LOAD_FACTOR : 0.25;
        static readonly FREE : 0;
        static readonly PRIMES : number[];
        static readonly REMOVED : 1;
    }
    interface BlockCountingSection {
        anyMatch(arg0: Internal.IndexedBlockStatePredicate): boolean
    }
    interface ChannelPipeline implements Internal.ChannelInboundInvoker, Internal.ChannelOutboundInvoker, Internal.Iterable<Internal.Map$Entry<string, Internal.ChannelHandler>> {
        disconnect(): Internal.ChannelFuture
        disconnect(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        newProgressivePromise(): Internal.ChannelProgressivePromise
        fireChannelWritabilityChanged(): Internal.ChannelPipeline
        fireChannelWritabilityChanged(): Internal.ChannelInboundInvoker
        channel(): Internal.Channel
        replace(arg0: string, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelHandler
        replace<T>(arg0: Internal.Class<T>, arg1: string, arg2: Internal.ChannelHandler): T
        replace(arg0: Internal.ChannelHandler, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelPipeline
        fireExceptionCaught(arg0: Internal.Throwable): Internal.ChannelPipeline
        fireExceptionCaught(arg0: Internal.Throwable): Internal.ChannelInboundInvoker
        fireChannelActive(): Internal.ChannelPipeline
        fireChannelActive(): Internal.ChannelInboundInvoker
        removeLast(): Internal.ChannelHandler
        remove<T>(arg0: Internal.Class<T>): T
        remove(arg0: string): Internal.ChannelHandler
        remove(arg0: Internal.ChannelHandler): Internal.ChannelPipeline
        writeAndFlush(arg0: object): Internal.ChannelFuture
        writeAndFlush(arg0: object, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        addLast(arg0: Internal.EventExecutorGroup, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelPipeline
        addLast(arg0: string, arg1: Internal.ChannelHandler): Internal.ChannelPipeline
        addLast(arg0: Internal.ChannelHandler[]): Internal.ChannelPipeline
        addLast(arg0: Internal.EventExecutorGroup, arg1: Internal.ChannelHandler[]): Internal.ChannelPipeline
        iterator(): Internal.Iterator<T>
        addAfter(arg0: Internal.EventExecutorGroup, arg1: string, arg2: string, arg3: Internal.ChannelHandler): Internal.ChannelPipeline
        addAfter(arg0: string, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelPipeline
        bind(arg0: Internal.SocketAddress): Internal.ChannelFuture
        bind(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        flush(): Internal.ChannelPipeline
        flush(): Internal.ChannelOutboundInvoker
        removeFirst(): Internal.ChannelHandler
        get<T>(arg0: Internal.Class<T>): T
        get(arg0: string): Internal.ChannelHandler
        context(arg0: Internal.ChannelHandler): Internal.ChannelHandlerContext
        context(arg0: string): Internal.ChannelHandlerContext
        context(arg0: Internal.Class<Internal.ChannelHandler>): Internal.ChannelHandlerContext
        close(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        close(): Internal.ChannelFuture
        write(arg0: object): Internal.ChannelFuture
        write(arg0: object, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress, arg2: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress): Internal.ChannelFuture
        connect(arg0: Internal.SocketAddress): Internal.ChannelFuture
        newPromise(): Internal.ChannelPromise
        firstContext(): Internal.ChannelHandlerContext
        read(): Internal.ChannelOutboundInvoker
        fireChannelInactive(): Internal.ChannelPipeline
        fireChannelInactive(): Internal.ChannelInboundInvoker
        fireChannelReadComplete(): Internal.ChannelPipeline
        fireChannelReadComplete(): Internal.ChannelInboundInvoker
        last(): Internal.ChannelHandler
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
        deregister(arg0: Internal.ChannelPromise): Internal.ChannelFuture
        deregister(): Internal.ChannelFuture
        newFailedFuture(arg0: Internal.Throwable): Internal.ChannelFuture
        fireChannelRegistered(): Internal.ChannelPipeline
        fireChannelRegistered(): Internal.ChannelInboundInvoker
        addBefore(arg0: Internal.EventExecutorGroup, arg1: string, arg2: string, arg3: Internal.ChannelHandler): Internal.ChannelPipeline
        addBefore(arg0: string, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelPipeline
        fireChannelRead(arg0: object): Internal.ChannelPipeline
        fireChannelRead(arg0: object): Internal.ChannelInboundInvoker
        names(): Internal.List<string>
        newSucceededFuture(): Internal.ChannelFuture
        voidPromise(): Internal.ChannelPromise
        toMap(): Map<string, Internal.ChannelHandler>
        fireUserEventTriggered(arg0: object): Internal.ChannelPipeline
        fireUserEventTriggered(arg0: object): Internal.ChannelInboundInvoker
        lastContext(): Internal.ChannelHandlerContext
        fireChannelUnregistered(): Internal.ChannelPipeline
        fireChannelUnregistered(): Internal.ChannelInboundInvoker
        addFirst(arg0: string, arg1: Internal.ChannelHandler): Internal.ChannelPipeline
        addFirst(arg0: Internal.EventExecutorGroup, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelPipeline
        addFirst(arg0: Internal.ChannelHandler[]): Internal.ChannelPipeline
        addFirst(arg0: Internal.EventExecutorGroup, arg1: Internal.ChannelHandler[]): Internal.ChannelPipeline
        first(): Internal.ChannelHandler
    }
    interface SpriteExtended {
        setActive(arg0: boolean): void
        isActive(): boolean
        set active(arg0: boolean);
    }
    class TypeWrappers {
        removeAll(): void
        getWrapperFactory(target: Internal.Class<object>, from: object): Internal.TypeWrapperFactory<object>
        register<T>(target: Internal.Class<T>, factory: Internal.TypeWrapperFactory<T>): void
        register<T>(target: Internal.Class<T>, validator: (arg0: object) => boolean, factory: Internal.TypeWrapperFactory<T>): void
        register<F, T>(id: string, from: Internal.Class<F>, to: Internal.Class<T>, factory: (arg0: F) => T): void
    }
    interface CompletionHandler <V, A> {
        failed(arg0: Internal.Throwable, arg1: A): void
        completed(arg0: V, arg1: A): void
    }
    class CompoundTag implements net.minecraft.nbt.Tag, Internal.CustomJavaObjectWrapper$AsMap {
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, staticType: Internal.Class<object>): Internal.Scriptable
        hashCode(): number
        merge(arg0: Internal.CompoundTag): Internal.CompoundTag
        equals(arg0: object): boolean
        toString(): string
        wrapAsJavaMap(): Map<any, any>
    }
    interface NeutralMob {
    }
    class BufferBuilder extends Internal.DefaultedVertexConsumer implements Internal.BufferVertexConsumer, Internal.BufferBuilderExtension, Internal.VertexDrain, Internal.VertexBufferView {
        flywheel$getVertices(): number
        ensureBufferCapacity(bytes: number): boolean
        createSink(factory: Internal.VertexType<any>): Internal.VertexSink
        flush(vertexCount: number, format: Internal.BufferVertexFormat): void
        flywheel$injectForRender(arg0: Internal.ByteBuffer, arg1: Internal.VertexFormat, arg2: number): void
        getWriterPosition(): number
        flywheel$freeBuffer(): void
        redirect$zpa000$debugGetNextBuffer(buffer: Internal.ByteBuffer, newLimit: number): Internal.ByteBuffer
        getVertexFormat(): Internal.VertexFormat
        getVertexFormat(): Internal.BufferVertexFormat
        putBulkData(arg0: Internal.ByteBuffer): void
        flywheel$appendBufferUnsafe(arg0: Internal.ByteBuffer): void
        getDirectBuffer(): Internal.ByteBuffer
        get writerPosition(): number;
        get vertexFormat(): Internal.VertexFormat;
        get vertexFormat(): Internal.BufferVertexFormat;
        get directBuffer(): Internal.ByteBuffer;
    }
    class PrintWriter extends Internal.Writer {
        print(arg0: number): void
        print(arg0: number): void
        print(arg0: number): void
        print(arg0: string): void
        print(arg0: boolean): void
        print(arg0: object): void
        print(arg0: string): void
        print(arg0: string[]): void
        print(arg0: number): void
        println(arg0: string[]): void
        println(): void
        println(arg0: boolean): void
        println(arg0: string): void
        println(arg0: object): void
        println(arg0: number): void
        println(arg0: number): void
        println(arg0: number): void
        println(arg0: number): void
        println(arg0: string): void
        flush(): void
        format(arg0: string, arg1: object[]): Internal.PrintWriter
        format(arg0: Internal.Locale, arg1: string, arg2: object[]): Internal.PrintWriter
        checkError(): boolean
        close(): void
        write(arg0: string[], arg1: number, arg2: number): void
        write(arg0: string): void
        write(arg0: string, arg1: number, arg2: number): void
        write(arg0: string[]): void
        write(arg0: number): void
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.PrintWriter
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Writer
        append(arg0: string): Internal.PrintWriter
        append(arg0: string): Internal.Appendable
        append(arg0: string): Internal.Writer
        append(arg0: Internal.CharSequence): Internal.PrintWriter
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.Writer
        printf(arg0: string, arg1: object[]): Internal.PrintWriter
        printf(arg0: Internal.Locale, arg1: string, arg2: object[]): Internal.PrintWriter
    }
    interface FontResourceManagerAccess {
        getFontSets(): Map<ResourceLocation, Internal.FontSet>
        get fontSets(): Map<ResourceLocation, Internal.FontSet>;
    }
    class Event$Result extends Internal.Enum<Internal.Event$Result> {
        static valueOf(arg0: string): Internal.Event$Result
        static values(): Internal.Event$Result[]
        static readonly DENY : Internal.Event$Result;
        static readonly DEFAULT : Internal.Event$Result;
        static readonly ALLOW : Internal.Event$Result;
    }
    class Material {
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
    }
    class Provider extends Internal.Properties {
        isConfigured(): boolean
        getOrDefault(arg0: object, arg1: object): object
        getName(): string
        keys(): Internal.Enumeration<object>
        computeIfAbsent(arg0: object, arg1: (arg0: object) => object): object
        values(): Internal.Collection<object>
        replace(arg0: object, arg1: object): object
        replace(arg0: object, arg1: object, arg2: object): boolean
        replaceAll(arg0: (arg0: object, arg1: object) => object): void
        put(arg0: object, arg1: object): object
        remove(arg0: object): object
        remove(arg0: object, arg1: object): boolean
        compute(arg0: object, arg1: (arg0: object, arg1: object) => object): object
        load(arg0: Internal.InputStream): void
        putAll(arg0: Map<object, object>): void
        merge(arg0: object, arg1: object, arg2: (arg0: object, arg1: object) => object): object
        get(arg0: object): object
        getServices(): Internal.Set<Internal.Provider$Service>
        keySet(): Internal.Set<object>
        getVersion(): number
        getProperty(arg0: string): string
        getInfo(): string
        entrySet(): Internal.Set<Internal.Map$Entry<object, object>>
        getVersionStr(): string
        forEach(arg0: (arg0: object, arg1: object) => void): void
        clear(): void
        configure(arg0: string): Internal.Provider
        getService(arg0: string, arg1: string): Internal.Provider$Service
        computeIfPresent(arg0: object, arg1: (arg0: object, arg1: object) => object): object
        elements(): Internal.Enumeration<object>
        toString(): string
        putIfAbsent(arg0: object, arg1: object): object
        get name(): string;
        get services(): Internal.Set<Internal.Provider$Service>;
        get version(): number;
        get info(): string;
        get versionStr(): string;
    }
    interface VertexWriter {
        seekToVertex(arg0: number): void
        writeVertexList(arg0: Internal.VertexList): void
        writeVertex(arg0: Internal.VertexList, arg1: number): void
        intoReader(): Internal.VertexList
    }
    interface ExtendedChunk {
        setSkyNibbles(arg0: Internal.SWMRNibbleArray[]): void
        getSkyEmptinessMap(): boolean[]
        getSkyNibbles(): Internal.SWMRNibbleArray[]
        getBlockNibbles(): Internal.SWMRNibbleArray[]
        setSkyEmptinessMap(arg0: boolean[]): void
        setBlockEmptinessMap(arg0: boolean[]): void
        getBlockEmptinessMap(): boolean[]
        setBlockNibbles(arg0: Internal.SWMRNibbleArray[]): void
        set skyNibbles(arg0: Internal.SWMRNibbleArray[]);
        get skyEmptinessMap(): boolean[];
        get skyNibbles(): Internal.SWMRNibbleArray[];
        get blockNibbles(): Internal.SWMRNibbleArray[];
        set skyEmptinessMap(arg0: boolean[]);
        set blockEmptinessMap(arg0: boolean[]);
        get blockEmptinessMap(): boolean[];
        set blockNibbles(arg0: Internal.SWMRNibbleArray[]);
    }
    interface Int2ObjectFunction <V> implements Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: number, arg1: V): V
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Object2ShortFunction<V>): Internal.Int2ShortFunction
        composeByte(arg0: Internal.Byte2IntFunction): Internal.Byte2ObjectFunction<V>
        andThenInt(arg0: Internal.Object2IntFunction<V>): Internal.Int2IntFunction
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: Internal.Reference2IntFunction<T>): (arg0: T) => V
        put(arg0: number, arg1: V): V
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: object): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: Internal.Object2DoubleFunction<V>): Internal.Int2DoubleFunction
        andThenObject<T>(arg0: (arg0: V) => T): Internal.Int2ObjectFunction<T>
        get(arg0: object): V
        get(arg0: number): V
        andThenLong(arg0: Internal.Object2LongFunction<V>): Internal.Int2LongFunction
        composeLong(arg0: Internal.Long2IntFunction): Internal.Long2ObjectFunction<V>
        andThenByte(arg0: Internal.Object2ByteFunction<V>): Internal.Int2ByteFunction
        andThenFloat(arg0: Internal.Object2FloatFunction<V>): Internal.Int2FloatFunction
        apply(arg0: number): V
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2IntFunction): Internal.Int2ObjectFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2IntFunction): Internal.Float2ObjectFunction<V>
        andThenChar(arg0: Internal.Object2CharFunction<V>): Internal.Int2CharFunction
        composeObject<T>(arg0: Internal.Object2IntFunction<T>): (arg0: T) => V
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => V
        composeShort(arg0: Internal.Short2IntFunction): Internal.Short2ObjectFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): Internal.Int2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2IntFunction): Internal.Char2ObjectFunction<V>
        composeDouble(arg0: Internal.Double2IntFunction): Internal.Double2ObjectFunction<V>
    }
    class Vector4f {
        setW(arg0: number): void
        setY(arg0: number): void
        setX(arg0: number): void
        set(arg0: number[]): void
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        setZ(arg0: number): void
        set w(arg0: number);
        set y(arg0: number);
        set x(arg0: number);
        set z(arg0: number);
    }
    class Text implements Internal.Iterable<Internal.Text>, Internal.Comparable<Internal.Text>, Internal.JsonSerializable, Internal.WrappedJS {
        rawCopy(): Internal.Text
        hasStyle(): boolean
        compareTo(other: Internal.Text): number
        compareTo(arg0: object): number
        italic(): Internal.Text
        italic(value: boolean): Internal.Text
        static componentOf(o: object): Internal.Component
        red(): Internal.Text
        aqua(): Internal.Text
        iterator(): Internal.Iterator<Internal.Text>
        white(): Internal.Text
        noColor(): Internal.Text
        darkPurple(): Internal.Text
        static join(separator: Internal.Text, texts: Internal.Iterable<Internal.Text>): Internal.Text
        obfuscated(value: boolean): Internal.Text
        obfuscated(): Internal.Text
        write(buffer: Internal.FriendlyByteBuf): void
        static read(buffer: Internal.FriendlyByteBuf): Internal.Text
        spliterator(): Internal.Spliterator<T>
        getSiblings(): Internal.List<Internal.Text>
        bold(): Internal.Text
        bold(value: boolean): Internal.Text
        click(value: string): Internal.Text
        toJson(): Internal.JsonElement
        darkGray(): Internal.Text
        insertion(value: string): Internal.Text
        color(c: Internal.Color): Internal.Text
        yellow(): Internal.Text
        darkBlue(): Internal.Text
        gold(): Internal.Text
        hover(text: object): Internal.Text
        gray(): Internal.Text
        darkRed(): Internal.Text
        hashCode(): number
        static of(o: object): Internal.Text
        strikethrough(): Internal.Text
        strikethrough(value: boolean): Internal.Text
        copy(): Internal.Text
        rawComponent(): Internal.MutableComponent
        createStyleJson(): Internal.JsonObject
        hasSiblings(): boolean
        green(): Internal.Text
        darkGreen(): Internal.Text
        forEach(arg0: (arg0: T) => void): void
        lightPurple(): Internal.Text
        black(): Internal.Text
        getString(): string
        getStyleAndSiblingJson(): Internal.JsonObject
        darkAqua(): Internal.Text
        component(): Internal.Component
        blue(): Internal.Text
        underlined(value: boolean): Internal.Text
        underlined(): Internal.Text
        equals(obj: object): boolean
        toString(): string
        createStyle(): Internal.Style
        append(sibling: object): Internal.Text
        font(value: string): Internal.Text
        get siblings(): Internal.List<Internal.Text>;
        get string(): string;
        get styleAndSiblingJson(): Internal.JsonObject;
    }
    class SoundType {
    }
    class AgeableListModel <E> extends Internal.EntityModel<E> {
    }
    interface AnnotatedType implements Internal.AnnotatedElement {
        getAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getDeclaredAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        getAnnotatedOwnerType(): Internal.AnnotatedType
        getType(): Internal.Type
        getAnnotation<T>(arg0: Internal.Class<T>): T
        getDeclaredAnnotation<T>(arg0: Internal.Class<T>): T
        getAnnotations(): Internal.Annotation[]
        getDeclaredAnnotations(): Internal.Annotation[]
        get annotatedOwnerType(): Internal.AnnotatedType;
        get type(): Internal.Type;
        get annotations(): Internal.Annotation[];
        get declaredAnnotations(): Internal.Annotation[];
    }
    interface ResourceManager implements Internal.ResourceProvider {
    }
    class SWMRNibbleArray$SaveState {
        readonly data : number[];
        readonly state : number;
    }
    class ImmutableList <E> extends Internal.ImmutableCollection<E> implements Internal.List<E>, Internal.RandomAccess {
        add(arg0: number, arg1: E): void
        subList(arg0: number, arg1: number): Internal.ImmutableList<E>
        subList(arg0: number, arg1: number): Internal.List<any>
        set(arg0: number, arg1: E): E
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        sort(arg0: Internal.Comparator<E>): void
        reverse(): Internal.ImmutableList<E>
        static copyOf<E>(arg0: E[]): Internal.ImmutableList<E>
        static copyOf<E>(arg0: Internal.Iterator<E>): Internal.ImmutableList<E>
        static copyOf<E>(arg0: Internal.Collection<E>): Internal.ImmutableList<E>
        static copyOf<E>(arg0: Internal.Iterable<E>): Internal.ImmutableList<E>
        replaceAll(arg0: Internal.UnaryOperator<E>): void
        asList(): Internal.ImmutableList<E>
        remove(arg0: number): E
        static builderWithExpectedSize<E>(arg0: number): Internal.ImmutableList$Builder<E>
        static sortedCopyOf<E>(arg0: Internal.Comparator<E>, arg1: Internal.Iterable<E>): Internal.ImmutableList<E>
        static sortedCopyOf<E>(arg0: Internal.Iterable<E>): Internal.ImmutableList<E>
        lastIndexOf(arg0: object): number
        contains(arg0: object): boolean
        iterator(): Internal.UnmodifiableIterator<E>
        iterator(): Internal.Iterator<any>
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean
        hashCode(): number
        get(arg0: number): E
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E): Internal.ImmutableList<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): Internal.ImmutableList<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): Internal.ImmutableList<E>
        static of<E>(): Internal.ImmutableList<E>
        static of<E>(arg0: E): Internal.ImmutableList<E>
        static of<E>(arg0: E, arg1: E): Internal.ImmutableList<E>
        static of<E>(arg0: E, arg1: E, arg2: E): Internal.ImmutableList<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): Internal.ImmutableList<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E, arg10: E, arg11: E, arg12: E[]): Internal.ImmutableList<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): Internal.ImmutableList<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E, arg10: E): Internal.ImmutableList<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): Internal.ImmutableList<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): Internal.ImmutableList<E>
        equals(arg0: object): boolean
        static toImmutableList<E>(): Internal.Collector<E, object, Internal.ImmutableList<E>>
        static builder<E>(): Internal.ImmutableList$Builder<E>
        listIterator(arg0: number): Internal.ListIterator<any>
        listIterator(arg0: number): Internal.UnmodifiableListIterator<E>
        listIterator(): Internal.ListIterator<any>
        listIterator(): Internal.UnmodifiableListIterator<E>
        indexOf(arg0: object): number
    }
    interface DoubleFunction <R> {
        apply(arg0: number): R
    }
    class ImmutableMultimap <K, V> extends Internal.BaseImmutableMultimap<K, V> implements Internal.Serializable {
        asMap(): Map<any, any>
        asMap(): Internal.ImmutableMap<K, Internal.Collection<V>>
        keys(): Internal.ImmutableMultiset<K>
        keys(): Internal.Multiset<any>
        values(): Internal.ImmutableCollection<V>
        values(): Internal.Collection<any>
        containsValue(arg0: object): boolean
        put(arg0: K, arg1: V): boolean
        remove(arg0: object, arg1: object): boolean
        removeAll(arg0: object): Internal.ImmutableCollection<V>
        removeAll(arg0: object): Internal.Collection<any>
        hashCode(): number
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean
        putAll(arg0: Internal.Multimap<K, V>): boolean
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): Internal.ImmutableMultimap<K, V>
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): Internal.ImmutableMultimap<K, V>
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): Internal.ImmutableMultimap<K, V>
        static of<K, V>(): Internal.ImmutableMultimap<K, V>
        static of<K, V>(arg0: K, arg1: V): Internal.ImmutableMultimap<K, V>
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): Internal.ImmutableMultimap<K, V>
        get(arg0: K): Internal.ImmutableCollection<V>
        get(arg0: object): Internal.Collection<any>
        static builder<K, V>(): Internal.ImmutableMultimap$Builder<K, V>
        keySet(): Internal.ImmutableSet<K>
        keySet(): Internal.Set<any>
        inverse(): Internal.ImmutableMultimap<V, K>
        containsEntry(arg0: object, arg1: object): boolean
        containsKey(arg0: object): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        isEmpty(): boolean
        clear(): void
        static copyOf<K, V>(arg0: Internal.Iterable<Internal.Map$Entry<K, V>>): Internal.ImmutableMultimap<K, V>
        static copyOf<K, V>(arg0: Internal.Multimap<K, V>): Internal.ImmutableMultimap<K, V>
        replaceValues(arg0: object, arg1: Internal.Iterable<any>): Internal.Collection<any>
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.ImmutableCollection<V>
        entries(): Internal.ImmutableCollection<Internal.Map$Entry<K, V>>
        entries(): Internal.Collection<any>
        size(): number
        equals(arg0: object): boolean
        toString(): string
    }
    interface EventListener {
    }
    interface List <E> implements Internal.Collection<E> {
        replaceAll(arg0: Internal.UnaryOperator<E>): void
        remove(arg0: object): boolean
        remove(arg0: number): E
        removeAll(arg0: Internal.Collection<object>): boolean
        iterator(): Internal.Iterator<E>
        stream(): Internal.Stream<E>
        hashCode(): number
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E): Internal.List<E>
        static of<E>(arg0: E, arg1: E, arg2: E): Internal.List<E>
        static of<E>(arg0: E, arg1: E): Internal.List<E>
        static of<E>(arg0: E): Internal.List<E>
        static of<E>(): Internal.List<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): Internal.List<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): Internal.List<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): Internal.List<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): Internal.List<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): Internal.List<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): Internal.List<E>
        static of<E>(arg0: E[]): Internal.List<E>
        get(arg0: number): E
        toArray(): object[]
        toArray<T>(arg0: T[]): T[]
        toArray<T>(arg0: Internal.IntFunction<T[]>): T[]
        parallelStream(): Internal.Stream<E>
        indexOf(arg0: object): number
        add(arg0: number, arg1: E): void
        add(arg0: E): boolean
        subList(arg0: number, arg1: number): Internal.List<E>
        set(arg0: number, arg1: E): E
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: T) => void): void
        containsAll(arg0: Internal.Collection<object>): boolean
        isEmpty(): boolean
        clear(): void
        sort(arg0: Internal.Comparator<E>): void
        static copyOf<E>(arg0: Internal.Collection<E>): Internal.List<E>
        removeIf(arg0: (arg0: E) => boolean): boolean
        lastIndexOf(arg0: object): number
        contains(arg0: object): boolean
        size(): number
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean
        addAll(arg0: Internal.Collection<E>): boolean
        equals(arg0: object): boolean
        listIterator(arg0: number): Internal.ListIterator<E>
        listIterator(): Internal.ListIterator<E>
        retainAll(arg0: Internal.Collection<object>): boolean
    }
    interface BiomeManager$NoiseBiomeSource {
    }
    interface Byte2FloatFunction implements Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: Internal.Float2ShortFunction): Internal.Byte2ShortFunction
        composeByte(arg0: Internal.Byte2ByteFunction): Internal.Byte2FloatFunction
        andThenInt(arg0: Internal.Float2IntFunction): Internal.Byte2IntFunction
        composeReference<T>(arg0: Internal.Reference2ByteFunction<T>): Internal.Reference2FloatFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Float2DoubleFunction): Internal.Byte2DoubleFunction
        andThenObject<T>(arg0: Internal.Float2ObjectFunction<T>): Internal.Byte2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Float2LongFunction): Internal.Byte2LongFunction
        composeLong(arg0: Internal.Long2ByteFunction): Internal.Long2FloatFunction
        andThenByte(arg0: Internal.Float2ByteFunction): Internal.Byte2ByteFunction
        andThenFloat(arg0: Internal.Float2FloatFunction): Internal.Byte2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ByteFunction): Internal.Int2FloatFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ByteFunction): Internal.Float2FloatFunction
        andThenChar(arg0: Internal.Float2CharFunction): Internal.Byte2CharFunction
        composeObject<T>(arg0: Internal.Object2ByteFunction<T>): Internal.Object2FloatFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2ByteFunction): Internal.Short2FloatFunction
        andThenReference<T>(arg0: Internal.Float2ReferenceFunction<T>): Internal.Byte2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ByteFunction): Internal.Char2FloatFunction
        composeDouble(arg0: Internal.Double2ByteFunction): Internal.Double2FloatFunction
    }
    class BlockEntityPredicate implements Internal.BlockPredicate {
        data(cd: Internal.BlockEntityPredicateDataCheck): Internal.BlockEntityPredicate
        toString(): string
        check(block: Internal.BlockContainerJS): boolean
    }
    interface ChronoPeriod implements Internal.TemporalAmount {
        minus(arg0: Internal.TemporalAmount): Internal.ChronoPeriod
        isNegative(): boolean
        negated(): Internal.ChronoPeriod
        normalized(): Internal.ChronoPeriod
        plus(arg0: Internal.TemporalAmount): Internal.ChronoPeriod
        multipliedBy(arg0: number): Internal.ChronoPeriod
        subtractFrom(arg0: Internal.Temporal): Internal.Temporal
        hashCode(): number
        equals(arg0: object): boolean
        get(arg0: Internal.TemporalUnit): number
        getUnits(): Internal.List<Internal.TemporalUnit>
        addTo(arg0: Internal.Temporal): Internal.Temporal
        isZero(): boolean
        toString(): string
        getChronology(): Internal.Chronology
        static between(arg0: Internal.ChronoLocalDate, arg1: Internal.ChronoLocalDate): Internal.ChronoPeriod
        get units(): Internal.List<Internal.TemporalUnit>;
        get chronology(): Internal.Chronology;
    }
    class OrConditionBuilder implements Internal.ConditionsContainer<Internal.OrConditionBuilder> {
        killerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B
        survivesExplosion(): B
        addCondition(arg0: Internal.LootItemCondition): Internal.ConditionsContainer<any>
        addCondition(arg0: Internal.LootItemCondition): Internal.OrConditionBuilder
        addCondition(arg0: Internal.LootItemCondition$Builder): B
        customDistanceToPlayer(arg0: (arg0: Internal.DistancePredicateBuilder) => void): B
        matchFluid(arg0: string): B
        not(arg0: (arg0: Internal.NotConditionBuilder) => void): B
        directKillerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B
        matchEquip(arg0: EquipmentSlot, arg1: Internal.IngredientJS): B
        and(arg0: (arg0: Internal.AndConditionBuilder) => void): B
        matchLoot(arg0: Internal.IngredientJS): B
        matchLoot(arg0: Internal.IngredientJS, arg1: boolean): B
        anyBiome(arg0: string[]): B
        distanceToKiller(arg0: Internal.MinMaxBounds$Doubles): B
        entityPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B
        matchEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        anyDimension(arg0: ResourceLocation[]): B
        killedByPlayer(): B
        or(arg0: (arg0: Internal.OrConditionBuilder) => void): B
        timeCheck(arg0: number, arg1: number, arg2: number): B
        timeCheck(arg0: number, arg1: number): B
        matchOffHand(arg0: Internal.IngredientJS): B
        randomChance(arg0: number): B
        playerPredicate(arg0: (arg0: Internal.PlayerJS<object>) => boolean): B
        weatherCheck(arg0: Map<string, boolean>): B
        matchDirectKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        matchBlockState(arg0: Internal.Block, arg1: Map<string, string>): B
        matchMainHand(arg0: Internal.IngredientJS): B
        matchPlayer(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        lightLevel(arg0: number, arg1: number): B
        build(): Internal.OrCondition
        biome(arg0: string[]): B
        customCondition(arg0: Internal.JsonObject): B
        matchKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        randomChanceWithLooting(arg0: number, arg1: number): B
        hasAnyStage(arg0: string[]): B
        randomChanceWithEnchantment(arg0: Internal.Enchantment, arg1: number[]): B
        anyStructure(arg0: ResourceLocation[], arg1: boolean): B
        matchDamageSource(arg0: (arg0: Internal.DamageSourcePredicateBuilderJS) => void): B
    }
    class DistancePredicateBuilder {
        horizontal(arg0: Internal.MinMaxBounds$Doubles): Internal.DistancePredicateBuilder
        build(): Internal.DistancePredicate
        absolute(arg0: Internal.MinMaxBounds$Doubles): Internal.DistancePredicateBuilder
        x(arg0: Internal.MinMaxBounds$Doubles): Internal.DistancePredicateBuilder
        y(arg0: Internal.MinMaxBounds$Doubles): Internal.DistancePredicateBuilder
        z(arg0: Internal.MinMaxBounds$Doubles): Internal.DistancePredicateBuilder
    }
    class NamedPackage {
    }
    interface ScheduledFuture <V> implements Internal.Delayed, Internal.Future<V> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        getDelay(arg0: Internal.TimeUnit): number
        get(arg0: number, arg1: Internal.TimeUnit): V
        get(): V
        compareTo(arg0: T): number
        isDone(): boolean
    }
    class Locale$Category extends Internal.Enum<Internal.Locale$Category> {
        static valueOf(arg0: string): Internal.Locale$Category
        static values(): Internal.Locale$Category[]
        static readonly DISPLAY : Internal.Locale$Category;
        static readonly FORMAT : Internal.Locale$Category;
    }
    class PlayerStatsJS {
        getPlayer(): Internal.PlayerJS<object>
        getPlayTime(): number
        getDamageAbsorbed(): number
        getWalkDistance(): number
        getCrouchDistance(): number
        getItemsPickedUp(item: Internal.Item): number
        getDamageDealt_absorbed(): number
        getFishCaught(): number
        getDeaths(): number
        getSwimDistance(): number
        getItemsCrafted(item: Internal.Item): number
        getBlocksMined(block: Internal.Block): number
        getDamageDealt_resisted(): number
        getPlayerKills(): number
        get(id: ResourceLocation): number
        getTimeSinceDeath(): number
        getDamageBlocked_by_shield(): number
        getKilled(entity: Internal.EntityType<object>): number
        getTimeCrouchTime(): number
        getDamageTaken(): number
        add(id: ResourceLocation, value: number): void
        getItemsDropped(item: Internal.Item): number
        set(id: ResourceLocation, value: number): void
        getJumps(): number
        getDamageResisted(): number
        getAnimalsBred(): number
        getItemsBroken(item: Internal.Item): number
        getMobKills(): number
        getSprintDistance(): number
        getTimeSinceRest(): number
        getKilledBy(entity: Internal.EntityType<object>): number
        getDamageDealt(): number
        getItemsUsed(item: Internal.Item): number
        get player(): Internal.PlayerJS<object>;
        get playTime(): number;
        get damageAbsorbed(): number;
        get walkDistance(): number;
        get crouchDistance(): number;
        get damageDealt_absorbed(): number;
        get fishCaught(): number;
        get deaths(): number;
        get swimDistance(): number;
        get damageDealt_resisted(): number;
        get playerKills(): number;
        get timeSinceDeath(): number;
        get damageBlocked_by_shield(): number;
        get timeCrouchTime(): number;
        get damageTaken(): number;
        get jumps(): number;
        get damageResisted(): number;
        get animalsBred(): number;
        get mobKills(): number;
        get sprintDistance(): number;
        get timeSinceRest(): number;
        get damageDealt(): number;
    }
    interface CommonLevelAccessor implements Internal.EntityGetter, Internal.LevelReader, Internal.LevelSimulatedRW {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
    }
    class SimpleContainer implements Internal.Container, Internal.StackedContentsCompatible {
        toString(): string
    }
    interface ObjDoubleConsumer <T> {
        accept(arg0: T, arg1: number): void
    }
    interface Char2IntFunction implements Internal.Function<string, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: string, arg1: number): number
        andThenShort(arg0: Internal.Int2ShortFunction): Internal.Char2ShortFunction
        composeByte(arg0: Internal.Byte2CharFunction): Internal.Byte2IntFunction
        andThenInt(arg0: Internal.Int2IntFunction): Internal.Char2IntFunction
        composeReference<T>(arg0: Internal.Reference2CharFunction<T>): Internal.Reference2IntFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: string) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: string, arg1: number): number
        put(arg0: string, arg1: number): number
        remove(arg0: string): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Int2DoubleFunction): Internal.Char2DoubleFunction
        andThenObject<T>(arg0: Internal.Int2ObjectFunction<T>): Internal.Char2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: string): number
        andThenLong(arg0: Internal.Int2LongFunction): Internal.Char2LongFunction
        composeLong(arg0: Internal.Long2CharFunction): Internal.Long2IntFunction
        andThenByte(arg0: Internal.Int2ByteFunction): Internal.Char2ByteFunction
        andThenFloat(arg0: Internal.Int2FloatFunction): Internal.Char2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: string): boolean
        composeInt(arg0: Internal.Int2CharFunction): Internal.Int2IntFunction
        clear(): void
        composeFloat(arg0: Internal.Float2CharFunction): Internal.Float2IntFunction
        andThenChar(arg0: Internal.Int2CharFunction): Internal.Char2CharFunction
        composeObject<T>(arg0: Internal.Object2CharFunction<T>): Internal.Object2IntFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => string): (arg0: T) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2CharFunction): Internal.Short2IntFunction
        andThenReference<T>(arg0: Internal.Int2ReferenceFunction<T>): Internal.Char2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2CharFunction): Internal.Char2IntFunction
        composeDouble(arg0: Internal.Double2CharFunction): Internal.Double2IntFunction
    }
    class ScreenPaintEventJS extends Internal.PaintEventJS {
        rawText(text: Internal.FormattedCharSequence, x: number, y: number, color: number, shadow: boolean): void
        scale(x: number, y: number): void
        scale(scale: number): void
        alignX(x: number, w: number, alignX: number): number
        rectangle(x: number, y: number, z: number, w: number, h: number, color: number): void
        rectangle(x: number, y: number, z: number, w: number, h: number, color: number, u0: number, v0: number, u1: number, v1: number): void
        text(text: Internal.Component, x: number, y: number, color: number, shadow: boolean): void
        rotateRad(angle: number): void
        alignY(y: number, h: number, alignY: number): number
        rotateDeg(angle: number): void
        translate(x: number, y: number): void
        readonly mouseX : number;
        readonly mc : Internal.Minecraft;
        readonly mouseY : number;
        readonly width : number;
        readonly delta : number;
        readonly screen : Internal.Screen;
        readonly tesselator : Internal.Tesselator;
        readonly buffer : Internal.BufferBuilder;
        readonly inventory : boolean;
        readonly matrices : Internal.PoseStack;
        readonly height : number;
        readonly font : Internal.Font;
    }
    interface EntryMessage implements Internal.FlowMessage {
        getText(): string
        getParameters(): object[]
        getFormattedMessage(): string
        getMessage(): org.apache.logging.log4j.message.Message
        getFormat(): string
        getThrowable(): Internal.Throwable
        get text(): string;
        get parameters(): object[];
        get formattedMessage(): string;
        get message(): org.apache.logging.log4j.message.Message;
        get format(): string;
        get throwable(): Internal.Throwable;
    }
    interface ExtendedWorld {
        getChunkAtImmediately(arg0: number, arg1: number): Internal.LevelChunk
        getAnyChunkImmediately(arg0: number, arg1: number): Internal.ChunkAccess
    }
    interface ExplosionAccess {
        static callAddBlockDrops(arg0: Internal.ObjectArrayList<com.mojang.datafixers.util.Pair<Internal.ItemStack, BlockPos>>, arg1: Internal.ItemStack, arg2: BlockPos): void
    }
    interface StackedContentsCompatible {
    }
    class IngredientAction extends Internal.IngredientActionFilter {
        static readList(buf: Internal.FriendlyByteBuf): Internal.List<Internal.IngredientAction>
        toJson(json: Internal.JsonObject): void
        toJson(): Internal.JsonObject
        transform(arg0: Internal.ItemStack, arg1: number, arg2: Internal.CraftingContainer): Internal.ItemStack
        static writeList(buf: Internal.FriendlyByteBuf, list: Internal.List<Internal.IngredientAction>): void
        getType(): string
        static getRemaining(container: Internal.CraftingContainer, index: number, ingredientActions: Internal.List<Internal.IngredientAction>): Internal.ItemStack
        static parseList(json: Internal.JsonElement): Internal.List<Internal.IngredientAction>
        static readonly FACTORY_MAP : Map<string, (arg0: Internal.JsonObject) => Internal.IngredientAction>;
        filterIndex : number;
        filterIngredient : Internal.IngredientJS;
        get type(): string;
    }
    interface TransformStack implements Internal.Transform<Internal.TransformStack>, Internal.TStack<Internal.TransformStack> {
        rotate(arg0: Internal.Direction, arg1: number): Self
        rotate(arg0: number, arg1: Internal.Direction$Axis): Self
        translateAll(arg0: number): Self
        scale(arg0: number, arg1: number, arg2: number): Self
        scale(arg0: number): Self
        translate(arg0: number, arg1: number, arg2: number): Self
        translate(arg0: Internal.Vector3f): Self
        translate(arg0: Vec3): Self
        translate(arg0: Vec3i): Self
        translateZ(arg0: number): Self
        static cast(arg0: Internal.PoseStack): Internal.TransformStack
        pushPose(): Self
        mulNormal(arg0: Internal.Matrix3f): Self
        transform(arg0: Internal.PoseStack): Self
        transform(arg0: Internal.Matrix4f, arg1: Internal.Matrix3f): Self
        translateY(arg0: number): Self
        translateX(arg0: number): Self
        multiply(arg0: Internal.Vector3f, arg1: number): Self
        multiply(arg0: Internal.Quaternion): Self
        rotateX(arg0: number): Self
        rotateY(arg0: number): Self
        translateBack(arg0: Vec3): Self
        translateBack(arg0: Vec3i): Self
        translateBack(arg0: number, arg1: number, arg2: number): Self
        rotateZ(arg0: number): Self
        rotateToFace(arg0: Internal.Direction): Self
        nudge(arg0: number): Self
        rotateCentered(arg0: Internal.Direction, arg1: number): Self
        rotateCentered(arg0: Internal.Quaternion): Self
        centre(): Self
        multiplyRadians(arg0: Internal.Vector3f, arg1: number): Self
        rotateZRadians(arg0: number): Self
        mulPose(arg0: Internal.Matrix4f): Self
        rotateYRadians(arg0: number): Self
        rotateXRadians(arg0: number): Self
        popPose(): Self
        unCentre(): Self
    }
    class AbstractMap <K, V> implements Map<K, V> {
        getOrDefault(arg0: object, arg1: V): V
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>
        forEach(arg0: (arg0: K, arg1: V) => void): void
        containsKey(arg0: object): boolean
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V
        values(): Internal.Collection<V>
        replace(arg0: K, arg1: V): V
        replace(arg0: K, arg1: V, arg2: V): boolean
        isEmpty(): boolean
        clear(): void
        replaceAll(arg0: (arg0: K, arg1: V) => V): void
        containsValue(arg0: object): boolean
        put(arg0: K, arg1: V): V
        remove(arg0: object): V
        remove(arg0: object, arg1: object): boolean
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        size(): number
        hashCode(): number
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        putAll(arg0: Map<K, V>): void
        equals(arg0: object): boolean
        get(arg0: object): V
        toString(): string
        putIfAbsent(arg0: K, arg1: V): V
        keySet(): Internal.Set<K>
    }
    interface BiFunction <T, U, R> {
        apply(arg0: T, arg1: U): R
        andThen<V>(arg0: (arg0: R) => V): (arg0: T, arg1: U) => V
    }
    interface IntCollection implements Internal.Collection<number>, Internal.IntIterable {
        intIterator(): Internal.IntIterator
        intSpliterator(): Internal.IntSpliterator
        remove(arg0: object): boolean
        intStream(): Internal.IntStream
        removeAll(arg0: Internal.IntCollection): boolean
        removeAll(arg0: Internal.Collection<object>): boolean
        iterator(): Internal.IntIterator
        iterator(): Internal.Iterator<any>
        stream(): Internal.Stream<number>
        hashCode(): number
        toIntArray(arg0: number[]): number[]
        toIntArray(): number[]
        toArray(arg0: number[]): number[]
        toArray<T>(arg0: T[]): T[]
        toArray<T>(arg0: Internal.IntFunction<T[]>): T[]
        toArray(): object[]
        parallelStream(): Internal.Stream<number>
        rem(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: object): boolean
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.IntSpliterator
        forEach(arg0: (arg0: number) => void): void
        forEach(arg0: java_.util.function_.IntConsumer): void
        forEach(arg0: Internal.IntConsumer): void
        containsAll(arg0: Internal.IntCollection): boolean
        containsAll(arg0: Internal.Collection<object>): boolean
        isEmpty(): boolean
        clear(): void
        removeIf(arg0: (arg0: number) => boolean): boolean
        removeIf(arg0: Internal.IntPredicate): boolean
        removeIf(arg0: it.unimi.dsi.fastutil.ints.IntPredicate): boolean
        contains(arg0: object): boolean
        contains(arg0: number): boolean
        size(): number
        addAll(arg0: Internal.IntCollection): boolean
        addAll(arg0: Internal.Collection<E>): boolean
        equals(arg0: object): boolean
        intParallelStream(): Internal.IntStream
        retainAll(arg0: Internal.IntCollection): boolean
        retainAll(arg0: Internal.Collection<object>): boolean
    }
    class Products$P11 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>>): Internal.App<F, R>
    }
    class Products$P15 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> {
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, Internal.Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>): Internal.App<F, R>
    }
    interface CollisionGetter implements Internal.BlockGetter {
    }
    class IdScriptableObject extends Internal.ScriptableObject implements Internal.IdFunctionCall {
        getAttributes(name: string): number
        getAttributes(key: Internal.Symbol): number
        initPrototypeConstructor(f: Internal.IdFunctionObject): void
        activatePrototypeMap(maxPrototypeId: number): void
        execIdCall(f: Internal.IdFunctionObject, cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: object[]): object
        setAttributes(name: string, attributes: number): void
        delete(key: Internal.Symbol): void
        delete(name: string): void
        put(key: Internal.Symbol, start: Internal.Scriptable, value: object): void
        put(name: string, start: Internal.Scriptable, value: object): void
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable, sealed: boolean): Internal.IdFunctionObject
        hasPrototypeMap(): boolean
        initPrototypeMethod(tag: object, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject
        initPrototypeMethod(tag: object, id: number, key: Internal.Symbol, functionName: string, arity: number): Internal.IdFunctionObject
        initPrototypeMethod(tag: object, id: number, name: string, arity: number): Internal.IdFunctionObject
        defineOwnProperty(cx: Internal.Context, key: object, desc: Internal.ScriptableObject): void
        initPrototypeValue(id: number, name: string, value: object, attributes: number): void
        initPrototypeValue(id: number, key: Internal.Symbol, value: object, attributes: number): void
        get(name: string, start: Internal.Scriptable): object
        get(key: Internal.Symbol, start: Internal.Scriptable): object
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean
        has(name: string, start: Internal.Scriptable): boolean
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : object;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
    }
    class ResourceKey <T> implements Internal.Comparable<Internal.ResourceKey<object>>, Internal.SpecialEquality {
        getNamespace(): string
        equals(arg0: object): boolean
        getPath(): string
        getRegistryName(): ResourceLocation
        toString(): string
        compareTo(arg0: object): number
        compareTo(arg0: Internal.ResourceKey<object>): number
        specialEquals(o: object, shallow: boolean): boolean
        get namespace(): string;
        get path(): string;
        get registryName(): ResourceLocation;
    }
    interface FileNameMap {
        getContentTypeFor(arg0: string): string
    }
    class TextureAtlas extends Internal.AbstractTexture implements Internal.Tickable {
        handler$zdd000$stealAtlasData(arg0: Internal.ResourceManager, arg1: Internal.Stream<any>, arg2: Internal.ProfilerFiller, arg3: number, arg4: Internal.CallbackInfoReturnable<any>): void
    }
    interface VertexConsumer implements Internal.IForgeVertexConsumer, Internal.VertexDrain {
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer): number
        createSink(factory: Internal.VertexType<any>): Internal.VertexSink
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void
        applyBakedNormals(arg0: Internal.Vector3f, arg1: Internal.ByteBuffer, arg2: Internal.Matrix3f): void
    }
    interface IngredientJS implements Internal.JsonSerializable, Internal.WrappedJS, Internal.Copyable {
        anyStackMatches(ingredient: Internal.IngredientJS): boolean
        getItemIds(): Internal.Set<string>
        testVanillaItem(item: Internal.Item): boolean
        test(arg0: Internal.ItemStackJS): boolean
        getStacks(): Internal.Set<Internal.ItemStackJS>
        getVanillaItems(): Internal.Set<Internal.Item>
        static ingredientFromRecipeJson(json: Internal.JsonElement): Internal.IngredientJS
        isEmpty(): boolean
        isInvalidRecipeIngredient(): boolean
        asIngredientStack(): Internal.IngredientStackJS
        static getCustomIngredient(object: Internal.JsonObject): Internal.Ingredient
        getVanillaPredicate(): (arg0: Internal.ItemStack) => boolean
        filter(filter: Internal.IngredientJS): Internal.IngredientJS
        createVanillaIngredient(): Internal.Ingredient
        toJson(): Internal.JsonElement
        not(): Internal.IngredientJS
        withCount(count: number): Internal.IngredientJS
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>
        getFirst(): Internal.ItemStackJS
        testVanilla(stack: Internal.ItemStack): boolean
        static of(o: object): Internal.IngredientJS
        x(c: number): Internal.IngredientJS
        copy(): Internal.IngredientJS
        copy(): Internal.Copyable
        getCount(): number
        get itemIds(): Internal.Set<string>;
        get stacks(): Internal.Set<Internal.ItemStackJS>;
        get vanillaItems(): Internal.Set<Internal.Item>;
        get vanillaPredicate(): (arg0: Internal.ItemStack) => boolean;
        get first(): Internal.ItemStackJS;
        get count(): number;
    }
    class AirBlock extends Internal.Block {
        readonly delegate : () => V;
    }
    class Fluid extends Internal.ForgeRegistryEntry<Internal.Fluid> implements Internal.IForgeFluid {
        getAttributes(): Internal.FluidAttributes
        getExplosionResistance(arg0: Internal.FluidState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): number
        getTags(): Internal.Set<ResourceLocation>
        isEntityInside(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity, arg4: number, arg5: Internal.SetTag<Internal.Fluid>, arg6: boolean): boolean
        isAABBInsideMaterial(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.AABB, arg4: net.minecraft.world.level.material.Material): boolean
        isAABBInsideLiquid(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.AABB): boolean
        readonly delegate : () => V;
        get attributes(): Internal.FluidAttributes;
        get tags(): Internal.Set<ResourceLocation>;
    }
    interface LevelReader implements Internal.BlockAndTintGetter, Internal.CollisionGetter, Internal.BiomeManager$NoiseBiomeSource {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
    }
    class MultipartBlockStateGenerator$Part {
        toJson(): Internal.JsonObject
        model(s: string): Internal.VariantBlockStateGenerator$Model
    }
    class FieldNamingPolicy extends Internal.Enum<Internal.FieldNamingPolicy> implements Internal.FieldNamingStrategy {
        static valueOf(arg0: string): Internal.FieldNamingPolicy
        static values(): Internal.FieldNamingPolicy[]
        translateName(arg0: Internal.Field): string
        static readonly IDENTITY : Internal.FieldNamingPolicy;
        static readonly UPPER_CAMEL_CASE_WITH_SPACES : Internal.FieldNamingPolicy;
        static readonly UPPER_CAMEL_CASE : Internal.FieldNamingPolicy;
        static readonly LOWER_CASE_WITH_DOTS : Internal.FieldNamingPolicy;
        static readonly LOWER_CASE_WITH_UNDERSCORES : Internal.FieldNamingPolicy;
        static readonly LOWER_CASE_WITH_DASHES : Internal.FieldNamingPolicy;
    }
    class StateHolder <O, S> {
        toString(): string
    }
    interface Float2FloatFunction implements Internal.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: number, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: Internal.Float2ShortFunction): Internal.Float2ShortFunction
        composeByte(arg0: Internal.Byte2FloatFunction): Internal.Byte2FloatFunction
        andThenInt(arg0: Internal.Float2IntFunction): Internal.Float2IntFunction
        composeReference<T>(arg0: Internal.Reference2FloatFunction<T>): Internal.Reference2FloatFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Float2DoubleFunction): Internal.Float2DoubleFunction
        andThenObject<T>(arg0: Internal.Float2ObjectFunction<T>): Internal.Float2ObjectFunction<T>
        static identity(): Internal.Float2FloatFunction
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Float2LongFunction): Internal.Float2LongFunction
        composeLong(arg0: Internal.Long2FloatFunction): Internal.Long2FloatFunction
        andThenByte(arg0: Internal.Float2ByteFunction): Internal.Float2ByteFunction
        andThenFloat(arg0: Internal.Float2FloatFunction): Internal.Float2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2FloatFunction): Internal.Int2FloatFunction
        clear(): void
        composeFloat(arg0: Internal.Float2FloatFunction): Internal.Float2FloatFunction
        andThenChar(arg0: Internal.Float2CharFunction): Internal.Float2CharFunction
        composeObject<T>(arg0: Internal.Object2FloatFunction<T>): Internal.Object2FloatFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        composeShort(arg0: Internal.Short2FloatFunction): Internal.Short2FloatFunction
        andThenReference<T>(arg0: Internal.Float2ReferenceFunction<T>): Internal.Float2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2FloatFunction): Internal.Char2FloatFunction
        composeDouble(arg0: Internal.Double2FloatFunction): Internal.Double2FloatFunction
    }
    class CokeOvenRecipeJS extends Internal.IERecipeJS {
        creosote(c: number): Internal.CokeOvenRecipeJS
        serialize(): void
        create(args: Internal.ListJS): void
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<object>;
        readonly inputFluids : Internal.List<Internal.FluidTagInput>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        serializeInputs : boolean;
    }
    interface Byte2ReferenceFunction <V> implements Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: number, arg1: V): V
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Reference2ShortFunction<V>): Internal.Byte2ShortFunction
        composeByte(arg0: Internal.Byte2ByteFunction): Internal.Byte2ReferenceFunction<V>
        andThenInt(arg0: Internal.Reference2IntFunction<V>): Internal.Byte2IntFunction
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: Internal.Reference2ByteFunction<T>): (arg0: T) => V
        put(arg0: number, arg1: V): V
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: object): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: Internal.Reference2DoubleFunction<V>): Internal.Byte2DoubleFunction
        andThenObject<T>(arg0: (arg0: V) => T): Internal.Byte2ObjectFunction<T>
        get(arg0: object): V
        get(arg0: number): V
        andThenLong(arg0: Internal.Reference2LongFunction<V>): Internal.Byte2LongFunction
        composeLong(arg0: Internal.Long2ByteFunction): Internal.Long2ReferenceFunction<V>
        andThenByte(arg0: Internal.Reference2ByteFunction<V>): Internal.Byte2ByteFunction
        andThenFloat(arg0: Internal.Reference2FloatFunction<V>): Internal.Byte2FloatFunction
        apply(arg0: number): V
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ByteFunction): Internal.Int2ReferenceFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2ByteFunction): Internal.Float2ReferenceFunction<V>
        andThenChar(arg0: Internal.Reference2CharFunction<V>): Internal.Byte2CharFunction
        composeObject<T>(arg0: Internal.Object2ByteFunction<T>): (arg0: T) => V
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => V
        composeShort(arg0: Internal.Short2ByteFunction): Internal.Short2ReferenceFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): Internal.Byte2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ByteFunction): Internal.Char2ReferenceFunction<V>
        composeDouble(arg0: Internal.Double2ByteFunction): Internal.Double2ReferenceFunction<V>
    }
    class PlayerEventJS extends Internal.LivingEntityEventJS {
        addGameStage(stage: string): void
        getPlayer(): Internal.PlayerJS<any>
        getMinecraftPlayer(): Internal.Player
        hasGameStage(stage: string): boolean
        removeGameStage(stage: string): void
        get player(): Internal.PlayerJS<any>;
        get minecraftPlayer(): Internal.Player;
    }
    interface IForgePackResources {
        isHidden(): boolean
    }
    interface ConstProperties {
        defineConst(arg0: string, arg1: Internal.Scriptable): void
        isConst(arg0: string): boolean
        putConst(arg0: string, arg1: Internal.Scriptable, arg2: object): void
    }
    interface MessageSupplier {
        get(): org.apache.logging.log4j.message.Message
    }
    interface IForgeBlock {
        rotate(arg0: Internal.BlockState, arg1: Internal.LevelAccessor, arg2: BlockPos, arg3: Internal.Rotation): Internal.BlockState
        getStateAtViewpoint(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Vec3): Internal.BlockState
        onBlockExploded(arg0: Internal.BlockState, arg1: Internal.Level, arg2: BlockPos, arg3: Internal.Explosion): void
        getBedDirection(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): Internal.Direction
        getExpDrop(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: number, arg4: number): number
        isConduitFrame(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): boolean
        getLightEmission(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): number
        onDestroyedByPlayer(arg0: Internal.BlockState, arg1: Internal.Level, arg2: BlockPos, arg3: Internal.Player, arg4: boolean, arg5: Internal.FluidState): boolean
        getTags(): Internal.Set<ResourceLocation>
        isBed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean
        canHarvestBlock(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Player): boolean
        shouldCheckWeakPower(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.BlockState): boolean
        collisionExtendsVertically(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean
        addLandingEffects(arg0: Internal.BlockState, arg1: Internal.ServerLevel, arg2: BlockPos, arg3: Internal.BlockState, arg4: Internal.LivingEntity, arg5: number): boolean
        isLadder(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean
        shouldDisplayFluidOverlay(arg0: Internal.BlockState, arg1: Internal.BlockAndTintGetter, arg2: BlockPos, arg3: Internal.FluidState): boolean
        getSoundType(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): Internal.SoundType
        canStickTo(arg0: Internal.BlockState, arg1: Internal.BlockState): boolean
        onNeighborChange(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): void
        addRunningEffects(arg0: Internal.BlockState, arg1: Internal.Level, arg2: BlockPos, arg3: Internal.Entity): boolean
        getWeakChanges(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): boolean
        canEntityDestroy(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean
        isBurning(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean
        getCloneItemStack(arg0: Internal.BlockState, arg1: Internal.HitResult, arg2: Internal.BlockGetter, arg3: BlockPos, arg4: Internal.Player): Internal.ItemStack
        getFriction(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): number
        isFlammable(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean
        isValidSpawn(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.SpawnPlacements$Type, arg4: Internal.EntityType<object>): boolean
        isPortalFrame(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean
        getExplosionResistance(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): number
        isScaffolding(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean
        canSustainPlant(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.IPlantable): boolean
        onCaughtFire(arg0: Internal.BlockState, arg1: Internal.Level, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.LivingEntity): void
        getEnchantPowerBonus(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): number
        setBedOccupied(arg0: Internal.BlockState, arg1: Internal.Level, arg2: BlockPos, arg3: Internal.LivingEntity, arg4: boolean): void
        isFireSource(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean
        canDropFromExplosion(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): boolean
        getRespawnPosition(arg0: Internal.BlockState, arg1: Internal.EntityType<object>, arg2: Internal.LevelReader, arg3: BlockPos, arg4: number, arg5: Internal.LivingEntity): Internal.Optional<Vec3>
        isStickyBlock(arg0: Internal.BlockState): boolean
        isFertile(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean
        getAiPathNodeType(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Mob): Internal.BlockPathTypes
        isSlimeBlock(arg0: Internal.BlockState): boolean
        canConnectRedstone(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean
        getFireSpreadSpeed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number
        getFlammability(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number
        getToolModifiedState(arg0: Internal.BlockState, arg1: Internal.Level, arg2: BlockPos, arg3: Internal.Player, arg4: Internal.ItemStack, arg5: Internal.ToolAction): Internal.BlockState
        getBeaconColorMultiplier(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): number[]
        get tags(): Internal.Set<ResourceLocation>;
    }
    class DataJsonGenerator extends Internal.JsonGenerator {
    }
    class Enchantment extends Internal.ForgeRegistryEntry<Internal.Enchantment> {
        isAllowedOnBooks(): boolean
        getTags(): Internal.Set<ResourceLocation>
        is(arg0: Internal.Tag<Internal.Enchantment>): boolean
        canApplyAtEnchantingTable(arg0: Internal.ItemStack): boolean
        readonly delegate : () => V;
        get tags(): Internal.Set<ResourceLocation>;
    }
    interface Short2CharFunction implements Internal.Function<number, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: string): string
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: string): string
        andThenShort(arg0: Internal.Char2ShortFunction): Internal.Short2ShortFunction
        composeByte(arg0: Internal.Byte2ShortFunction): Internal.Byte2CharFunction
        andThenInt(arg0: Internal.Char2IntFunction): Internal.Short2IntFunction
        composeReference<T>(arg0: Internal.Reference2ShortFunction<T>): Internal.Reference2CharFunction<T>
        andThen<T>(arg0: (arg0: string) => T): (arg0: number) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: string): string
        put(arg0: number, arg1: string): string
        remove(arg0: number): string
        remove(arg0: object): object
        remove(arg0: object): string
        defaultReturnValue(): string
        defaultReturnValue(arg0: string): void
        andThenDouble(arg0: Internal.Char2DoubleFunction): Internal.Short2DoubleFunction
        andThenObject<T>(arg0: Internal.Char2ObjectFunction<T>): Internal.Short2ObjectFunction<T>
        get(arg0: object): string
        get(arg0: object): object
        get(arg0: number): string
        andThenLong(arg0: Internal.Char2LongFunction): Internal.Short2LongFunction
        composeLong(arg0: Internal.Long2ShortFunction): Internal.Long2CharFunction
        andThenByte(arg0: Internal.Char2ByteFunction): Internal.Short2ByteFunction
        andThenFloat(arg0: Internal.Char2FloatFunction): Internal.Short2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ShortFunction): Internal.Int2CharFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ShortFunction): Internal.Float2CharFunction
        andThenChar(arg0: Internal.Char2CharFunction): Internal.Short2CharFunction
        composeObject<T>(arg0: Internal.Object2ShortFunction<T>): Internal.Object2CharFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => string
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2ShortFunction): Internal.Short2CharFunction
        andThenReference<T>(arg0: Internal.Char2ReferenceFunction<T>): Internal.Short2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ShortFunction): Internal.Char2CharFunction
        composeDouble(arg0: Internal.Double2ShortFunction): Internal.Double2CharFunction
    }
    class ScheduledEvent {
        getServer(): Internal.ServerJS
        reschedule(timer: number): Internal.ScheduledEvent
        reschedule(): void
        getEndTime(): number
        isUsingTicks(): boolean
        getTimer(): number
        getTimerDuration(): number
        getData(): object
        get server(): Internal.ServerJS;
        get endTime(): number;
        get timer(): number;
        get timerDuration(): number;
        get data(): object;
    }
    interface Constable {
        describeConstable(): Internal.Optional<Internal.ConstantDesc>
    }
    class Locale implements Internal.Cloneable, Internal.Serializable {
        stripExtensions(): Internal.Locale
        static forLanguageTag(arg0: string): Internal.Locale
        getUnicodeLocaleAttributes(): Internal.Set<string>
        getCountry(): string
        getUnicodeLocaleKeys(): Internal.Set<string>
        getISO3Country(): string
        static lookupTag(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<string>): string
        getDisplayCountry(): string
        getDisplayCountry(arg0: Internal.Locale): string
        getISO3Language(): string
        static getISOCountries(): string[]
        static getISOCountries(arg0: Internal.Locale$IsoCountryCode): Internal.Set<string>
        hashCode(): number
        getExtensionKeys(): Internal.Set<string>
        getDisplayVariant(arg0: Internal.Locale): string
        getDisplayVariant(): string
        static filterTags(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<string>): Internal.List<string>
        static filterTags(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<string>, arg2: Internal.Locale$FilteringMode): Internal.List<string>
        static getISOLanguages(): string[]
        toLanguageTag(): string
        static getAvailableLocales(): Internal.Locale[]
        getDisplayScript(arg0: Internal.Locale): string
        getDisplayScript(): string
        static lookup(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<Internal.Locale>): Internal.Locale
        getLanguage(): string
        getExtension(arg0: string): string
        getVariant(): string
        static getDefault(): Internal.Locale
        static getDefault(arg0: Internal.Locale$Category): Internal.Locale
        static setDefault(arg0: Internal.Locale$Category, arg1: Internal.Locale): void
        static setDefault(arg0: Internal.Locale): void
        hasExtensions(): boolean
        static filter(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<Internal.Locale>, arg2: Internal.Locale$FilteringMode): Internal.List<Internal.Locale>
        static filter(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<Internal.Locale>): Internal.List<Internal.Locale>
        getDisplayName(arg0: Internal.Locale): string
        getDisplayName(): string
        equals(arg0: object): boolean
        clone(): object
        toString(): string
        getDisplayLanguage(arg0: Internal.Locale): string
        getDisplayLanguage(): string
        getScript(): string
        getUnicodeLocaleType(arg0: string): string
        static readonly PRC : Internal.Locale;
        static readonly CANADA : Internal.Locale;
        static readonly ENGLISH : Internal.Locale;
        static readonly ROOT : Internal.Locale;
        static readonly TAIWAN : Internal.Locale;
        static readonly CHINA : Internal.Locale;
        static readonly ITALY : Internal.Locale;
        static readonly CHINESE : Internal.Locale;
        static readonly KOREA : Internal.Locale;
        static readonly FRENCH : Internal.Locale;
        static readonly FRANCE : Internal.Locale;
        static readonly TRADITIONAL_CHINESE : Internal.Locale;
        static readonly CANADA_FRENCH : Internal.Locale;
        static readonly GERMANY : Internal.Locale;
        static readonly ITALIAN : Internal.Locale;
        static readonly PRIVATE_USE_EXTENSION : "x";
        static readonly UK : Internal.Locale;
        static readonly JAPAN : Internal.Locale;
        static readonly JAPANESE : Internal.Locale;
        static readonly UNICODE_LOCALE_EXTENSION : "u";
        static readonly SIMPLIFIED_CHINESE : Internal.Locale;
        static readonly GERMAN : Internal.Locale;
        static readonly US : Internal.Locale;
        static readonly KOREAN : Internal.Locale;
        get unicodeLocaleAttributes(): Internal.Set<string>;
        get country(): string;
        get unicodeLocaleKeys(): Internal.Set<string>;
        get iSO3Country(): string;
        get displayCountry(): string;
        get iSO3Language(): string;
        get iSOCountries(): string[];
        get extensionKeys(): Internal.Set<string>;
        get displayVariant(): string;
        get iSOLanguages(): string[];
        get availableLocales(): Internal.Locale[];
        get displayScript(): string;
        get language(): string;
        get variant(): string;
        get default(): Internal.Locale;
        set default(arg0: Internal.Locale);
        get displayName(): string;
        get displayLanguage(): string;
        get script(): string;
    }
    class SequencedAssemblyRecipeJS extends Internal.RecipeJS {
        transitionalItem(item: Internal.ItemStackJS): Internal.SequencedAssemblyRecipeJS
        serialize(): void
        loops(loops: number): Internal.SequencedAssemblyRecipeJS
        create(args: Internal.ListJS): void
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<object>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
    }
    interface Hash {
        static readonly DEFAULT_GROWTH_FACTOR : 16;
        static readonly FAST_LOAD_FACTOR : 0.5;
        static readonly DEFAULT_INITIAL_SIZE : 16;
        static readonly DEFAULT_LOAD_FACTOR : 0.75;
        static readonly OCCUPIED : -1;
        static readonly VERY_FAST_LOAD_FACTOR : 0.25;
        static readonly FREE : 0;
        static readonly PRIMES : number[];
        static readonly REMOVED : 1;
    }
    class CompressorHolder implements Internal.Compressable {
        keys<T>(arg0: Internal.DynamicOps<T>): Internal.Stream<T>
        compressor<T>(arg0: Internal.DynamicOps<T>): Internal.KeyCompressor<T>
    }
    class ZoneOffsetTransition implements Internal.Comparable<Internal.ZoneOffsetTransition>, Internal.Serializable {
        getDateTimeAfter(): Internal.LocalDateTime
        getDateTimeBefore(): Internal.LocalDateTime
        getOffsetBefore(): Internal.ZoneOffset
        getOffsetAfter(): Internal.ZoneOffset
        compareTo(arg0: Internal.ZoneOffsetTransition): number
        compareTo(arg0: object): number
        getInstant(): Internal.Instant
        isGap(): boolean
        getDuration(): Internal.Duration
        toEpochSecond(): number
        hashCode(): number
        static of(arg0: Internal.LocalDateTime, arg1: Internal.ZoneOffset, arg2: Internal.ZoneOffset): Internal.ZoneOffsetTransition
        equals(arg0: object): boolean
        isOverlap(): boolean
        toString(): string
        isValidOffset(arg0: Internal.ZoneOffset): boolean
        get dateTimeAfter(): Internal.LocalDateTime;
        get dateTimeBefore(): Internal.LocalDateTime;
        get offsetBefore(): Internal.ZoneOffset;
        get offsetAfter(): Internal.ZoneOffset;
        get instant(): Internal.Instant;
        get duration(): Internal.Duration;
    }
    interface DoublePredicate {
        or(arg0: Internal.DoublePredicate): Internal.DoublePredicate
        test(arg0: number): boolean
        and(arg0: Internal.DoublePredicate): Internal.DoublePredicate
        negate(): Internal.DoublePredicate
    }
    class Record {
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
    }
    interface Function10 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> {
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, (arg0: T10) => R>
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10): R
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function3<T8, T9, T10, R>>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, (arg0: T9, arg1: T10) => R>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function5<T6, T7, T8, T9, T10, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function4<T7, T8, T9, T10, R>>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function7<T4, T5, T6, T7, T8, T9, T10, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function6<T5, T6, T7, T8, T9, T10, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function8<T3, T4, T5, T6, T7, T8, T9, T10, R>
        curry(): (arg0: T1) => Internal.Function9<T2, T3, T4, T5, T6, T7, T8, T9, T10, R>
    }
    class FluidIngredient implements Internal.Predicate<Internal.FluidStack> {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        static fromTag(arg0: Internal.Tag$Named<Internal.Fluid>, arg1: number): Internal.FluidIngredient
        static read(arg0: Internal.FriendlyByteBuf): Internal.FluidIngredient
        test(arg0: object): boolean
        test(arg0: Internal.FluidStack): boolean
        static isFluidIngredient(arg0: Internal.JsonElement): boolean
        static fromFluid(arg0: Internal.Fluid, arg1: number): Internal.FluidIngredient
        getMatchingFluidStacks(): Internal.List<Internal.FluidStack>
        serialize(): Internal.JsonObject
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
        getRequiredAmount(): number
        write(arg0: Internal.FriendlyByteBuf): void
        static fromFluidStack(arg0: Internal.FluidStack): Internal.FluidIngredient
        static deserialize(arg0: Internal.JsonElement): Internal.FluidIngredient
        matchingFluidStacks : Internal.List<Internal.FluidStack>;
        static readonly EMPTY : Internal.FluidIngredient;
        get requiredAmount(): number;
    }
    interface Char2ByteFunction implements Internal.Function<string, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: string, arg1: number): number
        andThenShort(arg0: Internal.Byte2ShortFunction): Internal.Char2ShortFunction
        composeByte(arg0: Internal.Byte2CharFunction): Internal.Byte2ByteFunction
        andThenInt(arg0: Internal.Byte2IntFunction): Internal.Char2IntFunction
        composeReference<T>(arg0: Internal.Reference2CharFunction<T>): Internal.Reference2ByteFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: string) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: string, arg1: number): number
        put(arg0: string, arg1: number): number
        remove(arg0: string): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Byte2DoubleFunction): Internal.Char2DoubleFunction
        andThenObject<T>(arg0: Internal.Byte2ObjectFunction<T>): Internal.Char2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: string): number
        andThenLong(arg0: Internal.Byte2LongFunction): Internal.Char2LongFunction
        composeLong(arg0: Internal.Long2CharFunction): Internal.Long2ByteFunction
        andThenByte(arg0: Internal.Byte2ByteFunction): Internal.Char2ByteFunction
        andThenFloat(arg0: Internal.Byte2FloatFunction): Internal.Char2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: string): boolean
        composeInt(arg0: Internal.Int2CharFunction): Internal.Int2ByteFunction
        clear(): void
        composeFloat(arg0: Internal.Float2CharFunction): Internal.Float2ByteFunction
        andThenChar(arg0: Internal.Byte2CharFunction): Internal.Char2CharFunction
        composeObject<T>(arg0: Internal.Object2CharFunction<T>): Internal.Object2ByteFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => string): (arg0: T) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2CharFunction): Internal.Short2ByteFunction
        andThenReference<T>(arg0: Internal.Byte2ReferenceFunction<T>): Internal.Char2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2CharFunction): Internal.Char2ByteFunction
        composeDouble(arg0: Internal.Double2CharFunction): Internal.Double2ByteFunction
    }
    interface ContentHandlerFactory {
        createContentHandler(arg0: string): Internal.ContentHandler
    }
    class PropertyChangeEvent extends Internal.EventObject {
        setPropagationId(arg0: object): void
        toString(): string
        getPropagationId(): object
        getOldValue(): object
        getNewValue(): object
        getPropertyName(): string
        set propagationId(arg0: object);
        get propagationId(): object;
        get oldValue(): object;
        get newValue(): object;
        get propertyName(): string;
    }
    interface Tickable {
    }
    interface DoubleSupplier {
        getAsDouble(): number
        get asDouble(): number;
    }
    class URLConnection {
        getLastModified(): number
        setConnectTimeout(arg0: number): void
        setIfModifiedSince(arg0: number): void
        getHeaderFieldLong(arg0: string, arg1: number): number
        getReadTimeout(): number
        getContent(): object
        getContent(arg0: Internal.Class<object>[]): object
        setUseCaches(arg0: boolean): void
        getHeaderFieldInt(arg0: string, arg1: number): number
        getRequestProperty(arg0: string): string
        static guessContentTypeFromStream(arg0: Internal.InputStream): string
        setRequestProperty(arg0: string, arg1: string): void
        static setDefaultRequestProperty(arg0: string, arg1: string): void
        getDoInput(): boolean
        getHeaderFieldDate(arg0: string, arg1: number): number
        static getFileNameMap(): Internal.FileNameMap
        getDate(): number
        getIfModifiedSince(): number
        getHeaderFieldKey(arg0: number): string
        connect(): void
        static setContentHandlerFactory(arg0: Internal.ContentHandlerFactory): void
        getContentEncoding(): string
        getPermission(): Internal.Permission
        static getDefaultAllowUserInteraction(): boolean
        static getDefaultUseCaches(arg0: string): boolean
        getDefaultUseCaches(): boolean
        getUseCaches(): boolean
        getAllowUserInteraction(): boolean
        getConnectTimeout(): number
        getContentLength(): number
        setDoInput(arg0: boolean): void
        getInputStream(): Internal.InputStream
        addRequestProperty(arg0: string, arg1: string): void
        setAllowUserInteraction(arg0: boolean): void
        getRequestProperties(): Map<string, Internal.List<string>>
        setReadTimeout(arg0: number): void
        getURL(): Internal.URL
        getHeaderField(arg0: number): string
        getHeaderField(arg0: string): string
        getHeaderFields(): Map<string, Internal.List<string>>
        getExpiration(): number
        static getDefaultRequestProperty(arg0: string): string
        getContentLengthLong(): number
        static setDefaultAllowUserInteraction(arg0: boolean): void
        static setFileNameMap(arg0: Internal.FileNameMap): void
        getContentType(): string
        getOutputStream(): Internal.OutputStream
        toString(): string
        getDoOutput(): boolean
        setDefaultUseCaches(arg0: boolean): void
        static setDefaultUseCaches(arg0: string, arg1: boolean): void
        setDoOutput(arg0: boolean): void
        static guessContentTypeFromName(arg0: string): string
        get lastModified(): number;
        set connectTimeout(arg0: number);
        set ifModifiedSince(arg0: number);
        get readTimeout(): number;
        get content(): object;
        set useCaches(arg0: boolean);
        get doInput(): boolean;
        get fileNameMap(): Internal.FileNameMap;
        get date(): number;
        get ifModifiedSince(): number;
        set contentHandlerFactory(arg0: Internal.ContentHandlerFactory);
        get contentEncoding(): string;
        get permission(): Internal.Permission;
        get defaultAllowUserInteraction(): boolean;
        get defaultUseCaches(): boolean;
        get useCaches(): boolean;
        get allowUserInteraction(): boolean;
        get connectTimeout(): number;
        get contentLength(): number;
        set doInput(arg0: boolean);
        get inputStream(): Internal.InputStream;
        set allowUserInteraction(arg0: boolean);
        get requestProperties(): Map<string, Internal.List<string>>;
        set readTimeout(arg0: number);
        get uRL(): Internal.URL;
        get headerFields(): Map<string, Internal.List<string>>;
        get expiration(): number;
        get contentLengthLong(): number;
        set defaultAllowUserInteraction(arg0: boolean);
        set fileNameMap(arg0: Internal.FileNameMap);
        get contentType(): string;
        get outputStream(): Internal.OutputStream;
        get doOutput(): boolean;
        set defaultUseCaches(arg0: boolean);
        set doOutput(arg0: boolean);
    }
    class BlockIDPredicate$PropertyObject {
    }
    class Enum$EnumDesc <E> extends Internal.DynamicConstantDesc<E> {
        static of<E>(arg0: Internal.ClassDesc, arg1: string): Internal.Enum$EnumDesc<E>
        toString(): string
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): object
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): E
    }
    class LongBuffer extends Internal.Buffer implements Internal.Comparable<Internal.LongBuffer> {
        hasArray(): boolean
        compact(): Internal.LongBuffer
        clear(): Internal.Buffer
        clear(): Internal.LongBuffer
        duplicate(): Internal.LongBuffer
        duplicate(): Internal.Buffer
        compareTo(arg0: object): number
        compareTo(arg0: Internal.LongBuffer): number
        asReadOnlyBuffer(): Internal.LongBuffer
        put(arg0: number[]): Internal.LongBuffer
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.LongBuffer
        put(arg0: number, arg1: number[]): Internal.LongBuffer
        put(arg0: number[], arg1: number, arg2: number): Internal.LongBuffer
        put(arg0: number, arg1: Internal.LongBuffer, arg2: number, arg3: number): Internal.LongBuffer
        put(arg0: Internal.LongBuffer): Internal.LongBuffer
        put(arg0: number, arg1: number): Internal.LongBuffer
        put(arg0: number): Internal.LongBuffer
        static allocate(arg0: number): Internal.LongBuffer
        rewind(): Internal.Buffer
        rewind(): Internal.LongBuffer
        slice(): Internal.Buffer
        slice(): Internal.LongBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.LongBuffer
        array(): number[]
        array(): object
        hashCode(): number
        mismatch(arg0: Internal.LongBuffer): number
        equals(arg0: object): boolean
        get(): number
        get(arg0: number, arg1: number[]): Internal.LongBuffer
        get(arg0: number): number
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.LongBuffer
        get(arg0: number[], arg1: number, arg2: number): Internal.LongBuffer
        get(arg0: number[]): Internal.LongBuffer
        limit(arg0: number): Internal.LongBuffer
        limit(arg0: number): Internal.Buffer
        reset(): Internal.Buffer
        reset(): Internal.LongBuffer
        arrayOffset(): number
        toString(): string
        position(arg0: number): Internal.LongBuffer
        position(arg0: number): Internal.Buffer
        flip(): Internal.Buffer
        flip(): Internal.LongBuffer
        isDirect(): boolean
        static wrap(arg0: number[]): Internal.LongBuffer
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.LongBuffer
        mark(): Internal.Buffer
        mark(): Internal.LongBuffer
        order(): Internal.ByteOrder
    }
    class VertexFormat$Mode extends Internal.Enum<Internal.VertexFormat$Mode> {
        static valueOf(arg0: string): Internal.VertexFormat$Mode
        static values(): Internal.VertexFormat$Mode[]
        static readonly QUADS : Internal.VertexFormat$Mode;
        static readonly TRIANGLE_FAN : Internal.VertexFormat$Mode;
        static readonly DEBUG_LINES : Internal.VertexFormat$Mode;
        static readonly TRIANGLES : Internal.VertexFormat$Mode;
        static readonly DEBUG_LINE_STRIP : Internal.VertexFormat$Mode;
        static readonly LINE_STRIP : Internal.VertexFormat$Mode;
        static readonly LINES : Internal.VertexFormat$Mode;
        static readonly TRIANGLE_STRIP : Internal.VertexFormat$Mode;
    }
    interface DoubleConsumer {
        andThen(arg0: Internal.DoubleConsumer): Internal.DoubleConsumer
        accept(arg0: number): void
    }
    interface WorldEntityByChunkAccess {
        getEntitiesInChunk(arg0: number, arg1: number): Internal.Collection<Internal.Entity>
    }
    class TypeToken <T> {
        getRawType(): Internal.Class<T>
        getType(): Internal.Type
        hashCode(): number
        equals(arg0: object): boolean
        static get(arg0: Internal.Type): Internal.TypeToken<object>
        static get<T>(arg0: Internal.Class<T>): Internal.TypeToken<T>
        static getArray(arg0: Internal.Type): Internal.TypeToken<object>
        toString(): string
        isAssignableFrom(arg0: Internal.TypeToken<object>): boolean
        isAssignableFrom(arg0: Internal.Type): boolean
        isAssignableFrom(arg0: Internal.Class<object>): boolean
        static getParameterized(arg0: Internal.Type, arg1: Internal.Type[]): Internal.TypeToken<object>
        get rawType(): Internal.Class<T>;
        get type(): Internal.Type;
    }
    interface NBTSerializable {
        toNBT(): net.minecraft.nbt.Tag
    }
    interface ListIterator <E> implements Internal.Iterator<E> {
        next(): E
        add(arg0: E): void
        set(arg0: E): void
        previous(): E
        hasPrevious(): boolean
        hasNext(): boolean
        forEachRemaining(arg0: (arg0: E) => void): void
        nextIndex(): number
        previousIndex(): number
        remove(): void
    }
    interface IntUnaryOperator {
        applyAsInt(arg0: number): number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        static identity(): Internal.IntUnaryOperator
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
    }
    class EntityArrayList extends Internal.ArrayList<Internal.EntityJS> implements Internal.MessageSender {
        filter(filter: (arg0: Internal.EntityJS) => boolean): Internal.EntityArrayList
        sendData(channel: string, data: Internal.CompoundTag): void
        getLevel(): Internal.LevelJS
        getWorld(): Internal.LevelJS
        setStatusMessage(message: Internal.Component): void
        getName(): Internal.Text
        getDisplayName(): Internal.Text
        getFirst(): Internal.EntityJS
        playSound(id: Internal.SoundEvent): void
        playSound(id: Internal.SoundEvent, volume: number, pitch: number): void
        tell(message: Internal.Component): void
        runCommand(command: string): number
        kill(): void
        runCommandSilent(command: string): number
        get level(): Internal.LevelJS;
        get world(): Internal.LevelJS;
        set statusMessage(message: Internal.Component);
        get name(): Internal.Text;
        get displayName(): Internal.Text;
        get first(): Internal.EntityJS;
    }
    class Subject implements Internal.Serializable {
        static getSubject(arg0: Internal.AccessControlContext): Internal.Subject
        static doAs<T>(arg0: Internal.Subject, arg1: Internal.PrivilegedExceptionAction<T>): T
        static doAs<T>(arg0: Internal.Subject, arg1: Internal.PrivilegedAction<T>): T
        getPrivateCredentials(): Internal.Set<object>
        getPrivateCredentials<T>(arg0: Internal.Class<T>): Internal.Set<T>
        isReadOnly(): boolean
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        getPrincipals<T>(arg0: Internal.Class<T>): Internal.Set<T>
        getPrincipals(): Internal.Set<Internal.Principal>
        getPublicCredentials(): Internal.Set<object>
        getPublicCredentials<T>(arg0: Internal.Class<T>): Internal.Set<T>
        setReadOnly(): void
        static doAsPrivileged<T>(arg0: Internal.Subject, arg1: Internal.PrivilegedExceptionAction<T>, arg2: Internal.AccessControlContext): T
        static doAsPrivileged<T>(arg0: Internal.Subject, arg1: Internal.PrivilegedAction<T>, arg2: Internal.AccessControlContext): T
        get privateCredentials(): Internal.Set<object>;
        get principals(): Internal.Set<Internal.Principal>;
        get publicCredentials(): Internal.Set<object>;
    }
    class Excluder implements Internal.TypeAdapterFactory, Internal.Cloneable {
        withExclusionStrategy(arg0: Internal.ExclusionStrategy, arg1: boolean, arg2: boolean): Internal.Excluder
        disableInnerClassSerialization(): Internal.Excluder
        withModifiers(arg0: number[]): Internal.Excluder
        create<T>(arg0: Internal.Gson, arg1: Internal.TypeToken<T>): Internal.TypeAdapter<T>
        excludeClass(arg0: Internal.Class<object>, arg1: boolean): boolean
        withVersion(arg0: number): Internal.Excluder
        excludeField(arg0: Internal.Field, arg1: boolean): boolean
        excludeFieldsWithoutExposeAnnotation(): Internal.Excluder
        static readonly DEFAULT : Internal.Excluder;
    }
    interface NonNullPredicate <T> {
        test(arg0: T): boolean
    }
    interface LongSupplier {
        getAsLong(): number
        get asLong(): number;
    }
    interface ToIntFunction <T> {
        applyAsInt(arg0: T): number
    }
    class OutputStream implements Internal.Closeable, Internal.Flushable {
        flush(): void
        static nullOutputStream(): Internal.OutputStream
        close(): void
        write(arg0: number[]): void
        write(arg0: number[], arg1: number, arg2: number): void
        write(arg0: number): void
    }
    class DataPackEventJS extends Internal.ServerEventJS {
        add(id: ResourceLocation, content: string): void
        addJson(id: ResourceLocation, json: Internal.JsonElement): void
    }
    interface IntIterable implements Internal.Iterable<number> {
        iterator(): Internal.Iterator<any>
        iterator(): Internal.IntIterator
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.IntSpliterator
        forEach(arg0: java_.util.function_.IntConsumer): void
        forEach(arg0: (arg0: number) => void): void
        forEach(arg0: Internal.IntConsumer): void
        intIterator(): Internal.IntIterator
        intSpliterator(): Internal.IntSpliterator
    }
    interface RandomGenerator {
        nextFloat(): number
        nextFloat(arg0: number): number
        nextFloat(arg0: number, arg1: number): number
        isDeprecated(): boolean
        static getDefault(): Internal.RandomGenerator
        nextInt(): number
        nextInt(arg0: number): number
        nextInt(arg0: number, arg1: number): number
        nextLong(arg0: number, arg1: number): number
        nextLong(arg0: number): number
        nextLong(): number
        nextGaussian(arg0: number, arg1: number): number
        nextGaussian(): number
        nextDouble(arg0: number): number
        nextDouble(arg0: number, arg1: number): number
        nextDouble(): number
        nextBytes(arg0: number[]): void
        longs(arg0: number): Internal.LongStream
        longs(arg0: number, arg1: number): Internal.LongStream
        longs(): Internal.LongStream
        longs(arg0: number, arg1: number, arg2: number): Internal.LongStream
        nextExponential(): number
        ints(): Internal.IntStream
        ints(arg0: number): Internal.IntStream
        ints(arg0: number, arg1: number, arg2: number): Internal.IntStream
        ints(arg0: number, arg1: number): Internal.IntStream
        doubles(): Internal.DoubleStream
        doubles(arg0: number): Internal.DoubleStream
        doubles(arg0: number, arg1: number, arg2: number): Internal.DoubleStream
        doubles(arg0: number, arg1: number): Internal.DoubleStream
        static of(arg0: string): Internal.RandomGenerator
        nextBoolean(): boolean
        get default(): Internal.RandomGenerator;
    }
    interface ObjectListIterator <K> implements Internal.ObjectBidirectionalIterator<K>, Internal.ListIterator<K> {
        next(): E
        add(arg0: K): void
        set(arg0: K): void
        previous(): K
        previous(): E
        hasPrevious(): boolean
        hasPrevious(): boolean
        back(arg0: number): number
        hasNext(): boolean
        skip(arg0: number): number
        nextIndex(): number
        forEachRemaining(arg0: (arg0: E) => void): void
        previousIndex(): number
        remove(): void
    }
    class VecBuffer {
        putVec2(arg0: number, arg1: number): Internal.VecBuffer
        putVec2(arg0: number, arg1: number): Internal.VecBuffer
        putVec3(arg0: number, arg1: number, arg2: number): Internal.VecBuffer
        putVec3(arg0: number, arg1: number, arg2: number): Internal.VecBuffer
        putVec4(arg0: number, arg1: number, arg2: number, arg3: number): Internal.VecBuffer
        putInt(arg0: number): Internal.VecBuffer
        putColor(arg0: number, arg1: number, arg2: number, arg3: number): Internal.VecBuffer
        putColor(arg0: number, arg1: number, arg2: number, arg3: number): Internal.VecBuffer
        put(arg0: number): Internal.VecBuffer
        put(arg0: Internal.FloatBuffer): Internal.VecBuffer
        put(arg0: Internal.ByteBuffer): Internal.VecBuffer
        putByteArray(arg0: number[]): Internal.VecBuffer
        unwrap(): Internal.ByteBuffer
        putFloat(arg0: number): Internal.VecBuffer
        static allocate(arg0: number): Internal.VecBuffer
        rewind(): Internal.VecBuffer
        position(arg0: number): Internal.VecBuffer
        position(): number
        putShort(arg0: number): Internal.VecBuffer
        putFloatArray(arg0: number[]): Internal.VecBuffer
    }
    class BaseFunction extends Internal.IdScriptableObject implements dev.latvian.mods.rhino.Function {
        getFunctionName(): string
        call(cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: object[]): object
        getTypeOf(): string
        setImmunePrototypeProperty(value: object): void
        hasInstance(instance: Internal.Scriptable): boolean
        getLength(): number
        execIdCall(f: Internal.IdFunctionObject, cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: object[]): object
        toString(): string
        construct(cx: Internal.Context, scope: Internal.Scriptable, args: object[]): Internal.Scriptable
        getClassName(): string
        getArity(): number
        createObject(cx: Internal.Context, scope: Internal.Scriptable): Internal.Scriptable
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : object;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get functionName(): string;
        get typeOf(): string;
        set immunePrototypeProperty(value: object);
        get length(): number;
        get className(): string;
        get arity(): number;
    }
    interface LongBinaryOperator {
        applyAsLong(arg0: number, arg1: number): number
    }
    class Range6Int extends Internal.Record {
        positiveY(): number
        positiveZ(): number
        hashCode(): number
        equals(o: object): boolean
        negativeX(): number
        toString(): string
        negativeY(): number
        negativeZ(): number
        positiveX(): number
    }
    interface Char2CharFunction implements Internal.Function<string, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: string): string
        getOrDefault(arg0: string, arg1: string): string
        andThenShort(arg0: Internal.Char2ShortFunction): Internal.Char2ShortFunction
        composeByte(arg0: Internal.Byte2CharFunction): Internal.Byte2CharFunction
        andThenInt(arg0: Internal.Char2IntFunction): Internal.Char2IntFunction
        composeReference<T>(arg0: Internal.Reference2CharFunction<T>): Internal.Reference2CharFunction<T>
        andThen<T>(arg0: (arg0: string) => T): (arg0: string) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: string, arg1: string): string
        put(arg0: string, arg1: string): string
        remove(arg0: string): string
        remove(arg0: object): object
        remove(arg0: object): string
        defaultReturnValue(): string
        defaultReturnValue(arg0: string): void
        andThenDouble(arg0: Internal.Char2DoubleFunction): Internal.Char2DoubleFunction
        andThenObject<T>(arg0: Internal.Char2ObjectFunction<T>): Internal.Char2ObjectFunction<T>
        static identity(): Internal.Char2CharFunction
        get(arg0: object): string
        get(arg0: object): object
        get(arg0: string): string
        andThenLong(arg0: Internal.Char2LongFunction): Internal.Char2LongFunction
        composeLong(arg0: Internal.Long2CharFunction): Internal.Long2CharFunction
        andThenByte(arg0: Internal.Char2ByteFunction): Internal.Char2ByteFunction
        andThenFloat(arg0: Internal.Char2FloatFunction): Internal.Char2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: string): boolean
        composeInt(arg0: Internal.Int2CharFunction): Internal.Int2CharFunction
        clear(): void
        composeFloat(arg0: Internal.Float2CharFunction): Internal.Float2CharFunction
        andThenChar(arg0: Internal.Char2CharFunction): Internal.Char2CharFunction
        composeObject<T>(arg0: Internal.Object2CharFunction<T>): Internal.Object2CharFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => string): (arg0: T) => string
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2CharFunction): Internal.Short2CharFunction
        andThenReference<T>(arg0: Internal.Char2ReferenceFunction<T>): Internal.Char2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2CharFunction): Internal.Char2CharFunction
        composeDouble(arg0: Internal.Double2CharFunction): Internal.Double2CharFunction
    }
    interface ItemTooltipEventJS$StaticTooltipHandlerFromJS {
        accept(arg0: Internal.ItemStackJS, arg1: boolean, arg2: Internal.List<object>): void
    }
    interface MethodTypeDesc implements Internal.ConstantDesc, Internal.TypeDescriptor$OfMethod<Internal.ClassDesc, Internal.MethodTypeDesc> {
        parameterType(arg0: number): Internal.TypeDescriptor$OfField<any>
        parameterType(arg0: number): Internal.ClassDesc
        dropParameterTypes(arg0: number, arg1: number): Internal.TypeDescriptor$OfMethod<any, any>
        dropParameterTypes(arg0: number, arg1: number): Internal.MethodTypeDesc
        parameterCount(): number
        changeReturnType(arg0: Internal.ClassDesc): Internal.MethodTypeDesc
        changeReturnType(arg0: Internal.TypeDescriptor$OfField<any>): Internal.TypeDescriptor$OfMethod<any, any>
        descriptorString(): string
        insertParameterTypes(arg0: number, arg1: Internal.ClassDesc[]): Internal.MethodTypeDesc
        insertParameterTypes(arg0: number, arg1: Internal.TypeDescriptor$OfField[]): Internal.TypeDescriptor$OfMethod<any, any>
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): object
        changeParameterType(arg0: number, arg1: Internal.TypeDescriptor$OfField<any>): Internal.TypeDescriptor$OfMethod<any, any>
        changeParameterType(arg0: number, arg1: Internal.ClassDesc): Internal.MethodTypeDesc
        parameterArray(): Internal.ClassDesc[]
        parameterArray(): Internal.TypeDescriptor$OfField[]
        static of(arg0: Internal.ClassDesc, arg1: Internal.ClassDesc[]): Internal.MethodTypeDesc
        equals(arg0: object): boolean
        parameterList(): Internal.List<Internal.ClassDesc>
        static ofDescriptor(arg0: string): Internal.MethodTypeDesc
        displayDescriptor(): string
        returnType(): Internal.ClassDesc
        returnType(): Internal.TypeDescriptor$OfField<any>
    }
    interface Char2FloatFunction implements Internal.Function<string, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: string, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: Internal.Float2ShortFunction): Internal.Char2ShortFunction
        composeByte(arg0: Internal.Byte2CharFunction): Internal.Byte2FloatFunction
        andThenInt(arg0: Internal.Float2IntFunction): Internal.Char2IntFunction
        composeReference<T>(arg0: Internal.Reference2CharFunction<T>): Internal.Reference2FloatFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: string) => T
        put(arg0: object, arg1: object): object
        put(arg0: string, arg1: number): number
        put(arg0: string, arg1: number): number
        remove(arg0: string): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Float2DoubleFunction): Internal.Char2DoubleFunction
        andThenObject<T>(arg0: Internal.Float2ObjectFunction<T>): Internal.Char2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: string): number
        andThenLong(arg0: Internal.Float2LongFunction): Internal.Char2LongFunction
        composeLong(arg0: Internal.Long2CharFunction): Internal.Long2FloatFunction
        andThenByte(arg0: Internal.Float2ByteFunction): Internal.Char2ByteFunction
        andThenFloat(arg0: Internal.Float2FloatFunction): Internal.Char2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: string): boolean
        composeInt(arg0: Internal.Int2CharFunction): Internal.Int2FloatFunction
        clear(): void
        composeFloat(arg0: Internal.Float2CharFunction): Internal.Float2FloatFunction
        andThenChar(arg0: Internal.Float2CharFunction): Internal.Char2CharFunction
        composeObject<T>(arg0: Internal.Object2CharFunction<T>): Internal.Object2FloatFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => string): (arg0: T) => number
        composeShort(arg0: Internal.Short2CharFunction): Internal.Short2FloatFunction
        andThenReference<T>(arg0: Internal.Float2ReferenceFunction<T>): Internal.Char2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2CharFunction): Internal.Char2FloatFunction
        composeDouble(arg0: Internal.Double2CharFunction): Internal.Double2FloatFunction
    }
    interface IVertexConsumer {
        setQuadOrientation(arg0: Internal.Direction): void
        setTexture(arg0: Internal.TextureAtlasSprite): void
        setApplyDiffuseLighting(arg0: boolean): void
        setQuadTint(arg0: number): void
        getVertexFormat(): Internal.VertexFormat
        put(arg0: number, arg1: number[]): void
        set quadOrientation(arg0: Internal.Direction);
        set texture(arg0: Internal.TextureAtlasSprite);
        set applyDiffuseLighting(arg0: boolean);
        set quadTint(arg0: number);
        get vertexFormat(): Internal.VertexFormat;
    }
    interface EntityTypeExtension <T> {
        flywheel$setInstancingController(arg0: Internal.EntityInstancingController<T>): void
        flywheel$getInstancingController(): Internal.EntityInstancingController<T>
    }
    class Throwable implements Internal.Serializable {
        addSuppressed(arg0: Internal.Throwable): void
        setStackTrace(arg0: Internal.StackTraceElement[]): void
        getStackTrace(): Internal.StackTraceElement[]
        printStackTrace(): void
        printStackTrace(arg0: Internal.PrintStream): void
        printStackTrace(arg0: Internal.PrintWriter): void
        getLocalizedMessage(): string
        initCause(arg0: Internal.Throwable): Internal.Throwable
        getMessage(): string
        getSuppressed(): Internal.Throwable[]
        toString(): string
        getCause(): Internal.Throwable
        fillInStackTrace(): Internal.Throwable
        set stackTrace(arg0: Internal.StackTraceElement[]);
        get stackTrace(): Internal.StackTraceElement[];
        get localizedMessage(): string;
        get message(): string;
        get suppressed(): Internal.Throwable[];
        get cause(): Internal.Throwable;
    }
    interface Cloneable {
    }
    interface ObjLongConsumer <T> {
        accept(arg0: T, arg1: number): void
    }
    class IndexedBlockStatePredicate implements Internal.Predicate<Internal.BlockState> {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        test(arg0: T): boolean
        getIndex(): number
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
        static readonly ALL_FLAGS : Internal.IndexedBlockStatePredicate[];
        static readonly FULLY_INITIALIZED : Internal.AtomicBoolean;
        get index(): number;
    }
    interface ObjIntConsumer <T> {
        accept(arg0: T, arg1: number): void
    }
    interface Copyable {
        copy(): Internal.Copyable
    }
    interface LongFunction <R> {
        apply(arg0: number): R
    }
    interface ConfigurableAutoFlush {
        setShouldAutoFlush(arg0: boolean): void
        set shouldAutoFlush(arg0: boolean);
    }
    interface IForgeCommandSourceStack {
        getAdvancement(arg0: ResourceLocation): Internal.Advancement
        getRecipeManager(): Internal.RecipeManager
        getUnsidedLevel(): Internal.Level
        getScoreboard(): Internal.Scoreboard
        get recipeManager(): Internal.RecipeManager;
        get unsidedLevel(): Internal.Level;
        get scoreboard(): Internal.Scoreboard;
    }
    interface AttributeView {
        name(): string
    }
    class LongSummaryStatistics implements Internal.LongConsumer, java_.util.function_.IntConsumer {
        getMin(): number
        getMax(): number
        toString(): string
        getAverage(): number
        getSum(): number
        getCount(): number
        andThen(arg0: Internal.LongConsumer): Internal.LongConsumer
        andThen(arg0: java_.util.function_.IntConsumer): java_.util.function_.IntConsumer
        combine(arg0: Internal.LongSummaryStatistics): void
        accept(arg0: number): void
        accept(arg0: number): void
        get min(): number;
        get max(): number;
        get average(): number;
        get sum(): number;
        get count(): number;
    }
    class Products$P9 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9> {
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>): Internal.App<F, R>
    }
    interface LongStream implements Internal.BaseStream<number, Internal.LongStream> {
        average(): Internal.OptionalDouble
        sequential(): Internal.BaseStream<any, any>
        sequential(): Internal.LongStream
        takeWhile(arg0: Internal.LongPredicate): Internal.LongStream
        static range(arg0: number, arg1: number): Internal.LongStream
        distinct(): Internal.LongStream
        findFirst(): Internal.OptionalLong
        sum(): number
        skip(arg0: number): Internal.LongStream
        allMatch(arg0: Internal.LongPredicate): boolean
        mapToObj<U>(arg0: Internal.LongFunction<U>): Internal.Stream<U>
        static empty(): Internal.LongStream
        mapMulti(arg0: Internal.LongStream$LongMapMultiConsumer): Internal.LongStream
        iterator(): Internal.Iterator<any>
        iterator(): Internal.PrimitiveIterator$OfLong
        asDoubleStream(): Internal.DoubleStream
        min(): Internal.OptionalLong
        parallel(): Internal.LongStream
        parallel(): Internal.BaseStream<any, any>
        noneMatch(arg0: Internal.LongPredicate): boolean
        findAny(): Internal.OptionalLong
        static of(arg0: number): Internal.LongStream
        static of(arg0: number[]): Internal.LongStream
        isParallel(): boolean
        limit(arg0: number): Internal.LongStream
        static builder(): Internal.LongStream$Builder
        toArray(): number[]
        forEachOrdered(arg0: Internal.LongConsumer): void
        close(): void
        static generate(arg0: Internal.LongSupplier): Internal.LongStream
        anyMatch(arg0: Internal.LongPredicate): boolean
        map(arg0: Internal.LongUnaryOperator): Internal.LongStream
        mapToDouble(arg0: Internal.LongToDoubleFunction): Internal.DoubleStream
        static iterate(arg0: number, arg1: Internal.LongPredicate, arg2: Internal.LongUnaryOperator): Internal.LongStream
        static iterate(arg0: number, arg1: Internal.LongUnaryOperator): Internal.LongStream
        unordered(): S
        reduce(arg0: Internal.LongBinaryOperator): Internal.OptionalLong
        reduce(arg0: number, arg1: Internal.LongBinaryOperator): number
        spliterator(): Internal.Spliterator$OfLong
        spliterator(): Internal.Spliterator<any>
        max(): Internal.OptionalLong
        forEach(arg0: Internal.LongConsumer): void
        count(): number
        static concat(arg0: Internal.LongStream, arg1: Internal.LongStream): Internal.LongStream
        dropWhile(arg0: Internal.LongPredicate): Internal.LongStream
        peek(arg0: Internal.LongConsumer): Internal.LongStream
        flatMap(arg0: Internal.LongFunction<Internal.LongStream>): Internal.LongStream
        filter(arg0: Internal.LongPredicate): Internal.LongStream
        onClose(arg0: Internal.Runnable): S
        sorted(): Internal.LongStream
        boxed(): Internal.Stream<number>
        summaryStatistics(): Internal.LongSummaryStatistics
        static rangeClosed(arg0: number, arg1: number): Internal.LongStream
        mapToInt(arg0: Internal.LongToIntFunction): Internal.IntStream
        collect<R>(arg0: () => R, arg1: Internal.ObjLongConsumer<R>, arg2: (arg0: R, arg1: R) => void): R
    }
    class BlockContainerJS implements Internal.SpecialEquality {
        spawnFireworks(fireworks: Internal.FireworksJS): void
        getBiomeId(): string
        getItem(): Internal.ItemStackJS
        getUp(): Internal.BlockContainerJS
        getTags(): Internal.Collection<ResourceLocation>
        getId(): string
        clearCache(): void
        getCanSeeSky(): boolean
        getEast(): Internal.BlockContainerJS
        getNorth(): Internal.BlockContainerJS
        getPos(): BlockPos
        setEntityData(tag: Internal.CompoundTag): void
        getDimension(): string
        getEntityId(): string
        mergeEntityData(tag: Internal.CompoundTag): void
        getInventory(facing: Internal.Direction): Internal.InventoryJS
        getLight(): number
        getWest(): Internal.BlockContainerJS
        getPlayersInRadius(): Internal.EntityArrayList
        getPlayersInRadius(radius: number): Internal.EntityArrayList
        set(id: ResourceLocation, properties: Map<object, object>): void
        set(id: ResourceLocation, properties: Map<object, object>, flags: number): void
        set(id: ResourceLocation): void
        hasTag(tag: ResourceLocation): boolean
        offset(x: number, y: number, z: number): Internal.BlockContainerJS
        offset(f: Internal.Direction): Internal.BlockContainerJS
        offset(f: Internal.Direction, d: number): Internal.BlockContainerJS
        getDown(): Internal.BlockContainerJS
        getProperties(): Map<string, string>
        createExplosion(): Internal.ExplosionJS
        setBlockState(state: Internal.BlockState, flags: number): void
        getEntity(): Internal.BlockEntity
        createEntity(id: ResourceLocation): Internal.EntityJS
        getMaterial(): Internal.MaterialJS
        getSouth(): Internal.BlockContainerJS
        spawnLightning(effectOnly: boolean): void
        spawnLightning(effectOnly: boolean, player: Internal.EntityJS): void
        getLevel(): Internal.LevelJS
        getX(): number
        getY(): number
        getZ(): number
        getEntityData(): Internal.CompoundTag
        equals(obj: object): boolean
        toString(): string
        getBlockState(): Internal.BlockState
        specialEquals(o: object, shallow: boolean): boolean
        readonly minecraftLevel : Internal.Level;
        get biomeId(): string;
        get item(): Internal.ItemStackJS;
        get up(): Internal.BlockContainerJS;
        get tags(): Internal.Collection<ResourceLocation>;
        get id(): string;
        get canSeeSky(): boolean;
        get east(): Internal.BlockContainerJS;
        get north(): Internal.BlockContainerJS;
        get pos(): BlockPos;
        set entityData(tag: Internal.CompoundTag);
        get dimension(): string;
        get entityId(): string;
        get light(): number;
        get west(): Internal.BlockContainerJS;
        get playersInRadius(): Internal.EntityArrayList;
        get down(): Internal.BlockContainerJS;
        get properties(): Map<string, string>;
        get entity(): Internal.BlockEntity;
        get material(): Internal.MaterialJS;
        get south(): Internal.BlockContainerJS;
        get level(): Internal.LevelJS;
        get x(): number;
        get y(): number;
        get z(): number;
        get entityData(): Internal.CompoundTag;
        get blockState(): Internal.BlockState;
    }
    interface TypeWrapperFactory <T> {
        wrap(arg0: object): T
    }
    interface IForgeBakedModel {
        doesHandlePerspectives(): boolean
        getModelData(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.BlockState, arg3: Internal.IModelData): Internal.IModelData
        isLayered(): boolean
        handlePerspective(arg0: Internal.ItemTransforms$TransformType, arg1: Internal.PoseStack): Internal.BakedModel
        getQuads(arg0: Internal.BlockState, arg1: Internal.Direction, arg2: Internal.Random, arg3: Internal.IModelData): Internal.List<Internal.BakedQuad>
        useAmbientOcclusion(arg0: Internal.BlockState): boolean
        getLayerModels(arg0: Internal.ItemStack, arg1: boolean): Internal.List<com.mojang.datafixers.util.Pair<Internal.BakedModel, Internal.RenderType>>
        getParticleIcon(arg0: Internal.IModelData): Internal.TextureAtlasSprite
    }
    class ImmutableCollection <E> extends Internal.AbstractCollection<E> implements Internal.Serializable {
        add(arg0: E): boolean
        removeAll(arg0: Internal.Collection<object>): boolean
        contains(arg0: object): boolean
        iterator(): Internal.UnmodifiableIterator<E>
        iterator(): Internal.Iterator<any>
        addAll(arg0: Internal.Collection<E>): boolean
        spliterator(): Internal.Spliterator<E>
        toArray(): object[]
        toArray<T>(arg0: T[]): T[]
        clear(): void
        asList(): Internal.ImmutableList<E>
        remove(arg0: object): boolean
        retainAll(arg0: Internal.Collection<object>): boolean
        removeIf(arg0: (arg0: E) => boolean): boolean
    }
    interface ServerWorldAccessor {
        getEntityManager(): Internal.PersistentEntitySectionManager<Internal.Entity>
        get entityManager(): Internal.PersistentEntitySectionManager<Internal.Entity>;
    }
    class Pair$Mu <S> implements Internal.K1 {
    }
    interface AttributedCharacterIterator implements Internal.CharacterIterator {
        next(): string
        getAttributes(): Map<Internal.AttributedCharacterIterator$Attribute, object>
        getIndex(): number
        previous(): string
        last(): string
        getRunLimit(arg0: Internal.Set<Internal.AttributedCharacterIterator$Attribute>): number
        getRunLimit(arg0: Internal.AttributedCharacterIterator$Attribute): number
        getRunLimit(): number
        getBeginIndex(): number
        current(): string
        getAttribute(arg0: Internal.AttributedCharacterIterator$Attribute): object
        getEndIndex(): number
        setIndex(arg0: number): string
        clone(): object
        getRunStart(): number
        getRunStart(arg0: Internal.Set<Internal.AttributedCharacterIterator$Attribute>): number
        getRunStart(arg0: Internal.AttributedCharacterIterator$Attribute): number
        first(): string
        getAllAttributeKeys(): Internal.Set<Internal.AttributedCharacterIterator$Attribute>
        static readonly DONE : "￿";
        get attributes(): Map<Internal.AttributedCharacterIterator$Attribute, object>;
        get index(): number;
        get runLimit(): number;
        get beginIndex(): number;
        get endIndex(): number;
        set index(arg0: number);
        get runStart(): number;
        get allAttributeKeys(): Internal.Set<Internal.AttributedCharacterIterator$Attribute>;
    }
    class Matrix3f implements Internal.MatrixWrite, Internal.Matrix3fExtended {
        multiplyBackward(arg0: Internal.Matrix3f): void
        getA20(): number
        rotate(quaternion: Internal.Quaternion): void
        getA21(): number
        getA10(): number
        getA22(): number
        getA00(): number
        getA11(): number
        getA12(): number
        getA01(): number
        getA02(): number
        flywheel$write(arg0: Internal.VecBuffer): void
        hashCode(): number
        flywheel$writeUnsafe(arg0: number): void
        equals(arg0: object): boolean
        transformVecZ(x: number, y: number, z: number): number
        transformVecZ(dir: Internal.Vector3f): number
        transformVecY(x: number, y: number, z: number): number
        transformVecY(dir: Internal.Vector3f): number
        toString(): string
        transformVecX(x: number, y: number, z: number): number
        transformVecX(dir: Internal.Vector3f): number
        computeNormal(dir: Internal.Direction): number
        get a20(): number;
        get a21(): number;
        get a10(): number;
        get a22(): number;
        get a00(): number;
        get a11(): number;
        get a12(): number;
        get a01(): number;
        get a02(): number;
    }
    class PartialModel {
        getLocation(): ResourceLocation
        static onModelRegistry(arg0: Internal.ModelRegistryEvent): void
        get(): Internal.BakedModel
        static onModelBake(arg0: Internal.ModelBakeEvent): void
        get location(): ResourceLocation;
    }
    interface BlockGetter implements Internal.LevelHeightAccessor {
    }
    interface IntSpliterator implements Internal.Spliterator$OfInt {
        trySplit(): Internal.Spliterator<any>
        trySplit(): Internal.Spliterator$OfInt
        trySplit(): Internal.IntSpliterator
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>
        characteristics(): number
        tryAdvance(arg0: (arg0: number) => void): boolean
        tryAdvance(arg0: Internal.IntConsumer): boolean
        tryAdvance(arg0: java_.util.function_.IntConsumer): boolean
        tryAdvance(arg0: object): boolean
        getComparator(): Internal.Comparator<any>
        getComparator(): Internal.IntComparator
        getExactSizeIfKnown(): number
        estimateSize(): number
        skip(arg0: number): number
        hasCharacteristics(arg0: number): boolean
        forEachRemaining(arg0: (arg0: number) => void): void
        forEachRemaining(arg0: Internal.IntConsumer): void
        forEachRemaining(arg0: object): void
        forEachRemaining(arg0: java_.util.function_.IntConsumer): void
        static readonly NONNULL : 256;
        static readonly SUBSIZED : 16384;
        static readonly ORDERED : 16;
        static readonly DISTINCT : 1;
        static readonly SIZED : 64;
        static readonly IMMUTABLE : 1024;
        static readonly CONCURRENT : 4096;
        static readonly SORTED : 4;
        get comparator(): Internal.Comparator<any>;
        get comparator(): Internal.IntComparator;
        get exactSizeIfKnown(): number;
    }
    interface Short2DoubleFunction implements Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: Internal.Double2ShortFunction): Internal.Short2ShortFunction
        composeByte(arg0: Internal.Byte2ShortFunction): Internal.Byte2DoubleFunction
        andThenInt(arg0: Internal.Double2IntFunction): Internal.Short2IntFunction
        composeReference<T>(arg0: Internal.Reference2ShortFunction<T>): Internal.Reference2DoubleFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Double2DoubleFunction): Internal.Short2DoubleFunction
        andThenObject<T>(arg0: Internal.Double2ObjectFunction<T>): Internal.Short2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Double2LongFunction): Internal.Short2LongFunction
        composeLong(arg0: Internal.Long2ShortFunction): Internal.Long2DoubleFunction
        andThenByte(arg0: Internal.Double2ByteFunction): Internal.Short2ByteFunction
        andThenFloat(arg0: Internal.Double2FloatFunction): Internal.Short2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ShortFunction): Internal.Int2DoubleFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ShortFunction): Internal.Float2DoubleFunction
        andThenChar(arg0: Internal.Double2CharFunction): Internal.Short2CharFunction
        composeObject<T>(arg0: Internal.Object2ShortFunction<T>): Internal.Object2DoubleFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2ShortFunction): Internal.Short2DoubleFunction
        andThenReference<T>(arg0: Internal.Double2ReferenceFunction<T>): Internal.Short2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ShortFunction): Internal.Char2DoubleFunction
        composeDouble(arg0: Internal.Double2ShortFunction): Internal.Double2DoubleFunction
    }
    class BlockBehaviour extends Internal.ForgeRegistryEntry<Internal.Block> implements Internal.BlockKJS {
        getBlockStatesKJS(): Internal.List<Internal.BlockState>
        setSoundTypeKJS(arg0: Internal.SoundType): void
        getBlockBuilderKJS(): Internal.BlockBuilder
        setExplosionResistanceKJS(arg0: number): void
        setSpeedFactorKJS(arg0: number): void
        setJumpFactorKJS(arg0: number): void
        setBlockBuilderKJS(b: Internal.BlockBuilder): void
        setFrictionKJS(arg0: number): void
        setIsRandomlyTickingKJS(arg0: boolean): void
        setHasCollisionKJS(arg0: boolean): void
        setMaterialKJS(arg0: net.minecraft.world.level.material.Material): void
        readonly delegate : () => V;
        get blockStatesKJS(): Internal.List<Internal.BlockState>;
        set soundTypeKJS(arg0: Internal.SoundType);
        get blockBuilderKJS(): Internal.BlockBuilder;
        set explosionResistanceKJS(arg0: number);
        set speedFactorKJS(arg0: number);
        set jumpFactorKJS(arg0: number);
        set blockBuilderKJS(b: Internal.BlockBuilder);
        set frictionKJS(arg0: number);
        set isRandomlyTickingKJS(arg0: boolean);
        set hasCollisionKJS(arg0: boolean);
        set materialKJS(arg0: net.minecraft.world.level.material.Material);
    }
    interface URLStreamHandlerFactory {
        createURLStreamHandler(arg0: string): Internal.URLStreamHandler
    }
    interface RenderTypeAccess {
        getName(): string
        get name(): string;
    }
    class FluidState extends Internal.StateHolder<Internal.Fluid, Internal.FluidState> implements Internal.IForgeFluidState {
        getExplosionResistance(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): number
        isEntityInside(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity, arg3: number, arg4: Internal.SetTag<Internal.Fluid>, arg5: boolean): boolean
    }
    interface Function3 <T1, T2, T3, R> {
        apply(arg0: T1, arg1: T2, arg2: T3): R
        curry2(): (arg0: T1, arg1: T2) => (arg0: T3) => R
        curry(): (arg0: T1) => (arg0: T2, arg1: T3) => R
    }
    class LevelChunk extends Internal.ChunkAccess implements Internal.ICapabilityProviderImpl<Internal.LevelChunk>, Internal.LevelHeightAccessor, Internal.ExtendedChunk {
        getWorldForge(): Internal.Level
        getWorldForge(): Internal.LevelAccessor
        handler$bbb000$onTransitionToFull(arg0: Internal.ServerLevel, arg1: Internal.ProtoChunk, arg2: Internal.LevelChunk$PostLoadProcessor, arg3: Internal.CallbackInfo): void
        invalidateCaps(): void
        getCapability<T>(arg0: Internal.Capability<T>, arg1: Internal.Direction): Internal.LazyOptional<T>
        getCapability<T>(arg0: Internal.Capability<T>): Internal.LazyOptional<T>
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.LevelChunk>): boolean
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        writeCapsToNBT(): Internal.CompoundTag
        handler$bbb000$onConstruct(arg0: Internal.Level, arg1: Internal.ChunkPos, arg2: Internal.UpgradeData, arg3: Internal.LevelChunkTicks<any>, arg4: Internal.LevelChunkTicks<any>, arg5: number, arg6: Internal.LevelChunkSection[], arg7: Internal.LevelChunk$PostLoadProcessor, arg8: Internal.BlendingData, arg9: Internal.CallbackInfo): void
        readCapsFromNBT(arg0: Internal.CompoundTag): void
        reviveCaps(): void
        get worldForge(): Internal.Level;
        get worldForge(): Internal.LevelAccessor;
    }
    class IngredientActionFilter {
        checkFilter(index: number, stack: Internal.ItemStack): boolean
        static filterOf(o: object): Internal.IngredientActionFilter
        copyFrom(filter: Internal.IngredientActionFilter): void
        filterIndex : number;
        filterIngredient : Internal.IngredientJS;
    }
    interface BlockStateLightInfo {
        getLightSubtracted(): number
        getExtrudedFaces(): Internal.VoxelShape[]
        get lightSubtracted(): number;
        get extrudedFaces(): Internal.VoxelShape[];
    }
    class LevelJS implements Internal.WithAttachedData {
        getPlayer(entity: Internal.Entity): Internal.PlayerJS<any>
        getEntitiesWithin(aabb: Internal.AABB): Internal.EntityArrayList
        getPlayerData(arg0: Internal.Player): Internal.PlayerDataJS<any, any>
        spawnFireworks(x: number, y: number, z: number, f: Internal.FireworksJS): void
        getTime(): number
        getSide(): Internal.ScriptType
        getGameRules(): Internal.GameRulesJS
        setRainStrength(strength: number): void
        getDimension(): string
        isDaytime(): boolean
        createEntityList(entities: Internal.Collection<Internal.Entity>): Internal.EntityArrayList
        getPlayers(): Internal.EntityArrayList
        getData(): Internal.AttachedData
        getMinecraftLevel(): Internal.Level
        getServer(): Internal.ServerJS
        getLivingEntity(entity: Internal.Entity): Internal.LivingEntityJS
        getBlock(x: number, y: number, z: number): Internal.BlockContainerJS
        getBlock(pos: BlockPos): Internal.BlockContainerJS
        getBlock(blockEntity: Internal.BlockEntity): Internal.BlockContainerJS
        isOverworld(): boolean
        createExplosion(x: number, y: number, z: number): Internal.ExplosionJS
        getEntity(e: Internal.Entity): Internal.EntityJS
        createEntity(id: ResourceLocation): Internal.EntityJS
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean): void
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean, player: Internal.EntityJS): void
        getLocalTime(): number
        isThundering(): boolean
        getEntities(): Internal.EntityArrayList
        isRaining(): boolean
        readonly minecraftLevel : Internal.Level;
        get time(): number;
        get side(): Internal.ScriptType;
        get gameRules(): Internal.GameRulesJS;
        set rainStrength(strength: number);
        get dimension(): string;
        get players(): Internal.EntityArrayList;
        get data(): Internal.AttachedData;
        get server(): Internal.ServerJS;
        get localTime(): number;
        get entities(): Internal.EntityArrayList;
    }
    class AbstractContainerScreen <T> extends Internal.Screen implements Internal.MenuAccess<T>, Internal.AbstractContainerScreenAccessor {
        setSkipNextRelease(arg0: boolean): void
        getSlotUnderMouse(): Internal.Slot
        setIsQuickCrafting(arg0: boolean): void
        getQuickCraftingButton(): number
        getYSize(): number
        invokeSlotClicked(arg0: Internal.Slot, arg1: number, arg2: number, arg3: Internal.ClickType): void
        getIsQuickCrafting(): boolean
        getSlotColor(arg0: number): number
        getXSize(): number
        getGuiTop(): number
        getGuiLeft(): number
        invokeFindSlot(arg0: number, arg1: number): Internal.Slot
        static renderSlotHighlight(arg0: Internal.PoseStack, arg1: number, arg2: number, arg3: number, arg4: number): void
        set skipNextRelease(arg0: boolean);
        get slotUnderMouse(): Internal.Slot;
        set isQuickCrafting(arg0: boolean);
        get quickCraftingButton(): number;
        get ySize(): number;
        get isQuickCrafting(): boolean;
        get xSize(): number;
        get guiTop(): number;
        get guiLeft(): number;
    }
    class OffsetDateTime implements Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.OffsetDateTime>, Internal.Serializable {
        plusHours(arg0: number): Internal.OffsetDateTime
        isEqual(arg0: Internal.OffsetDateTime): boolean
        toLocalTime(): Internal.LocalTime
        compareTo(arg0: Internal.OffsetDateTime): number
        compareTo(arg0: object): number
        withOffsetSameLocal(arg0: Internal.ZoneOffset): Internal.OffsetDateTime
        getDayOfWeek(): Internal.DayOfWeek
        plusSeconds(arg0: number): Internal.OffsetDateTime
        getMinute(): number
        static from(arg0: Internal.TemporalAccessor): Internal.OffsetDateTime
        getMonth(): Internal.Month
        plusNanos(arg0: number): Internal.OffsetDateTime
        atZoneSameInstant(arg0: Internal.ZoneId): Internal.ZonedDateTime
        withHour(arg0: number): Internal.OffsetDateTime
        plusMonths(arg0: number): Internal.OffsetDateTime
        plusYears(arg0: number): Internal.OffsetDateTime
        truncatedTo(arg0: Internal.TemporalUnit): Internal.OffsetDateTime
        query<R>(arg0: Internal.TemporalQuery<R>): R
        minusNanos(arg0: number): Internal.OffsetDateTime
        getNano(): number
        format(arg0: Internal.DateTimeFormatter): string
        isSupported(arg0: Internal.TemporalUnit): boolean
        isSupported(arg0: Internal.TemporalField): boolean
        plus(arg0: Internal.TemporalAmount): Internal.OffsetDateTime
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.OffsetDateTime
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        getYear(): number
        toEpochSecond(): number
        toLocalDateTime(): Internal.LocalDateTime
        withDayOfMonth(arg0: number): Internal.OffsetDateTime
        withMonth(arg0: number): Internal.OffsetDateTime
        isAfter(arg0: Internal.OffsetDateTime): boolean
        static ofInstant(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.OffsetDateTime
        minus(arg0: Internal.TemporalAmount): Internal.OffsetDateTime
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.OffsetDateTime
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        toOffsetTime(): Internal.OffsetTime
        minusHours(arg0: number): Internal.OffsetDateTime
        getOffset(): Internal.ZoneOffset
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        withYear(arg0: number): Internal.OffsetDateTime
        plusMinutes(arg0: number): Internal.OffsetDateTime
        minusMinutes(arg0: number): Internal.OffsetDateTime
        plusDays(arg0: number): Internal.OffsetDateTime
        atZoneSimilarLocal(arg0: Internal.ZoneId): Internal.ZonedDateTime
        hashCode(): number
        static now(arg0: Internal.Clock): Internal.OffsetDateTime
        static now(arg0: Internal.ZoneId): Internal.OffsetDateTime
        static now(): Internal.OffsetDateTime
        static of(arg0: Internal.LocalDate, arg1: Internal.LocalTime, arg2: Internal.ZoneOffset): Internal.OffsetDateTime
        static of(arg0: Internal.LocalDateTime, arg1: Internal.ZoneOffset): Internal.OffsetDateTime
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneOffset): Internal.OffsetDateTime
        get(arg0: Internal.TemporalField): number
        getDayOfYear(): number
        plusWeeks(arg0: number): Internal.OffsetDateTime
        getHour(): number
        withMinute(arg0: number): Internal.OffsetDateTime
        getMonthValue(): number
        toZonedDateTime(): Internal.ZonedDateTime
        minusYears(arg0: number): Internal.OffsetDateTime
        minusWeeks(arg0: number): Internal.OffsetDateTime
        withDayOfYear(arg0: number): Internal.OffsetDateTime
        static parse(arg0: Internal.CharSequence, arg1: Internal.DateTimeFormatter): Internal.OffsetDateTime
        static parse(arg0: Internal.CharSequence): Internal.OffsetDateTime
        toInstant(): Internal.Instant
        isBefore(arg0: Internal.OffsetDateTime): boolean
        minusDays(arg0: number): Internal.OffsetDateTime
        withNano(arg0: number): Internal.OffsetDateTime
        getLong(arg0: Internal.TemporalField): number
        minusMonths(arg0: number): Internal.OffsetDateTime
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.OffsetDateTime
        with(arg0: Internal.TemporalField, arg1: number): Internal.OffsetDateTime
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        toLocalDate(): Internal.LocalDate
        withOffsetSameInstant(arg0: Internal.ZoneOffset): Internal.OffsetDateTime
        equals(arg0: object): boolean
        getSecond(): number
        static timeLineOrder(): Internal.Comparator<Internal.OffsetDateTime>
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        toString(): string
        getDayOfMonth(): number
        minusSeconds(arg0: number): Internal.OffsetDateTime
        withSecond(arg0: number): Internal.OffsetDateTime
        static readonly MIN : Internal.OffsetDateTime;
        static readonly MAX : Internal.OffsetDateTime;
        get dayOfWeek(): Internal.DayOfWeek;
        get minute(): number;
        get month(): Internal.Month;
        get nano(): number;
        get year(): number;
        get offset(): Internal.ZoneOffset;
        get dayOfYear(): number;
        get hour(): number;
        get monthValue(): number;
        get second(): number;
        get dayOfMonth(): number;
    }
    class JsonObject extends Internal.JsonElement {
        add(arg0: string, arg1: Internal.JsonElement): void
        getAsJsonObject(arg0: string): Internal.JsonObject
        entrySet(): Internal.Set<Internal.Map$Entry<string, Internal.JsonElement>>
        addProperty(arg0: string, arg1: string): void
        addProperty(arg0: string, arg1: boolean): void
        addProperty(arg0: string, arg1: string): void
        addProperty(arg0: string, arg1: Internal.Number): void
        remove(arg0: string): Internal.JsonElement
        deepCopy(): Internal.JsonElement
        deepCopy(): Internal.JsonObject
        getAsJsonArray(arg0: string): Internal.JsonArray
        size(): number
        getAsJsonPrimitive(arg0: string): Internal.JsonPrimitive
        hashCode(): number
        equals(arg0: object): boolean
        get(arg0: string): Internal.JsonElement
        has(arg0: string): boolean
        keySet(): Internal.Set<string>
    }
    interface Frustum {
        isBoxVisible(minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number): boolean
        testBox(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): Internal.Frustum$Visibility
    }
    interface Executor {
        execute(arg0: Internal.Runnable): void
    }
    class Charset implements Internal.Comparable<Internal.Charset> {
        encode(arg0: string): Internal.ByteBuffer
        encode(arg0: Internal.CharBuffer): Internal.ByteBuffer
        aliases(): Internal.Set<string>
        static forName(arg0: string): Internal.Charset
        displayName(): string
        displayName(arg0: Internal.Locale): string
        newDecoder(): Internal.CharsetDecoder
        static defaultCharset(): Internal.Charset
        static isSupported(arg0: string): boolean
        compareTo(arg0: object): number
        compareTo(arg0: Internal.Charset): number
        decode(arg0: Internal.ByteBuffer): Internal.CharBuffer
        contains(arg0: Internal.Charset): boolean
        hashCode(): number
        canEncode(): boolean
        equals(arg0: object): boolean
        newEncoder(): Internal.CharsetEncoder
        name(): string
        isRegistered(): boolean
        toString(): string
        static availableCharsets(): Internal.SortedMap<string, Internal.Charset>
    }
    class Random implements Internal.RandomGenerator, Internal.Serializable {
        nextFloat(): number
        nextFloat(arg0: number): number
        nextFloat(arg0: number, arg1: number): number
        longs(arg0: number, arg1: number, arg2: number): Internal.LongStream
        longs(arg0: number): Internal.LongStream
        longs(): Internal.LongStream
        longs(arg0: number, arg1: number): Internal.LongStream
        isDeprecated(): boolean
        nextExponential(): number
        ints(arg0: number): Internal.IntStream
        ints(): Internal.IntStream
        ints(arg0: number, arg1: number): Internal.IntStream
        ints(arg0: number, arg1: number, arg2: number): Internal.IntStream
        doubles(arg0: number): Internal.DoubleStream
        doubles(arg0: number, arg1: number, arg2: number): Internal.DoubleStream
        doubles(): Internal.DoubleStream
        doubles(arg0: number, arg1: number): Internal.DoubleStream
        nextBoolean(): boolean
        nextInt(): number
        nextInt(arg0: number): number
        nextInt(arg0: number, arg1: number): number
        setSeed(arg0: number): void
        nextLong(): number
        nextLong(arg0: number, arg1: number): number
        nextLong(arg0: number): number
        nextGaussian(): number
        nextGaussian(arg0: number, arg1: number): number
        nextDouble(): number
        nextDouble(arg0: number): number
        nextDouble(arg0: number, arg1: number): number
        nextBytes(arg0: number[]): void
        set seed(arg0: number);
    }
    interface ProgressivePromise <V> implements Internal.Promise<V>, Internal.ProgressiveFuture<V> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.ProgressivePromise<V>
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.Promise<V>
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.ProgressiveFuture<V>
        getNow(): V
        setProgress(arg0: number, arg1: number): Internal.ProgressivePromise<V>
        cause(): Internal.Throwable
        awaitUninterruptibly(): Internal.ProgressivePromise<V>
        awaitUninterruptibly(): Internal.Promise<V>
        awaitUninterruptibly(): io.netty.util.concurrent.Future<V>
        awaitUninterruptibly(): Internal.ProgressiveFuture<V>
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.ProgressivePromise<V>
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.Promise<V>
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.ProgressiveFuture<V>
        tryFailure(arg0: Internal.Throwable): boolean
        isDone(): boolean
        sync(): Internal.ProgressivePromise<V>
        sync(): Internal.Promise<V>
        sync(): io.netty.util.concurrent.Future<V>
        sync(): Internal.ProgressiveFuture<V>
        setSuccess(arg0: V): Internal.ProgressivePromise<V>
        setSuccess(arg0: V): Internal.Promise<V>
        setFailure(arg0: Internal.Throwable): Internal.ProgressivePromise<V>
        setFailure(arg0: Internal.Throwable): Internal.Promise<V>
        trySuccess(arg0: V): boolean
        tryProgress(arg0: number, arg1: number): boolean
        syncUninterruptibly(): Internal.ProgressivePromise<V>
        syncUninterruptibly(): Internal.Promise<V>
        syncUninterruptibly(): io.netty.util.concurrent.Future<V>
        syncUninterruptibly(): Internal.ProgressiveFuture<V>
        get(arg0: number, arg1: Internal.TimeUnit): V
        get(): V
        isCancellable(): boolean
        await(): Internal.ProgressivePromise<V>
        await(): Internal.Promise<V>
        await(): io.netty.util.concurrent.Future<V>
        await(): Internal.ProgressiveFuture<V>
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.ProgressivePromise<V>
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.Promise<V>
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.ProgressiveFuture<V>
        isSuccess(): boolean
        setUncancellable(): boolean
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.ProgressivePromise<V>
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.Promise<V>
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.ProgressiveFuture<V>
        get now(): V;
        set success(arg0: V);
        set success(arg0: V);
        set failure(arg0: Internal.Throwable);
        set failure(arg0: Internal.Throwable);
    }
    interface WatchEvent$Kind <T> {
        name(): string
        type(): Internal.Class<T>
    }
    class AlloyRecipeJS extends Internal.IERecipeJS {
        serialize(): void
        create(args: Internal.ListJS): void
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<object>;
        readonly inputFluids : Internal.List<Internal.FluidTagInput>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        serializeInputs : boolean;
    }
    class FoodProperties {
    }
    interface TypeVariable <D> implements Internal.Type, Internal.AnnotatedElement {
        getAnnotatedBounds(): Internal.AnnotatedType[]
        getName(): string
        getAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getDeclaredAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getAnnotation<T>(arg0: Internal.Class<T>): T
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        getDeclaredAnnotation<T>(arg0: Internal.Class<T>): T
        getTypeName(): string
        getAnnotations(): Internal.Annotation[]
        getBounds(): Internal.Type[]
        getDeclaredAnnotations(): Internal.Annotation[]
        getGenericDeclaration(): D
        get annotatedBounds(): Internal.AnnotatedType[];
        get name(): string;
        get typeName(): string;
        get annotations(): Internal.Annotation[];
        get bounds(): Internal.Type[];
        get declaredAnnotations(): Internal.Annotation[];
        get genericDeclaration(): D;
    }
    class ModuleDescriptor$Version implements Internal.Comparable<Internal.ModuleDescriptor$Version> {
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        static parse(arg0: string): Internal.ModuleDescriptor$Version
        compareTo(arg0: Internal.ModuleDescriptor$Version): number
        compareTo(arg0: object): number
    }
    class LongSerializationPolicy extends Internal.Enum<Internal.LongSerializationPolicy> {
        serialize(arg0: number): Internal.JsonElement
        static valueOf(arg0: string): Internal.LongSerializationPolicy
        static values(): Internal.LongSerializationPolicy[]
        static readonly STRING : Internal.LongSerializationPolicy;
        static readonly DEFAULT : Internal.LongSerializationPolicy;
    }
    class JsonArray extends Internal.JsonElement implements Internal.Iterable<Internal.JsonElement> {
        getAsFloat(): number
        getAsByte(): number
        getAsBigDecimal(): Internal.BigDecimal
        getAsNumber(): Internal.Number
        getAsCharacter(): string
        getAsString(): string
        getAsInt(): number
        remove(arg0: number): Internal.JsonElement
        remove(arg0: Internal.JsonElement): boolean
        getAsLong(): number
        iterator(): Internal.Iterator<Internal.JsonElement>
        hashCode(): number
        get(arg0: number): Internal.JsonElement
        getAsBigInteger(): Internal.BigInteger
        add(arg0: string): void
        add(arg0: Internal.Number): void
        add(arg0: Internal.JsonElement): void
        add(arg0: string): void
        add(arg0: boolean): void
        set(arg0: number, arg1: Internal.JsonElement): Internal.JsonElement
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
        isEmpty(): boolean
        getAsDouble(): number
        deepCopy(): Internal.JsonElement
        deepCopy(): Internal.JsonArray
        contains(arg0: Internal.JsonElement): boolean
        size(): number
        addAll(arg0: Internal.JsonArray): void
        getAsBoolean(): boolean
        equals(arg0: object): boolean
        getAsShort(): number
        get asFloat(): number;
        get asByte(): number;
        get asBigDecimal(): Internal.BigDecimal;
        get asNumber(): Internal.Number;
        get asCharacter(): string;
        get asString(): string;
        get asInt(): number;
        get asLong(): number;
        get asBigInteger(): Internal.BigInteger;
        get asDouble(): number;
        get asBoolean(): boolean;
        get asShort(): number;
    }
    interface GenericDeclaration implements Internal.AnnotatedElement {
        getAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getDeclaredAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getAnnotation<T>(arg0: Internal.Class<T>): T
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        getDeclaredAnnotation<T>(arg0: Internal.Class<T>): T
        getTypeParameters(): Internal.TypeVariable<object>[]
        getAnnotations(): Internal.Annotation[]
        getDeclaredAnnotations(): Internal.Annotation[]
        get typeParameters(): Internal.TypeVariable<object>[];
        get annotations(): Internal.Annotation[];
        get declaredAnnotations(): Internal.Annotation[];
    }
    interface Function13 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, (arg0: T13) => R>
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function4<T10, T11, T12, T13, R>>
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13): R
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function6<T8, T9, T10, T11, T12, T13, R>>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function5<T9, T10, T11, T12, T13, R>>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function8<T6, T7, T8, T9, T10, T11, T12, T13, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function7<T7, T8, T9, T10, T11, T12, T13, R>>
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function3<T11, T12, T13, R>>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function10<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, (arg0: T12, arg1: T13) => R>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function9<T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function11<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>
        curry(): (arg0: T1) => Internal.Function12<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>
    }
    class ChatFormatting extends Internal.Enum<Internal.ChatFormatting> implements Internal.Color {
        getRgbKJS(): number
        static valueOf(arg0: string): Internal.ChatFormatting
        static values(): Internal.ChatFormatting[]
        createTextColorKJS(): Internal.TextColor
        getHexKJS(): string
        getArgbKJS(): number
        toString(): string
        getFireworkColorKJS(): number
        getSerializeKJS(): string
        specialEquals(o: object, shallow: boolean): boolean
        static readonly ITALIC : Internal.ChatFormatting;
        static readonly GOLD : Internal.ChatFormatting;
        static readonly GRAY : Internal.ChatFormatting;
        static readonly AQUA : Internal.ChatFormatting;
        static readonly WHITE : Internal.ChatFormatting;
        static readonly BLUE : Internal.ChatFormatting;
        static readonly OBFUSCATED : Internal.ChatFormatting;
        static readonly DARK_AQUA : Internal.ChatFormatting;
        static readonly RESET : Internal.ChatFormatting;
        static readonly DARK_BLUE : Internal.ChatFormatting;
        static readonly GREEN : Internal.ChatFormatting;
        static readonly UNDERLINE : Internal.ChatFormatting;
        static readonly RED : Internal.ChatFormatting;
        static readonly DARK_PURPLE : Internal.ChatFormatting;
        static readonly STRIKETHROUGH : Internal.ChatFormatting;
        static readonly DARK_RED : Internal.ChatFormatting;
        static readonly LIGHT_PURPLE : Internal.ChatFormatting;
        static readonly BLACK : Internal.ChatFormatting;
        static readonly BOLD : Internal.ChatFormatting;
        static readonly DARK_GREEN : Internal.ChatFormatting;
        static readonly YELLOW : Internal.ChatFormatting;
        static readonly DARK_GRAY : Internal.ChatFormatting;
        get rgbKJS(): number;
        get hexKJS(): string;
        get argbKJS(): number;
        get fireworkColorKJS(): number;
        get serializeKJS(): string;
    }
    class RandomTickCallbackJS {
        getServer(): Internal.ServerJS
        getLevel(): Internal.LevelJS
        random : Internal.Random;
        block : Internal.BlockContainerJS;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
    }
    class ItemTooltipEventJS extends Internal.EventJS {
        add(item: object, text: object): void
        isAlt(): boolean
        isCtrl(): boolean
        isShift(): boolean
        addAdvanced(item: object, handler: Internal.ItemTooltipEventJS$StaticTooltipHandlerFromJS): void
        addToAll(text: object): void
        addAdvancedToAll(handler: Internal.ItemTooltipEventJS$StaticTooltipHandlerFromJS): void
    }
    interface PlayerKJS {
        setStagesKJS(arg0: Internal.Stages): void
        getStagesRawKJS(): Internal.Stages
        getStagesKJS(): Internal.Stages
        set stagesKJS(arg0: Internal.Stages);
        get stagesRawKJS(): Internal.Stages;
        get stagesKJS(): Internal.Stages;
    }
    class GsonBuilder {
        setFieldNamingPolicy(arg0: Internal.FieldNamingPolicy): Internal.GsonBuilder
        setDateFormat(arg0: number): Internal.GsonBuilder
        setDateFormat(arg0: string): Internal.GsonBuilder
        setDateFormat(arg0: number, arg1: number): Internal.GsonBuilder
        enableComplexMapKeySerialization(): Internal.GsonBuilder
        setVersion(arg0: number): Internal.GsonBuilder
        disableInnerClassSerialization(): Internal.GsonBuilder
        setFieldNamingStrategy(arg0: Internal.FieldNamingStrategy): Internal.GsonBuilder
        excludeFieldsWithModifiers(arg0: number[]): Internal.GsonBuilder
        setLenient(): Internal.GsonBuilder
        serializeSpecialFloatingPointValues(): Internal.GsonBuilder
        serializeNulls(): Internal.GsonBuilder
        addSerializationExclusionStrategy(arg0: Internal.ExclusionStrategy): Internal.GsonBuilder
        generateNonExecutableJson(): Internal.GsonBuilder
        registerTypeHierarchyAdapter(arg0: Internal.Class<object>, arg1: object): Internal.GsonBuilder
        addDeserializationExclusionStrategy(arg0: Internal.ExclusionStrategy): Internal.GsonBuilder
        setLongSerializationPolicy(arg0: Internal.LongSerializationPolicy): Internal.GsonBuilder
        registerTypeAdapter(arg0: Internal.Type, arg1: object): Internal.GsonBuilder
        setPrettyPrinting(): Internal.GsonBuilder
        registerTypeAdapterFactory(arg0: Internal.TypeAdapterFactory): Internal.GsonBuilder
        create(): Internal.Gson
        disableHtmlEscaping(): Internal.GsonBuilder
        setExclusionStrategies(arg0: Internal.ExclusionStrategy[]): Internal.GsonBuilder
        excludeFieldsWithoutExposeAnnotation(): Internal.GsonBuilder
        set fieldNamingPolicy(arg0: Internal.FieldNamingPolicy);
        set dateFormat(arg0: number);
        set dateFormat(arg0: string);
        set version(arg0: number);
        set fieldNamingStrategy(arg0: Internal.FieldNamingStrategy);
        set longSerializationPolicy(arg0: Internal.LongSerializationPolicy);
        set exclusionStrategies(arg0: Internal.ExclusionStrategy[]);
    }
    interface Message {
        getString(): string
        get string(): string;
    }
    class CapabilityDispatcher implements Internal.INBTSerializable<Internal.CompoundTag>, Internal.ICapabilityProvider {
        serializeNBT(): net.minecraft.nbt.Tag
        serializeNBT(): Internal.CompoundTag
        getCapability<T>(arg0: Internal.Capability<T>, arg1: Internal.Direction): Internal.LazyOptional<T>
        getCapability<T>(arg0: Internal.Capability<T>): Internal.LazyOptional<T>
        deserializeNBT(arg0: Internal.CompoundTag): void
        deserializeNBT(arg0: net.minecraft.nbt.Tag): void
        invalidate(): void
        areCompatible(arg0: Internal.CapabilityDispatcher): boolean
    }
    class FieldPosition {
        getEndIndex(): number
        hashCode(): number
        getFieldAttribute(): Internal.Format$Field
        equals(arg0: object): boolean
        getField(): number
        setEndIndex(arg0: number): void
        toString(): string
        getBeginIndex(): number
        setBeginIndex(arg0: number): void
        get endIndex(): number;
        get fieldAttribute(): Internal.Format$Field;
        get field(): number;
        set endIndex(arg0: number);
        get beginIndex(): number;
        set beginIndex(arg0: number);
    }
    class FluidTagInput implements Internal.Predicate<Internal.FluidStack> {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        static read(arg0: Internal.FriendlyByteBuf): Internal.FluidTagInput
        getRandomizedExampleStack(arg0: number): Internal.FluidStack
        test(arg0: Internal.FluidStack): boolean
        test(arg0: object): boolean
        extractFrom(arg0: Internal.IFluidHandler, arg1: Internal.IFluidHandler$FluidAction): boolean
        getMatchingFluidStacks(): Internal.List<Internal.FluidStack>
        serialize(): Internal.JsonElement
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
        testIgnoringAmount(arg0: Internal.FluidStack): boolean
        withAmount(arg0: number): Internal.FluidTagInput
        write(arg0: Internal.FriendlyByteBuf): void
        static deserialize(arg0: Internal.JsonElement): Internal.FluidTagInput
        getAmount(): number
        get matchingFluidStacks(): Internal.List<Internal.FluidStack>;
        get amount(): number;
    }
    interface IExtensibleEnum {
        init(): void
        static createCodecForExtensibleEnum<E>(arg0: () => E[], arg1: (arg0: string) => E): Internal.Codec<E>
    }
    interface OpSupplier {
        create(arg0: dev.latvian.mods.rhino.util.unit.Unit, arg1: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
    }
    class OffsetTime implements Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.OffsetTime>, Internal.Serializable {
        static ofInstant(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.OffsetTime
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.OffsetTime
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: Internal.TemporalAmount): Internal.OffsetTime
        plusHours(arg0: number): Internal.OffsetTime
        minusHours(arg0: number): Internal.OffsetTime
        isEqual(arg0: Internal.OffsetTime): boolean
        getOffset(): Internal.ZoneOffset
        atDate(arg0: Internal.LocalDate): Internal.OffsetDateTime
        toLocalTime(): Internal.LocalTime
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        compareTo(arg0: object): number
        compareTo(arg0: Internal.OffsetTime): number
        plusMinutes(arg0: number): Internal.OffsetTime
        withOffsetSameLocal(arg0: Internal.ZoneOffset): Internal.OffsetTime
        minusMinutes(arg0: number): Internal.OffsetTime
        hashCode(): number
        static now(): Internal.OffsetTime
        static now(arg0: Internal.ZoneId): Internal.OffsetTime
        static now(arg0: Internal.Clock): Internal.OffsetTime
        static of(arg0: Internal.LocalTime, arg1: Internal.ZoneOffset): Internal.OffsetTime
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.ZoneOffset): Internal.OffsetTime
        get(arg0: Internal.TemporalField): number
        plusSeconds(arg0: number): Internal.OffsetTime
        getMinute(): number
        getHour(): number
        static from(arg0: Internal.TemporalAccessor): Internal.OffsetTime
        plusNanos(arg0: number): Internal.OffsetTime
        withMinute(arg0: number): Internal.OffsetTime
        withHour(arg0: number): Internal.OffsetTime
        truncatedTo(arg0: Internal.TemporalUnit): Internal.OffsetTime
        query<R>(arg0: Internal.TemporalQuery<R>): R
        minusNanos(arg0: number): Internal.OffsetTime
        getNano(): number
        format(arg0: Internal.DateTimeFormatter): string
        static parse(arg0: Internal.CharSequence, arg1: Internal.DateTimeFormatter): Internal.OffsetTime
        static parse(arg0: Internal.CharSequence): Internal.OffsetTime
        isSupported(arg0: Internal.TemporalUnit): boolean
        isSupported(arg0: Internal.TemporalField): boolean
        isBefore(arg0: Internal.OffsetTime): boolean
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.OffsetTime
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.OffsetTime
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        withNano(arg0: number): Internal.OffsetTime
        getLong(arg0: Internal.TemporalField): number
        with(arg0: Internal.TemporalAdjuster): Internal.OffsetTime
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        with(arg0: Internal.TemporalField, arg1: number): Internal.OffsetTime
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        withOffsetSameInstant(arg0: Internal.ZoneOffset): Internal.OffsetTime
        toEpochSecond(arg0: Internal.LocalDate): number
        equals(arg0: object): boolean
        getSecond(): number
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        toString(): string
        minusSeconds(arg0: number): Internal.OffsetTime
        isAfter(arg0: Internal.OffsetTime): boolean
        withSecond(arg0: number): Internal.OffsetTime
        static readonly MIN : Internal.OffsetTime;
        static readonly MAX : Internal.OffsetTime;
        get offset(): Internal.ZoneOffset;
        get minute(): number;
        get hour(): number;
        get nano(): number;
        get second(): number;
    }
    class FluidAttributes$Builder {
        viscosity(arg0: number): Internal.FluidAttributes$Builder
        density(arg0: number): Internal.FluidAttributes$Builder
        overlay(arg0: ResourceLocation): Internal.FluidAttributes$Builder
        translationKey(arg0: string): Internal.FluidAttributes$Builder
        color(arg0: number): Internal.FluidAttributes$Builder
        build(arg0: Internal.Fluid): Internal.FluidAttributes
        sound(arg0: Internal.SoundEvent): Internal.FluidAttributes$Builder
        sound(arg0: Internal.SoundEvent, arg1: Internal.SoundEvent): Internal.FluidAttributes$Builder
        temperature(arg0: number): Internal.FluidAttributes$Builder
        luminosity(arg0: number): Internal.FluidAttributes$Builder
        gaseous(): Internal.FluidAttributes$Builder
        rarity(arg0: Internal.Rarity): Internal.FluidAttributes$Builder
    }
    interface FileAttributeView implements Internal.AttributeView {
        name(): string
    }
    interface Spliterator$OfPrimitive <T, T_CONS, T_SPLITR> implements Internal.Spliterator<T> {
        trySplit(): Internal.Spliterator<any>
        trySplit(): T_SPLITR
        characteristics(): number
        tryAdvance(arg0: T_CONS): boolean
        tryAdvance(arg0: (arg0: T) => void): boolean
        getComparator(): Internal.Comparator<T>
        getExactSizeIfKnown(): number
        estimateSize(): number
        hasCharacteristics(arg0: number): boolean
        forEachRemaining(arg0: T_CONS): void
        forEachRemaining(arg0: (arg0: T) => void): void
        static readonly NONNULL : 256;
        static readonly SUBSIZED : 16384;
        static readonly ORDERED : 16;
        static readonly DISTINCT : 1;
        static readonly SIZED : 64;
        static readonly IMMUTABLE : 1024;
        static readonly CONCURRENT : 4096;
        static readonly SORTED : 4;
        get comparator(): Internal.Comparator<T>;
        get exactSizeIfKnown(): number;
    }
    class AbstractContainerEventHandler extends Internal.GuiComponent implements Internal.ContainerEventHandler {
    }
    class DrawBuffer {
        hasVertices(): boolean
        reset(): void
        inject(arg0: Internal.BufferBuilderExtension): void
        begin(arg0: number): Internal.DirectVertexConsumer
    }
    class DoubleBuffer extends Internal.Buffer implements Internal.Comparable<Internal.DoubleBuffer> {
        hasArray(): boolean
        compact(): Internal.DoubleBuffer
        clear(): Internal.Buffer
        clear(): Internal.DoubleBuffer
        duplicate(): Internal.DoubleBuffer
        duplicate(): Internal.Buffer
        compareTo(arg0: object): number
        compareTo(arg0: Internal.DoubleBuffer): number
        asReadOnlyBuffer(): Internal.DoubleBuffer
        put(arg0: number[]): Internal.DoubleBuffer
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.DoubleBuffer
        put(arg0: number, arg1: number[]): Internal.DoubleBuffer
        put(arg0: number[], arg1: number, arg2: number): Internal.DoubleBuffer
        put(arg0: number, arg1: Internal.DoubleBuffer, arg2: number, arg3: number): Internal.DoubleBuffer
        put(arg0: Internal.DoubleBuffer): Internal.DoubleBuffer
        put(arg0: number, arg1: number): Internal.DoubleBuffer
        put(arg0: number): Internal.DoubleBuffer
        static allocate(arg0: number): Internal.DoubleBuffer
        rewind(): Internal.Buffer
        rewind(): Internal.DoubleBuffer
        slice(): Internal.Buffer
        slice(): Internal.DoubleBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.DoubleBuffer
        array(): number[]
        array(): object
        hashCode(): number
        mismatch(arg0: Internal.DoubleBuffer): number
        equals(arg0: object): boolean
        get(): number
        get(arg0: number, arg1: number[]): Internal.DoubleBuffer
        get(arg0: number): number
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.DoubleBuffer
        get(arg0: number[], arg1: number, arg2: number): Internal.DoubleBuffer
        get(arg0: number[]): Internal.DoubleBuffer
        limit(arg0: number): Internal.DoubleBuffer
        limit(arg0: number): Internal.Buffer
        reset(): Internal.Buffer
        reset(): Internal.DoubleBuffer
        arrayOffset(): number
        toString(): string
        position(arg0: number): Internal.DoubleBuffer
        position(arg0: number): Internal.Buffer
        flip(): Internal.Buffer
        flip(): Internal.DoubleBuffer
        isDirect(): boolean
        static wrap(arg0: number[]): Internal.DoubleBuffer
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.DoubleBuffer
        mark(): Internal.Buffer
        mark(): Internal.DoubleBuffer
        order(): Internal.ByteOrder
    }
    class SoundEvent extends Internal.ForgeRegistryEntry<Internal.SoundEvent> {
        readonly delegate : () => V;
    }
    class BackpackInventory extends Internal.SimpleContainer {
        getBackpackStack(): Internal.ItemStack
        get backpackStack(): Internal.ItemStack;
    }
    class ModuleReference {
        location(): Internal.Optional<Internal.URI>
        descriptor(): Internal.ModuleDescriptor
        open(): Internal.ModuleReader
    }
    class AbstractContainerMenu implements Internal.ContainerAccess {
        getRemoteSlots(): Internal.NonNullList<any>
        getLastSlots(): Internal.NonNullList<any>
        get remoteSlots(): Internal.NonNullList<any>;
        get lastSlots(): Internal.NonNullList<any>;
    }
    class MethodHandles$Lookup {
        findStaticVarHandle(arg0: Internal.Class<object>, arg1: string, arg2: Internal.Class<object>): Internal.VarHandle
        hasFullPrivilegeAccess(): boolean
        findStaticGetter(arg0: Internal.Class<object>, arg1: string, arg2: Internal.Class<object>): Internal.MethodHandle
        lookupClass(): Internal.Class<object>
        defineHiddenClass(arg0: number[], arg1: boolean, arg2: Internal.MethodHandles$Lookup$ClassOption[]): Internal.MethodHandles$Lookup
        unreflectSetter(arg0: Internal.Field): Internal.MethodHandle
        findVirtual(arg0: Internal.Class<object>, arg1: string, arg2: Internal.MethodType): Internal.MethodHandle
        findConstructor(arg0: Internal.Class<object>, arg1: Internal.MethodType): Internal.MethodHandle
        dropLookupMode(arg0: number): Internal.MethodHandles$Lookup
        findStaticSetter(arg0: Internal.Class<object>, arg1: string, arg2: Internal.Class<object>): Internal.MethodHandle
        bind(arg0: object, arg1: string, arg2: Internal.MethodType): Internal.MethodHandle
        findGetter(arg0: Internal.Class<object>, arg1: string, arg2: Internal.Class<object>): Internal.MethodHandle
        hasPrivateAccess(): boolean
        unreflectGetter(arg0: Internal.Field): Internal.MethodHandle
        accessClass(arg0: Internal.Class<object>): Internal.Class<object>
        findSpecial(arg0: Internal.Class<object>, arg1: string, arg2: Internal.MethodType, arg3: Internal.Class<object>): Internal.MethodHandle
        in(arg0: Internal.Class<object>): Internal.MethodHandles$Lookup
        defineClass(arg0: number[]): Internal.Class<object>
        unreflectConstructor(arg0: Internal.Constructor<object>): Internal.MethodHandle
        unreflectVarHandle(arg0: Internal.Field): Internal.VarHandle
        findClass(arg0: string): Internal.Class<object>
        defineHiddenClassWithClassData(arg0: number[], arg1: object, arg2: boolean, arg3: Internal.MethodHandles$Lookup$ClassOption[]): Internal.MethodHandles$Lookup
        unreflectSpecial(arg0: Internal.Method, arg1: Internal.Class<object>): Internal.MethodHandle
        lookupModes(): number
        findStatic(arg0: Internal.Class<object>, arg1: string, arg2: Internal.MethodType): Internal.MethodHandle
        ensureInitialized(arg0: Internal.Class<object>): Internal.Class<object>
        unreflect(arg0: Internal.Method): Internal.MethodHandle
        findVarHandle(arg0: Internal.Class<object>, arg1: string, arg2: Internal.Class<object>): Internal.VarHandle
        findSetter(arg0: Internal.Class<object>, arg1: string, arg2: Internal.Class<object>): Internal.MethodHandle
        toString(): string
        previousLookupClass(): Internal.Class<object>
        revealDirect(arg0: Internal.MethodHandle): Internal.MethodHandleInfo
        static readonly MODULE : 16;
        static readonly PACKAGE : 8;
        static readonly PUBLIC : 1;
        static readonly ORIGINAL : 64;
        static readonly UNCONDITIONAL : 32;
        static readonly PROTECTED : 4;
        static readonly PRIVATE : 2;
    }
    interface ClientEntityManagerAccessor <T> {
        getCache(): Internal.EntitySectionStorage<T>
        get cache(): Internal.EntitySectionStorage<T>;
    }
    class MultiBufferSource$BufferSource implements Internal.MultiBufferSource {
    }
    interface EventExecutor implements Internal.EventExecutorGroup {
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<object>
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<object>
        next(): Internal.EventExecutor
        terminationFuture(): io.netty.util.concurrent.Future<object>
        parent(): Internal.EventExecutorGroup
        newProgressivePromise<V>(): Internal.ProgressivePromise<V>
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit): io.netty.util.concurrent.Future<object>
        shutdownGracefully(): io.netty.util.concurrent.Future<object>
        submit<T>(arg0: Internal.Runnable, arg1: T): io.netty.util.concurrent.Future<T>
        submit<T>(arg0: Internal.Runnable, arg1: T): Internal.Future<T>
        submit<T>(arg0: java_.util.concurrent.Callable<T>): io.netty.util.concurrent.Future<T>
        submit<T>(arg0: java_.util.concurrent.Callable<T>): Internal.Future<T>
        submit(arg0: Internal.Runnable): io.netty.util.concurrent.Future<object>
        submit(arg0: Internal.Runnable): Internal.Future<object>
        spliterator(): Internal.Spliterator<T>
        isTerminated(): boolean
        forEach(arg0: (arg0: T) => void): void
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<object>
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<object>
        invokeAll<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<Internal.Future<T>>
        invokeAll<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>): Internal.List<Internal.Future<T>>
        newFailedFuture<V>(arg0: Internal.Throwable): io.netty.util.concurrent.Future<V>
        execute(arg0: Internal.Runnable): void
        inEventLoop(arg0: Internal.Thread): boolean
        inEventLoop(): boolean
        isShuttingDown(): boolean
        schedule<V>(arg0: java_.util.concurrent.Callable<V>, arg1: number, arg2: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<V>
        schedule<V>(arg0: java_.util.concurrent.Callable<V>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<object>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<object>
        iterator(): Internal.Iterator<Internal.EventExecutor>
        newSucceededFuture<V>(arg0: V): io.netty.util.concurrent.Future<V>
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean
        invokeAny<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>): T
        invokeAny<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>, arg1: number, arg2: Internal.TimeUnit): T
        shutdownNow(): Internal.List<Internal.Runnable>
        shutdown(): void
        isShutdown(): boolean
        newPromise<V>(): Internal.Promise<V>
    }
    class FireworksJS {
        static of(o: object): Internal.FireworksJS
        createFireworkRocket(w: Internal.Level, x: number, y: number, z: number): Internal.FireworkRocketEntity
        flight : number;
        lifetime : number;
        readonly explosions : Internal.List<Internal.FireworksJS$Explosion>;
    }
    class Screen extends Internal.AbstractContainerEventHandler implements Internal.Widget, Internal.AccessScreen {
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.ItemStack): void
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.Font, arg5: Internal.ItemStack): void
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.Font): void
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.ItemStack): void
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedCharSequence>, arg2: number, arg3: number, arg4: Internal.Font): void
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.Font): void
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.Font, arg6: Internal.ItemStack): void
        getRenderables(): Internal.List<any>
        getMinecraft(): Internal.Minecraft
        get renderables(): Internal.List<any>;
        get minecraft(): Internal.Minecraft;
    }
    interface Iterable <T> {
        iterator(): Internal.Iterator<T>
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
    }
    interface Scale <Self> {
        scale(arg0: number, arg1: number, arg2: number): Self
        scale(arg0: number): Self
    }
    interface Object2FloatFunction <K> implements Internal.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: number): number
        applyAsDouble(arg0: K): number
        andThenShort(arg0: Internal.Float2ShortFunction): Internal.Object2ShortFunction<K>
        composeByte(arg0: Internal.Byte2ObjectFunction<K>): Internal.Byte2FloatFunction
        getFloat(arg0: object): number
        andThenInt(arg0: Internal.Float2IntFunction): Internal.Object2IntFunction<K>
        composeReference<T>(arg0: (arg0: T) => K): Internal.Reference2FloatFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: K) => T
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: object, arg1: object): object
        remove(arg0: object): number
        remove(arg0: object): object
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: Internal.Float2DoubleFunction): Internal.Object2DoubleFunction<K>
        andThenObject<T>(arg0: Internal.Float2ObjectFunction<T>): (arg0: K) => T
        get(arg0: object): object
        get(arg0: object): number
        andThenLong(arg0: Internal.Float2LongFunction): Internal.Object2LongFunction<K>
        composeLong(arg0: Internal.Long2ObjectFunction<K>): Internal.Long2FloatFunction
        andThenByte(arg0: Internal.Float2ByteFunction): Internal.Object2ByteFunction<K>
        andThenFloat(arg0: Internal.Float2FloatFunction): Internal.Object2FloatFunction<K>
        removeFloat(arg0: object): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ObjectFunction<K>): Internal.Int2FloatFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ObjectFunction<K>): Internal.Float2FloatFunction
        andThenChar(arg0: Internal.Float2CharFunction): Internal.Object2CharFunction<K>
        composeObject<T>(arg0: (arg0: T) => K): Internal.Object2FloatFunction<T>
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ObjectFunction<K>): Internal.Short2FloatFunction
        andThenReference<T>(arg0: Internal.Float2ReferenceFunction<T>): (arg0: K) => T
        composeChar(arg0: Internal.Char2ObjectFunction<K>): Internal.Char2FloatFunction
        composeDouble(arg0: Internal.Double2ObjectFunction<K>): Internal.Double2FloatFunction
    }
    class ParticleEngine implements Internal.PreparableReloadListener, Internal.ParticleManagerAccess, Internal.ParticleEngineAccessor {
        create$getProviders(): Map<any, any>
        addBlockHitEffects(arg0: BlockPos, arg1: Internal.BlockHitResult): void
        invokeMakeParticle(arg0: Internal.ParticleOptions, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Internal.Particle
        render(arg0: Internal.PoseStack, arg1: Internal.MultiBufferSource$BufferSource, arg2: Internal.LightTexture, arg3: Internal.Camera, arg4: number, arg5: net.minecraft.client.renderer.culling.Frustum): void
    }
    class ByteBuf implements Internal.ReferenceCounted, Internal.Comparable<Internal.ByteBuf> {
        asReadOnly(): Internal.ByteBuf
        markReaderIndex(): Internal.ByteBuf
        getByte(arg0: number): number
        release(arg0: number): boolean
        release(): boolean
        readDoubleLE(): number
        writeZero(arg0: number): Internal.ByteBuf
        resetReaderIndex(): Internal.ByteBuf
        writeFloat(arg0: number): Internal.ByteBuf
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf
        readRetainedSlice(arg0: number): Internal.ByteBuf
        slice(): Internal.ByteBuf
        slice(arg0: number, arg1: number): Internal.ByteBuf
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf
        getMediumLE(arg0: number): number
        readUnsignedIntLE(): number
        writeFloatLE(arg0: number): Internal.ByteBuf
        readInt(): number
        order(): Internal.ByteOrder
        order(arg0: Internal.ByteOrder): Internal.ByteBuf
        writeMedium(arg0: number): Internal.ByteBuf
        resetWriterIndex(): Internal.ByteBuf
        writableBytes(): number
        getUnsignedShort(arg0: number): number
        maxCapacity(): number
        bytesBefore(arg0: number): number
        bytesBefore(arg0: number, arg1: number, arg2: number): number
        bytesBefore(arg0: number, arg1: number): number
        nioBufferCount(): number
        setInt(arg0: number, arg1: number): Internal.ByteBuf
        getInt(arg0: number): number
        markWriterIndex(): Internal.ByteBuf
        isReadable(arg0: number): boolean
        isReadable(): boolean
        writeBoolean(arg0: boolean): Internal.ByteBuf
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf
        writeLongLE(arg0: number): Internal.ByteBuf
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf
        retain(arg0: number): Internal.ByteBuf
        retain(arg0: number): Internal.ReferenceCounted
        retain(): Internal.ByteBuf
        retain(): Internal.ReferenceCounted
        isWritable(): boolean
        isWritable(arg0: number): boolean
        readChar(): string
        hasMemoryAddress(): boolean
        capacity(): number
        capacity(arg0: number): Internal.ByteBuf
        readCharSequence(arg0: number, arg1: Internal.Charset): Internal.CharSequence
        isReadOnly(): boolean
        readUnsignedShortLE(): number
        readDouble(): number
        readFloat(): number
        getLongLE(arg0: number): number
        getBoolean(arg0: number): boolean
        copy(): Internal.ByteBuf
        copy(arg0: number, arg1: number): Internal.ByteBuf
        readShortLE(): number
        readUnsignedMedium(): number
        ensureWritable(arg0: number): Internal.ByteBuf
        ensureWritable(arg0: number, arg1: boolean): number
        writeInt(arg0: number): Internal.ByteBuf
        readFloatLE(): number
        getDoubleLE(arg0: number): number
        hasArray(): boolean
        memoryAddress(): number
        maxFastWritableBytes(): number
        readableBytes(): number
        readSlice(arg0: number): Internal.ByteBuf
        getIntLE(arg0: number): number
        forEachByteDesc(arg0: Internal.ByteProcessor): number
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        nioBuffers(): Internal.ByteBuffer[]
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[]
        skipBytes(arg0: number): Internal.ByteBuf
        getLong(arg0: number): number
        readLong(): number
        readShort(): number
        equals(arg0: object): boolean
        setZero(arg0: number, arg1: number): Internal.ByteBuf
        getUnsignedMedium(arg0: number): number
        readBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        readBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        readBytes(arg0: number[]): Internal.ByteBuf
        readBytes(arg0: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        readBytes(arg0: Internal.GatheringByteChannel, arg1: number): number
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        readBoolean(): boolean
        toString(arg0: number, arg1: number, arg2: Internal.Charset): string
        toString(arg0: Internal.Charset): string
        toString(): string
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf
        retainedSlice(): Internal.ByteBuf
        readMediumLE(): number
        setMedium(arg0: number, arg1: number): Internal.ByteBuf
        isDirect(): boolean
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf
        getFloatLE(arg0: number): number
        readerIndex(): number
        readerIndex(arg0: number): Internal.ByteBuf
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset): Internal.CharSequence
        setShort(arg0: number, arg1: number): Internal.ByteBuf
        compareTo(arg0: Internal.ByteBuf): number
        compareTo(arg0: object): number
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel, arg2: number): number
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        unwrap(): Internal.ByteBuf
        setDouble(arg0: number, arg1: number): Internal.ByteBuf
        setChar(arg0: number, arg1: number): Internal.ByteBuf
        refCnt(): number
        getUnsignedIntLE(arg0: number): number
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf
        getUnsignedInt(arg0: number): number
        indexOf(arg0: number, arg1: number, arg2: number): number
        writeByte(arg0: number): Internal.ByteBuf
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        nioBuffer(): Internal.ByteBuffer
        discardSomeReadBytes(): Internal.ByteBuf
        touch(arg0: object): Internal.ReferenceCounted
        touch(arg0: object): Internal.ByteBuf
        touch(): Internal.ByteBuf
        touch(): Internal.ReferenceCounted
        duplicate(): Internal.ByteBuf
        writerIndex(arg0: number): Internal.ByteBuf
        writerIndex(): number
        writeCharSequence(arg0: Internal.CharSequence, arg1: Internal.Charset): number
        readUnsignedInt(): number
        getUnsignedShortLE(arg0: number): number
        retainedDuplicate(): Internal.ByteBuf
        getChar(arg0: number): string
        setLong(arg0: number, arg1: number): Internal.ByteBuf
        readMedium(): number
        writeBytes(arg0: Internal.InputStream, arg1: number): number
        writeBytes(arg0: Internal.ScatteringByteChannel, arg1: number): number
        writeBytes(arg0: number[]): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        writeBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        forEachByte(arg0: Internal.ByteProcessor): number
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        setIndex(arg0: number, arg1: number): Internal.ByteBuf
        writeShort(arg0: number): Internal.ByteBuf
        alloc(): Internal.ByteBufAllocator
        getShortLE(arg0: number): number
        getMedium(arg0: number): number
        readUnsignedShort(): number
        setByte(arg0: number, arg1: number): Internal.ByteBuf
        writeShortLE(arg0: number): Internal.ByteBuf
        maxWritableBytes(): number
        getDouble(arg0: number): number
        getFloat(arg0: number): number
        writeLong(arg0: number): Internal.ByteBuf
        writeIntLE(arg0: number): Internal.ByteBuf
        array(): number[]
        setCharSequence(arg0: number, arg1: Internal.CharSequence, arg2: Internal.Charset): number
        hashCode(): number
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        arrayOffset(): number
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf
        readIntLE(): number
        readUnsignedByte(): number
        readUnsignedMediumLE(): number
        readLongLE(): number
        writeDouble(arg0: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.InputStream, arg2: number): number
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel, arg2: number): number
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        setFloat(arg0: number, arg1: number): Internal.ByteBuf
        getShort(arg0: number): number
        writeMediumLE(arg0: number): Internal.ByteBuf
        clear(): Internal.ByteBuf
        getUnsignedByte(arg0: number): number
        discardReadBytes(): Internal.ByteBuf
        writeChar(arg0: number): Internal.ByteBuf
        writeDoubleLE(arg0: number): Internal.ByteBuf
        isContiguous(): boolean
        getUnsignedMediumLE(arg0: number): number
        readByte(): number
    }
    interface IForgeTransformation {
        applyOrigin(arg0: Internal.Vector3f): Internal.Transformation
        blockCornerToCenter(): Internal.Transformation
        rotateTransform(arg0: Internal.Direction): Internal.Direction
        isIdentity(): boolean
        transformPosition(arg0: Internal.Vector4f): void
        transformNormal(arg0: Internal.Vector3f): void
        push(arg0: Internal.PoseStack): void
        blockCenterToCorner(): Internal.Transformation
    }
    class JsonGenerator {
        json(id: ResourceLocation, json: Internal.JsonElement): void
    }
    interface ServerEntityManagerAccessor <T> {
        getCache(): Internal.EntitySectionStorage<T>
        get cache(): Internal.EntitySectionStorage<T>;
    }
    class PlatformWrapper$ModInfo {
        getVersion(): string
        getName(): string
        getId(): string
        get version(): string;
        get name(): string;
        get id(): string;
    }
    class OptionalInt {
        isEmpty(): boolean
        isPresent(): boolean
        orElse(arg0: number): number
        getAsInt(): number
        orElseThrow<X>(arg0: () => X): number
        orElseThrow(): number
        static empty(): Internal.OptionalInt
        orElseGet(arg0: Internal.IntSupplier): number
        stream(): Internal.IntStream
        hashCode(): number
        ifPresentOrElse(arg0: java_.util.function_.IntConsumer, arg1: Internal.Runnable): void
        ifPresent(arg0: java_.util.function_.IntConsumer): void
        static of(arg0: number): Internal.OptionalInt
        equals(arg0: object): boolean
        toString(): string
        get asInt(): number;
    }
    interface Cancellable {
        cancel(): void
        isCancelled(): boolean
        isCancellable(): boolean
    }
    interface Symbol {
    }
    interface EntityTypeTest <B, T> {
    }
    class Dictionary <K, V> {
        size(): number
        keys(): Internal.Enumeration<K>
        elements(): Internal.Enumeration<V>
        get(arg0: object): V
        isEmpty(): boolean
        put(arg0: K, arg1: V): V
        remove(arg0: object): V
    }
    interface Byte2ShortFunction implements Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Short2ShortFunction): Internal.Byte2ShortFunction
        composeByte(arg0: Internal.Byte2ByteFunction): Internal.Byte2ShortFunction
        andThenInt(arg0: Internal.Short2IntFunction): Internal.Byte2IntFunction
        composeReference<T>(arg0: Internal.Reference2ByteFunction<T>): Internal.Reference2ShortFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Short2DoubleFunction): Internal.Byte2DoubleFunction
        andThenObject<T>(arg0: Internal.Short2ObjectFunction<T>): Internal.Byte2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Short2LongFunction): Internal.Byte2LongFunction
        composeLong(arg0: Internal.Long2ByteFunction): Internal.Long2ShortFunction
        andThenByte(arg0: Internal.Short2ByteFunction): Internal.Byte2ByteFunction
        andThenFloat(arg0: Internal.Short2FloatFunction): Internal.Byte2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ByteFunction): Internal.Int2ShortFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ByteFunction): Internal.Float2ShortFunction
        andThenChar(arg0: Internal.Short2CharFunction): Internal.Byte2CharFunction
        composeObject<T>(arg0: Internal.Object2ByteFunction<T>): Internal.Object2ShortFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2ByteFunction): Internal.Short2ShortFunction
        andThenReference<T>(arg0: Internal.Short2ReferenceFunction<T>): Internal.Byte2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ByteFunction): Internal.Char2ShortFunction
        composeDouble(arg0: Internal.Double2ByteFunction): Internal.Double2ShortFunction
    }
    interface FlowMessage implements org.apache.logging.log4j.message.Message {
        getText(): string
        getParameters(): object[]
        getFormattedMessage(): string
        getMessage(): org.apache.logging.log4j.message.Message
        getFormat(): string
        getThrowable(): Internal.Throwable
        get text(): string;
        get parameters(): object[];
        get formattedMessage(): string;
        get message(): org.apache.logging.log4j.message.Message;
        get format(): string;
        get throwable(): Internal.Throwable;
    }
    class ClocheRecipeJS extends Internal.IERecipeJS {
        serialize(): void
        create(args: Internal.ListJS): void
        render(o: object): Internal.ClocheRecipeJS
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        renderReference : Internal.ClocheRenderFunction$ClocheRenderReference;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<object>;
        readonly inputFluids : Internal.List<Internal.FluidTagInput>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        serializeInputs : boolean;
    }
    interface Int2CharFunction implements Internal.Function<number, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: string): string
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: string): string
        andThenShort(arg0: Internal.Char2ShortFunction): Internal.Int2ShortFunction
        composeByte(arg0: Internal.Byte2IntFunction): Internal.Byte2CharFunction
        andThenInt(arg0: Internal.Char2IntFunction): Internal.Int2IntFunction
        composeReference<T>(arg0: Internal.Reference2IntFunction<T>): Internal.Reference2CharFunction<T>
        andThen<T>(arg0: (arg0: string) => T): (arg0: number) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: string): string
        put(arg0: number, arg1: string): string
        remove(arg0: number): string
        remove(arg0: object): object
        remove(arg0: object): string
        defaultReturnValue(): string
        defaultReturnValue(arg0: string): void
        andThenDouble(arg0: Internal.Char2DoubleFunction): Internal.Int2DoubleFunction
        andThenObject<T>(arg0: Internal.Char2ObjectFunction<T>): Internal.Int2ObjectFunction<T>
        get(arg0: object): string
        get(arg0: object): object
        get(arg0: number): string
        andThenLong(arg0: Internal.Char2LongFunction): Internal.Int2LongFunction
        composeLong(arg0: Internal.Long2IntFunction): Internal.Long2CharFunction
        andThenByte(arg0: Internal.Char2ByteFunction): Internal.Int2ByteFunction
        andThenFloat(arg0: Internal.Char2FloatFunction): Internal.Int2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2IntFunction): Internal.Int2CharFunction
        clear(): void
        composeFloat(arg0: Internal.Float2IntFunction): Internal.Float2CharFunction
        andThenChar(arg0: Internal.Char2CharFunction): Internal.Int2CharFunction
        composeObject<T>(arg0: Internal.Object2IntFunction<T>): Internal.Object2CharFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => string
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2IntFunction): Internal.Short2CharFunction
        andThenReference<T>(arg0: Internal.Char2ReferenceFunction<T>): Internal.Int2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2IntFunction): Internal.Char2CharFunction
        composeDouble(arg0: Internal.Double2IntFunction): Internal.Double2CharFunction
    }
    interface Transform <Self> implements Internal.Translate<Self>, Internal.Rotate<Self>, Internal.Scale<Self> {
        rotate(arg0: Internal.Direction, arg1: number): Self
        rotate(arg0: number, arg1: Internal.Direction$Axis): Self
        translateAll(arg0: number): Self
        rotateCentered(arg0: Internal.Direction, arg1: number): Self
        rotateCentered(arg0: Internal.Quaternion): Self
        scale(arg0: number, arg1: number, arg2: number): Self
        scale(arg0: number): Self
        centre(): Self
        multiplyRadians(arg0: Internal.Vector3f, arg1: number): Self
        translate(arg0: number, arg1: number, arg2: number): Self
        translate(arg0: Internal.Vector3f): Self
        translate(arg0: Vec3): Self
        translate(arg0: Vec3i): Self
        rotateZRadians(arg0: number): Self
        translateZ(arg0: number): Self
        mulNormal(arg0: Internal.Matrix3f): Self
        transform(arg0: Internal.PoseStack): Self
        transform(arg0: Internal.Matrix4f, arg1: Internal.Matrix3f): Self
        mulPose(arg0: Internal.Matrix4f): Self
        rotateYRadians(arg0: number): Self
        rotateXRadians(arg0: number): Self
        translateY(arg0: number): Self
        translateX(arg0: number): Self
        unCentre(): Self
        multiply(arg0: Internal.Vector3f, arg1: number): Self
        multiply(arg0: Internal.Quaternion): Self
        rotateX(arg0: number): Self
        rotateY(arg0: number): Self
        translateBack(arg0: Vec3): Self
        translateBack(arg0: Vec3i): Self
        translateBack(arg0: number, arg1: number, arg2: number): Self
        rotateZ(arg0: number): Self
        rotateToFace(arg0: Internal.Direction): Self
        nudge(arg0: number): Self
    }
    class TagEventJS <T> extends Internal.EventJS {
        add(tag: ResourceLocation, ids: object): Internal.TagEventJS$TagWrapper<T>
        removeAll(tag: ResourceLocation): Internal.TagEventJS$TagWrapper<T>
        post(event: string): void
        getType(): string
        removeAllTagsFrom(ids: object): void
        get(id: ResourceLocation): Internal.TagEventJS$TagWrapper<T>
        setGlobalPriorityList(o: object): void
        remove(tag: ResourceLocation, ids: object): Internal.TagEventJS$TagWrapper<T>
        get type(): string;
        set globalPriorityList(o: object);
    }
    class Rotation extends Internal.Enum<Internal.Rotation> {
        static valueOf(arg0: string): Internal.Rotation
        static values(): Internal.Rotation[]
        static readonly COUNTERCLOCKWISE_90 : Internal.Rotation;
        static readonly CLOCKWISE_90 : Internal.Rotation;
        static readonly CLOCKWISE_180 : Internal.Rotation;
        static readonly NONE : Internal.Rotation;
    }
    class SearchRegistry implements Internal.ResourceManagerReloadListener {
    }
    class URL implements Internal.Serializable {
        static setURLStreamHandlerFactory(arg0: Internal.URLStreamHandlerFactory): void
        getDefaultPort(): number
        openConnection(): Internal.URLConnection
        openConnection(arg0: Internal.Proxy): Internal.URLConnection
        toURI(): Internal.URI
        getContent(): object
        getContent(arg0: Internal.Class<object>[]): object
        getProtocol(): string
        getAuthority(): string
        getFile(): string
        openStream(): Internal.InputStream
        toExternalForm(): string
        getPort(): number
        getRef(): string
        sameFile(arg0: Internal.URL): boolean
        hashCode(): number
        equals(arg0: object): boolean
        getPath(): string
        toString(): string
        getUserInfo(): string
        getQuery(): string
        getHost(): string
        set uRLStreamHandlerFactory(arg0: Internal.URLStreamHandlerFactory);
        get defaultPort(): number;
        get content(): object;
        get protocol(): string;
        get authority(): string;
        get file(): string;
        get port(): number;
        get ref(): string;
        get path(): string;
        get userInfo(): string;
        get query(): string;
        get host(): string;
    }
    class AbstractSet <E> extends Internal.AbstractCollection<E> implements Internal.Set<E> {
        removeAll(arg0: Internal.Collection<object>): boolean
        spliterator(): Internal.Spliterator<E>
        hashCode(): number
        equals(arg0: object): boolean
    }
    class DataOutputStream extends Internal.FilterOutputStream implements Internal.DataOutput {
        writeInt(arg0: number): void
        writeByte(arg0: number): void
        writeFloat(arg0: number): void
        writeChar(arg0: number): void
        writeLong(arg0: number): void
        writeBytes(arg0: string): void
        size(): number
        flush(): void
        writeUTF(arg0: string): void
        writeShort(arg0: number): void
        writeChars(arg0: string): void
        write(arg0: number[], arg1: number, arg2: number): void
        write(arg0: number): void
        writeBoolean(arg0: boolean): void
        writeDouble(arg0: number): void
    }
    interface Spliterator$OfDouble implements Internal.Spliterator$OfPrimitive<number, Internal.DoubleConsumer, Internal.Spliterator$OfDouble> {
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>
        trySplit(): Internal.Spliterator<any>
        trySplit(): Internal.Spliterator$OfDouble
        characteristics(): number
        tryAdvance(arg0: Internal.DoubleConsumer): boolean
        tryAdvance(arg0: (arg0: number) => void): boolean
        tryAdvance(arg0: object): boolean
        getComparator(): Internal.Comparator<T>
        getExactSizeIfKnown(): number
        estimateSize(): number
        hasCharacteristics(arg0: number): boolean
        forEachRemaining(arg0: object): void
        forEachRemaining(arg0: Internal.DoubleConsumer): void
        forEachRemaining(arg0: (arg0: number) => void): void
        static readonly NONNULL : 256;
        static readonly SUBSIZED : 16384;
        static readonly ORDERED : 16;
        static readonly DISTINCT : 1;
        static readonly SIZED : 64;
        static readonly IMMUTABLE : 1024;
        static readonly CONCURRENT : 4096;
        static readonly SORTED : 4;
        get comparator(): Internal.Comparator<T>;
        get exactSizeIfKnown(): number;
    }
    interface PausedPartialTickAccessor {
        flywheel$getPartialTicksPaused(): number
    }
    interface ResourceManagerReloadListener implements Internal.PreparableReloadListener {
    }
    class GridAlignedBB implements Internal.ImmutableBox {
        setMinY(arg0: number): Internal.GridAlignedBB
        intersects(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean
        intersects(arg0: Internal.ImmutableBox): boolean
        setMinX(arg0: number): Internal.GridAlignedBB
        setMinZ(arg0: number): Internal.GridAlignedBB
        forEachContained(arg0: Internal.CoordinateConsumer): void
        fixMinMax(): void
        nextPowerOf2(): void
        translate(arg0: number, arg1: number, arg2: number): void
        translate(arg0: Vec3i): void
        empty(): boolean
        setMin(arg0: number, arg1: number, arg2: number): Internal.GridAlignedBB
        setMin(arg0: Vec3i): Internal.GridAlignedBB
        mirrorAbout(arg0: Internal.Direction$Axis): void
        hashCode(): number
        static ofRadius(arg0: number): Internal.GridAlignedBB
        static from(arg0: Internal.AABB): Internal.GridAlignedBB
        static from(arg0: number, arg1: number): Internal.GridAlignedBB
        static from(arg0: Internal.SectionPos): Internal.GridAlignedBB
        static from(arg0: BlockPos, arg1: BlockPos): Internal.GridAlignedBB
        static from(arg0: BlockPos): Internal.GridAlignedBB
        copy(): Internal.GridAlignedBB
        intersectAssign(arg0: Internal.ImmutableBox): void
        setMax(arg0: Vec3i): Internal.GridAlignedBB
        setMax(arg0: number, arg1: number, arg2: number): Internal.GridAlignedBB
        hasPowerOf2Sides(): boolean
        grow(arg0: number): void
        grow(arg0: number, arg1: number, arg2: number): void
        intersect(arg0: Internal.ImmutableBox): Internal.GridAlignedBB
        nextPowerOf2Centered(): void
        getMaxX(): number
        getMaxY(): number
        union(arg0: Internal.ImmutableBox): Internal.ImmutableBox
        static containingAll(arg0: Internal.Collection<BlockPos>): Internal.ImmutableBox
        getMaxZ(): number
        volume(): number
        sizeX(): number
        contains(arg0: Internal.ImmutableBox): boolean
        contains(arg0: number, arg1: number, arg2: number): boolean
        isContainedBy(arg0: Internal.GridAlignedBB): boolean
        unionAssign(arg0: Internal.ImmutableBox): void
        unionAssign(arg0: Internal.AABB): void
        setMaxZ(arg0: number): Internal.GridAlignedBB
        toAABB(): Internal.AABB
        equals(arg0: object): boolean
        setMaxY(arg0: number): Internal.GridAlignedBB
        toString(): string
        setMaxX(arg0: number): Internal.GridAlignedBB
        getMinZ(): number
        sizeY(): number
        getMinX(): number
        sizeZ(): number
        assign(arg0: Internal.ImmutableBox): void
        assign(arg0: BlockPos, arg1: BlockPos): Internal.GridAlignedBB
        assign(arg0: Internal.AABB): void
        sameAs(arg0: Internal.ImmutableBox): boolean
        sameAs(arg0: Internal.AABB): boolean
        getMinY(): number
        set minY(arg0: number);
        set minX(arg0: number);
        set minZ(arg0: number);
        set min(arg0: Vec3i);
        set max(arg0: Vec3i);
        get maxX(): number;
        get maxY(): number;
        get maxZ(): number;
        set maxZ(arg0: number);
        set maxY(arg0: number);
        set maxX(arg0: number);
        get minZ(): number;
        get minX(): number;
        get minY(): number;
    }
    interface MessageSizeEstimator$Handle {
        size(arg0: object): number
    }
    interface Short2LongFunction implements Internal.Function<number, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Long2ShortFunction): Internal.Short2ShortFunction
        composeByte(arg0: Internal.Byte2ShortFunction): Internal.Byte2LongFunction
        andThenInt(arg0: Internal.Long2IntFunction): Internal.Short2IntFunction
        composeReference<T>(arg0: Internal.Reference2ShortFunction<T>): Internal.Reference2LongFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Long2DoubleFunction): Internal.Short2DoubleFunction
        andThenObject<T>(arg0: Internal.Long2ObjectFunction<T>): Internal.Short2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Long2LongFunction): Internal.Short2LongFunction
        composeLong(arg0: Internal.Long2ShortFunction): Internal.Long2LongFunction
        andThenByte(arg0: Internal.Long2ByteFunction): Internal.Short2ByteFunction
        andThenFloat(arg0: Internal.Long2FloatFunction): Internal.Short2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ShortFunction): Internal.Int2LongFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ShortFunction): Internal.Float2LongFunction
        andThenChar(arg0: Internal.Long2CharFunction): Internal.Short2CharFunction
        applyAsLong(arg0: number): number
        composeObject<T>(arg0: Internal.Object2ShortFunction<T>): Internal.Object2LongFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2ShortFunction): Internal.Short2LongFunction
        andThenReference<T>(arg0: Internal.Long2ReferenceFunction<T>): Internal.Short2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ShortFunction): Internal.Char2LongFunction
        composeDouble(arg0: Internal.Double2ShortFunction): Internal.Double2LongFunction
    }
    class Method extends Internal.Executable {
        getName(): string
        getParameterCount(): number
        getGenericReturnType(): Internal.Type
        isSynthetic(): boolean
        getParameterTypes(): Internal.Class<object>[]
        invoke(arg0: object, arg1: object[]): object
        isBridge(): boolean
        getGenericExceptionTypes(): Internal.Type[]
        getDefaultValue(): object
        getDeclaredAnnotations(): Internal.Annotation[]
        getDeclaringClass(): Internal.Class<object>
        hashCode(): number
        toGenericString(): string
        getTypeParameters(): Internal.TypeVariable<Internal.Method>[]
        getModifiers(): number
        setAccessible(arg0: boolean): void
        isVarArgs(): boolean
        getExceptionTypes(): Internal.Class<object>[]
        isDefault(): boolean
        getGenericParameterTypes(): Internal.Type[]
        getReturnType(): Internal.Class<object>
        getAnnotation<T>(arg0: Internal.Class<T>): T
        equals(arg0: object): boolean
        toString(): string
        getAnnotatedReturnType(): Internal.AnnotatedType
        getParameterAnnotations(): Internal.Annotation[][]
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get name(): string;
        get parameterCount(): number;
        get genericReturnType(): Internal.Type;
        get parameterTypes(): Internal.Class<object>[];
        get genericExceptionTypes(): Internal.Type[];
        get defaultValue(): object;
        get declaredAnnotations(): Internal.Annotation[];
        get declaringClass(): Internal.Class<object>;
        get typeParameters(): Internal.TypeVariable<Internal.Method>[];
        get modifiers(): number;
        set accessible(arg0: boolean);
        get exceptionTypes(): Internal.Class<object>[];
        get genericParameterTypes(): Internal.Type[];
        get returnType(): Internal.Class<object>;
        get annotatedReturnType(): Internal.AnnotatedType;
        get parameterAnnotations(): Internal.Annotation[][];
    }
    interface MenuAccess <T> {
    }
    interface DataOutput {
        writeChar(arg0: number): void
        writeInt(arg0: number): void
        writeLong(arg0: number): void
        writeByte(arg0: number): void
        writeBytes(arg0: string): void
        writeUTF(arg0: string): void
        writeShort(arg0: number): void
        writeChars(arg0: string): void
        writeFloat(arg0: number): void
        write(arg0: number[], arg1: number, arg2: number): void
        write(arg0: number[]): void
        write(arg0: number): void
        writeBoolean(arg0: boolean): void
        writeDouble(arg0: number): void
    }
    class Module implements Internal.AnnotatedElement {
        getDescriptor(): Internal.ModuleDescriptor
        getName(): string
        addReads(arg0: Internal.Module): Internal.Module
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        canRead(arg0: Internal.Module): boolean
        getLayer(): Internal.ModuleLayer
        getResourceAsStream(arg0: string): Internal.InputStream
        addUses(arg0: Internal.Class<object>): Internal.Module
        addExports(arg0: string, arg1: Internal.Module): Internal.Module
        getClassLoader(): Internal.ClassLoader
        isNamed(): boolean
        getAnnotations(): Internal.Annotation[]
        canUse(arg0: Internal.Class<object>): boolean
        getDeclaredAnnotations(): Internal.Annotation[]
        isOpen(arg0: string): boolean
        isOpen(arg0: string, arg1: Internal.Module): boolean
        getAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getDeclaredAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getAnnotation<T>(arg0: Internal.Class<T>): T
        isExported(arg0: string, arg1: Internal.Module): boolean
        isExported(arg0: string): boolean
        getDeclaredAnnotation<T>(arg0: Internal.Class<T>): T
        getPackages(): Internal.Set<string>
        toString(): string
        addOpens(arg0: string, arg1: Internal.Module): Internal.Module
        get descriptor(): Internal.ModuleDescriptor;
        get name(): string;
        get layer(): Internal.ModuleLayer;
        get classLoader(): Internal.ClassLoader;
        get annotations(): Internal.Annotation[];
        get declaredAnnotations(): Internal.Annotation[];
        get packages(): Internal.Set<string>;
    }
    interface SetMultimap <K, V> implements Internal.Multimap<K, V> {
        containsEntry(arg0: object, arg1: object): boolean
        keys(): Internal.Multiset<K>
        containsKey(arg0: object): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        asMap(): Map<K, Internal.Collection<V>>
        values(): Internal.Collection<V>
        isEmpty(): boolean
        clear(): void
        replaceValues(arg0: object, arg1: Internal.Iterable<any>): Internal.Collection<any>
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.Set<V>
        containsValue(arg0: object): boolean
        put(arg0: K, arg1: V): boolean
        remove(arg0: object, arg1: object): boolean
        removeAll(arg0: object): Internal.Set<V>
        removeAll(arg0: object): Internal.Collection<any>
        entries(): Internal.Collection<any>
        entries(): Internal.Set<Internal.Map$Entry<K, V>>
        size(): number
        hashCode(): number
        putAll(arg0: Internal.Multimap<K, V>): boolean
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean
        equals(arg0: object): boolean
        get(arg0: K): Internal.Set<V>
        get(arg0: object): Internal.Collection<any>
        keySet(): Internal.Set<K>
    }
    class ProtoChunk extends Internal.ChunkAccess implements Internal.ExtendedChunk {
        handler$bbc000$onConstruct(arg0: Internal.ChunkPos, arg1: Internal.UpgradeData, arg2: Internal.LevelChunkSection[], arg3: Internal.ProtoChunkTicks<any>, arg4: Internal.ProtoChunkTicks<any>, arg5: Internal.LevelHeightAccessor, arg6: Internal.Registry<any>, arg7: Internal.BlendingData, arg8: Internal.CallbackInfo): void
    }
    interface LongStream$Builder implements Internal.LongConsumer {
        add(arg0: number): Internal.LongStream$Builder
        build(): Internal.LongStream
        andThen(arg0: Internal.LongConsumer): Internal.LongConsumer
        accept(arg0: number): void
    }
    class KeyCompressor <T> {
        decompress(arg0: number): T
        size(): number
        compress(arg0: T): number
        compress(arg0: string): number
    }
    interface RecipeManagerAccessor {
        getRecipeMap<C, T>(arg0: Internal.RecipeType<T>): Map<ResourceLocation, Internal.Recipe<C>>
    }
    interface IntIterator implements Internal.PrimitiveIterator$OfInt {
        next(): object
        next(): number
        hasNext(): boolean
        skip(arg0: number): number
        nextInt(): number
        forEachRemaining(arg0: (arg0: number) => void): void
        forEachRemaining(arg0: Internal.IntConsumer): void
        forEachRemaining(arg0: object): void
        forEachRemaining(arg0: java_.util.function_.IntConsumer): void
        remove(): void
    }
    interface IIngredientSerializer <T> {
        parse(arg0: Internal.JsonObject): T
        parse(arg0: Internal.FriendlyByteBuf): T
        write(arg0: Internal.FriendlyByteBuf, arg1: T): void
    }
    class LootContext$EntityTarget extends Internal.Enum<Internal.LootContext$EntityTarget> implements Internal.EntityTargetKJS {
        static valueOf(arg0: string): Internal.LootContext$EntityTarget
        static values(): Internal.LootContext$EntityTarget[]
        getNameKJS(): string
        static readonly DIRECT_KILLER : Internal.LootContext$EntityTarget;
        static readonly KILLER_PLAYER : Internal.LootContext$EntityTarget;
        static readonly KILLER : Internal.LootContext$EntityTarget;
        static readonly THIS : Internal.LootContext$EntityTarget;
        get nameKJS(): string;
    }
    interface BlockCachingEntity {
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listening: boolean): void
        lithiumOnBlockCacheDeleted(): void
        getCachedFeetBlockState(): Internal.BlockState
        get cachedFeetBlockState(): Internal.BlockState;
    }
    interface ModelState implements Internal.IForgeModelState {
        getPartTransformation(arg0: object): Internal.Transformation
    }
    interface LootItemCondition$Builder {
    }
    class ServerLevelJS extends Internal.LevelJS {
        getServer(): Internal.ServerJS
        getSeed(): number
        getPlayerData(arg0: Internal.Player): Internal.PlayerDataJS<any, any>
        getPlayerData(player: Internal.Player): Internal.ServerPlayerDataJS
        getSide(): Internal.ScriptType
        getEntities(filter: string): Internal.EntityArrayList
        getEntities(): Internal.EntityArrayList
        toString(): string
        setLocalTime(time: number): void
        getMinecraftLevel(): Internal.ServerLevel
        getMinecraftLevel(): Internal.Level
        setTime(time: number): void
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftLevel : Internal.Level;
        get server(): Internal.ServerJS;
        get seed(): number;
        get side(): Internal.ScriptType;
        get entities(): Internal.EntityArrayList;
        set localTime(time: number);
        set time(time: number);
    }
    interface Callable {
        call(arg0: Internal.Context, arg1: Internal.Scriptable, arg2: Internal.Scriptable, arg3: object[]): object
    }
    class StringBuilder extends Internal.AbstractStringBuilder implements Internal.Serializable, Internal.Comparable<Internal.StringBuilder>, Internal.CharSequence {
        deleteCharAt(arg0: number): Internal.AbstractStringBuilder
        deleteCharAt(arg0: number): Internal.StringBuilder
        codePointAt(arg0: number): number
        setCharAt(arg0: number, arg1: string): void
        replace(arg0: number, arg1: number, arg2: string): Internal.AbstractStringBuilder
        replace(arg0: number, arg1: number, arg2: string): Internal.StringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string): Internal.StringBuilder
        insert(arg0: number, arg1: object): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: object): Internal.StringBuilder
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.StringBuilder
        insert(arg0: number, arg1: Internal.CharSequence, arg2: number, arg3: number): Internal.StringBuilder
        insert(arg0: number, arg1: Internal.CharSequence, arg2: number, arg3: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: Internal.CharSequence): Internal.StringBuilder
        insert(arg0: number, arg1: Internal.CharSequence): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string[]): Internal.StringBuilder
        insert(arg0: number, arg1: string[]): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: boolean): Internal.StringBuilder
        insert(arg0: number, arg1: boolean): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string): Internal.StringBuilder
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuilder
        compareTo(arg0: object): number
        compareTo(arg0: Internal.StringBuilder): number
        delete(arg0: number, arg1: number): Internal.AbstractStringBuilder
        delete(arg0: number, arg1: number): Internal.StringBuilder
        substring(arg0: number, arg1: number): string
        substring(arg0: number): string
        capacity(): number
        appendCodePoint(arg0: number): Internal.StringBuilder
        appendCodePoint(arg0: number): Internal.AbstractStringBuilder
        codePointBefore(arg0: number): number
        indexOf(arg0: string): number
        indexOf(arg0: string, arg1: number): number
        codePointCount(arg0: number, arg1: number): number
        codePoints(): Internal.IntStream
        trimToSize(): void
        getChars(arg0: number, arg1: number, arg2: string[], arg3: number): void
        length(): number
        subSequence(arg0: number, arg1: number): Internal.CharSequence
        reverse(): Internal.StringBuilder
        reverse(): Internal.AbstractStringBuilder
        lastIndexOf(arg0: string, arg1: number): number
        lastIndexOf(arg0: string): number
        setLength(arg0: number): void
        toString(): string
        ensureCapacity(arg0: number): void
        chars(): Internal.IntStream
        offsetByCodePoints(arg0: number, arg1: number): number
        charAt(arg0: number): string
        append(arg0: Internal.StringBuffer): Internal.AbstractStringBuilder
        append(arg0: Internal.StringBuffer): Internal.StringBuilder
        append(arg0: Internal.CharSequence): Internal.AbstractStringBuilder
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.StringBuilder
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.AbstractStringBuilder
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.StringBuilder
        append(arg0: string[]): Internal.AbstractStringBuilder
        append(arg0: string[]): Internal.StringBuilder
        append(arg0: object): Internal.AbstractStringBuilder
        append(arg0: object): Internal.StringBuilder
        append(arg0: string): Internal.AbstractStringBuilder
        append(arg0: string): Internal.StringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.StringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.StringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.StringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.StringBuilder
        append(arg0: string): Internal.AbstractStringBuilder
        append(arg0: string): Internal.Appendable
        append(arg0: string): Internal.StringBuilder
        append(arg0: boolean): Internal.AbstractStringBuilder
        append(arg0: boolean): Internal.StringBuilder
        append(arg0: string[], arg1: number, arg2: number): Internal.AbstractStringBuilder
        append(arg0: string[], arg1: number, arg2: number): Internal.StringBuilder
    }
    class Products$P10 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> {
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>>): Internal.App<F, R>
    }
    class ConsoleJS {
        printObject(o: object, tree: boolean): void
        printObject(o: object): void
        infof(message: object, args: object[]): void
        log(message: object): void
        errorf(message: string, args: object[]): void
        setMuted(m: boolean): void
        error(message: string, throwable: Internal.Throwable): void
        error(message: object): void
        error(message: string, throwable: Internal.Throwable, skip: Internal.Pattern): void
        debugf(message: string, args: object[]): void
        trace(): void
        flush(): void
        setWriteToFile(m: boolean): void
        setLineNumber(b: boolean): void
        getScriptLine(): number
        warnf(message: string, args: object[]): void
        info(message: object): void
        group(): void
        getMuted(): boolean
        debug(message: object): void
        printStackTrace(throwable: Internal.Throwable, skip: Internal.Pattern): void
        getLogger(): Internal.Logger
        shouldPrintDebug(): boolean
        setDebugEnabled(m: boolean): void
        resetFile(): void
        warn(message: object): void
        warn(message: string, throwable: Internal.Throwable, skip: Internal.Pattern): void
        warn(message: string, throwable: Internal.Throwable): void
        getDebugEnabled(): boolean
        groupEnd(): void
        printClass(className: string, tree: boolean): void
        printClass(className: string): void
        getWriteToFile(): boolean
        static SERVER : Internal.ConsoleJS;
        static STARTUP : Internal.ConsoleJS;
        static CLIENT : Internal.ConsoleJS;
        set muted(m: boolean);
        set writeToFile(m: boolean);
        set lineNumber(b: boolean);
        get scriptLine(): number;
        get muted(): boolean;
        get logger(): Internal.Logger;
        set debugEnabled(m: boolean);
        get debugEnabled(): boolean;
        get writeToFile(): boolean;
    }
    class SpawnPlacements$Type extends Internal.Enum<Internal.SpawnPlacements$Type> implements Internal.IExtensibleEnum {
        init(): void
        canSpawnAt(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.EntityType<object>): boolean
        static valueOf(arg0: string): Internal.SpawnPlacements$Type
        static values(): Internal.SpawnPlacements$Type[]
        static create(arg0: string, arg1: Internal.TriPredicate<Internal.LevelReader, BlockPos, Internal.EntityType<Internal.Mob>>): Internal.SpawnPlacements$Type
        static readonly IN_LAVA : Internal.SpawnPlacements$Type;
        static readonly IN_WATER : Internal.SpawnPlacements$Type;
        static readonly ON_GROUND : Internal.SpawnPlacements$Type;
        static readonly NO_RESTRICTIONS : Internal.SpawnPlacements$Type;
    }
    interface Wrapper {
        static unwrapped(o: object): object
        unwrap(): object
    }
    class File implements Internal.Serializable, Internal.Comparable<Internal.File> {
        getUsableSpace(): number
        static listRoots(): Internal.File[]
        renameTo(arg0: Internal.File): boolean
        getName(): string
        setExecutable(arg0: boolean, arg1: boolean): boolean
        setExecutable(arg0: boolean): boolean
        canRead(): boolean
        getCanonicalFile(): Internal.File
        compareTo(arg0: Internal.File): number
        compareTo(arg0: object): number
        delete(): boolean
        setReadable(arg0: boolean): boolean
        setReadable(arg0: boolean, arg1: boolean): boolean
        getTotalSpace(): number
        hashCode(): number
        getParentFile(): Internal.File
        getPath(): string
        getAbsoluteFile(): Internal.File
        listFiles(arg0: Internal.FilenameFilter): Internal.File[]
        listFiles(arg0: Internal.FileFilter): Internal.File[]
        listFiles(): Internal.File[]
        mkdir(): boolean
        deleteOnExit(): void
        canExecute(): boolean
        getCanonicalPath(): string
        toURL(): Internal.URL
        getParent(): string
        setWritable(arg0: boolean): boolean
        setWritable(arg0: boolean, arg1: boolean): boolean
        isFile(): boolean
        getAbsolutePath(): string
        toURI(): Internal.URI
        getFreeSpace(): number
        length(): number
        canWrite(): boolean
        static createTempFile(arg0: string, arg1: string, arg2: Internal.File): Internal.File
        static createTempFile(arg0: string, arg1: string): Internal.File
        list(): string[]
        list(arg0: Internal.FilenameFilter): string[]
        isHidden(): boolean
        toPath(): Internal.Path
        mkdirs(): boolean
        equals(arg0: object): boolean
        exists(): boolean
        isAbsolute(): boolean
        toString(): string
        lastModified(): number
        createNewFile(): boolean
        setLastModified(arg0: number): boolean
        isDirectory(): boolean
        setReadOnly(): boolean
        static readonly pathSeparator : ";";
        static readonly pathSeparatorChar : ";";
        static readonly separatorChar : "\\";
        static readonly separator : "\\";
        get usableSpace(): number;
        get name(): string;
        set executable(arg0: boolean);
        get canonicalFile(): Internal.File;
        set readable(arg0: boolean);
        get totalSpace(): number;
        get parentFile(): Internal.File;
        get path(): string;
        get absoluteFile(): Internal.File;
        get canonicalPath(): string;
        get parent(): string;
        set writable(arg0: boolean);
        get absolutePath(): string;
        get freeSpace(): number;
    }
    interface AsKJS {
        asKJS(): object
    }
    interface IForgeBlockEntity implements Internal.ICapabilitySerializable<Internal.CompoundTag> {
        requestModelDataUpdate(): void
        serializeNBT(): net.minecraft.nbt.Tag
        serializeNBT(): Internal.CompoundTag
        getModelData(): Internal.IModelData
        getCapability<T>(arg0: Internal.Capability<T>, arg1: Internal.Direction): Internal.LazyOptional<T>
        getCapability<T>(arg0: Internal.Capability<T>): Internal.LazyOptional<T>
        getTileData(): Internal.CompoundTag
        getRenderBoundingBox(): Internal.AABB
        onChunkUnloaded(): void
        onDataPacket(arg0: Internal.Connection, arg1: Internal.ClientboundBlockEntityDataPacket): void
        deserializeNBT(arg0: net.minecraft.nbt.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        onLoad(): void
        handleUpdateTag(arg0: Internal.CompoundTag): void
        static readonly INFINITE_EXTENT_AABB : Internal.AABB;
        get modelData(): Internal.IModelData;
        get tileData(): Internal.CompoundTag;
        get renderBoundingBox(): Internal.AABB;
    }
    interface IntComparator implements Internal.Comparator<number> {
        compare(arg0: number, arg1: number): number
        compare(arg0: object, arg1: object): number
        compare(arg0: number, arg1: number): number
        thenComparingLong(arg0: Internal.ToLongFunction<T>): Internal.Comparator<T>
        thenComparingInt(arg0: Internal.ToIntFunction<T>): Internal.Comparator<T>
        thenComparing(arg0: Internal.Comparator<number>): Internal.Comparator<number>
        thenComparing(arg0: Internal.IntComparator): Internal.IntComparator
        thenComparing<U>(arg0: (arg0: T) => U, arg1: Internal.Comparator<U>): Internal.Comparator<T>
        thenComparing<U>(arg0: (arg0: T) => U): Internal.Comparator<T>
        thenComparingDouble(arg0: Internal.ToDoubleFunction<T>): Internal.Comparator<T>
        equals(arg0: object): boolean
        reversed(): Internal.IntComparator
        reversed(): Internal.Comparator<any>
    }
    class DataResult$Instance extends Internal.Enum<Internal.DataResult$Instance> implements Internal.Applicative<Internal.DataResult$Mu, Unknown> {
        static values(): Internal.DataResult$Instance[]
        point<A>(arg0: A): Internal.App<Internal.DataResult$Mu, A>
        map<T, R>(arg0: (arg0: T) => R, arg1: Internal.App<Internal.DataResult$Mu, T>): Internal.App<Internal.DataResult$Mu, R>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>): Internal.Products$P11<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>): Internal.Products$P10<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>): Internal.Products$P9<F, T1, T2, T3, T4, T5, T6, T7, T8, T9>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>, arg13: Internal.App<F, T14>, arg14: Internal.App<F, T15>, arg15: Internal.App<F, T16>): Internal.Products$P16<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>, arg13: Internal.App<F, T14>, arg14: Internal.App<F, T15>): Internal.Products$P15<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>, arg13: Internal.App<F, T14>): Internal.Products$P14<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>): Internal.Products$P13<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>): Internal.Products$P12<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
        group<T1, T2, T3>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>): Internal.Products$P3<F, T1, T2, T3>
        group<T1, T2>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>): Internal.Products$P2<F, T1, T2>
        group<T1>(arg0: Internal.App<F, T1>): Internal.Products$P1<F, T1>
        group<T1, T2, T3, T4, T5, T6, T7, T8>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        group<T1, T2, T3, T4, T5, T6, T7>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        group<T1, T2, T3, T4, T5, T6>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>
        group<T1, T2, T3, T4, T5>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>
        group<T1, T2, T3, T4>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>): Internal.Products$P4<F, T1, T2, T3, T4>
        apply2<A, B, R>(arg0: (arg0: A, arg1: B) => R, arg1: Internal.App<F, A>, arg2: Internal.App<F, B>): Internal.App<F, R>
        apply3<T1, T2, T3, R>(arg0: Internal.Function3<T1, T2, T3, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>): Internal.App<F, R>
        apply4<T1, T2, T3, T4, R>(arg0: Internal.Function4<T1, T2, T3, T4, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>): Internal.App<F, R>
        ap11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>(arg0: Internal.App<F, Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>): Internal.App<F, R>
        ap2<A, B, R>(arg0: Internal.App<Internal.DataResult$Mu, (arg0: A, arg1: B) => R>, arg1: Internal.App<Internal.DataResult$Mu, A>, arg2: Internal.App<Internal.DataResult$Mu, B>): Internal.App<Internal.DataResult$Mu, R>
        apply5<T1, T2, T3, T4, T5, R>(arg0: Internal.Function5<T1, T2, T3, T4, T5, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>): Internal.App<F, R>
        ap10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>(arg0: Internal.App<F, Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>): Internal.App<F, R>
        ap4<T1, T2, T3, T4, R>(arg0: Internal.App<F, Internal.Function4<T1, T2, T3, T4, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>): Internal.App<F, R>
        lift2<A, B, R>(arg0: Internal.App<F, (arg0: A, arg1: B) => R>): (arg0: Internal.App<F, A>, arg1: Internal.App<F, B>) => Internal.App<F, R>
        ap3<T1, T2, T3, R>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function3<T1, T2, T3, R>>, arg1: Internal.App<Internal.DataResult$Mu, T1>, arg2: Internal.App<Internal.DataResult$Mu, T2>, arg3: Internal.App<Internal.DataResult$Mu, T3>): Internal.App<Internal.DataResult$Mu, R>
        lift1<A, R>(arg0: Internal.App<Internal.DataResult$Mu, (arg0: A) => R>): (arg0: Internal.App<Internal.DataResult$Mu, A>) => Internal.App<Internal.DataResult$Mu, R>
        ap6<T1, T2, T3, T4, T5, T6, R>(arg0: Internal.App<F, Internal.Function6<T1, T2, T3, T4, T5, T6, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>): Internal.App<F, R>
        static valueOf(arg0: string): Internal.DataResult$Instance
        ap5<T1, T2, T3, T4, T5, R>(arg0: Internal.App<F, Internal.Function5<T1, T2, T3, T4, T5, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>): Internal.App<F, R>
        ap8<T1, T2, T3, T4, T5, T6, T7, T8, R>(arg0: Internal.App<F, Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>): Internal.App<F, R>
        lift6<T1, T2, T3, T4, T5, T6, R>(arg0: Internal.App<F, Internal.Function6<T1, T2, T3, T4, T5, T6, R>>): Internal.Function6<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, R>>
        lift5<T1, T2, T3, T4, T5, R>(arg0: Internal.App<F, Internal.Function5<T1, T2, T3, T4, T5, R>>): Internal.Function5<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, R>>
        ap7<T1, T2, T3, T4, T5, T6, T7, R>(arg0: Internal.App<F, Internal.Function7<T1, T2, T3, T4, T5, T6, T7, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>): Internal.App<F, R>
        lift4<T1, T2, T3, T4, R>(arg0: Internal.App<F, Internal.Function4<T1, T2, T3, T4, R>>): Internal.Function4<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, R>>
        ap9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>(arg0: Internal.App<F, Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>): Internal.App<F, R>
        lift3<T1, T2, T3, R>(arg0: Internal.App<F, Internal.Function3<T1, T2, T3, R>>): Internal.Function3<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, R>>
        apply6<T1, T2, T3, T4, T5, T6, R>(arg0: Internal.Function6<T1, T2, T3, T4, T5, T6, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>): Internal.App<F, R>
        apply7<T1, T2, T3, T4, T5, T6, T7, R>(arg0: Internal.Function7<T1, T2, T3, T4, T5, T6, T7, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>): Internal.App<F, R>
        lift9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>(arg0: Internal.App<F, Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>): Internal.Function9<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, T7>, Internal.App<F, T8>, Internal.App<F, T9>, Internal.App<F, R>>
        apply8<T1, T2, T3, T4, T5, T6, T7, T8, R>(arg0: Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>): Internal.App<F, R>
        lift8<T1, T2, T3, T4, T5, T6, T7, T8, R>(arg0: Internal.App<F, Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>>): Internal.Function8<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, T7>, Internal.App<F, T8>, Internal.App<F, R>>
        apply9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>(arg0: Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>): Internal.App<F, R>
        lift7<T1, T2, T3, T4, T5, T6, T7, R>(arg0: Internal.App<F, Internal.Function7<T1, T2, T3, T4, T5, T6, T7, R>>): Internal.Function7<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, T7>, Internal.App<F, R>>
        ap<A, R>(arg0: Internal.App<Internal.DataResult$Mu, (arg0: A) => R>, arg1: Internal.App<Internal.DataResult$Mu, A>): Internal.App<Internal.DataResult$Mu, R>
        ap<A, R>(arg0: (arg0: A) => R, arg1: Internal.App<F, A>): Internal.App<F, R>
        ap16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>(arg0: Internal.App<F, Internal.Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>, arg12: Internal.App<F, T12>, arg13: Internal.App<F, T13>, arg14: Internal.App<F, T14>, arg15: Internal.App<F, T15>, arg16: Internal.App<F, T16>): Internal.App<F, R>
        ap13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>(arg0: Internal.App<F, Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>, arg12: Internal.App<F, T12>, arg13: Internal.App<F, T13>): Internal.App<F, R>
        ap12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>(arg0: Internal.App<F, Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>, arg12: Internal.App<F, T12>): Internal.App<F, R>
        ap15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>(arg0: Internal.App<F, Internal.Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>, arg12: Internal.App<F, T12>, arg13: Internal.App<F, T13>, arg14: Internal.App<F, T14>, arg15: Internal.App<F, T15>): Internal.App<F, R>
        ap14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>(arg0: Internal.App<F, Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>, arg12: Internal.App<F, T12>, arg13: Internal.App<F, T13>, arg14: Internal.App<F, T14>): Internal.App<F, R>
        static readonly INSTANCE : Internal.DataResult$Instance;
    }
    interface ItemColorsExtended {
        getColorProvider(arg0: Internal.ItemStack): Internal.ItemColor
    }
    interface SeekableByteChannel implements Internal.ByteChannel {
        isOpen(): boolean
        read(arg0: Internal.ByteBuffer): number
        truncate(arg0: number): Internal.SeekableByteChannel
        size(): number
        position(): number
        position(arg0: number): Internal.SeekableByteChannel
        close(): void
        write(arg0: Internal.ByteBuffer): number
    }
    interface Function7 <T1, T2, T3, T4, T5, T6, T7, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7): R
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, (arg0: T6, arg1: T7) => R>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, (arg0: T7) => R>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function4<T4, T5, T6, T7, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function3<T5, T6, T7, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function5<T3, T4, T5, T6, T7, R>
        curry(): (arg0: T1) => Internal.Function6<T2, T3, T4, T5, T6, T7, R>
    }
    interface VertexType <T> {
        createFallbackWriter(arg0: Internal.VertexConsumer): T
        asBlittable(): Internal.BlittableVertexType<T>
    }
    class CountingMap {
        add(key: object, value: number): number
        getSize(): number
        set(key: object, value: number): number
        getValues(): Internal.Collection<number>
        getEntries(): Internal.List<Internal.Object2LongEntry>
        forEach(forEach: (arg0: Internal.Object2LongEntry) => void): void
        get(key: object): number
        clear(): void
        getTotalCount(): number
        getKeys(): Internal.Set<object>
        get size(): number;
        get values(): Internal.Collection<number>;
        get entries(): Internal.List<Internal.Object2LongEntry>;
        get totalCount(): number;
        get keys(): Internal.Set<object>;
    }
    class DataResult <R> implements Internal.App<Internal.DataResult$Mu, R> {
        apply2<R2, S>(arg0: (arg0: R, arg1: R2) => S, arg1: Internal.DataResult<R2>): Internal.DataResult<S>
        apply3<R2, R3, S>(arg0: Internal.Function3<R, R2, R3, S>, arg1: Internal.DataResult<R2>, arg2: Internal.DataResult<R3>): Internal.DataResult<S>
        static instance(): Internal.DataResult$Instance
        setPartial(arg0: R): Internal.DataResult<R>
        setPartial(arg0: () => R): Internal.DataResult<R>
        addLifecycle(arg0: Internal.Lifecycle): Internal.DataResult<R>
        static partialGet<K, V>(arg0: (arg0: K) => V, arg1: () => string): (arg0: K) => Internal.DataResult<V>
        static error<R>(arg0: string, arg1: R, arg2: Internal.Lifecycle): Internal.DataResult<R>
        error(): Internal.Optional<Internal.DataResult$PartialResult<R>>
        static error<R>(arg0: string): Internal.DataResult<R>
        static error<R>(arg0: string, arg1: Internal.Lifecycle): Internal.DataResult<R>
        static error<R>(arg0: string, arg1: R): Internal.DataResult<R>
        apply2stable<R2, S>(arg0: (arg0: R, arg1: R2) => S, arg1: Internal.DataResult<R2>): Internal.DataResult<S>
        promotePartial(arg0: (arg0: string) => void): Internal.DataResult<R>
        ap<R2>(arg0: Internal.DataResult<(arg0: R) => R2>): Internal.DataResult<R2>
        lifecycle(): Internal.Lifecycle
        flatMap<R2>(arg0: (arg0: R) => Internal.DataResult<R2>): Internal.DataResult<R2>
        result(): Internal.Optional<R>
        mapError(arg0: Internal.UnaryOperator<string>): Internal.DataResult<R>
        setLifecycle(arg0: Internal.Lifecycle): Internal.DataResult<R>
        static success<R>(arg0: R): Internal.DataResult<R>
        static success<R>(arg0: R, arg1: Internal.Lifecycle): Internal.DataResult<R>
        static unbox<R>(arg0: Internal.App<Internal.DataResult$Mu, R>): Internal.DataResult<R>
        hashCode(): number
        getOrThrow(arg0: boolean, arg1: (arg0: string) => void): R
        equals(arg0: object): boolean
        get(): Internal.Either<R, Internal.DataResult$PartialResult<R>>
        toString(): string
        map<T>(arg0: (arg0: R) => T): Internal.DataResult<T>
        resultOrPartial(arg0: (arg0: string) => void): Internal.Optional<R>
        set partial(arg0: R);
        set partial(arg0: () => R);
    }
    class ModelGenerator {
        parent(s: string): void
        toJson(): Internal.JsonObject
        textures(json: Internal.JsonObject): void
        texture(name: string, texture: string): void
        element(consumer: (arg0: Internal.ModelGenerator$Element) => void): void
    }
    interface IForgeMobEffectInstance {
        writeCurativeItems(arg0: Internal.CompoundTag): void
        addCurativeItem(arg0: Internal.ItemStack): void
        setCurativeItems(arg0: Internal.List<Internal.ItemStack>): void
        isCurativeItem(arg0: Internal.ItemStack): boolean
        getCurativeItems(): Internal.List<Internal.ItemStack>
        set curativeItems(arg0: Internal.List<Internal.ItemStack>);
        get curativeItems(): Internal.List<Internal.ItemStack>;
    }
    class MobEffect extends Internal.ForgeRegistryEntry<Internal.MobEffect> implements Internal.IForgeMobEffect {
        getTags(): Internal.Set<ResourceLocation>
        is(arg0: Internal.Tag<Internal.MobEffect>): boolean
        initializeClient(arg0: (arg0: Internal.EffectRenderer) => void): void
        getCurativeItems(): Internal.List<Internal.ItemStack>
        getEffectRendererInternal(): object
        getSortOrder(arg0: Internal.MobEffectInstance): number
        readonly delegate : () => V;
        get tags(): Internal.Set<ResourceLocation>;
        get curativeItems(): Internal.List<Internal.ItemStack>;
        get effectRendererInternal(): object;
    }
    class Explosion implements Internal.ExplosionAccess {
        getPosition(): Vec3
        getExploder(): Internal.Entity
        redirect$zoi000$collectBlocks(affectedBlocks: Internal.List<any>, collection: Internal.Collection<any>): boolean
        static callAddBlockDrops_$md$8422c5$0(arg0: Internal.ObjectArrayList<any>, arg1: Internal.ItemStack, arg2: BlockPos): void
        redirect$zoi000$skipNewHashSet(): Internal.HashSet<any>
        constant$zoi000$skipLoop(prevValue: number): number
        get position(): Vec3;
        get exploder(): Internal.Entity;
    }
    interface IForgeRegistry <V> implements Internal.Iterable<V> {
        getKey(arg0: V): ResourceLocation
        getCodec(): Internal.Codec<V>
        getValues(): Internal.Collection<V>
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
        registerAll(arg0: V[]): void
        containsKey(arg0: ResourceLocation): boolean
        getDefaultKey(): ResourceLocation
        isEmpty(): boolean
        getRegistryName(): ResourceLocation
        getRegistrySuperType(): Internal.Class<V>
        getKeys(): Internal.Set<ResourceLocation>
        getSlaveMap<T>(arg0: ResourceLocation, arg1: Internal.Class<T>): T
        containsValue(arg0: V): boolean
        getResourceKey(arg0: V): Internal.Optional<Internal.ResourceKey<V>>
        getValue(arg0: ResourceLocation): V
        iterator(): Internal.Iterator<T>
        getEntries(): Internal.Set<Internal.Map$Entry<Internal.ResourceKey<V>, V>>
        register(arg0: V): void
        get codec(): Internal.Codec<V>;
        get values(): Internal.Collection<V>;
        get defaultKey(): ResourceLocation;
        get registryName(): ResourceLocation;
        get registrySuperType(): Internal.Class<V>;
        get keys(): Internal.Set<ResourceLocation>;
        get entries(): Internal.Set<Internal.Map$Entry<Internal.ResourceKey<V>, V>>;
    }
    interface IEventListener {
        listenerName(): string
        invoke(arg0: Internal.Event): void
    }
    class FileChannel$MapMode {
        toString(): string
        static readonly READ_ONLY : Internal.FileChannel$MapMode;
        static readonly READ_WRITE : Internal.FileChannel$MapMode;
        static readonly PRIVATE : Internal.FileChannel$MapMode;
    }
    interface Byte2ObjectFunction <V> implements Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: number, arg1: V): V
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Object2ShortFunction<V>): Internal.Byte2ShortFunction
        composeByte(arg0: Internal.Byte2ByteFunction): Internal.Byte2ObjectFunction<V>
        andThenInt(arg0: Internal.Object2IntFunction<V>): Internal.Byte2IntFunction
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: Internal.Reference2ByteFunction<T>): (arg0: T) => V
        put(arg0: number, arg1: V): V
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: object): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: Internal.Object2DoubleFunction<V>): Internal.Byte2DoubleFunction
        andThenObject<T>(arg0: (arg0: V) => T): Internal.Byte2ObjectFunction<T>
        get(arg0: object): V
        get(arg0: number): V
        andThenLong(arg0: Internal.Object2LongFunction<V>): Internal.Byte2LongFunction
        composeLong(arg0: Internal.Long2ByteFunction): Internal.Long2ObjectFunction<V>
        andThenByte(arg0: Internal.Object2ByteFunction<V>): Internal.Byte2ByteFunction
        andThenFloat(arg0: Internal.Object2FloatFunction<V>): Internal.Byte2FloatFunction
        apply(arg0: number): V
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ByteFunction): Internal.Int2ObjectFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2ByteFunction): Internal.Float2ObjectFunction<V>
        andThenChar(arg0: Internal.Object2CharFunction<V>): Internal.Byte2CharFunction
        composeObject<T>(arg0: Internal.Object2ByteFunction<T>): (arg0: T) => V
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => V
        composeShort(arg0: Internal.Short2ByteFunction): Internal.Short2ObjectFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): Internal.Byte2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ByteFunction): Internal.Char2ObjectFunction<V>
        composeDouble(arg0: Internal.Double2ByteFunction): Internal.Double2ObjectFunction<V>
    }
    class ScriptFileInfo {
        getPackMode(): string
        getProperty(s: string, def: string): string
        getPriority(): number
        preload(source: Internal.ScriptSource): Internal.Throwable
        isIgnored(): boolean
        readonly file : string;
        readonly location : string;
        readonly id : ResourceLocation;
        readonly pack : Internal.ScriptPackInfo;
        get packMode(): string;
        get priority(): number;
    }
    interface LongPredicate {
        or(arg0: Internal.LongPredicate): Internal.LongPredicate
        test(arg0: number): boolean
        and(arg0: Internal.LongPredicate): Internal.LongPredicate
        negate(): Internal.LongPredicate
    }
    class Style {
        hashCode(): number
        equals(arg0: object): boolean
        setObfuscated(arg0: boolean): Internal.Style
        toString(): string
        setUnderlined(arg0: boolean): Internal.Style
        setStrikethrough(arg0: boolean): Internal.Style
        set obfuscated(arg0: boolean);
        set underlined(arg0: boolean);
        set strikethrough(arg0: boolean);
    }
    interface Byte2ByteFunction implements Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Byte2ShortFunction): Internal.Byte2ShortFunction
        composeByte(arg0: Internal.Byte2ByteFunction): Internal.Byte2ByteFunction
        andThenInt(arg0: Internal.Byte2IntFunction): Internal.Byte2IntFunction
        composeReference<T>(arg0: Internal.Reference2ByteFunction<T>): Internal.Reference2ByteFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Byte2DoubleFunction): Internal.Byte2DoubleFunction
        andThenObject<T>(arg0: Internal.Byte2ObjectFunction<T>): Internal.Byte2ObjectFunction<T>
        static identity(): Internal.Byte2ByteFunction
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Byte2LongFunction): Internal.Byte2LongFunction
        composeLong(arg0: Internal.Long2ByteFunction): Internal.Long2ByteFunction
        andThenByte(arg0: Internal.Byte2ByteFunction): Internal.Byte2ByteFunction
        andThenFloat(arg0: Internal.Byte2FloatFunction): Internal.Byte2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ByteFunction): Internal.Int2ByteFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ByteFunction): Internal.Float2ByteFunction
        andThenChar(arg0: Internal.Byte2CharFunction): Internal.Byte2CharFunction
        composeObject<T>(arg0: Internal.Object2ByteFunction<T>): Internal.Object2ByteFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2ByteFunction): Internal.Short2ByteFunction
        andThenReference<T>(arg0: Internal.Byte2ReferenceFunction<T>): Internal.Byte2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ByteFunction): Internal.Char2ByteFunction
        composeDouble(arg0: Internal.Double2ByteFunction): Internal.Double2ByteFunction
    }
    class IntBuffer extends Internal.Buffer implements Internal.Comparable<Internal.IntBuffer> {
        hasArray(): boolean
        compact(): Internal.IntBuffer
        clear(): Internal.Buffer
        clear(): Internal.IntBuffer
        duplicate(): Internal.IntBuffer
        duplicate(): Internal.Buffer
        compareTo(arg0: object): number
        compareTo(arg0: Internal.IntBuffer): number
        asReadOnlyBuffer(): Internal.IntBuffer
        put(arg0: number[]): Internal.IntBuffer
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.IntBuffer
        put(arg0: number, arg1: number[]): Internal.IntBuffer
        put(arg0: number[], arg1: number, arg2: number): Internal.IntBuffer
        put(arg0: number, arg1: Internal.IntBuffer, arg2: number, arg3: number): Internal.IntBuffer
        put(arg0: Internal.IntBuffer): Internal.IntBuffer
        put(arg0: number, arg1: number): Internal.IntBuffer
        put(arg0: number): Internal.IntBuffer
        static allocate(arg0: number): Internal.IntBuffer
        rewind(): Internal.Buffer
        rewind(): Internal.IntBuffer
        slice(): Internal.Buffer
        slice(): Internal.IntBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.IntBuffer
        array(): number[]
        array(): object
        hashCode(): number
        mismatch(arg0: Internal.IntBuffer): number
        equals(arg0: object): boolean
        get(): number
        get(arg0: number, arg1: number[]): Internal.IntBuffer
        get(arg0: number): number
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.IntBuffer
        get(arg0: number[], arg1: number, arg2: number): Internal.IntBuffer
        get(arg0: number[]): Internal.IntBuffer
        limit(arg0: number): Internal.IntBuffer
        limit(arg0: number): Internal.Buffer
        reset(): Internal.Buffer
        reset(): Internal.IntBuffer
        arrayOffset(): number
        toString(): string
        position(arg0: number): Internal.IntBuffer
        position(arg0: number): Internal.Buffer
        flip(): Internal.Buffer
        flip(): Internal.IntBuffer
        isDirect(): boolean
        static wrap(arg0: number[]): Internal.IntBuffer
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.IntBuffer
        mark(): Internal.Buffer
        mark(): Internal.IntBuffer
        order(): Internal.ByteOrder
    }
    interface Reference2DoubleFunction <K> implements Internal.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: number): number
        applyAsDouble(arg0: K): number
        andThenShort(arg0: Internal.Double2ShortFunction): Internal.Reference2ShortFunction<K>
        getDouble(arg0: object): number
        composeByte(arg0: Internal.Byte2ReferenceFunction<K>): Internal.Byte2DoubleFunction
        andThenInt(arg0: Internal.Double2IntFunction): Internal.Reference2IntFunction<K>
        composeReference<T>(arg0: (arg0: T) => K): Internal.Reference2DoubleFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: K) => T
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: object, arg1: object): object
        remove(arg0: object): number
        remove(arg0: object): object
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: Internal.Double2DoubleFunction): Internal.Reference2DoubleFunction<K>
        andThenObject<T>(arg0: Internal.Double2ObjectFunction<T>): (arg0: K) => T
        get(arg0: object): object
        get(arg0: object): number
        andThenLong(arg0: Internal.Double2LongFunction): Internal.Reference2LongFunction<K>
        composeLong(arg0: Internal.Long2ReferenceFunction<K>): Internal.Long2DoubleFunction
        andThenByte(arg0: Internal.Double2ByteFunction): Internal.Reference2ByteFunction<K>
        andThenFloat(arg0: Internal.Double2FloatFunction): Internal.Reference2FloatFunction<K>
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ReferenceFunction<K>): Internal.Int2DoubleFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ReferenceFunction<K>): Internal.Float2DoubleFunction
        andThenChar(arg0: Internal.Double2CharFunction): Internal.Reference2CharFunction<K>
        composeObject<T>(arg0: (arg0: T) => K): Internal.Object2DoubleFunction<T>
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        removeDouble(arg0: object): number
        composeShort(arg0: Internal.Short2ReferenceFunction<K>): Internal.Short2DoubleFunction
        andThenReference<T>(arg0: Internal.Double2ReferenceFunction<T>): (arg0: K) => T
        composeChar(arg0: Internal.Char2ReferenceFunction<K>): Internal.Char2DoubleFunction
        composeDouble(arg0: Internal.Double2ReferenceFunction<K>): Internal.Double2DoubleFunction
    }
    class ScreenPainterObject extends Internal.PainterObject {
        preDraw(event: Internal.ScreenPaintEventJS): void
        draw(arg0: Internal.ScreenPaintEventJS): void
        parent : Internal.PainterObjectStorage;
        visible : boolean;
        w : dev.latvian.mods.rhino.util.unit.Unit;
        x : dev.latvian.mods.rhino.util.unit.Unit;
        h : dev.latvian.mods.rhino.util.unit.Unit;
        y : dev.latvian.mods.rhino.util.unit.Unit;
        z : dev.latvian.mods.rhino.util.unit.Unit;
        alignX : number;
        id : string;
        alignY : number;
    }
    class Certificate implements Internal.Serializable {
        getType(): string
        getEncoded(): number[]
        hashCode(): number
        equals(arg0: object): boolean
        verify(arg0: Internal.PublicKey): void
        verify(arg0: Internal.PublicKey, arg1: string): void
        verify(arg0: Internal.PublicKey, arg1: Internal.Provider): void
        toString(): string
        getPublicKey(): Internal.PublicKey
        get type(): string;
        get encoded(): number[];
        get publicKey(): Internal.PublicKey;
    }
    interface DoubleBinaryOperator {
        applyAsDouble(arg0: number, arg1: number): number
    }
    interface SerializableTickContainer <T> {
    }
    interface Long2IntFunction implements Internal.Function<number, number>, Internal.LongToIntFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Int2ShortFunction): Internal.Long2ShortFunction
        composeByte(arg0: Internal.Byte2LongFunction): Internal.Byte2IntFunction
        andThenInt(arg0: Internal.Int2IntFunction): Internal.Long2IntFunction
        composeReference<T>(arg0: Internal.Reference2LongFunction<T>): Internal.Reference2IntFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Int2DoubleFunction): Internal.Long2DoubleFunction
        andThenObject<T>(arg0: Internal.Int2ObjectFunction<T>): Internal.Long2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Int2LongFunction): Internal.Long2LongFunction
        composeLong(arg0: Internal.Long2LongFunction): Internal.Long2IntFunction
        andThenByte(arg0: Internal.Int2ByteFunction): Internal.Long2ByteFunction
        andThenFloat(arg0: Internal.Int2FloatFunction): Internal.Long2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2LongFunction): Internal.Int2IntFunction
        clear(): void
        composeFloat(arg0: Internal.Float2LongFunction): Internal.Float2IntFunction
        andThenChar(arg0: Internal.Int2CharFunction): Internal.Long2CharFunction
        composeObject<T>(arg0: Internal.Object2LongFunction<T>): Internal.Object2IntFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2LongFunction): Internal.Short2IntFunction
        andThenReference<T>(arg0: Internal.Int2ReferenceFunction<T>): Internal.Long2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2LongFunction): Internal.Char2IntFunction
        composeDouble(arg0: Internal.Double2LongFunction): Internal.Double2IntFunction
    }
    class Unit extends Internal.Enum<Internal.Unit> {
        static valueOf(arg0: string): Internal.Unit
        static values(): Internal.Unit[]
        toString(): string
        static readonly INSTANCE : Internal.Unit;
    }
    class PainterObjectStorage {
        createScreenObjects(): Internal.ScreenPainterObject[]
        getObject(key: string): Internal.PainterObject
        createWorldObjects(): Internal.WorldPainterObject[]
        clear(): void
        handle(root: Internal.CompoundTag): void
        remove(id: string): void
        getObjects(): Internal.Collection<Internal.PainterObject>
        get objects(): Internal.Collection<Internal.PainterObject>;
    }
    class Matcher implements Internal.MatchResult {
        hasTransparentBounds(): boolean
        requireEnd(): boolean
        useTransparentBounds(arg0: boolean): Internal.Matcher
        pattern(): Internal.Pattern
        replaceFirst(arg0: string): string
        replaceFirst(arg0: (arg0: Internal.MatchResult) => string): string
        regionStart(): number
        replaceAll(arg0: (arg0: Internal.MatchResult) => string): string
        replaceAll(arg0: string): string
        lookingAt(): boolean
        toMatchResult(): Internal.MatchResult
        static quoteReplacement(arg0: string): string
        find(): boolean
        find(arg0: number): boolean
        end(arg0: string): number
        end(arg0: number): number
        end(): number
        results(): Internal.Stream<Internal.MatchResult>
        group(arg0: string): string
        group(arg0: number): string
        group(): string
        start(arg0: number): number
        start(): number
        start(arg0: string): number
        regionEnd(): number
        matches(): boolean
        hasAnchoringBounds(): boolean
        appendReplacement(arg0: Internal.StringBuffer, arg1: string): Internal.Matcher
        appendReplacement(arg0: Internal.StringBuilder, arg1: string): Internal.Matcher
        appendTail(arg0: Internal.StringBuffer): Internal.StringBuffer
        appendTail(arg0: Internal.StringBuilder): Internal.StringBuilder
        groupCount(): number
        reset(): Internal.Matcher
        reset(arg0: Internal.CharSequence): Internal.Matcher
        toString(): string
        region(arg0: number, arg1: number): Internal.Matcher
        useAnchoringBounds(arg0: boolean): Internal.Matcher
        hitEnd(): boolean
        usePattern(arg0: Internal.Pattern): Internal.Matcher
    }
    class BuilderBase {
        translationKey(key: string): Internal.BuilderBase
        getBuilderType(): string
        newID(pre: string, post: string): ResourceLocation
        displayName(name: string): Internal.BuilderBase
        tag(tag: ResourceLocation): Internal.BuilderBase
        readonly id : ResourceLocation;
        defaultTags : Internal.Set<ResourceLocation>;
        get builderType(): string;
    }
    class AndConditionBuilder implements Internal.ConditionsContainer<Internal.AndConditionBuilder> {
        killerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B
        survivesExplosion(): B
        addCondition(arg0: Internal.LootItemCondition): Internal.ConditionsContainer<any>
        addCondition(arg0: Internal.LootItemCondition): Internal.AndConditionBuilder
        addCondition(arg0: Internal.LootItemCondition$Builder): B
        customDistanceToPlayer(arg0: (arg0: Internal.DistancePredicateBuilder) => void): B
        matchFluid(arg0: string): B
        not(arg0: (arg0: Internal.NotConditionBuilder) => void): B
        directKillerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B
        matchEquip(arg0: EquipmentSlot, arg1: Internal.IngredientJS): B
        and(arg0: (arg0: Internal.AndConditionBuilder) => void): B
        matchLoot(arg0: Internal.IngredientJS): B
        matchLoot(arg0: Internal.IngredientJS, arg1: boolean): B
        anyBiome(arg0: string[]): B
        distanceToKiller(arg0: Internal.MinMaxBounds$Doubles): B
        entityPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B
        matchEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        anyDimension(arg0: ResourceLocation[]): B
        killedByPlayer(): B
        or(arg0: (arg0: Internal.OrConditionBuilder) => void): B
        timeCheck(arg0: number, arg1: number, arg2: number): B
        timeCheck(arg0: number, arg1: number): B
        matchOffHand(arg0: Internal.IngredientJS): B
        randomChance(arg0: number): B
        playerPredicate(arg0: (arg0: Internal.PlayerJS<object>) => boolean): B
        weatherCheck(arg0: Map<string, boolean>): B
        matchDirectKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        matchBlockState(arg0: Internal.Block, arg1: Map<string, string>): B
        matchMainHand(arg0: Internal.IngredientJS): B
        matchPlayer(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        lightLevel(arg0: number, arg1: number): B
        build(): Internal.AndCondition
        biome(arg0: string[]): B
        customCondition(arg0: Internal.JsonObject): B
        matchKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        randomChanceWithLooting(arg0: number, arg1: number): B
        hasAnyStage(arg0: string[]): B
        randomChanceWithEnchantment(arg0: Internal.Enchantment, arg1: number[]): B
        anyStructure(arg0: ResourceLocation[], arg1: boolean): B
        matchDamageSource(arg0: (arg0: Internal.DamageSourcePredicateBuilderJS) => void): B
    }
    class ZoneOffset extends Internal.ZoneId implements Internal.TemporalAccessor, Internal.TemporalAdjuster, Internal.Comparable<Internal.ZoneOffset>, Internal.Serializable {
        getTotalSeconds(): number
        static ofHoursMinutes(arg0: number, arg1: number): Internal.ZoneOffset
        query<R>(arg0: Internal.TemporalQuery<R>): R
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        getId(): string
        isSupported(arg0: Internal.TemporalField): boolean
        compareTo(arg0: Internal.ZoneOffset): number
        compareTo(arg0: object): number
        getLong(arg0: Internal.TemporalField): number
        static ofHours(arg0: number): Internal.ZoneOffset
        hashCode(): number
        static of(arg0: string): Internal.ZoneOffset
        equals(arg0: object): boolean
        get(arg0: Internal.TemporalField): number
        static from(arg0: Internal.TemporalAccessor): Internal.ZoneOffset
        toString(): string
        getRules(): Internal.ZoneRules
        static ofHoursMinutesSeconds(arg0: number, arg1: number, arg2: number): Internal.ZoneOffset
        static ofTotalSeconds(arg0: number): Internal.ZoneOffset
        static readonly MIN : Internal.ZoneOffset;
        static readonly UTC : Internal.ZoneOffset;
        static readonly MAX : Internal.ZoneOffset;
        static readonly SHORT_IDS : Map<string, string>;
        get totalSeconds(): number;
        get id(): string;
        get rules(): Internal.ZoneRules;
    }
    interface MessageSender {
        setStatusMessage(message: Internal.Component): void
        getName(): Internal.Text
        getDisplayName(): Internal.Text
        tell(arg0: Internal.Component): void
        runCommand(arg0: string): number
        runCommandSilent(command: string): number
        set statusMessage(message: Internal.Component);
        get name(): Internal.Text;
        get displayName(): Internal.Text;
    }
    class AbstractObjectList <K> extends Internal.AbstractObjectCollection<K> implements Internal.ObjectList<K>, Internal.Stack<K> {
        compareTo(arg0: object): number
        compareTo(arg0: Internal.List<K>): number
        replaceAll(arg0: Internal.UnaryOperator<E>): void
        remove(arg0: number): K
        pop(): K
        iterator(): Internal.Iterator<any>
        iterator(): Internal.ObjectListIterator<K>
        iterator(): Internal.ObjectIterator<any>
        top(): K
        addElements(arg0: number, arg1: K[]): void
        addElements(arg0: number, arg1: K[], arg2: number, arg3: number): void
        hashCode(): number
        get(arg0: number): E
        toArray<T>(arg0: T[]): T[]
        toArray(): object[]
        indexOf(arg0: object): number
        add(arg0: K): boolean
        add(arg0: number, arg1: K): void
        subList(arg0: number, arg1: number): Internal.List<any>
        subList(arg0: number, arg1: number): Internal.ObjectList<K>
        set(arg0: number, arg1: K): K
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.ObjectSpliterator<K>
        forEach(arg0: (arg0: K) => void): void
        clear(): void
        setElements(arg0: number, arg1: K[], arg2: number, arg3: number): void
        setElements(arg0: K[]): void
        setElements(arg0: number, arg1: K[]): void
        sort(arg0: Internal.Comparator<K>): void
        removeElements(arg0: number, arg1: number): void
        push(arg0: K): void
        peek(arg0: number): K
        lastIndexOf(arg0: object): number
        contains(arg0: object): boolean
        size(arg0: number): void
        addAll(arg0: number, arg1: Internal.Collection<K>): boolean
        addAll(arg0: Internal.Collection<K>): boolean
        addAll(arg0: Internal.ObjectList<K>): boolean
        addAll(arg0: number, arg1: Internal.ObjectList<K>): boolean
        getElements(arg0: number, arg1: object[], arg2: number, arg3: number): void
        equals(arg0: object): boolean
        listIterator(arg0: number): Internal.ListIterator<any>
        listIterator(arg0: number): Internal.ObjectListIterator<K>
        listIterator(): Internal.ObjectListIterator<K>
        listIterator(): Internal.ListIterator<any>
        toString(): string
        unstableSort(arg0: Internal.Comparator<K>): void
        set elements(arg0: K[]);
    }
    class ProtectionDomain {
        getPermissions(): Internal.PermissionCollection
        getClassLoader(): Internal.ClassLoader
        toString(): string
        getPrincipals(): Internal.Principal[]
        implies(arg0: Internal.Permission): boolean
        staticPermissionsOnly(): boolean
        getCodeSource(): Internal.CodeSource
        get permissions(): Internal.PermissionCollection;
        get classLoader(): Internal.ClassLoader;
        get principals(): Internal.Principal[];
        get codeSource(): Internal.CodeSource;
    }
    interface ProfilerMeasured {
    }
    class ModuleDescriptor$Exports$Modifier extends Internal.Enum<Internal.ModuleDescriptor$Exports$Modifier> {
        static valueOf(arg0: string): Internal.ModuleDescriptor$Exports$Modifier
        static values(): Internal.ModuleDescriptor$Exports$Modifier[]
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Exports$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Exports$Modifier;
    }
    interface IdEnumerationIterator {
        enumerationIteratorNext(arg0: Internal.Context, arg1: (arg0: object) => void): boolean
        enumerationIteratorHasNext(arg0: Internal.Context, arg1: (arg0: object) => void): boolean
    }
    interface ObjectIterator <K> implements Internal.Iterator<K> {
        next(): E
        hasNext(): boolean
        skip(arg0: number): number
        forEachRemaining(arg0: (arg0: E) => void): void
        remove(): void
    }
    interface StructType <S> {
        getLayout(): Internal.BufferLayout
        create(): S
        get layout(): Internal.BufferLayout;
    }
    class ConditionalFunction implements Internal.FunctionContainer, Internal.ConditionContainer {
        damage(damage: Internal.NumberProvider): Internal.FunctionContainer
        nbt(tag: Internal.CompoundTag): Internal.FunctionContainer
        enchantWithLevels(levels: Internal.NumberProvider, treasure: boolean): Internal.FunctionContainer
        survivesExplosion(): Internal.ConditionContainer
        killedByPlayer(): Internal.ConditionContainer
        randomChance(chance: number): Internal.ConditionContainer
        addFunction(arg0: Internal.JsonObject): Internal.FunctionContainer
        addFunction(o: Internal.JsonObject): Internal.ConditionalFunction
        count(count: Internal.NumberProvider): Internal.FunctionContainer
        addConditionalFunction(func: (arg0: Internal.ConditionalFunction) => void): Internal.FunctionContainer
        addCondition(arg0: Internal.JsonObject): Internal.ConditionContainer
        addCondition(o: Internal.JsonObject): Internal.ConditionalFunction
        lootingEnchant(count: Internal.NumberProvider, limit: number): Internal.FunctionContainer
        lootTable(table: ResourceLocation, seed: number): Internal.FunctionContainer
        entityScores(entity: Internal.LootContext$EntityTarget, scores: Map<string, object>): Internal.ConditionContainer
        copyName(source: Internal.CopyNameFunction$NameSource): Internal.FunctionContainer
        name(name: Internal.Text, entity: Internal.LootContext$EntityTarget): Internal.FunctionContainer
        name(name: Internal.Text): Internal.FunctionContainer
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer
        furnaceSmelt(): Internal.FunctionContainer
        enchantRandomly(enchantments: ResourceLocation[]): Internal.FunctionContainer
        entityProperties(entity: Internal.LootContext$EntityTarget, properties: Internal.JsonObject): Internal.ConditionContainer
        function : Internal.JsonObject;
        conditions : Internal.JsonArray;
    }
    class EntitySectionStorage <T> implements Internal.WorldEntityByChunkAccess, Internal.MovementTrackerCache {
        deduplicate(tracker: Internal.SectionedEntityMovementTracker<any, any>): Internal.SectionedEntityMovementTracker<any, any>
        handler$zmm000$forEachInBox(box: Internal.AABB, action: Internal.Consumer<any>, ci: Internal.CallbackInfo, minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number): void
        getEntitiesInChunk(chunkX: number, chunkZ: number): Internal.Collection<any>
        remove(tracker: Internal.SectionedEntityMovementTracker<any, any>): void
    }
    interface ChannelHandler {
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void
        handlerAdded(arg0: Internal.ChannelHandlerContext): void
        handlerRemoved(arg0: Internal.ChannelHandlerContext): void
    }
    interface ItemLike {
    }
    interface BakedModel implements Internal.IForgeBakedModel {
        doesHandlePerspectives(): boolean
        getModelData(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.BlockState, arg3: Internal.IModelData): Internal.IModelData
        isLayered(): boolean
        handlePerspective(arg0: Internal.ItemTransforms$TransformType, arg1: Internal.PoseStack): Internal.BakedModel
        getQuads(arg0: Internal.BlockState, arg1: Internal.Direction, arg2: Internal.Random, arg3: Internal.IModelData): Internal.List<Internal.BakedQuad>
        useAmbientOcclusion(arg0: Internal.BlockState): boolean
        getLayerModels(arg0: Internal.ItemStack, arg1: boolean): Internal.List<com.mojang.datafixers.util.Pair<Internal.BakedModel, Internal.RenderType>>
        getParticleIcon(arg0: Internal.IModelData): Internal.TextureAtlasSprite
    }
    interface BufferVertexFormat {
        getStride(): number
        static from(format: Internal.VertexFormat): Internal.BufferVertexFormat
        get stride(): number;
    }
    class FormatStyle extends Internal.Enum<Internal.FormatStyle> {
        static valueOf(arg0: string): Internal.FormatStyle
        static values(): Internal.FormatStyle[]
        static readonly MEDIUM : Internal.FormatStyle;
        static readonly FULL : Internal.FormatStyle;
        static readonly LONG : Internal.FormatStyle;
        static readonly SHORT : Internal.FormatStyle;
    }
    interface Flushable {
        flush(): void
    }
    class BigDecimal extends Internal.Number implements Internal.Comparable<Internal.BigDecimal> {
        longValueExact(): number
        movePointLeft(arg0: number): Internal.BigDecimal
        precision(): number
        byteValueExact(): number
        toBigInteger(): Internal.BigInteger
        scale(): number
        toPlainString(): string
        compareTo(arg0: Internal.BigDecimal): number
        compareTo(arg0: object): number
        shortValueExact(): number
        longValue(): number
        min(arg0: Internal.BigDecimal): Internal.BigDecimal
        unscaledValue(): Internal.BigInteger
        sqrt(arg0: Internal.MathContext): Internal.BigDecimal
        scaleByPowerOfTen(arg0: number): Internal.BigDecimal
        hashCode(): number
        pow(arg0: number, arg1: Internal.MathContext): Internal.BigDecimal
        pow(arg0: number): Internal.BigDecimal
        divide(arg0: Internal.BigDecimal): Internal.BigDecimal
        divide(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal
        divide(arg0: Internal.BigDecimal, arg1: number): Internal.BigDecimal
        divide(arg0: Internal.BigDecimal, arg1: Internal.RoundingMode): Internal.BigDecimal
        divide(arg0: Internal.BigDecimal, arg1: number, arg2: number): Internal.BigDecimal
        divide(arg0: Internal.BigDecimal, arg1: number, arg2: Internal.RoundingMode): Internal.BigDecimal
        multiply(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal
        multiply(arg0: Internal.BigDecimal): Internal.BigDecimal
        signum(): number
        add(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal
        add(arg0: Internal.BigDecimal): Internal.BigDecimal
        toBigIntegerExact(): Internal.BigInteger
        toEngineeringString(): string
        max(arg0: Internal.BigDecimal): Internal.BigDecimal
        setScale(arg0: number): Internal.BigDecimal
        setScale(arg0: number, arg1: Internal.RoundingMode): Internal.BigDecimal
        setScale(arg0: number, arg1: number): Internal.BigDecimal
        static valueOf(arg0: number): Internal.BigDecimal
        static valueOf(arg0: number): Internal.BigDecimal
        static valueOf(arg0: number, arg1: number): Internal.BigDecimal
        intValue(): number
        subtract(arg0: Internal.BigDecimal): Internal.BigDecimal
        subtract(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal
        floatValue(): number
        doubleValue(): number
        divideToIntegralValue(arg0: Internal.BigDecimal): Internal.BigDecimal
        divideToIntegralValue(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal
        plus(arg0: Internal.MathContext): Internal.BigDecimal
        plus(): Internal.BigDecimal
        abs(): Internal.BigDecimal
        abs(arg0: Internal.MathContext): Internal.BigDecimal
        round(arg0: Internal.MathContext): Internal.BigDecimal
        divideAndRemainder(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal[]
        divideAndRemainder(arg0: Internal.BigDecimal): Internal.BigDecimal[]
        negate(arg0: Internal.MathContext): Internal.BigDecimal
        negate(): Internal.BigDecimal
        movePointRight(arg0: number): Internal.BigDecimal
        equals(arg0: object): boolean
        ulp(): Internal.BigDecimal
        toString(): string
        stripTrailingZeros(): Internal.BigDecimal
        remainder(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal
        remainder(arg0: Internal.BigDecimal): Internal.BigDecimal
        intValueExact(): number
        static readonly ZERO : Internal.BigDecimal;
        static readonly ROUND_DOWN : 1;
        static readonly ROUND_UNNECESSARY : 7;
        static readonly ROUND_CEILING : 2;
        static readonly ROUND_HALF_DOWN : 5;
        static readonly ROUND_HALF_UP : 4;
        static readonly ONE : Internal.BigDecimal;
        static readonly ROUND_UP : 0;
        static readonly ROUND_FLOOR : 3;
        static readonly ROUND_HALF_EVEN : 6;
        static readonly TEN : Internal.BigDecimal;
    }
    interface Collector <T, A, R> {
        characteristics(): Internal.Set<Internal.Collector$Characteristics>
        supplier(): () => A
        static of<T, A, R>(arg0: () => A, arg1: (arg0: A, arg1: T) => void, arg2: Internal.BinaryOperator<A>, arg3: (arg0: A) => R, arg4: Internal.Collector$Characteristics[]): Internal.Collector<T, A, R>
        static of<T, R>(arg0: () => R, arg1: (arg0: R, arg1: T) => void, arg2: Internal.BinaryOperator<R>, arg3: Internal.Collector$Characteristics[]): Internal.Collector<T, R, R>
        finisher(): (arg0: A) => R
        accumulator(): (arg0: A, arg1: T) => void
        combiner(): Internal.BinaryOperator<A>
    }
    class MethodType implements Internal.Constable, Internal.TypeDescriptor$OfMethod<Internal.Class<object>, Internal.MethodType>, Internal.Serializable {
        toMethodDescriptorString(): string
        dropParameterTypes(arg0: number, arg1: number): Internal.TypeDescriptor$OfMethod<any, any>
        dropParameterTypes(arg0: number, arg1: number): Internal.MethodType
        changeReturnType(arg0: Internal.Class<object>): Internal.MethodType
        changeReturnType(arg0: Internal.TypeDescriptor$OfField<any>): Internal.TypeDescriptor$OfMethod<any, any>
        static fromMethodDescriptorString(arg0: string, arg1: Internal.ClassLoader): Internal.MethodType
        lastParameterType(): Internal.Class<object>
        describeConstable(): Internal.Optional<Internal.MethodTypeDesc>
        changeParameterType(arg0: number, arg1: Internal.TypeDescriptor$OfField<any>): Internal.TypeDescriptor$OfMethod<any, any>
        changeParameterType(arg0: number, arg1: Internal.Class<object>): Internal.MethodType
        unwrap(): Internal.MethodType
        hasWrappers(): boolean
        static methodType(arg0: Internal.Class<object>, arg1: Internal.Class<object>[]): Internal.MethodType
        static methodType(arg0: Internal.Class<object>, arg1: Internal.MethodType): Internal.MethodType
        static methodType(arg0: Internal.Class<object>, arg1: Internal.Class<object>, arg2: Internal.Class<object>[]): Internal.MethodType
        static methodType(arg0: Internal.Class<object>, arg1: Internal.List<Internal.Class<object>>): Internal.MethodType
        static methodType(arg0: Internal.Class<object>, arg1: Internal.Class<object>): Internal.MethodType
        static methodType(arg0: Internal.Class<object>): Internal.MethodType
        parameterArray(): Internal.Class<object>[]
        parameterArray(): Internal.TypeDescriptor$OfField[]
        hashCode(): number
        appendParameterTypes(arg0: Internal.List<Internal.Class<object>>): Internal.MethodType
        appendParameterTypes(arg0: Internal.Class<object>[]): Internal.MethodType
        parameterType(arg0: number): Internal.Class<object>
        parameterType(arg0: number): Internal.TypeDescriptor$OfField<any>
        erase(): Internal.MethodType
        parameterCount(): number
        descriptorString(): string
        insertParameterTypes(arg0: number, arg1: Internal.List<Internal.Class<object>>): Internal.MethodType
        insertParameterTypes(arg0: number, arg1: Internal.Class<object>[]): Internal.MethodType
        insertParameterTypes(arg0: number, arg1: Internal.TypeDescriptor$OfField[]): Internal.TypeDescriptor$OfMethod<any, any>
        generic(): Internal.MethodType
        hasPrimitives(): boolean
        equals(arg0: object): boolean
        parameterList(): Internal.List<Internal.Class<object>>
        toString(): string
        static genericMethodType(arg0: number, arg1: boolean): Internal.MethodType
        static genericMethodType(arg0: number): Internal.MethodType
        wrap(): Internal.MethodType
        returnType(): Internal.Class<object>
        returnType(): Internal.TypeDescriptor$OfField<any>
    }
    class ClocheFertilizerRecipeJS extends Internal.IERecipeJS {
        serialize(): void
        growthModifier(f: number): Internal.ClocheFertilizerRecipeJS
        create(args: Internal.ListJS): void
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<object>;
        readonly inputFluids : Internal.List<Internal.FluidTagInput>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        serializeInputs : boolean;
    }
    interface IntConsumer implements Internal.Consumer<number>, java_.util.function_.IntConsumer {
        andThen(arg0: java_.util.function_.IntConsumer): java_.util.function_.IntConsumer
        andThen(arg0: java_.util.function_.IntConsumer): Internal.IntConsumer
        andThen(arg0: (arg0: number) => void): (arg0: number) => void
        andThen(arg0: Internal.IntConsumer): Internal.IntConsumer
        accept(arg0: object): void
        accept(arg0: number): void
        accept(arg0: number): void
    }
    interface Decoder <A> {
        simple(): Internal.Decoder$Simple<A>
        static ofBoxed<A>(arg0: Internal.Decoder$Boxed<A>): Internal.Decoder<A>
        terminal(): Internal.Decoder$Terminal<A>
        parse<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<A>
        parse<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<A>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Decoder<A>
        static error<A>(arg0: string): Internal.Decoder<A>
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
        decode<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
        promotePartial(arg0: (arg0: string) => void): Internal.Decoder<A>
        flatMap<B>(arg0: (arg0: A) => Internal.DataResult<B>): Internal.Decoder<B>
        static ofSimple<A>(arg0: Internal.Decoder$Simple<A>): Internal.Decoder<A>
        static unit<A>(arg0: () => A): Internal.MapDecoder<A>
        static unit<A>(arg0: A): Internal.MapDecoder<A>
        boxed(): Internal.Decoder$Boxed<A>
        fieldOf(arg0: string): Internal.MapDecoder<A>
        static ofTerminal<A>(arg0: Internal.Decoder$Terminal<A>): Internal.Decoder<A>
        map<B>(arg0: (arg0: A) => B): Internal.Decoder<B>
    }
    class RenderLayer extends Internal.Enum<Internal.RenderLayer> {
        static getPrimaryLayer(arg0: Internal.RenderType): Internal.RenderLayer
        static getLayer(arg0: Internal.RenderType): Internal.RenderLayer
        static valueOf(arg0: string): Internal.RenderLayer
        static values(): Internal.RenderLayer[]
        static readonly CUTOUT : Internal.RenderLayer;
        static readonly SOLID : Internal.RenderLayer;
        static readonly TRANSPARENT : Internal.RenderLayer;
    }
    class RecipeJS {
        parseResultItemList(o: object): Internal.List<Internal.ItemStackJS>
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS
        getMod(): string
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS
        save(): void
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS
        getId(): string
        dontAdd(): void
        serializeJson(): void
        getUniqueId(): string
        createRecipe(): Internal.Recipe<object>
        getFromToString(): string
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean
        parseIngredientItemList(o: object): Internal.List<Internal.IngredientJS>
        merge(data: object): Internal.RecipeJS
        getPath(): string
        create(arg0: Internal.ListJS): void
        parseIngredientItemStackList(o: object): Internal.List<Internal.IngredientStackJS>
        deserializeJson(): void
        id(_id: ResourceLocation): Internal.RecipeJS
        getOrCreateId(): ResourceLocation
        parseIngredientItem(o: object, key: string): Internal.IngredientJS
        parseIngredientItem(o: object): Internal.IngredientJS
        deserialize(): void
        group(g: string): Internal.RecipeJS
        serializeNBTAsJson(): boolean
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        getOriginalRecipeResult(): Internal.ItemStackJS
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number
        serialize(): void
        setGroup(g: string): void
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS
        stage(s: string): Internal.RecipeJS
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean
        getType(): string
        getGroup(): string
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        toString(): string
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean
        parseResultItem(o: object): Internal.ItemStackJS
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<object>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get mod(): string;
        get uniqueId(): string;
        get fromToString(): string;
        get path(): string;
        get orCreateId(): ResourceLocation;
        get originalRecipeResult(): Internal.ItemStackJS;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
    }
    class Rarity extends Internal.Enum<Internal.Rarity> implements Internal.IExtensibleEnum {
        init(): void
        static valueOf(arg0: string): Internal.Rarity
        static values(): Internal.Rarity[]
        static create(arg0: string, arg1: Internal.ChatFormatting): Internal.Rarity
        static readonly RARE : Internal.Rarity;
        static readonly EPIC : Internal.Rarity;
        static readonly UNCOMMON : Internal.Rarity;
        static readonly COMMON : Internal.Rarity;
    }
    class CapabilityProvider <B> implements Internal.ICapabilityProviderImpl<B> {
        invalidateCaps(): void
        getCapability<T>(arg0: Internal.Capability<T>, arg1: Internal.Direction): Internal.LazyOptional<T>
        getCapability<T>(arg0: Internal.Capability<T>): Internal.LazyOptional<T>
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<B>): boolean
        reviveCaps(): void
    }
    interface VertexDrain {
        createSink<T>(arg0: Internal.VertexType<T>): T
        static of(consumer: Internal.VertexConsumer): Internal.VertexDrain
    }
    interface Clearable {
    }
    class ImmutableSetMultimap$Builder <K, V> extends Internal.ImmutableMultimap$Builder<K, V> {
        orderKeysBy(arg0: Internal.Comparator<K>): Internal.ImmutableSetMultimap$Builder<K, V>
        orderKeysBy(arg0: Internal.Comparator<any>): Internal.ImmutableMultimap$Builder<any, any>
        build(): Internal.ImmutableMultimap<any, any>
        build(): Internal.ImmutableSetMultimap<K, V>
        orderValuesBy(arg0: Internal.Comparator<V>): Internal.ImmutableSetMultimap$Builder<K, V>
        orderValuesBy(arg0: Internal.Comparator<any>): Internal.ImmutableMultimap$Builder<any, any>
        putAll(arg0: Internal.Iterable<any>): Internal.ImmutableMultimap$Builder<any, any>
        putAll(arg0: Internal.Iterable<Internal.Map$Entry<K, V>>): Internal.ImmutableSetMultimap$Builder<K, V>
        putAll(arg0: object, arg1: Internal.Iterable<any>): Internal.ImmutableMultimap$Builder<any, any>
        putAll(arg0: K, arg1: Internal.Iterable<V>): Internal.ImmutableSetMultimap$Builder<K, V>
        putAll(arg0: object, arg1: object[]): Internal.ImmutableMultimap$Builder<any, any>
        putAll(arg0: K, arg1: V[]): Internal.ImmutableSetMultimap$Builder<K, V>
        putAll(arg0: Internal.Multimap<any, any>): Internal.ImmutableMultimap$Builder<any, any>
        putAll(arg0: Internal.Multimap<K, V>): Internal.ImmutableSetMultimap$Builder<K, V>
        put(arg0: Internal.Map$Entry<K, V>): Internal.ImmutableSetMultimap$Builder<K, V>
        put(arg0: Internal.Map$Entry<any, any>): Internal.ImmutableMultimap$Builder<any, any>
        put(arg0: object, arg1: object): Internal.ImmutableMultimap$Builder<any, any>
        put(arg0: K, arg1: V): Internal.ImmutableSetMultimap$Builder<K, V>
    }
    interface RecordBuilder <T> {
        withErrorsFrom(arg0: Internal.DataResult<object>): Internal.RecordBuilder<T>
        add(arg0: string, arg1: T): Internal.RecordBuilder<T>
        add(arg0: string, arg1: Internal.DataResult<T>): Internal.RecordBuilder<T>
        add(arg0: Internal.DataResult<T>, arg1: Internal.DataResult<T>): Internal.RecordBuilder<T>
        add<E>(arg0: string, arg1: E, arg2: Internal.Encoder<E>): Internal.RecordBuilder<T>
        add(arg0: T, arg1: T): Internal.RecordBuilder<T>
        add(arg0: T, arg1: Internal.DataResult<T>): Internal.RecordBuilder<T>
        mapError(arg0: Internal.UnaryOperator<string>): Internal.RecordBuilder<T>
        ops(): Internal.DynamicOps<T>
        setLifecycle(arg0: Internal.Lifecycle): Internal.RecordBuilder<T>
        build(arg0: Internal.DataResult<T>): Internal.DataResult<T>
        build(arg0: T): Internal.DataResult<T>
        set lifecycle(arg0: Internal.Lifecycle);
    }
    interface PropertyChangeListener implements Internal.EventListener {
        propertyChange(arg0: Internal.PropertyChangeEvent): void
    }
    class EntityDimensions {
        toString(): string
    }
    class TypeAdapter <T> {
        toJson(arg0: T): string
        toJson(arg0: Internal.Writer, arg1: T): void
        read(arg0: Internal.JsonReader): T
        toJsonTree(arg0: T): Internal.JsonElement
        fromJson(arg0: string): T
        fromJson(arg0: Internal.Reader): T
        nullSafe(): Internal.TypeAdapter<T>
        write(arg0: Internal.JsonWriter, arg1: T): void
        fromJsonTree(arg0: Internal.JsonElement): T
    }
    interface EntityInstancingController <T> {
        createInstance(arg0: Internal.MaterialManager, arg1: T): Internal.EntityInstance<T>
        shouldSkipRender(arg0: T): boolean
    }
    interface Char2ReferenceFunction <V> implements Internal.Function<string, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: string, arg1: V): V
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Reference2ShortFunction<V>): Internal.Char2ShortFunction
        composeByte(arg0: Internal.Byte2CharFunction): Internal.Byte2ReferenceFunction<V>
        andThenInt(arg0: Internal.Reference2IntFunction<V>): Internal.Char2IntFunction
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: Internal.Reference2CharFunction<T>): (arg0: T) => V
        put(arg0: string, arg1: V): V
        put(arg0: object, arg1: object): object
        put(arg0: string, arg1: V): V
        remove(arg0: string): V
        remove(arg0: object): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: Internal.Reference2DoubleFunction<V>): Internal.Char2DoubleFunction
        andThenObject<T>(arg0: (arg0: V) => T): Internal.Char2ObjectFunction<T>
        get(arg0: object): V
        get(arg0: string): V
        andThenLong(arg0: Internal.Reference2LongFunction<V>): Internal.Char2LongFunction
        composeLong(arg0: Internal.Long2CharFunction): Internal.Long2ReferenceFunction<V>
        andThenByte(arg0: Internal.Reference2ByteFunction<V>): Internal.Char2ByteFunction
        andThenFloat(arg0: Internal.Reference2FloatFunction<V>): Internal.Char2FloatFunction
        apply(arg0: number): V
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: string): boolean
        composeInt(arg0: Internal.Int2CharFunction): Internal.Int2ReferenceFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2CharFunction): Internal.Float2ReferenceFunction<V>
        andThenChar(arg0: Internal.Reference2CharFunction<V>): Internal.Char2CharFunction
        composeObject<T>(arg0: Internal.Object2CharFunction<T>): (arg0: T) => V
        size(): number
        compose<T>(arg0: (arg0: T) => string): (arg0: T) => V
        composeShort(arg0: Internal.Short2CharFunction): Internal.Short2ReferenceFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): Internal.Char2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2CharFunction): Internal.Char2ReferenceFunction<V>
        composeDouble(arg0: Internal.Double2CharFunction): Internal.Double2ReferenceFunction<V>
    }
    class AttributedCharacterIterator$Attribute implements Internal.Serializable {
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        static readonly LANGUAGE : Internal.AttributedCharacterIterator$Attribute;
        static readonly INPUT_METHOD_SEGMENT : Internal.AttributedCharacterIterator$Attribute;
        static readonly READING : Internal.AttributedCharacterIterator$Attribute;
    }
    class AbstractInt2IntMap extends Internal.AbstractInt2IntFunction implements Internal.Int2IntMap, Internal.Serializable {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: number, arg1: number): number
        computeIfAbsent(arg0: number, arg1: Internal.IntUnaryOperator): number
        computeIfAbsent(arg0: object, arg1: java_.util.function_.Function<any, any>): object
        computeIfAbsent(arg0: number, arg1: (arg0: number) => number): number
        computeIfAbsent(arg0: number, arg1: Internal.Int2IntFunction): number
        values(): Internal.Collection<any>
        values(): Internal.IntCollection
        replace(arg0: number, arg1: number, arg2: number): boolean
        replace(arg0: number, arg1: number, arg2: number): boolean
        replace(arg0: number, arg1: number): number
        replace(arg0: number, arg1: number): number
        replace(arg0: object, arg1: object): object
        replace(arg0: object, arg1: object, arg2: object): boolean
        computeIfAbsentPartial(arg0: number, arg1: Internal.Int2IntFunction): number
        replaceAll(arg0: (arg0: K, arg1: V) => V): void
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        remove(arg0: number, arg1: number): boolean
        remove(arg0: object, arg1: object): boolean
        containsValue(arg0: number): boolean
        containsValue(arg0: object): boolean
        int2IntEntrySet(): Internal.ObjectSet<Internal.Int2IntMap$Entry>
        mergeInt(arg0: number, arg1: number, arg2: Internal.IntBinaryOperator): number
        mergeInt(arg0: number, arg1: number, arg2: java_.util.function_.IntBinaryOperator): number
        compute(arg0: object, arg1: Internal.BiFunction<any, any, any>): object
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        hashCode(): number
        merge(arg0: object, arg1: object, arg2: Internal.BiFunction<any, any, any>): object
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number
        get(arg0: object): object
        get(arg0: object): number
        putAll(arg0: Map<number, number>): void
        keySet(): Internal.Set<any>
        keySet(): Internal.IntSet
        computeIfAbsentNullable(arg0: number, arg1: Internal.IntFunction<number>): number
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, number>>
        entrySet(): Internal.Set<any>
        forEach(arg0: (arg0: number, arg1: number) => void): void
        containsKey(arg0: number): boolean
        containsKey(arg0: object): boolean
        clear(): void
        isEmpty(): boolean
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        computeIfPresent(arg0: object, arg1: Internal.BiFunction<any, any, any>): object
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        size(): number
        equals(arg0: object): boolean
        toString(): string
        putIfAbsent(arg0: object, arg1: object): object
        putIfAbsent(arg0: number, arg1: number): number
        putIfAbsent(arg0: number, arg1: number): number
    }
    interface Byte2DoubleFunction implements Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: Internal.Double2ShortFunction): Internal.Byte2ShortFunction
        composeByte(arg0: Internal.Byte2ByteFunction): Internal.Byte2DoubleFunction
        andThenInt(arg0: Internal.Double2IntFunction): Internal.Byte2IntFunction
        composeReference<T>(arg0: Internal.Reference2ByteFunction<T>): Internal.Reference2DoubleFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Double2DoubleFunction): Internal.Byte2DoubleFunction
        andThenObject<T>(arg0: Internal.Double2ObjectFunction<T>): Internal.Byte2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Double2LongFunction): Internal.Byte2LongFunction
        composeLong(arg0: Internal.Long2ByteFunction): Internal.Long2DoubleFunction
        andThenByte(arg0: Internal.Double2ByteFunction): Internal.Byte2ByteFunction
        andThenFloat(arg0: Internal.Double2FloatFunction): Internal.Byte2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ByteFunction): Internal.Int2DoubleFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ByteFunction): Internal.Float2DoubleFunction
        andThenChar(arg0: Internal.Double2CharFunction): Internal.Byte2CharFunction
        composeObject<T>(arg0: Internal.Object2ByteFunction<T>): Internal.Object2DoubleFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2ByteFunction): Internal.Short2DoubleFunction
        andThenReference<T>(arg0: Internal.Double2ReferenceFunction<T>): Internal.Byte2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ByteFunction): Internal.Char2DoubleFunction
        composeDouble(arg0: Internal.Double2ByteFunction): Internal.Double2DoubleFunction
    }
    interface Function16 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, Internal.Function4<T13, T14, T15, T16, R>>
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function7<T10, T11, T12, T13, T14, T15, T16, R>>
        curry13(): Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, Internal.Function3<T14, T15, T16, R>>
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13, arg13: T14, arg14: T15, arg15: T16): R
        curry14(): Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, (arg0: T15, arg1: T16) => R>
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function9<T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>
        curry15(): Internal.Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, (arg0: T16) => R>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function8<T9, T10, T11, T12, T13, T14, T15, T16, R>>
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function6<T11, T12, T13, T14, T15, T16, R>>
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function5<T12, T13, T14, T15, T16, R>>
        curry(): (arg0: T1) => Internal.Function15<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function11<T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function10<T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function13<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function12<T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function14<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>
    }
    class EvaluatorException extends Internal.RhinoException {
    }
    class MapCodec <A> extends Internal.CompressorHolder implements Internal.MapDecoder<A>, Internal.MapEncoder<A> {
        encode<T>(arg0: A, arg1: Internal.DynamicOps<T>, arg2: Internal.RecordBuilder<T>): Internal.RecordBuilder<T>
        setPartial(arg0: () => A): Internal.MapCodec<A>
        keys<T>(arg0: Internal.DynamicOps<T>): Internal.Stream<T>
        deprecated(arg0: number): Internal.MapCodec<A>
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: Internal.MapLike<T>): Internal.DataResult<A>
        flatXmap<S>(arg0: (arg0: A) => Internal.DataResult<S>, arg1: (arg0: S) => Internal.DataResult<A>): Internal.MapCodec<S>
        comap<B>(arg0: (arg0: B) => A): Internal.MapEncoder<B>
        static of<A>(arg0: Internal.MapEncoder<A>, arg1: Internal.MapDecoder<A>, arg2: () => string): Internal.MapCodec<A>
        static of<A>(arg0: Internal.MapEncoder<A>, arg1: Internal.MapDecoder<A>): Internal.MapCodec<A>
        fieldOf(arg0: string): Internal.MapCodec<A>
        xmap<S>(arg0: (arg0: A) => S, arg1: (arg0: S) => A): Internal.MapCodec<S>
        map<B>(arg0: (arg0: A) => B): Internal.MapDecoder<B>
        dependent<E>(arg0: Internal.MapCodec<E>, arg1: (arg0: A) => com.mojang.datafixers.util.Pair<E, Internal.MapCodec<E>>, arg2: (arg0: A, arg1: E) => A): Internal.MapCodec<A>
        flatComap<B>(arg0: (arg0: B) => Internal.DataResult<A>): Internal.MapEncoder<B>
        compressedDecode<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<A>
        compressedBuilder<T>(arg0: Internal.DynamicOps<T>): Internal.RecordBuilder<T>
        decoder(): Internal.Decoder<A>
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapDecoder<any>
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapCodec<A>
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapEncoder<any>
        encoder(): Internal.Encoder<A>
        orElse(arg0: A): Internal.MapCodec<A>
        orElse(arg0: (arg0: string) => void, arg1: A): Internal.MapCodec<A>
        orElse(arg0: Internal.UnaryOperator<string>, arg1: A): Internal.MapCodec<A>
        forGetter<O>(arg0: (arg0: O) => A): Internal.RecordCodecBuilder<O, A>
        ap<E>(arg0: Internal.MapDecoder<(arg0: A) => E>): Internal.MapDecoder<E>
        flatMap<B>(arg0: (arg0: A) => Internal.DataResult<B>): Internal.MapDecoder<B>
        codec(): Internal.Codec<A>
        static unit<A>(arg0: A): Internal.MapCodec<A>
        static unit<A>(arg0: () => A): Internal.MapCodec<A>
        orElseGet(arg0: () => A): Internal.MapCodec<A>
        orElseGet(arg0: (arg0: string) => void, arg1: () => A): Internal.MapCodec<A>
        orElseGet(arg0: Internal.UnaryOperator<string>, arg1: () => A): Internal.MapCodec<A>
        stable(): Internal.MapCodec<A>
        mapResult(arg0: Internal.MapCodec$ResultFunction<A>): Internal.MapCodec<A>
        set partial(arg0: () => A);
    }
    class GameProfile {
        getName(): string
        isLegacy(): boolean
        hashCode(): number
        getProperties(): Internal.PropertyMap
        equals(arg0: object): boolean
        getId(): Internal.UUID
        toString(): string
        isComplete(): boolean
        get name(): string;
        get properties(): Internal.PropertyMap;
        get id(): Internal.UUID;
    }
    class CharsetEncoder {
        encode(arg0: Internal.CharBuffer, arg1: Internal.ByteBuffer, arg2: boolean): Internal.CoderResult
        encode(arg0: Internal.CharBuffer): Internal.ByteBuffer
        charset(): Internal.Charset
        onUnmappableCharacter(arg0: Internal.CodingErrorAction): Internal.CharsetEncoder
        maxBytesPerChar(): number
        isLegalReplacement(arg0: number[]): boolean
        unmappableCharacterAction(): Internal.CodingErrorAction
        malformedInputAction(): Internal.CodingErrorAction
        flush(arg0: Internal.ByteBuffer): Internal.CoderResult
        canEncode(arg0: Internal.CharSequence): boolean
        canEncode(arg0: string): boolean
        averageBytesPerChar(): number
        onMalformedInput(arg0: Internal.CodingErrorAction): Internal.CharsetEncoder
        reset(): Internal.CharsetEncoder
        replacement(): number[]
        replaceWith(arg0: number[]): Internal.CharsetEncoder
    }
    class StackTraceElement implements Internal.Serializable {
        getLineNumber(): number
        getMethodName(): string
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        getClassName(): string
        getClassLoaderName(): string
        getModuleName(): string
        getFileName(): string
        isNativeMethod(): boolean
        getModuleVersion(): string
        get lineNumber(): number;
        get methodName(): string;
        get className(): string;
        get classLoaderName(): string;
        get moduleName(): string;
        get fileName(): string;
        get moduleVersion(): string;
    }
    interface LootContextUser {
    }
    class DistancePredicate {
    }
    interface ProfilerFiller {
    }
    interface IScheduledEventCallback {
        onCallback(arg0: Internal.ScheduledEvent): void
    }
    class ModelBakery {
        getSpriteMap(): Internal.AtlasSet
        getSpecialModels(): Internal.Set<ResourceLocation>
        bake(arg0: ResourceLocation, arg1: Internal.ModelState, arg2: (arg0: Internal.Material) => Internal.TextureAtlasSprite): Internal.BakedModel
        get spriteMap(): Internal.AtlasSet;
        get specialModels(): Internal.Set<ResourceLocation>;
    }
    class Collector$Characteristics extends Internal.Enum<Internal.Collector$Characteristics> {
        static valueOf(arg0: string): Internal.Collector$Characteristics
        static values(): Internal.Collector$Characteristics[]
        static readonly IDENTITY_FINISH : Internal.Collector$Characteristics;
        static readonly UNORDERED : Internal.Collector$Characteristics;
        static readonly CONCURRENT : Internal.Collector$Characteristics;
    }
    interface IForgeModelState {
        getPartTransformation(arg0: object): Internal.Transformation
    }
    class EventJS {
        cancel(): void
        isCancelled(): boolean
        post(t: Internal.ScriptType, id: string, sub: string): boolean
        post(t: Internal.ScriptType, id: string): boolean
        canCancel(): boolean
    }
    class DayOfWeek extends Internal.Enum<Internal.DayOfWeek> implements Internal.TemporalAccessor, Internal.TemporalAdjuster {
        minus(arg0: number): Internal.DayOfWeek
        static valueOf(arg0: string): Internal.DayOfWeek
        query<R>(arg0: Internal.TemporalQuery<R>): R
        static values(): Internal.DayOfWeek[]
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        isSupported(arg0: Internal.TemporalField): boolean
        plus(arg0: number): Internal.DayOfWeek
        getLong(arg0: Internal.TemporalField): number
        getValue(): number
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        static of(arg0: number): Internal.DayOfWeek
        get(arg0: Internal.TemporalField): number
        static from(arg0: Internal.TemporalAccessor): Internal.DayOfWeek
        static readonly WEDNESDAY : Internal.DayOfWeek;
        static readonly MONDAY : Internal.DayOfWeek;
        static readonly THURSDAY : Internal.DayOfWeek;
        static readonly SUNDAY : Internal.DayOfWeek;
        static readonly TUESDAY : Internal.DayOfWeek;
        static readonly FRIDAY : Internal.DayOfWeek;
        static readonly SATURDAY : Internal.DayOfWeek;
        get value(): number;
    }
    class ElementBuffer {
        bind(): void
        unbind(): void
        readonly eboIndexType : Internal.GlNumericType;
        readonly elementCount : number;
    }
    interface IntPredicate {
        or(arg0: Internal.IntPredicate): Internal.IntPredicate
        test(arg0: number): boolean
        and(arg0: Internal.IntPredicate): Internal.IntPredicate
        negate(): Internal.IntPredicate
    }
    interface Double2DoubleFunction implements Internal.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: number, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: Internal.Double2ShortFunction): Internal.Double2ShortFunction
        composeByte(arg0: Internal.Byte2DoubleFunction): Internal.Byte2DoubleFunction
        andThenInt(arg0: Internal.Double2IntFunction): Internal.Double2IntFunction
        composeReference<T>(arg0: Internal.Reference2DoubleFunction<T>): Internal.Reference2DoubleFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Double2DoubleFunction): Internal.Double2DoubleFunction
        andThenObject<T>(arg0: Internal.Double2ObjectFunction<T>): Internal.Double2ObjectFunction<T>
        static identity(): Internal.Double2DoubleFunction
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Double2LongFunction): Internal.Double2LongFunction
        composeLong(arg0: Internal.Long2DoubleFunction): Internal.Long2DoubleFunction
        andThenByte(arg0: Internal.Double2ByteFunction): Internal.Double2ByteFunction
        andThenFloat(arg0: Internal.Double2FloatFunction): Internal.Double2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2DoubleFunction): Internal.Int2DoubleFunction
        clear(): void
        composeFloat(arg0: Internal.Float2DoubleFunction): Internal.Float2DoubleFunction
        andThenChar(arg0: Internal.Double2CharFunction): Internal.Double2CharFunction
        composeObject<T>(arg0: Internal.Object2DoubleFunction<T>): Internal.Object2DoubleFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        composeShort(arg0: Internal.Short2DoubleFunction): Internal.Short2DoubleFunction
        andThenReference<T>(arg0: Internal.Double2ReferenceFunction<T>): Internal.Double2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2DoubleFunction): Internal.Char2DoubleFunction
        composeDouble(arg0: Internal.Double2DoubleFunction): Internal.Double2DoubleFunction
    }
    interface Enemy {
    }
    interface IForgeItemStack implements Internal.ICapabilitySerializable<Internal.CompoundTag> {
        canElytraFly(arg0: Internal.LivingEntity): boolean
        getCapability<T>(arg0: Internal.Capability<T>, arg1: Internal.Direction): Internal.LazyOptional<T>
        getCapability<T>(arg0: Internal.Capability<T>): Internal.LazyOptional<T>
        canEquip(arg0: EquipmentSlot, arg1: Internal.Entity): boolean
        canPerformAction(arg0: Internal.ToolAction): boolean
        onBlockStartBreak(arg0: BlockPos, arg1: Internal.Player): boolean
        onHorseArmorTick(arg0: Internal.Level, arg1: Internal.Mob): void
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack): boolean
        getItemEnchantability(): number
        serializeNBT(): Internal.CompoundTag
        serializeNBT(): net.minecraft.nbt.Tag
        getEntityLifespan(arg0: Internal.Level): number
        getXpRepairRatio(): number
        getHighlightTip(arg0: Internal.Component): Internal.Component
        readShareTag(arg0: Internal.CompoundTag): void
        onEntityItemUpdate(arg0: Internal.ItemEntity): boolean
        onArmorTick(arg0: Internal.Level, arg1: Internal.Player): void
        isBookEnchantable(arg0: Internal.ItemStack): boolean
        hasContainerItem(): boolean
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: Internal.LivingEntity): boolean
        doesSneakBypassUse(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Player): boolean
        onItemUseFirst(arg0: Internal.UseOnContext): Internal.InteractionResult
        deserializeNBT(arg0: T): void
        getContainerItem(): Internal.ItemStack
        onUsingTick(arg0: Internal.LivingEntity, arg1: number): void
        isPiglinCurrency(): boolean
        getSweepHitBox(arg0: Internal.Player, arg1: Internal.Entity): Internal.AABB
        isRepairable(): boolean
        getEquipmentSlot(): EquipmentSlot
        getShareTag(): Internal.CompoundTag
        getBurnTime(arg0: Internal.RecipeType<object>): number
        onDroppedByPlayer(arg0: Internal.Player): boolean
        onEntitySwing(arg0: Internal.LivingEntity): boolean
        equals(arg0: Internal.ItemStack, arg1: boolean): boolean
        elytraFlightTick(arg0: Internal.LivingEntity, arg1: number): boolean
        makesPiglinsNeutral(arg0: Internal.LivingEntity): boolean
        isEnderMask(arg0: Internal.Player, arg1: Internal.EnderMan): boolean
        areShareTagsEqual(arg0: Internal.ItemStack): boolean
        canApplyAtEnchantingTable(arg0: Internal.Enchantment): boolean
        get itemEnchantability(): number;
        get xpRepairRatio(): number;
        get containerItem(): Internal.ItemStack;
        get equipmentSlot(): EquipmentSlot;
        get shareTag(): Internal.CompoundTag;
    }
    interface LayoutItem {
        size(): number
        attributeCount(): number
        vertexAttribPointer(arg0: number, arg1: number, arg2: number): void
    }
    class Optional <T> {
        or(arg0: () => Internal.Optional<T>): Internal.Optional<T>
        static ofNullable<T>(arg0: T): Internal.Optional<T>
        isEmpty(): boolean
        isPresent(): boolean
        orElse(arg0: T): T
        orElseThrow<X>(arg0: () => X): T
        orElseThrow(): T
        static empty<T>(): Internal.Optional<T>
        flatMap<U>(arg0: (arg0: T) => Internal.Optional<U>): Internal.Optional<U>
        filter(arg0: (arg0: T) => boolean): Internal.Optional<T>
        orElseGet(arg0: () => T): T
        stream(): Internal.Stream<T>
        hashCode(): number
        ifPresentOrElse(arg0: (arg0: T) => void, arg1: Internal.Runnable): void
        ifPresent(arg0: (arg0: T) => void): void
        static of<T>(arg0: T): Internal.Optional<T>
        equals(arg0: object): boolean
        get(): T
        toString(): string
        map<U>(arg0: (arg0: T) => U): Internal.Optional<U>
    }
    class Level extends Internal.CapabilityProvider<Internal.Level> implements Internal.LevelAccessor, Internal.AutoCloseable, Internal.IForgeLevel, Internal.LevelKJS, Internal.ChunkRandomSource, Internal.BlockEntityGetter, Internal.LevelHeightAccessor, Internal.ExtendedWorld {
        getChunkAtImmediately(arg0: number, arg1: number): Internal.LevelChunk
        getAnyChunkImmediately(arg0: number, arg1: number): Internal.ChunkAccess
        increaseMaxEntityRadius(arg0: number): number
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
        getRandomPosInChunk(x: number, y: number, z: number, mask: number, out: Internal.BlockPos$MutableBlockPos): void
        getMaxEntityRadius(): number
        addFreshBlockEntities(arg0: Internal.Collection<Internal.BlockEntity>): void
        getLoadedExistingBlockEntity(pos: BlockPos): Internal.BlockEntity
        close(): void
        asKJS(): object
        markAndNotifyBlock(arg0: BlockPos, arg1: Internal.LevelChunk, arg2: Internal.BlockState, arg3: Internal.BlockState, arg4: number, arg5: number): void
        restoringBlockSnapshots : boolean;
        capturedBlockSnapshots : Internal.ArrayList<Internal.BlockSnapshot>;
        captureBlockSnapshots : boolean;
        get maxEntityRadius(): number;
    }
    interface BlockStatePathingCache {
        getNeighborPathNodeType(): Internal.BlockPathTypes
        getPathNodeType(): Internal.BlockPathTypes
        get neighborPathNodeType(): Internal.BlockPathTypes;
        get pathNodeType(): Internal.BlockPathTypes;
    }
    class ClientPlayerJS extends Internal.PlayerJS<Internal.Player> {
        getStats(): Internal.PlayerStatsJS
        sendData(channel: string, data: Internal.CompoundTag): void
        paint(tag: Internal.CompoundTag): void
        rayTrace(distance: number): Internal.RayTraceResultJS
        isSelf(): boolean
        isMiningBlock(): boolean
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftPlayer : E;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        get stats(): Internal.PlayerStatsJS;
    }
    class Locale$LanguageRange {
        getWeight(): number
        getRange(): string
        hashCode(): number
        equals(arg0: object): boolean
        static mapEquivalents(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Map<string, Internal.List<string>>): Internal.List<Internal.Locale$LanguageRange>
        toString(): string
        static parse(arg0: string): Internal.List<Internal.Locale$LanguageRange>
        static parse(arg0: string, arg1: Map<string, Internal.List<string>>): Internal.List<Internal.Locale$LanguageRange>
        static readonly MAX_WEIGHT : 1.0;
        static readonly MIN_WEIGHT : 0.0;
        get weight(): number;
        get range(): string;
    }
    interface IntBinaryOperator implements Internal.BinaryOperator<number>, java_.util.function_.IntBinaryOperator {
        applyAsInt(arg0: number, arg1: number): number
        apply(arg0: object, arg1: object): object
        apply(arg0: number, arg1: number): number
        apply(arg0: number, arg1: number): number
        andThen<V>(arg0: (arg0: R) => V): (arg0: T, arg1: U) => V
    }
    interface ContextFactory$Listener {
        contextReleased(arg0: Internal.Context): void
        contextCreated(arg0: Internal.Context): void
    }
    interface LongToIntFunction {
        applyAsInt(arg0: number): number
    }
    class UnitStorage {
        addConstant(name: string, val: number): void
        addFunc(name: string, func: Internal.FuncSupplier): void
        createFunc(name: string, args: Internal.List<dev.latvian.mods.rhino.util.unit.Unit>): dev.latvian.mods.rhino.util.unit.Unit
        addOp(name: string, op: Internal.OpSupplier): void
        getConstant(name: string): Internal.ConstantUnit
        setVariable(key: string, unit: dev.latvian.mods.rhino.util.unit.Unit): void
        getVariableVersion(): number
        addFunc2(name: string, func: Internal.FuncSupplier$Func2): void
        addFunc1(name: string, func: Internal.FuncSupplier$Func1): void
        parse(string: string): dev.latvian.mods.rhino.util.unit.Unit
        createOp(name: string, unit: dev.latvian.mods.rhino.util.unit.Unit, with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        getVariable(key: string): dev.latvian.mods.rhino.util.unit.Unit
        clearVariables(): void
        get variableVersion(): number;
    }
    class AbstractIntCollection extends Internal.AbstractCollection<number> implements Internal.IntCollection {
        add(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: object): boolean
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.IntSpliterator
        forEach(arg0: Internal.IntConsumer): void
        forEach(arg0: (arg0: number) => void): void
        forEach(arg0: java_.util.function_.IntConsumer): void
        containsAll(arg0: Internal.Collection<object>): boolean
        containsAll(arg0: Internal.IntCollection): boolean
        intIterator(): Internal.IntIterator
        intSpliterator(): Internal.IntSpliterator
        remove(arg0: object): boolean
        removeIf(arg0: it.unimi.dsi.fastutil.ints.IntPredicate): boolean
        removeIf(arg0: (arg0: number) => boolean): boolean
        removeIf(arg0: Internal.IntPredicate): boolean
        intStream(): Internal.IntStream
        removeAll(arg0: Internal.IntCollection): boolean
        removeAll(arg0: Internal.Collection<object>): boolean
        contains(arg0: number): boolean
        contains(arg0: object): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.IntIterator
        stream(): Internal.Stream<number>
        addAll(arg0: Internal.IntCollection): boolean
        addAll(arg0: Internal.Collection<number>): boolean
        toIntArray(arg0: number[]): number[]
        toIntArray(): number[]
        toArray(arg0: number[]): number[]
        parallelStream(): Internal.Stream<number>
        toString(): string
        rem(arg0: number): boolean
        intParallelStream(): Internal.IntStream
        retainAll(arg0: Internal.Collection<object>): boolean
        retainAll(arg0: Internal.IntCollection): boolean
    }
    class ZonedDateTime implements Internal.Temporal, Internal.ChronoZonedDateTime<Internal.LocalDate>, Internal.Serializable {
        plusHours(arg0: number): Internal.ZonedDateTime
        isEqual(arg0: Internal.ChronoZonedDateTime<object>): boolean
        toLocalTime(): Internal.LocalTime
        compareTo(arg0: object): number
        compareTo(arg0: Internal.ChronoZonedDateTime<object>): number
        static ofLocal(arg0: Internal.LocalDateTime, arg1: Internal.ZoneId, arg2: Internal.ZoneOffset): Internal.ZonedDateTime
        getDayOfWeek(): Internal.DayOfWeek
        static ofStrict(arg0: Internal.LocalDateTime, arg1: Internal.ZoneOffset, arg2: Internal.ZoneId): Internal.ZonedDateTime
        plusSeconds(arg0: number): Internal.ZonedDateTime
        getMinute(): number
        static from(arg0: Internal.TemporalAccessor): Internal.ZonedDateTime
        getMonth(): Internal.Month
        plusNanos(arg0: number): Internal.ZonedDateTime
        withHour(arg0: number): Internal.ZonedDateTime
        plusMonths(arg0: number): Internal.ZonedDateTime
        plusYears(arg0: number): Internal.ZonedDateTime
        truncatedTo(arg0: Internal.TemporalUnit): Internal.ZonedDateTime
        query<R>(arg0: Internal.TemporalQuery<R>): R
        minusNanos(arg0: number): Internal.ZonedDateTime
        getNano(): number
        format(arg0: Internal.DateTimeFormatter): string
        getZone(): Internal.ZoneId
        isSupported(arg0: Internal.TemporalField): boolean
        isSupported(arg0: Internal.TemporalUnit): boolean
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.ZonedDateTime
        plus(arg0: Internal.TemporalAmount): Internal.ChronoZonedDateTime<any>
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.ZonedDateTime
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoZonedDateTime<any>
        getYear(): number
        toEpochSecond(): number
        toLocalDateTime(): Internal.ChronoLocalDateTime<any>
        toLocalDateTime(): Internal.LocalDateTime
        withDayOfMonth(arg0: number): Internal.ZonedDateTime
        isAfter(arg0: Internal.ChronoZonedDateTime<object>): boolean
        withMonth(arg0: number): Internal.ZonedDateTime
        toOffsetDateTime(): Internal.OffsetDateTime
        static ofInstant(arg0: Internal.LocalDateTime, arg1: Internal.ZoneOffset, arg2: Internal.ZoneId): Internal.ZonedDateTime
        static ofInstant(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.ZonedDateTime
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.ZonedDateTime
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoZonedDateTime<any>
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: Internal.TemporalAmount): Internal.ChronoZonedDateTime<any>
        minus(arg0: Internal.TemporalAmount): Internal.ZonedDateTime
        withFixedOffsetZone(): Internal.ZonedDateTime
        minusHours(arg0: number): Internal.ZonedDateTime
        getOffset(): Internal.ZoneOffset
        range(arg0: Internal.TemporalField): Internal.ValueRange
        withYear(arg0: number): Internal.ZonedDateTime
        plusMinutes(arg0: number): Internal.ZonedDateTime
        minusMinutes(arg0: number): Internal.ZonedDateTime
        plusDays(arg0: number): Internal.ZonedDateTime
        withLaterOffsetAtOverlap(): Internal.ChronoZonedDateTime<any>
        withLaterOffsetAtOverlap(): Internal.ZonedDateTime
        hashCode(): number
        static now(arg0: Internal.Clock): Internal.ZonedDateTime
        static now(arg0: Internal.ZoneId): Internal.ZonedDateTime
        static now(): Internal.ZonedDateTime
        static of(arg0: Internal.LocalDate, arg1: Internal.LocalTime, arg2: Internal.ZoneId): Internal.ZonedDateTime
        static of(arg0: Internal.LocalDateTime, arg1: Internal.ZoneId): Internal.ZonedDateTime
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneId): Internal.ZonedDateTime
        get(arg0: Internal.TemporalField): number
        withEarlierOffsetAtOverlap(): Internal.ChronoZonedDateTime<any>
        withEarlierOffsetAtOverlap(): Internal.ZonedDateTime
        withZoneSameLocal(arg0: Internal.ZoneId): Internal.ChronoZonedDateTime<any>
        withZoneSameLocal(arg0: Internal.ZoneId): Internal.ZonedDateTime
        getDayOfYear(): number
        plusWeeks(arg0: number): Internal.ZonedDateTime
        getHour(): number
        getChronology(): Internal.Chronology
        withMinute(arg0: number): Internal.ZonedDateTime
        getMonthValue(): number
        minusYears(arg0: number): Internal.ZonedDateTime
        withZoneSameInstant(arg0: Internal.ZoneId): Internal.ZonedDateTime
        withZoneSameInstant(arg0: Internal.ZoneId): Internal.ChronoZonedDateTime<any>
        minusWeeks(arg0: number): Internal.ZonedDateTime
        withDayOfYear(arg0: number): Internal.ZonedDateTime
        static parse(arg0: Internal.CharSequence, arg1: Internal.DateTimeFormatter): Internal.ZonedDateTime
        static parse(arg0: Internal.CharSequence): Internal.ZonedDateTime
        toInstant(): Internal.Instant
        isBefore(arg0: Internal.ChronoZonedDateTime<object>): boolean
        minusDays(arg0: number): Internal.ZonedDateTime
        withNano(arg0: number): Internal.ZonedDateTime
        getLong(arg0: Internal.TemporalField): number
        minusMonths(arg0: number): Internal.ZonedDateTime
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.ChronoZonedDateTime<any>
        with(arg0: Internal.TemporalAdjuster): Internal.ZonedDateTime
        with(arg0: Internal.TemporalField, arg1: number): Internal.ZonedDateTime
        with(arg0: Internal.TemporalField, arg1: number): Internal.ChronoZonedDateTime<any>
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        toLocalDate(): Internal.LocalDate
        toLocalDate(): Internal.ChronoLocalDate
        equals(arg0: object): boolean
        getSecond(): number
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        toString(): string
        getDayOfMonth(): number
        minusSeconds(arg0: number): Internal.ZonedDateTime
        withSecond(arg0: number): Internal.ZonedDateTime
        get dayOfWeek(): Internal.DayOfWeek;
        get minute(): number;
        get month(): Internal.Month;
        get nano(): number;
        get zone(): Internal.ZoneId;
        get year(): number;
        get offset(): Internal.ZoneOffset;
        get dayOfYear(): number;
        get hour(): number;
        get chronology(): Internal.Chronology;
        get monthValue(): number;
        get second(): number;
        get dayOfMonth(): number;
    }
    class Direction$Axis extends Internal.Enum<Internal.Direction$Axis> implements Internal.StringRepresentable, Internal.Predicate<Internal.Direction> {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        test(arg0: Internal.Direction): boolean
        test(arg0: object): boolean
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
        static valueOf(arg0: string): Internal.Direction$Axis
        static values(): Internal.Direction$Axis[]
        toString(): string
        static readonly X : Internal.Direction$Axis;
        static readonly Y : Internal.Direction$Axis;
        static readonly Z : Internal.Direction$Axis;
    }
    class EventsJS {
        postToHandlers(id: string, list: Internal.List<Internal.EventsJS$ScriptEventHandler>, event: Internal.EventJS): boolean
        handlers(id: string): Internal.List<Internal.EventsJS$ScriptEventHandler>
        clear(): void
        listen(id: string, handler: Internal.IEventHandler): void
        readonly scriptManager : Internal.ScriptManager;
    }
    class Attribute extends Internal.ForgeRegistryEntry<Internal.Attribute> {
        readonly delegate : () => V;
    }
    class ModelBakeEvent extends Internal.Event implements Internal.IModBusEvent {
        getListenerList(): Internal.ListenerList
        getModelRegistry(): Map<ResourceLocation, Internal.BakedModel>
        getModelManager(): Internal.ModelManager
        getModelLoader(): Internal.ForgeModelBakery
        get listenerList(): Internal.ListenerList;
        get modelRegistry(): Map<ResourceLocation, Internal.BakedModel>;
        get modelManager(): Internal.ModelManager;
        get modelLoader(): Internal.ForgeModelBakery;
    }
    class PacketFlow extends Internal.Enum<Internal.PacketFlow> {
        static valueOf(arg0: string): Internal.PacketFlow
        static values(): Internal.PacketFlow[]
        static readonly CLIENTBOUND : Internal.PacketFlow;
        static readonly SERVERBOUND : Internal.PacketFlow;
    }
    interface RecipeManagerKJS {
        customRecipesKJS(jsonMap: Map<ResourceLocation, Internal.JsonObject>): void
        getByNameKJS(): Map<ResourceLocation, Internal.Recipe<object>>
        setByNameKJS(arg0: Map<ResourceLocation, Internal.Recipe<object>>): void
        setRecipesKJS(arg0: Map<Internal.RecipeType<object>, Map<ResourceLocation, Internal.Recipe<object>>>): void
        getRecipesKJS(): Map<Internal.RecipeType<object>, Map<ResourceLocation, Internal.Recipe<object>>>
        get byNameKJS(): Map<ResourceLocation, Internal.Recipe<object>>;
        set byNameKJS(arg0: Map<ResourceLocation, Internal.Recipe<object>>);
        set recipesKJS(arg0: Map<Internal.RecipeType<object>, Map<ResourceLocation, Internal.Recipe<object>>>);
        get recipesKJS(): Map<Internal.RecipeType<object>, Map<ResourceLocation, Internal.Recipe<object>>>;
    }
    interface Double2ObjectFunction <V> implements Internal.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: number, arg1: V): V
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Object2ShortFunction<V>): Internal.Double2ShortFunction
        composeByte(arg0: Internal.Byte2DoubleFunction): Internal.Byte2ObjectFunction<V>
        andThenInt(arg0: Internal.Object2IntFunction<V>): Internal.Double2IntFunction
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: Internal.Reference2DoubleFunction<T>): (arg0: T) => V
        put(arg0: number, arg1: V): V
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: object): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: Internal.Object2DoubleFunction<V>): Internal.Double2DoubleFunction
        andThenObject<T>(arg0: (arg0: V) => T): Internal.Double2ObjectFunction<T>
        get(arg0: object): V
        get(arg0: number): V
        andThenLong(arg0: Internal.Object2LongFunction<V>): Internal.Double2LongFunction
        composeLong(arg0: Internal.Long2DoubleFunction): Internal.Long2ObjectFunction<V>
        andThenByte(arg0: Internal.Object2ByteFunction<V>): Internal.Double2ByteFunction
        andThenFloat(arg0: Internal.Object2FloatFunction<V>): Internal.Double2FloatFunction
        apply(arg0: number): V
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2DoubleFunction): Internal.Int2ObjectFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2DoubleFunction): Internal.Float2ObjectFunction<V>
        andThenChar(arg0: Internal.Object2CharFunction<V>): Internal.Double2CharFunction
        composeObject<T>(arg0: Internal.Object2DoubleFunction<T>): (arg0: T) => V
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => V
        composeShort(arg0: Internal.Short2DoubleFunction): Internal.Short2ObjectFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): Internal.Double2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2DoubleFunction): Internal.Char2ObjectFunction<V>
        composeDouble(arg0: Internal.Double2DoubleFunction): Internal.Double2ObjectFunction<V>
    }
    interface ITeleporter {
        getPortalInfo(arg0: Internal.Entity, arg1: Internal.ServerLevel, arg2: (arg0: Internal.ServerLevel) => Internal.PortalInfo): Internal.PortalInfo
        isVanilla(): boolean
        playTeleportSound(arg0: Internal.ServerPlayer, arg1: Internal.ServerLevel, arg2: Internal.ServerLevel): boolean
        placeEntity(arg0: Internal.Entity, arg1: Internal.ServerLevel, arg2: Internal.ServerLevel, arg3: number, arg4: (arg0: boolean) => Internal.Entity): Internal.Entity
    }
    interface Function11 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R> {
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, (arg0: T10, arg1: T11) => R>
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11): R
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function4<T8, T9, T10, T11, R>>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function3<T9, T10, T11, R>>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function6<T6, T7, T8, T9, T10, T11, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function5<T7, T8, T9, T10, T11, R>>
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, (arg0: T11) => R>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function8<T4, T5, T6, T7, T8, T9, T10, T11, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function7<T5, T6, T7, T8, T9, T10, T11, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function9<T3, T4, T5, T6, T7, T8, T9, T10, T11, R>
        curry(): (arg0: T1) => Internal.Function10<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>
    }
    class SqueezerRecipeJS extends Internal.IERecipeJS {
        serialize(): void
        create(args: Internal.ListJS): void
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<object>;
        readonly inputFluids : Internal.List<Internal.FluidTagInput>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        serializeInputs : boolean;
    }
    class BlockItem extends Internal.Item implements Internal.IPlaceableItem {
        removeFromBlockToItemMap(arg0: Map<Internal.Block, Internal.Item>, arg1: Internal.Item): void
        readonly delegate : () => V;
        renderProperties : object;
    }
    interface IModelData {
        setData<T>(arg0: (arg0: T) => boolean, arg1: T): T
        hasProperty(arg0: (arg0: object) => boolean): boolean
        getData<T>(arg0: (arg0: T) => boolean): T
    }
    interface IForgeEntity implements Internal.ICapabilitySerializable<Internal.CompoundTag> {
        shouldRiderSit(): boolean
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        canUpdate(arg0: boolean): void
        canUpdate(): boolean
        getCapability<T>(arg0: Internal.Capability<T>, arg1: Internal.Direction): Internal.LazyOptional<T>
        getCapability<T>(arg0: Internal.Capability<T>): Internal.LazyOptional<T>
        onRemovedFromWorld(): void
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        isMultipartEntity(): boolean
        deserializeNBT(arg0: Internal.CompoundTag): void
        deserializeNBT(arg0: net.minecraft.nbt.Tag): void
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        getPersistentData(): Internal.CompoundTag
        canRiderInteract(): boolean
        serializeNBT(): Internal.CompoundTag
        serializeNBT(): net.minecraft.nbt.Tag
        onAddedToWorld(): void
        revive(): void
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        isAddedToWorld(): boolean
        getClassification(arg0: boolean): Internal.MobCategory
        getParts(): Internal.PartEntity<object>[]
        get persistentData(): Internal.CompoundTag;
        get parts(): Internal.PartEntity<object>[];
    }
    interface Long2ByteFunction implements Internal.Function<number, number>, Internal.LongToIntFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Byte2ShortFunction): Internal.Long2ShortFunction
        composeByte(arg0: Internal.Byte2LongFunction): Internal.Byte2ByteFunction
        andThenInt(arg0: Internal.Byte2IntFunction): Internal.Long2IntFunction
        composeReference<T>(arg0: Internal.Reference2LongFunction<T>): Internal.Reference2ByteFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Byte2DoubleFunction): Internal.Long2DoubleFunction
        andThenObject<T>(arg0: Internal.Byte2ObjectFunction<T>): Internal.Long2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Byte2LongFunction): Internal.Long2LongFunction
        composeLong(arg0: Internal.Long2LongFunction): Internal.Long2ByteFunction
        andThenByte(arg0: Internal.Byte2ByteFunction): Internal.Long2ByteFunction
        andThenFloat(arg0: Internal.Byte2FloatFunction): Internal.Long2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2LongFunction): Internal.Int2ByteFunction
        clear(): void
        composeFloat(arg0: Internal.Float2LongFunction): Internal.Float2ByteFunction
        andThenChar(arg0: Internal.Byte2CharFunction): Internal.Long2CharFunction
        composeObject<T>(arg0: Internal.Object2LongFunction<T>): Internal.Object2ByteFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2LongFunction): Internal.Short2ByteFunction
        andThenReference<T>(arg0: Internal.Byte2ReferenceFunction<T>): Internal.Long2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2LongFunction): Internal.Char2ByteFunction
        composeDouble(arg0: Internal.Double2LongFunction): Internal.Double2ByteFunction
    }
    interface ItemEntityAccess {
        setAge(arg0: number): void
        set age(arg0: number);
    }
    interface PreparableReloadListener {
    }
    class ItemStackJS implements Internal.IngredientJS, Internal.NBTSerializable, Internal.ChangeListener<net.minecraft.nbt.Tag>, Internal.SpecialEquality {
        getItemIds(): Internal.Set<string>
        getNbt(): Internal.CompoundTag
        isBlock(): boolean
        getName(): Internal.Text
        getStacks(): Internal.Set<Internal.ItemStackJS>
        getVanillaItems(): Internal.Set<Internal.Item>
        static findGroup(id: string): Internal.CreativeModeTab
        getItem(): Internal.Item
        getTags(): Internal.Collection<ResourceLocation>
        hasEnchantment(enchantment: Internal.Enchantment, level: number): boolean
        getItemGroup(): string
        setChance(c: number): void
        static getList(): Internal.List<Internal.ItemStackJS>
        getFirst(): Internal.ItemStackJS
        withName(displayName: Internal.Component): Internal.ItemStackJS
        withChance(c: number): Internal.ItemStackJS
        getCount(): number
        setCount(count: number): void
        testVanillaItem(item: Internal.Item): boolean
        hasTag(tag: ResourceLocation): boolean
        test(other: Internal.ItemStackJS): boolean
        hasChance(): boolean
        asIngredientStack(): Internal.IngredientStackJS
        static getRawItem(o: object): Internal.Item
        getNbtString(): string
        createVanillaIngredient(): Internal.Ingredient
        isNBTEqual(other: Internal.ItemStackJS): boolean
        isNBTEqual(other: Internal.ItemStack): boolean
        toJson(): Internal.JsonElement
        withCount(c: number): Internal.ItemStackJS
        withCount(arg0: number): Internal.IngredientJS
        static getListJS(): Internal.ListJS
        specialEquals(o: object, shallow: boolean): boolean
        anyStackMatches(ingredient: Internal.IngredientJS): boolean
        hasNBT(): boolean
        areItemsEqual(other: Internal.ItemStackJS): boolean
        areItemsEqual(other: Internal.ItemStack): boolean
        getMod(): string
        getChance(): number
        isInvalidRecipeIngredient(): boolean
        getId(): string
        weakNBT(): Internal.IngredientJS
        static clearListCache(): void
        not(): Internal.IngredientJS
        toNBT(): Internal.CompoundTag
        toNBT(): net.minecraft.nbt.Tag
        getHarvestSpeed(): number
        getHarvestSpeed(block: Internal.BlockContainerJS): number
        hashCode(): number
        toRawResultJson(): Internal.JsonElement
        static of(o: object): Internal.ItemStackJS
        getItemStack(): Internal.ItemStack
        copy(): Internal.ItemStackJS
        copy(): Internal.IngredientJS
        copy(): Internal.Copyable
        withNBT(nbt: Internal.CompoundTag): Internal.ItemStackJS
        toResultJson(): Internal.JsonElement
        onChanged(arg0: object): void
        onChanged(o: net.minecraft.nbt.Tag): void
        static getTypeList(): Internal.ListJS
        isEmpty(): boolean
        strongEquals(o: object): boolean
        getVanillaPredicate(): (arg0: Internal.ItemStack) => boolean
        filter(filter: Internal.IngredientJS): Internal.IngredientJS
        getEnchantments(): Internal.MapJS
        getFluidStack(): Internal.FluidStackJS
        removeNBT(): Internal.ItemStackJS
        static resultFromRecipeJson(json: Internal.JsonElement): Internal.ItemStackJS
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>
        enchant(enchantment: Internal.Enchantment, level: number): Internal.ItemStackJS
        enchant(enchantments: Internal.MapJS): Internal.ItemStackJS
        testVanilla(other: Internal.ItemStack): boolean
        equals(o: object): boolean
        x(c: number): Internal.IngredientJS
        ignoreNBT(): Internal.IngredientJS
        toString(): string
        removeChance(): void
        setNbt(tag: Internal.CompoundTag): void
        static readonly EMPTY : Internal.ItemStackJS;
        get itemIds(): Internal.Set<string>;
        get nbt(): Internal.CompoundTag;
        get name(): Internal.Text;
        get stacks(): Internal.Set<Internal.ItemStackJS>;
        get vanillaItems(): Internal.Set<Internal.Item>;
        get item(): Internal.Item;
        get tags(): Internal.Collection<ResourceLocation>;
        get itemGroup(): string;
        set chance(c: number);
        get list(): Internal.List<Internal.ItemStackJS>;
        get first(): Internal.ItemStackJS;
        get count(): number;
        set count(count: number);
        get nbtString(): string;
        get listJS(): Internal.ListJS;
        get mod(): string;
        get chance(): number;
        get id(): string;
        get harvestSpeed(): number;
        get itemStack(): Internal.ItemStack;
        get typeList(): Internal.ListJS;
        get vanillaPredicate(): (arg0: Internal.ItemStack) => boolean;
        get enchantments(): Internal.MapJS;
        get fluidStack(): Internal.FluidStackJS;
        set nbt(tag: Internal.CompoundTag);
    }
    interface Path implements Internal.Comparable<Internal.Path>, Internal.Iterable<Internal.Path>, Internal.Watchable {
        getName(arg0: number): Internal.Path
        resolve(arg0: string): Internal.Path
        resolve(arg0: Internal.Path): Internal.Path
        resolveSibling(arg0: Internal.Path): Internal.Path
        resolveSibling(arg0: string): Internal.Path
        subpath(arg0: number, arg1: number): Internal.Path
        compareTo(arg0: Internal.Path): number
        compareTo(arg0: object): number
        iterator(): Internal.Iterator<Internal.Path>
        hashCode(): number
        normalize(): Internal.Path
        static of(arg0: string, arg1: string[]): Internal.Path
        static of(arg0: Internal.URI): Internal.Path
        relativize(arg0: Internal.Path): Internal.Path
        getRoot(): Internal.Path
        getFileName(): Internal.Path
        getNameCount(): number
        getParent(): Internal.Path
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
        toUri(): Internal.URI
        toAbsolutePath(): Internal.Path
        getFileSystem(): Internal.FileSystem
        equals(arg0: object): boolean
        toFile(): Internal.File
        toRealPath(arg0: Internal.LinkOption[]): Internal.Path
        endsWith(arg0: Internal.Path): boolean
        endsWith(arg0: string): boolean
        isAbsolute(): boolean
        toString(): string
        register(arg0: Internal.WatchService, arg1: Internal.WatchEvent$Kind<object>[]): Internal.WatchKey
        register(arg0: Internal.WatchService, arg1: Internal.WatchEvent$Kind<object>[], arg2: Internal.WatchEvent$Modifier[]): Internal.WatchKey
        startsWith(arg0: string): boolean
        startsWith(arg0: Internal.Path): boolean
        get root(): Internal.Path;
        get fileName(): Internal.Path;
        get nameCount(): number;
        get parent(): Internal.Path;
        get fileSystem(): Internal.FileSystem;
    }
    class ClientWrapper {
        getLevel(): Internal.ClientLevelJS
        getPlayer(): Internal.ClientPlayerJS
        isKeyDown(key: number): boolean
        getCurrentWorldName(): string
        setTitle(t: string): void
        getCurrentScreen(): Internal.Screen
        getMinecraft(): Internal.Minecraft
        setCurrentScreen(gui: Internal.Screen): void
        get level(): Internal.ClientLevelJS;
        get player(): Internal.ClientPlayerJS;
        get currentWorldName(): string;
        set title(t: string);
        get currentScreen(): Internal.Screen;
        get minecraft(): Internal.Minecraft;
        set currentScreen(gui: Internal.Screen);
    }
    class DynamicLike <T> {
        createIntList(arg0: Internal.IntStream): Internal.Dynamic<object>
        createLong(arg0: number): Internal.Dynamic<T>
        getElementGeneric(arg0: T): Internal.DataResult<T>
        getElementGeneric(arg0: T, arg1: T): T
        asLongStreamOpt(): Internal.DataResult<Internal.LongStream>
        createDouble(arg0: number): Internal.Dynamic<T>
        createLongList(arg0: Internal.LongStream): Internal.Dynamic<object>
        readMap<K, V>(arg0: Internal.Decoder<K>, arg1: Internal.Decoder<V>): Internal.DataResult<Internal.List<com.mojang.datafixers.util.Pair<K, V>>>
        readMap<R>(arg0: Internal.DataResult<R>, arg1: Internal.Function3<R, Internal.Dynamic<T>, Internal.Dynamic<T>, Internal.DataResult<R>>): Internal.DataResult<R>
        readMap<K, V>(arg0: Internal.Decoder<K>, arg1: (arg0: K) => Internal.Decoder<V>): Internal.DataResult<Internal.List<com.mojang.datafixers.util.Pair<K, V>>>
        asListOpt<U>(arg0: (arg0: Internal.Dynamic<T>) => U): Internal.DataResult<Internal.List<U>>
        asStreamOpt(): Internal.DataResult<Internal.Stream<Internal.Dynamic<T>>>
        createShort(arg0: number): Internal.Dynamic<T>
        asMap<K, V>(arg0: (arg0: Internal.Dynamic<T>) => K, arg1: (arg0: Internal.Dynamic<T>) => V): Map<K, V>
        asIntStream(): Internal.IntStream
        createByteList(arg0: Internal.ByteBuffer): Internal.Dynamic<object>
        asByteBuffer(): Internal.ByteBuffer
        asFloat(arg0: number): number
        decode<A>(arg0: Internal.Decoder<A>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
        asIntStreamOpt(): Internal.DataResult<Internal.IntStream>
        asLongStream(): Internal.LongStream
        createBoolean(arg0: boolean): Internal.Dynamic<T>
        asList<U>(arg0: (arg0: Internal.Dynamic<T>) => U): Internal.List<U>
        asInt(arg0: number): number
        readList<E>(arg0: (arg0: Internal.Dynamic<object>) => Internal.DataResult<E>): Internal.DataResult<Internal.List<E>>
        readList<E>(arg0: Internal.Decoder<E>): Internal.DataResult<Internal.List<E>>
        emptyList(): Internal.Dynamic<T>
        asShort(arg0: number): number
        get(arg0: string): Internal.OptionalDynamic<T>
        emptyMap(): Internal.Dynamic<T>
        createNumeric(arg0: Internal.Number): Internal.Dynamic<T>
        asString(arg0: string): string
        asString(): Internal.DataResult<string>
        asByte(arg0: number): number
        createList(arg0: Internal.Stream<Internal.Dynamic<object>>): Internal.Dynamic<T>
        asByteBufferOpt(): Internal.DataResult<Internal.ByteBuffer>
        read<A>(arg0: Internal.Decoder<A>): Internal.DataResult<A>
        asNumber(arg0: Internal.Number): Internal.Number
        asNumber(): Internal.DataResult<Internal.Number>
        asMapOpt<K, V>(arg0: (arg0: Internal.Dynamic<T>) => K, arg1: (arg0: Internal.Dynamic<T>) => V): Internal.DataResult<Map<K, V>>
        asMapOpt(): Internal.DataResult<Internal.Stream<com.mojang.datafixers.util.Pair<Internal.Dynamic<T>, Internal.Dynamic<T>>>>
        getGeneric(arg0: T): Internal.DataResult<T>
        createString(arg0: string): Internal.Dynamic<T>
        asStream(): Internal.Stream<Internal.Dynamic<T>>
        createMap(arg0: Map<Internal.Dynamic<object>, Internal.Dynamic<object>>): Internal.Dynamic<T>
        asLong(arg0: number): number
        createByte(arg0: number): Internal.Dynamic<T>
        createFloat(arg0: number): Internal.Dynamic<T>
        getOps(): Internal.DynamicOps<T>
        getElement(arg0: string): Internal.DataResult<T>
        getElement(arg0: string, arg1: T): T
        asDouble(arg0: number): number
        createInt(arg0: number): Internal.Dynamic<T>
        asBoolean(arg0: boolean): boolean
        get ops(): Internal.DynamicOps<T>;
    }
    class OreConfiguration$TargetBlockState {
    }
    class ChunkAccess implements Internal.BlockGetter, Internal.BiomeManager$NoiseBiomeSource, Internal.FeatureAccess, Internal.ExtendedChunk {
        setSkyNibbles(arg0: Internal.SWMRNibbleArray[]): void
        getWorldForge(): Internal.LevelAccessor
        getSkyEmptinessMap(): boolean[]
        getSkyNibbles(): Internal.SWMRNibbleArray[]
        getBlockNibbles(): Internal.SWMRNibbleArray[]
        setSkyEmptinessMap(arg0: boolean[]): void
        setBlockEmptinessMap(arg0: boolean[]): void
        getBlockEmptinessMap(): boolean[]
        setBlockNibbles(arg0: Internal.SWMRNibbleArray[]): void
        set skyNibbles(arg0: Internal.SWMRNibbleArray[]);
        get worldForge(): Internal.LevelAccessor;
        get skyEmptinessMap(): boolean[];
        get skyNibbles(): Internal.SWMRNibbleArray[];
        get blockNibbles(): Internal.SWMRNibbleArray[];
        set skyEmptinessMap(arg0: boolean[]);
        set blockEmptinessMap(arg0: boolean[]);
        get blockEmptinessMap(): boolean[];
        set blockNibbles(arg0: Internal.SWMRNibbleArray[]);
    }
    class Font implements Internal.IAntiqueTextProvider {
        setAntiqueInk(arg0: boolean): void
        hasAntiqueInk(): boolean
        set antiqueInk(arg0: boolean);
    }
    interface Float2IntFunction implements Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Int2ShortFunction): Internal.Float2ShortFunction
        composeByte(arg0: Internal.Byte2FloatFunction): Internal.Byte2IntFunction
        andThenInt(arg0: Internal.Int2IntFunction): Internal.Float2IntFunction
        composeReference<T>(arg0: Internal.Reference2FloatFunction<T>): Internal.Reference2IntFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Int2DoubleFunction): Internal.Float2DoubleFunction
        andThenObject<T>(arg0: Internal.Int2ObjectFunction<T>): Internal.Float2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Int2LongFunction): Internal.Float2LongFunction
        composeLong(arg0: Internal.Long2FloatFunction): Internal.Long2IntFunction
        andThenByte(arg0: Internal.Int2ByteFunction): Internal.Float2ByteFunction
        andThenFloat(arg0: Internal.Int2FloatFunction): Internal.Float2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2FloatFunction): Internal.Int2IntFunction
        clear(): void
        composeFloat(arg0: Internal.Float2FloatFunction): Internal.Float2IntFunction
        andThenChar(arg0: Internal.Int2CharFunction): Internal.Float2CharFunction
        composeObject<T>(arg0: Internal.Object2FloatFunction<T>): Internal.Object2IntFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2FloatFunction): Internal.Short2IntFunction
        andThenReference<T>(arg0: Internal.Int2ReferenceFunction<T>): Internal.Float2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2FloatFunction): Internal.Char2IntFunction
        composeDouble(arg0: Internal.Double2FloatFunction): Internal.Double2IntFunction
    }
    class ChannelInboundHandlerAdapter extends Internal.ChannelHandlerAdapter implements Internal.ChannelInboundHandler {
        channelInactive(arg0: Internal.ChannelHandlerContext): void
        channelUnregistered(arg0: Internal.ChannelHandlerContext): void
        channelReadComplete(arg0: Internal.ChannelHandlerContext): void
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void
        channelActive(arg0: Internal.ChannelHandlerContext): void
        userEventTriggered(arg0: Internal.ChannelHandlerContext, arg1: object): void
        channelRegistered(arg0: Internal.ChannelHandlerContext): void
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext): void
        channelRead(arg0: Internal.ChannelHandlerContext, arg1: object): void
    }
    class RhinoException extends Internal.RuntimeException {
        printStackTrace(s: Internal.PrintStream): void
        printStackTrace(s: Internal.PrintWriter): void
        getScriptStack(limit: number, hideFunction: string): Internal.ScriptStackElement[]
        getScriptStack(): Internal.ScriptStackElement[]
        initSourceName(sourceName: string): void
        initColumnNumber(columnNumber: number): void
        getMessage(): string
        getScriptStackTrace(limit: number, functionName: string): string
        getScriptStackTrace(): string
        initLineSource(lineSource: string): void
        columnNumber(): number
        lineSource(): string
        initLineNumber(lineNumber: number): void
        details(): string
        sourceName(): string
        lineNumber(): number
        get scriptStack(): Internal.ScriptStackElement[];
        get message(): string;
        get scriptStackTrace(): string;
    }
    class Products$P2 <F, T1, T2> {
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: (arg0: T1, arg1: T2) => R): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, (arg0: T1, arg1: T2) => R>): Internal.App<F, R>
        and<T3, T4, T5, T6, T7>(arg0: Internal.Products$P5<F, T3, T4, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        and<T3, T4, T5, T6, T7, T8>(arg0: Internal.Products$P6<F, T3, T4, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        and<T3>(arg0: Internal.App<F, T3>): Internal.Products$P3<F, T1, T2, T3>
        and<T3, T4>(arg0: Internal.Products$P2<F, T3, T4>): Internal.Products$P4<F, T1, T2, T3, T4>
        and<T3, T4, T5>(arg0: Internal.Products$P3<F, T3, T4, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>
        and<T3, T4, T5, T6>(arg0: Internal.Products$P4<F, T3, T4, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>
        t1(): Internal.App<F, T1>
        t2(): Internal.App<F, T2>
    }
    class PlayerDataJS <E, P> implements Internal.WithAttachedData {
        getPlayer(): P
        getMinecraftPlayer(): E
        getName(): string
        getProfile(): Internal.GameProfile
        hasClientMod(): boolean
        getId(): Internal.UUID
        getOverworld(): Internal.LevelJS
        getData(): Internal.AttachedData
        get player(): P;
        get minecraftPlayer(): E;
        get name(): string;
        get profile(): Internal.GameProfile;
        get id(): Internal.UUID;
        get overworld(): Internal.LevelJS;
        get data(): Internal.AttachedData;
    }
    interface Object2ShortFunction <K> implements Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        andThenShort(arg0: Internal.Short2ShortFunction): Internal.Object2ShortFunction<K>
        composeByte(arg0: Internal.Byte2ObjectFunction<K>): Internal.Byte2ShortFunction
        removeShort(arg0: object): number
        andThenInt(arg0: Internal.Short2IntFunction): Internal.Object2IntFunction<K>
        composeReference<T>(arg0: (arg0: T) => K): Internal.Reference2ShortFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: K) => T
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: object, arg1: object): object
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: Internal.Short2DoubleFunction): Internal.Object2DoubleFunction<K>
        andThenObject<T>(arg0: Internal.Short2ObjectFunction<T>): (arg0: K) => T
        get(arg0: object): number
        get(arg0: object): object
        andThenLong(arg0: Internal.Short2LongFunction): Internal.Object2LongFunction<K>
        composeLong(arg0: Internal.Long2ObjectFunction<K>): Internal.Long2ShortFunction
        andThenByte(arg0: Internal.Short2ByteFunction): Internal.Object2ByteFunction<K>
        andThenFloat(arg0: Internal.Short2FloatFunction): Internal.Object2FloatFunction<K>
        applyAsInt(arg0: K): number
        apply(arg0: K): V
        getShort(arg0: object): number
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ObjectFunction<K>): Internal.Int2ShortFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ObjectFunction<K>): Internal.Float2ShortFunction
        andThenChar(arg0: Internal.Short2CharFunction): Internal.Object2CharFunction<K>
        composeObject<T>(arg0: (arg0: T) => K): Internal.Object2ShortFunction<T>
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ObjectFunction<K>): Internal.Short2ShortFunction
        andThenReference<T>(arg0: Internal.Short2ReferenceFunction<T>): (arg0: K) => T
        composeChar(arg0: Internal.Char2ObjectFunction<K>): Internal.Char2ShortFunction
        composeDouble(arg0: Internal.Double2ObjectFunction<K>): Internal.Double2ShortFunction
    }
    class Period implements Internal.ChronoPeriod, Internal.Serializable {
        minus(arg0: Internal.TemporalAmount): Internal.Period
        minus(arg0: Internal.TemporalAmount): Internal.ChronoPeriod
        negated(): Internal.Period
        negated(): Internal.ChronoPeriod
        normalized(): Internal.ChronoPeriod
        normalized(): Internal.Period
        static ofYears(arg0: number): Internal.Period
        getMonths(): number
        plusDays(arg0: number): Internal.Period
        multipliedBy(arg0: number): Internal.ChronoPeriod
        multipliedBy(arg0: number): Internal.Period
        getYears(): number
        hashCode(): number
        static of(arg0: number, arg1: number, arg2: number): Internal.Period
        get(arg0: Internal.TemporalUnit): number
        isZero(): boolean
        static from(arg0: Internal.TemporalAmount): Internal.Period
        withDays(arg0: number): Internal.Period
        getChronology(): Internal.IsoChronology
        getChronology(): Internal.Chronology
        static between(arg0: Internal.LocalDate, arg1: Internal.LocalDate): Internal.Period
        isNegative(): boolean
        withMonths(arg0: number): Internal.Period
        minusYears(arg0: number): Internal.Period
        plusMonths(arg0: number): Internal.Period
        plusYears(arg0: number): Internal.Period
        static ofDays(arg0: number): Internal.Period
        static parse(arg0: Internal.CharSequence): Internal.Period
        toTotalMonths(): number
        plus(arg0: Internal.TemporalAmount): Internal.ChronoPeriod
        plus(arg0: Internal.TemporalAmount): Internal.Period
        minusDays(arg0: number): Internal.Period
        minusMonths(arg0: number): Internal.Period
        static ofWeeks(arg0: number): Internal.Period
        getDays(): number
        subtractFrom(arg0: Internal.Temporal): Internal.Temporal
        equals(arg0: object): boolean
        getUnits(): Internal.List<Internal.TemporalUnit>
        static ofMonths(arg0: number): Internal.Period
        addTo(arg0: Internal.Temporal): Internal.Temporal
        toString(): string
        withYears(arg0: number): Internal.Period
        static readonly ZERO : Internal.Period;
        get months(): number;
        get years(): number;
        get chronology(): Internal.IsoChronology;
        get chronology(): Internal.Chronology;
        get days(): number;
        get units(): Internal.List<Internal.TemporalUnit>;
    }
    class NetworkEvent$Context {
        getNetworkManager(): Internal.Connection
        getDirection(): Internal.NetworkDirection
        enqueueWork(arg0: Internal.Runnable): Internal.CompletableFuture<void>
        setPacketHandled(arg0: boolean): void
        getSender(): Internal.ServerPlayer
        attr<T>(arg0: Internal.AttributeKey<T>): io.netty.util.Attribute<T>
        getPacketDispatcher(): Internal.NetworkEvent$PacketDispatcher
        getPacketHandled(): boolean
        get networkManager(): Internal.Connection;
        get direction(): Internal.NetworkDirection;
        set packetHandled(arg0: boolean);
        get sender(): Internal.ServerPlayer;
        get packetDispatcher(): Internal.NetworkEvent$PacketDispatcher;
        get packetHandled(): boolean;
    }
    class AccessControlContext {
        checkPermission(arg0: Internal.Permission): void
        hashCode(): number
        equals(arg0: object): boolean
        getDomainCombiner(): Internal.DomainCombiner
        get domainCombiner(): Internal.DomainCombiner;
    }
    interface Float2CharFunction implements Internal.Function<number, string>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: object, arg1: string): string
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: string): string
        andThenShort(arg0: Internal.Char2ShortFunction): Internal.Float2ShortFunction
        composeByte(arg0: Internal.Byte2FloatFunction): Internal.Byte2CharFunction
        andThenInt(arg0: Internal.Char2IntFunction): Internal.Float2IntFunction
        composeReference<T>(arg0: Internal.Reference2FloatFunction<T>): Internal.Reference2CharFunction<T>
        andThen<T>(arg0: (arg0: string) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: string): string
        put(arg0: number, arg1: string): string
        remove(arg0: number): string
        remove(arg0: object): object
        remove(arg0: object): string
        defaultReturnValue(): string
        defaultReturnValue(arg0: string): void
        andThenDouble(arg0: Internal.Char2DoubleFunction): Internal.Float2DoubleFunction
        andThenObject<T>(arg0: Internal.Char2ObjectFunction<T>): Internal.Float2ObjectFunction<T>
        get(arg0: object): string
        get(arg0: object): object
        get(arg0: number): string
        andThenLong(arg0: Internal.Char2LongFunction): Internal.Float2LongFunction
        composeLong(arg0: Internal.Long2FloatFunction): Internal.Long2CharFunction
        andThenByte(arg0: Internal.Char2ByteFunction): Internal.Float2ByteFunction
        andThenFloat(arg0: Internal.Char2FloatFunction): Internal.Float2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2FloatFunction): Internal.Int2CharFunction
        clear(): void
        composeFloat(arg0: Internal.Float2FloatFunction): Internal.Float2CharFunction
        andThenChar(arg0: Internal.Char2CharFunction): Internal.Float2CharFunction
        composeObject<T>(arg0: Internal.Object2FloatFunction<T>): Internal.Object2CharFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => string
        composeShort(arg0: Internal.Short2FloatFunction): Internal.Short2CharFunction
        andThenReference<T>(arg0: Internal.Char2ReferenceFunction<T>): Internal.Float2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2FloatFunction): Internal.Char2CharFunction
        composeDouble(arg0: Internal.Double2FloatFunction): Internal.Double2CharFunction
    }
    interface FuncSupplier$Func2 implements Internal.FuncSupplier {
        create2(arg0: dev.latvian.mods.rhino.util.unit.Unit, arg1: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        create(args: Internal.List<dev.latvian.mods.rhino.util.unit.Unit>): dev.latvian.mods.rhino.util.unit.Unit
    }
    interface Short2FloatFunction implements Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: Internal.Float2ShortFunction): Internal.Short2ShortFunction
        composeByte(arg0: Internal.Byte2ShortFunction): Internal.Byte2FloatFunction
        andThenInt(arg0: Internal.Float2IntFunction): Internal.Short2IntFunction
        composeReference<T>(arg0: Internal.Reference2ShortFunction<T>): Internal.Reference2FloatFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Float2DoubleFunction): Internal.Short2DoubleFunction
        andThenObject<T>(arg0: Internal.Float2ObjectFunction<T>): Internal.Short2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Float2LongFunction): Internal.Short2LongFunction
        composeLong(arg0: Internal.Long2ShortFunction): Internal.Long2FloatFunction
        andThenByte(arg0: Internal.Float2ByteFunction): Internal.Short2ByteFunction
        andThenFloat(arg0: Internal.Float2FloatFunction): Internal.Short2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ShortFunction): Internal.Int2FloatFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ShortFunction): Internal.Float2FloatFunction
        andThenChar(arg0: Internal.Float2CharFunction): Internal.Short2CharFunction
        composeObject<T>(arg0: Internal.Object2ShortFunction<T>): Internal.Object2FloatFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2ShortFunction): Internal.Short2FloatFunction
        andThenReference<T>(arg0: Internal.Float2ReferenceFunction<T>): Internal.Short2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ShortFunction): Internal.Char2FloatFunction
        composeDouble(arg0: Internal.Double2ShortFunction): Internal.Double2FloatFunction
    }
    class ModelGenerator$Face {
        uv(u0: number, v0: number, u1: number, v1: number): Internal.ModelGenerator$Face
        toJson(): Internal.JsonObject
        tex(t: string): Internal.ModelGenerator$Face
        cull(): Internal.ModelGenerator$Face
        cull(d: Internal.Direction): Internal.ModelGenerator$Face
        tintindex(i: number): Internal.ModelGenerator$Face
    }
    class FluidStackJS implements Internal.WrappedJS, Internal.Copyable {
        getNbt(): Internal.CompoundTag
        getChance(): number
        getTags(): Internal.Collection<ResourceLocation>
        getId(): string
        toNBT(): Internal.CompoundTag
        setChance(c: number): void
        hashCode(): number
        static of(o: object, amount: number, nbt: Internal.CompoundTag): Internal.FluidStackJS
        static of(o: object): Internal.FluidStackJS
        withAmount(amount: number): Internal.FluidStackJS
        withChance(c: number): Internal.FluidStackJS
        copy(): Internal.FluidStackJS
        copy(): Internal.Copyable
        setAmount(arg0: number): void
        withNBT(nbt: Internal.CompoundTag): Internal.FluidStackJS
        getAmount(): number
        hasTag(tag: ResourceLocation): boolean
        isEmpty(): boolean
        hasChance(): boolean
        strongEquals(o: object): boolean
        getFluidStack(): dev.architectury.fluid.FluidStack
        toJson(): Internal.JsonObject
        equals(o: object): boolean
        getFluid(): Internal.Fluid
        static fromJson(e: Internal.JsonElement): Internal.FluidStackJS
        toString(): string
        removeChance(): void
        setNbt(arg0: Internal.CompoundTag): void
        get nbt(): Internal.CompoundTag;
        get chance(): number;
        get tags(): Internal.Collection<ResourceLocation>;
        get id(): string;
        set chance(c: number);
        set amount(arg0: number);
        get amount(): number;
        get fluidStack(): dev.architectury.fluid.FluidStack;
        get fluid(): Internal.Fluid;
        set nbt(arg0: Internal.CompoundTag);
    }
    class LocalTime implements Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.LocalTime>, Internal.Serializable {
        static ofInstant(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.LocalTime
        minus(arg0: Internal.TemporalAmount): Internal.LocalTime
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.LocalTime
        plusHours(arg0: number): Internal.LocalTime
        minusHours(arg0: number): Internal.LocalTime
        atDate(arg0: Internal.LocalDate): Internal.LocalDateTime
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        compareTo(arg0: object): number
        compareTo(arg0: Internal.LocalTime): number
        plusMinutes(arg0: number): Internal.LocalTime
        toSecondOfDay(): number
        minusMinutes(arg0: number): Internal.LocalTime
        hashCode(): number
        static now(): Internal.LocalTime
        static now(arg0: Internal.Clock): Internal.LocalTime
        static now(arg0: Internal.ZoneId): Internal.LocalTime
        static of(arg0: number, arg1: number, arg2: number, arg3: number): Internal.LocalTime
        static of(arg0: number, arg1: number): Internal.LocalTime
        static of(arg0: number, arg1: number, arg2: number): Internal.LocalTime
        get(arg0: Internal.TemporalField): number
        plusSeconds(arg0: number): Internal.LocalTime
        getMinute(): number
        getHour(): number
        static from(arg0: Internal.TemporalAccessor): Internal.LocalTime
        plusNanos(arg0: number): Internal.LocalTime
        withMinute(arg0: number): Internal.LocalTime
        withHour(arg0: number): Internal.LocalTime
        static ofNanoOfDay(arg0: number): Internal.LocalTime
        atOffset(arg0: Internal.ZoneOffset): Internal.OffsetTime
        truncatedTo(arg0: Internal.TemporalUnit): Internal.LocalTime
        query<R>(arg0: Internal.TemporalQuery<R>): R
        minusNanos(arg0: number): Internal.LocalTime
        getNano(): number
        format(arg0: Internal.DateTimeFormatter): string
        static parse(arg0: Internal.CharSequence, arg1: Internal.DateTimeFormatter): Internal.LocalTime
        static parse(arg0: Internal.CharSequence): Internal.LocalTime
        isSupported(arg0: Internal.TemporalField): boolean
        isSupported(arg0: Internal.TemporalUnit): boolean
        isBefore(arg0: Internal.LocalTime): boolean
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.LocalTime
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.LocalTime
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        withNano(arg0: number): Internal.LocalTime
        getLong(arg0: Internal.TemporalField): number
        static ofSecondOfDay(arg0: number): Internal.LocalTime
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalField, arg1: number): Internal.LocalTime
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.LocalTime
        toNanoOfDay(): number
        toEpochSecond(arg0: Internal.LocalDate, arg1: Internal.ZoneOffset): number
        equals(arg0: object): boolean
        getSecond(): number
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        toString(): string
        minusSeconds(arg0: number): Internal.LocalTime
        isAfter(arg0: Internal.LocalTime): boolean
        withSecond(arg0: number): Internal.LocalTime
        static readonly MIN : Internal.LocalTime;
        static readonly NOON : Internal.LocalTime;
        static readonly MAX : Internal.LocalTime;
        static readonly MIDNIGHT : Internal.LocalTime;
        get minute(): number;
        get hour(): number;
        get nano(): number;
        get second(): number;
    }
    class JsonPrimitive extends Internal.JsonElement {
        getAsFloat(): number
        getAsBigInteger(): Internal.BigInteger
        getAsByte(): number
        getAsBigDecimal(): Internal.BigDecimal
        getAsNumber(): Internal.Number
        getAsCharacter(): string
        getAsString(): string
        getAsDouble(): number
        getAsInt(): number
        deepCopy(): Internal.JsonPrimitive
        deepCopy(): Internal.JsonElement
        isBoolean(): boolean
        getAsLong(): number
        isNumber(): boolean
        getAsBoolean(): boolean
        hashCode(): number
        equals(arg0: object): boolean
        isString(): boolean
        getAsShort(): number
        get asFloat(): number;
        get asBigInteger(): Internal.BigInteger;
        get asByte(): number;
        get asBigDecimal(): Internal.BigDecimal;
        get asNumber(): Internal.Number;
        get asCharacter(): string;
        get asString(): string;
        get asDouble(): number;
        get asInt(): number;
        get asLong(): number;
        get asBoolean(): boolean;
        get asShort(): number;
    }
    class FileStore {
        getTotalSpace(): number
        getAttribute(arg0: string): object
        getUsableSpace(): number
        isReadOnly(): boolean
        getBlockSize(): number
        supportsFileAttributeView(arg0: Internal.Class<Internal.FileAttributeView>): boolean
        supportsFileAttributeView(arg0: string): boolean
        name(): string
        type(): string
        getUnallocatedSpace(): number
        getFileStoreAttributeView<V>(arg0: Internal.Class<V>): V
        get totalSpace(): number;
        get usableSpace(): number;
        get blockSize(): number;
        get unallocatedSpace(): number;
    }
    interface Double2ByteFunction implements Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Byte2ShortFunction): Internal.Double2ShortFunction
        composeByte(arg0: Internal.Byte2DoubleFunction): Internal.Byte2ByteFunction
        andThenInt(arg0: Internal.Byte2IntFunction): Internal.Double2IntFunction
        composeReference<T>(arg0: Internal.Reference2DoubleFunction<T>): Internal.Reference2ByteFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Byte2DoubleFunction): Internal.Double2DoubleFunction
        andThenObject<T>(arg0: Internal.Byte2ObjectFunction<T>): Internal.Double2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Byte2LongFunction): Internal.Double2LongFunction
        composeLong(arg0: Internal.Long2DoubleFunction): Internal.Long2ByteFunction
        andThenByte(arg0: Internal.Byte2ByteFunction): Internal.Double2ByteFunction
        andThenFloat(arg0: Internal.Byte2FloatFunction): Internal.Double2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2DoubleFunction): Internal.Int2ByteFunction
        clear(): void
        composeFloat(arg0: Internal.Float2DoubleFunction): Internal.Float2ByteFunction
        andThenChar(arg0: Internal.Byte2CharFunction): Internal.Double2CharFunction
        composeObject<T>(arg0: Internal.Object2DoubleFunction<T>): Internal.Object2ByteFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2DoubleFunction): Internal.Short2ByteFunction
        andThenReference<T>(arg0: Internal.Byte2ReferenceFunction<T>): Internal.Double2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2DoubleFunction): Internal.Char2ByteFunction
        composeDouble(arg0: Internal.Double2DoubleFunction): Internal.Double2ByteFunction
    }
    interface PathMatcher {
        matches(arg0: Internal.Path): boolean
    }
    interface NearbyEntityListener {
        getEntityClass(): Internal.Class<Internal.Entity>
        getChunkRange(): Internal.Range6Int
        onSectionLeftRange<T>(entityTrackingSection: object, collection: Internal.ClassInstanceMultiMap<T>): void
        onEntityLeftRange(arg0: Internal.Entity): void
        onSectionEnteredRange<T>(entityTrackingSection: object, collection: Internal.ClassInstanceMultiMap<T>): void
        forEachChunkInRangeChange(entityCache: Internal.EntitySectionStorage<Internal.EntityAccess>, prevCenterPos: Internal.SectionPos, newCenterPos: Internal.SectionPos): void
        onEntityEnteredRange(arg0: Internal.Entity): void
        static readonly EMPTY_RANGE : Internal.Range6Int;
        get entityClass(): Internal.Class<Internal.Entity>;
        get chunkRange(): Internal.Range6Int;
    }
    class DataLayer implements Internal.IReadonly {
        isReadonly(): boolean
        get(idx: number): number
        toString(): string
    }
    class ZoneRules implements Internal.Serializable {
        getTransitions(): Internal.List<Internal.ZoneOffsetTransition>
        getDaylightSavings(arg0: Internal.Instant): Internal.Duration
        getTransitionRules(): Internal.List<Internal.ZoneOffsetTransitionRule>
        previousTransition(arg0: Internal.Instant): Internal.ZoneOffsetTransition
        getOffset(arg0: Internal.LocalDateTime): Internal.ZoneOffset
        getOffset(arg0: Internal.Instant): Internal.ZoneOffset
        isFixedOffset(): boolean
        hashCode(): number
        getTransition(arg0: Internal.LocalDateTime): Internal.ZoneOffsetTransition
        getValidOffsets(arg0: Internal.LocalDateTime): Internal.List<Internal.ZoneOffset>
        static of(arg0: Internal.ZoneOffset, arg1: Internal.ZoneOffset, arg2: Internal.List<Internal.ZoneOffsetTransition>, arg3: Internal.List<Internal.ZoneOffsetTransition>, arg4: Internal.List<Internal.ZoneOffsetTransitionRule>): Internal.ZoneRules
        static of(arg0: Internal.ZoneOffset): Internal.ZoneRules
        equals(arg0: object): boolean
        nextTransition(arg0: Internal.Instant): Internal.ZoneOffsetTransition
        getStandardOffset(arg0: Internal.Instant): Internal.ZoneOffset
        toString(): string
        isDaylightSavings(arg0: Internal.Instant): boolean
        isValidOffset(arg0: Internal.LocalDateTime, arg1: Internal.ZoneOffset): boolean
        get transitions(): Internal.List<Internal.ZoneOffsetTransition>;
        get transitionRules(): Internal.List<Internal.ZoneOffsetTransitionRule>;
    }
    class CollectionTag <T> extends Internal.AbstractList<T> implements net.minecraft.nbt.Tag, Internal.CustomJavaObjectWrapper$AsList {
        add(arg0: number, arg1: T): void
        add(arg0: number, arg1: object): void
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, staticType: Internal.Class<object>): Internal.Scriptable
        wrapAsJavaList(): Internal.List<any>
        set(arg0: number, arg1: T): T
        set(arg0: number, arg1: object): object
        remove(arg0: number): object
        remove(arg0: number): T
    }
    class ServerPlayer extends Internal.Player {
        getLanguage(): string
        refreshTabListName(): void
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        backpackedMoved : boolean;
        backpackedInventory : Internal.BackpackInventory;
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
        get language(): string;
    }
    class OptionalLong {
        isEmpty(): boolean
        isPresent(): boolean
        orElse(arg0: number): number
        orElseThrow<X>(arg0: () => X): number
        orElseThrow(): number
        static empty(): Internal.OptionalLong
        getAsLong(): number
        orElseGet(arg0: Internal.LongSupplier): number
        stream(): Internal.LongStream
        hashCode(): number
        ifPresentOrElse(arg0: Internal.LongConsumer, arg1: Internal.Runnable): void
        ifPresent(arg0: Internal.LongConsumer): void
        static of(arg0: number): Internal.OptionalLong
        equals(arg0: object): boolean
        toString(): string
        get asLong(): number;
    }
    class ChronoUnit extends Internal.Enum<Internal.ChronoUnit> implements Internal.TemporalUnit {
        isDurationEstimated(): boolean
        getDuration(): Internal.Duration
        static valueOf(arg0: string): Internal.ChronoUnit
        isTimeBased(): boolean
        static values(): Internal.ChronoUnit[]
        addTo<R>(arg0: R, arg1: number): R
        toString(): string
        isDateBased(): boolean
        between(arg0: Internal.Temporal, arg1: Internal.Temporal): number
        isSupportedBy(arg0: Internal.Temporal): boolean
        static readonly FOREVER : Internal.ChronoUnit;
        static readonly MICROS : Internal.ChronoUnit;
        static readonly SECONDS : Internal.ChronoUnit;
        static readonly DECADES : Internal.ChronoUnit;
        static readonly MILLENNIA : Internal.ChronoUnit;
        static readonly DAYS : Internal.ChronoUnit;
        static readonly MILLIS : Internal.ChronoUnit;
        static readonly HALF_DAYS : Internal.ChronoUnit;
        static readonly MONTHS : Internal.ChronoUnit;
        static readonly YEARS : Internal.ChronoUnit;
        static readonly HOURS : Internal.ChronoUnit;
        static readonly WEEKS : Internal.ChronoUnit;
        static readonly NANOS : Internal.ChronoUnit;
        static readonly CENTURIES : Internal.ChronoUnit;
        static readonly MINUTES : Internal.ChronoUnit;
        static readonly ERAS : Internal.ChronoUnit;
        get duration(): Internal.Duration;
    }
    class ForgeRegistryEntry <V> implements Internal.IForgeRegistryEntry<V> {
        getRegistryType(): Internal.Class<V>
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): object
        setRegistryName(arg0: ResourceLocation): V
        setRegistryName(arg0: string): V
        setRegistryName(arg0: string, arg1: string): V
        readonly delegate : () => V;
        get registryType(): Internal.Class<V>;
        get registryName(): ResourceLocation;
        set registryName(arg0: ResourceLocation);
        set registryName(arg0: ResourceLocation);
        set registryName(arg0: string);
    }
    interface NumberProvider implements Internal.LootContextUser {
    }
    class NetworkEvent$PacketDispatcher {
        sendPacket(arg0: ResourceLocation, arg1: Internal.FriendlyByteBuf): void
    }
    class Object2LongEntry implements Internal.Comparable<Internal.Object2LongEntry> {
        compareTo(arg0: object): number
        compareTo(o: Internal.Object2LongEntry): number
        readonly value : number;
        readonly key : object;
    }
    class BlockBehaviour$Properties {
        lootFrom(arg0: () => Internal.Block): Internal.BlockBehaviour$Properties
    }
    interface Long2ReferenceFunction <V> implements Internal.Function<number, V>, Internal.LongFunction<V> {
        getOrDefault(arg0: number, arg1: V): V
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Reference2ShortFunction<V>): Internal.Long2ShortFunction
        composeByte(arg0: Internal.Byte2LongFunction): Internal.Byte2ReferenceFunction<V>
        andThenInt(arg0: Internal.Reference2IntFunction<V>): Internal.Long2IntFunction
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: Internal.Reference2LongFunction<T>): (arg0: T) => V
        put(arg0: number, arg1: V): V
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: object): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: Internal.Reference2DoubleFunction<V>): Internal.Long2DoubleFunction
        andThenObject<T>(arg0: (arg0: V) => T): Internal.Long2ObjectFunction<T>
        get(arg0: object): V
        get(arg0: number): V
        andThenLong(arg0: Internal.Reference2LongFunction<V>): Internal.Long2LongFunction
        composeLong(arg0: Internal.Long2LongFunction): Internal.Long2ReferenceFunction<V>
        andThenByte(arg0: Internal.Reference2ByteFunction<V>): Internal.Long2ByteFunction
        andThenFloat(arg0: Internal.Reference2FloatFunction<V>): Internal.Long2FloatFunction
        apply(arg0: number): V
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2LongFunction): Internal.Int2ReferenceFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2LongFunction): Internal.Float2ReferenceFunction<V>
        andThenChar(arg0: Internal.Reference2CharFunction<V>): Internal.Long2CharFunction
        composeObject<T>(arg0: Internal.Object2LongFunction<T>): (arg0: T) => V
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => V
        composeShort(arg0: Internal.Short2LongFunction): Internal.Short2ReferenceFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): Internal.Long2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2LongFunction): Internal.Char2ReferenceFunction<V>
        composeDouble(arg0: Internal.Double2LongFunction): Internal.Double2ReferenceFunction<V>
    }
    interface DirectoryStream <T> implements Internal.Closeable, Internal.Iterable<T> {
        iterator(): Internal.Iterator<T>
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
        close(): void
    }
    class LevelChunkSection implements Internal.BlockCountingSection {
        anyMatch(indexedBlockStatePredicate: Internal.IndexedBlockStatePredicate): boolean
    }
    class Products$P3 <F, T1, T2, T3> {
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.Function3<T1, T2, T3, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, Internal.Function3<T1, T2, T3, R>>): Internal.App<F, R>
        and<T4, T5, T6, T7>(arg0: Internal.Products$P4<F, T4, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        and<T4, T5, T6, T7, T8>(arg0: Internal.Products$P5<F, T4, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        and<T4>(arg0: Internal.App<F, T4>): Internal.Products$P4<F, T1, T2, T3, T4>
        and<T4, T5>(arg0: Internal.Products$P2<F, T4, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>
        and<T4, T5, T6>(arg0: Internal.Products$P3<F, T4, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>
        t1(): Internal.App<F, T1>
        t2(): Internal.App<F, T2>
        t3(): Internal.App<F, T3>
    }
    class Tesselator {
    }
    interface ICustomPacket <T> {
        setName(arg0: ResourceLocation): void
        getThis(): T
        getName(): ResourceLocation
        getDirection(): Internal.NetworkDirection
        getIndex(): number
        setData(arg0: Internal.FriendlyByteBuf): void
        setIndex(arg0: number): void
        getInternalData(): Internal.FriendlyByteBuf
        set name(arg0: ResourceLocation);
        get this(): T;
        get name(): ResourceLocation;
        get direction(): Internal.NetworkDirection;
        get index(): number;
        set data(arg0: Internal.FriendlyByteBuf);
        set index(arg0: number);
        get internalData(): Internal.FriendlyByteBuf;
    }
    interface AttributeMap {
        hasAttr<T>(arg0: Internal.AttributeKey<T>): boolean
        attr<T>(arg0: Internal.AttributeKey<T>): io.netty.util.Attribute<T>
    }
    class FoodBuilder {
        saturation(s: number): Internal.FoodBuilder
        build(): Internal.FoodProperties
        removeEffect(mobEffect: Internal.MobEffect): Internal.FoodBuilder
        effect(mobEffectId: ResourceLocation, duration: number, amplifier: number, probability: number): Internal.FoodBuilder
        alwaysEdible(flag: boolean): Internal.FoodBuilder
        alwaysEdible(): Internal.FoodBuilder
        meat(flag: boolean): Internal.FoodBuilder
        meat(): Internal.FoodBuilder
        fastToEat(flag: boolean): Internal.FoodBuilder
        fastToEat(): Internal.FoodBuilder
        eaten(e: (arg0: Internal.ItemFoodEatenEventJS) => void): Internal.FoodBuilder
        hunger(h: number): Internal.FoodBuilder
    }
    interface ClassGroupFilterableList <T> {
        getAllOfGroupType(arg0: Internal.EntityClassGroup): Internal.Collection<T>
    }
    interface LootItemCondition implements Internal.LootContextUser, Internal.Predicate<Internal.LootContext>, Internal.ILootHandler, Internal.LootItemConditionMixin {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        test(arg0: T): boolean
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
    }
    class ListenerList {
        getListeners(arg0: number): Internal.IEventListener[]
        static clearBusID(arg0: number): void
        unregister(arg0: number, arg1: Internal.IEventListener): void
        static unregisterAll(arg0: number, arg1: Internal.IEventListener): void
        register(arg0: number, arg1: Internal.EventPriority, arg2: Internal.IEventListener): void
    }
    interface IForgeBlockState {
        rotate(arg0: Internal.LevelAccessor, arg1: BlockPos, arg2: Internal.Rotation): Internal.BlockState
        getStateAtViewpoint(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Vec3): Internal.BlockState
        onBlockExploded(arg0: Internal.Level, arg1: BlockPos, arg2: Internal.Explosion): void
        getBedDirection(arg0: Internal.LevelReader, arg1: BlockPos): Internal.Direction
        getExpDrop(arg0: Internal.LevelReader, arg1: BlockPos, arg2: number, arg3: number): number
        isConduitFrame(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): boolean
        getLightEmission(arg0: Internal.BlockGetter, arg1: BlockPos): number
        onDestroyedByPlayer(arg0: Internal.Level, arg1: BlockPos, arg2: Internal.Player, arg3: boolean, arg4: Internal.FluidState): boolean
        isBed(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.LivingEntity): boolean
        canHarvestBlock(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Player): boolean
        shouldCheckWeakPower(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Direction): boolean
        collisionExtendsVertically(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Entity): boolean
        addLandingEffects(arg0: Internal.ServerLevel, arg1: BlockPos, arg2: Internal.BlockState, arg3: Internal.LivingEntity, arg4: number): boolean
        isLadder(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.LivingEntity): boolean
        shouldDisplayFluidOverlay(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidState): boolean
        getSoundType(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity): Internal.SoundType
        canStickTo(arg0: Internal.BlockState): boolean
        onNeighborChange(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): void
        addRunningEffects(arg0: Internal.Level, arg1: BlockPos, arg2: Internal.Entity): boolean
        getWeakChanges(arg0: Internal.LevelReader, arg1: BlockPos): boolean
        canEntityDestroy(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Entity): boolean
        isBurning(arg0: Internal.BlockGetter, arg1: BlockPos): boolean
        getCloneItemStack(arg0: Internal.HitResult, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Player): Internal.ItemStack
        getFriction(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity): number
        isFlammable(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): boolean
        isValidSpawn(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.SpawnPlacements$Type, arg3: Internal.EntityType<object>): boolean
        isPortalFrame(arg0: Internal.BlockGetter, arg1: BlockPos): boolean
        getBlockPathType(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Mob): Internal.BlockPathTypes
        getBlockPathType(arg0: Internal.BlockGetter, arg1: BlockPos): Internal.BlockPathTypes
        getExplosionResistance(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): number
        isScaffolding(arg0: Internal.LivingEntity): boolean
        canSustainPlant(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction, arg3: Internal.IPlantable): boolean
        onCaughtFire(arg0: Internal.Level, arg1: BlockPos, arg2: Internal.Direction, arg3: Internal.LivingEntity): void
        getEnchantPowerBonus(arg0: Internal.LevelReader, arg1: BlockPos): number
        setBedOccupied(arg0: Internal.Level, arg1: BlockPos, arg2: Internal.LivingEntity, arg3: boolean): void
        isFireSource(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Direction): boolean
        canDropFromExplosion(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): boolean
        getRespawnPosition(arg0: Internal.EntityType<object>, arg1: Internal.LevelReader, arg2: BlockPos, arg3: number, arg4: Internal.LivingEntity): Internal.Optional<Vec3>
        canRedstoneConnectTo(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): boolean
        isStickyBlock(): boolean
        isFertile(arg0: Internal.BlockGetter, arg1: BlockPos): boolean
        isSlimeBlock(): boolean
        getFireSpreadSpeed(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): number
        getFlammability(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): number
        getToolModifiedState(arg0: Internal.Level, arg1: BlockPos, arg2: Internal.Player, arg3: Internal.ItemStack, arg4: Internal.ToolAction): Internal.BlockState
        getBeaconColorMultiplier(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): number[]
    }
    class LootModificationEventJS extends Internal.EventJS {
        addLootTableModifier(arg0: string[]): Internal.LootActionsBuilderJS
        getGlobalModifiers(): Internal.List<string>
        addBlockLootModifier(arg0: BlockStatePredicate): Internal.LootActionsBuilderJS
        addLootTypeModifier(arg0: LootType[]): Internal.LootActionsBuilderJS
        addEntityLootModifier(arg0: Internal.EntityType<object>[]): Internal.LootActionsBuilderJS
        removeGlobalModifier(arg0: string[]): void
        enableLogging(): void
        splitLocationsOrPattern(arg0: string[], arg1: Internal.List<Internal.Pattern>, arg2: Internal.List<ResourceLocation>): void
        disableLootModification(arg0: string[]): void
        get globalModifiers(): Internal.List<string>;
    }
    class FileSystem implements Internal.Closeable {
        isReadOnly(): boolean
        isOpen(): boolean
        supportedFileAttributeViews(): Internal.Set<string>
        provider(): Internal.FileSystemProvider
        getFileStores(): Internal.Iterable<Internal.FileStore>
        getRootDirectories(): Internal.Iterable<Internal.Path>
        getPath(arg0: string, arg1: string[]): Internal.Path
        getSeparator(): string
        getPathMatcher(arg0: string): Internal.PathMatcher
        newWatchService(): Internal.WatchService
        close(): void
        getUserPrincipalLookupService(): Internal.UserPrincipalLookupService
        get fileStores(): Internal.Iterable<Internal.FileStore>;
        get rootDirectories(): Internal.Iterable<Internal.Path>;
        get separator(): string;
        get userPrincipalLookupService(): Internal.UserPrincipalLookupService;
    }
    class AndCondition implements Internal.IExtendedLootCondition {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        test(arg0: Internal.LootContext): boolean
        test(arg0: object): boolean
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
    }
    interface ChronoZonedDateTime <D> implements Internal.Temporal, Internal.Comparable<Internal.ChronoZonedDateTime<object>> {
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoZonedDateTime<D>
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: Internal.TemporalAmount): Internal.ChronoZonedDateTime<D>
        isEqual(arg0: Internal.ChronoZonedDateTime<object>): boolean
        getOffset(): Internal.ZoneOffset
        toLocalTime(): Internal.LocalTime
        range(arg0: Internal.TemporalField): Internal.ValueRange
        compareTo(arg0: object): number
        compareTo(arg0: Internal.ChronoZonedDateTime<object>): number
        withLaterOffsetAtOverlap(): Internal.ChronoZonedDateTime<D>
        hashCode(): number
        get(arg0: Internal.TemporalField): number
        withEarlierOffsetAtOverlap(): Internal.ChronoZonedDateTime<D>
        withZoneSameLocal(arg0: Internal.ZoneId): Internal.ChronoZonedDateTime<D>
        static from(arg0: Internal.TemporalAccessor): Internal.ChronoZonedDateTime<object>
        getChronology(): Internal.Chronology
        withZoneSameInstant(arg0: Internal.ZoneId): Internal.ChronoZonedDateTime<D>
        query<R>(arg0: Internal.TemporalQuery<R>): R
        format(arg0: Internal.DateTimeFormatter): string
        getZone(): Internal.ZoneId
        isSupported(arg0: Internal.TemporalUnit): boolean
        isSupported(arg0: Internal.TemporalField): boolean
        toInstant(): Internal.Instant
        isBefore(arg0: Internal.ChronoZonedDateTime<object>): boolean
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.ChronoZonedDateTime<D>
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoZonedDateTime<D>
        getLong(arg0: Internal.TemporalField): number
        with(arg0: Internal.TemporalField, arg1: number): Internal.ChronoZonedDateTime<D>
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.ChronoZonedDateTime<D>
        toLocalDate(): D
        toEpochSecond(): number
        toLocalDateTime(): Internal.ChronoLocalDateTime<D>
        equals(arg0: object): boolean
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        static timeLineOrder(): Internal.Comparator<Internal.ChronoZonedDateTime<object>>
        toString(): string
        isAfter(arg0: Internal.ChronoZonedDateTime<object>): boolean
        get offset(): Internal.ZoneOffset;
        get chronology(): Internal.Chronology;
        get zone(): Internal.ZoneId;
    }
    class ContentHandler {
        getContent(arg0: Internal.URLConnection): object
        getContent(arg0: Internal.URLConnection, arg1: Internal.Class[]): object
    }
    class ObjectArrayList <K> extends Internal.AbstractObjectList<K> implements Internal.RandomAccess, Internal.Cloneable, Internal.Serializable {
        static toList<K>(): Internal.Collector<K, object, Internal.ObjectArrayList<K>>
        compareTo(arg0: Internal.List<K>): number
        compareTo(arg0: object): number
        compareTo(arg0: Internal.ObjectArrayList<K>): number
        remove(arg0: object): boolean
        remove(arg0: number): K
        removeAll(arg0: Internal.Collection<object>): boolean
        trim(arg0: number): void
        trim(): void
        addElements(arg0: number, arg1: K[], arg2: number, arg3: number): void
        static of<K>(arg0: K[]): Internal.ObjectArrayList<K>
        static of<K>(): Internal.ObjectArrayList<K>
        get(arg0: number): K
        toArray<K>(arg0: K[]): K[]
        toArray(): object[]
        static toListWithExpectedSize<K>(arg0: number): Internal.Collector<K, object, Internal.ObjectArrayList<K>>
        indexOf(arg0: object): number
        add(arg0: number, arg1: K): void
        add(arg0: K): boolean
        subList(arg0: number, arg1: number): Internal.List<any>
        subList(arg0: number, arg1: number): Internal.ObjectList<K>
        set(arg0: number, arg1: K): K
        spliterator(): Internal.ObjectSpliterator<K>
        spliterator(): Internal.Spliterator<any>
        forEach(arg0: (arg0: K) => void): void
        isEmpty(): boolean
        clear(): void
        setElements(arg0: number, arg1: K[], arg2: number, arg3: number): void
        sort(arg0: Internal.Comparator<K>): void
        removeElements(arg0: number, arg1: number): void
        lastIndexOf(arg0: object): number
        size(arg0: number): void
        size(): number
        addAll(arg0: number, arg1: Internal.ObjectList<K>): boolean
        addAll(arg0: number, arg1: Internal.Collection<K>): boolean
        getElements(arg0: number, arg1: object[], arg2: number, arg3: number): void
        elements(): K[]
        equals(arg0: Internal.ObjectArrayList<K>): boolean
        equals(arg0: object): boolean
        clone(): object
        clone(): Internal.ObjectArrayList<K>
        listIterator(arg0: number): Internal.ListIterator<any>
        listIterator(arg0: number): Internal.ObjectListIterator<K>
        ensureCapacity(arg0: number): void
        static wrap<K>(arg0: K[]): Internal.ObjectArrayList<K>
        static wrap<K>(arg0: K[], arg1: number): Internal.ObjectArrayList<K>
        unstableSort(arg0: Internal.Comparator<K>): void
        static readonly DEFAULT_INITIAL_CAPACITY : 10;
    }
    class Stages {
        add(stage: string): boolean
        getAll(): Internal.Collection<string>
        set(stage: string, enabled: boolean): boolean
        static added(event: (arg0: Internal.StageChangeEvent) => void): void
        static invokeAdded(stages: Internal.Stages, stage: string): void
        replace(stages: Internal.Collection<string>): void
        clear(): boolean
        toggle(stage: string): boolean
        addNoUpdate(arg0: string): boolean
        sync(): void
        remove(stage: string): boolean
        static removed(event: (arg0: Internal.StageChangeEvent) => void): void
        static get(player: Internal.Player): Internal.Stages
        static invokeRemoved(stages: Internal.Stages, stage: string): void
        static overrideCreation(event: (arg0: Internal.StageCreationEvent) => void): void
        has(stage: string): boolean
        removeNoUpdate(arg0: string): boolean
        readonly player : Internal.Player;
        get all(): Internal.Collection<string>;
    }
    class NetworkInterface {
        getInterfaceAddresses(): Internal.List<Internal.InterfaceAddress>
        getParent(): Internal.NetworkInterface
        getName(): string
        getIndex(): number
        supportsMulticast(): boolean
        getSubInterfaces(): Internal.Enumeration<Internal.NetworkInterface>
        static getByIndex(arg0: number): Internal.NetworkInterface
        inetAddresses(): Internal.Stream<Internal.InetAddress>
        static getByInetAddress(arg0: Internal.InetAddress): Internal.NetworkInterface
        isPointToPoint(): boolean
        getMTU(): number
        static networkInterfaces(): Internal.Stream<Internal.NetworkInterface>
        isUp(): boolean
        getDisplayName(): string
        hashCode(): number
        equals(arg0: object): boolean
        static getByName(arg0: string): Internal.NetworkInterface
        getHardwareAddress(): number[]
        isLoopback(): boolean
        subInterfaces(): Internal.Stream<Internal.NetworkInterface>
        toString(): string
        isVirtual(): boolean
        static getNetworkInterfaces(): Internal.Enumeration<Internal.NetworkInterface>
        getInetAddresses(): Internal.Enumeration<Internal.InetAddress>
        get interfaceAddresses(): Internal.List<Internal.InterfaceAddress>;
        get parent(): Internal.NetworkInterface;
        get name(): string;
        get index(): number;
        get mTU(): number;
        get displayName(): string;
        get hardwareAddress(): number[];
    }
    class ItemFoodEatenEventJS extends Internal.PlayerEventJS {
        getItem(): Internal.ItemStackJS
        getEntity(): Internal.EntityJS
        canCancel(): boolean
        get item(): Internal.ItemStackJS;
        get entity(): Internal.EntityJS;
    }
    class ScriptFile implements Internal.Comparable<Internal.ScriptFile> {
        getError(): Internal.Throwable
        load(): boolean
        compareTo(o: Internal.ScriptFile): number
        compareTo(arg0: object): number
        readonly source : Internal.ScriptSource;
        readonly pack : Internal.ScriptPack;
        readonly info : Internal.ScriptFileInfo;
        get error(): Internal.Throwable;
    }
    class NotConditionBuilder implements Internal.ConditionsContainer<Internal.NotConditionBuilder> {
        killerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B
        survivesExplosion(): B
        addCondition(arg0: Internal.LootItemCondition): Internal.ConditionsContainer<any>
        addCondition(arg0: Internal.LootItemCondition): Internal.NotConditionBuilder
        addCondition(arg0: Internal.LootItemCondition$Builder): B
        customDistanceToPlayer(arg0: (arg0: Internal.DistancePredicateBuilder) => void): B
        matchFluid(arg0: string): B
        not(arg0: (arg0: Internal.NotConditionBuilder) => void): B
        directKillerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B
        matchEquip(arg0: EquipmentSlot, arg1: Internal.IngredientJS): B
        and(arg0: (arg0: Internal.AndConditionBuilder) => void): B
        matchLoot(arg0: Internal.IngredientJS): B
        matchLoot(arg0: Internal.IngredientJS, arg1: boolean): B
        anyBiome(arg0: string[]): B
        distanceToKiller(arg0: Internal.MinMaxBounds$Doubles): B
        entityPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B
        matchEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        anyDimension(arg0: ResourceLocation[]): B
        killedByPlayer(): B
        or(arg0: (arg0: Internal.OrConditionBuilder) => void): B
        timeCheck(arg0: number, arg1: number, arg2: number): B
        timeCheck(arg0: number, arg1: number): B
        matchOffHand(arg0: Internal.IngredientJS): B
        randomChance(arg0: number): B
        playerPredicate(arg0: (arg0: Internal.PlayerJS<object>) => boolean): B
        weatherCheck(arg0: Map<string, boolean>): B
        matchDirectKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        matchBlockState(arg0: Internal.Block, arg1: Map<string, string>): B
        matchMainHand(arg0: Internal.IngredientJS): B
        matchPlayer(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        lightLevel(arg0: number, arg1: number): B
        build(): Internal.InvertedLootItemCondition
        biome(arg0: string[]): B
        customCondition(arg0: Internal.JsonObject): B
        matchKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        randomChanceWithLooting(arg0: number, arg1: number): B
        hasAnyStage(arg0: string[]): B
        randomChanceWithEnchantment(arg0: Internal.Enchantment, arg1: number[]): B
        anyStructure(arg0: ResourceLocation[], arg1: boolean): B
        matchDamageSource(arg0: (arg0: Internal.DamageSourcePredicateBuilderJS) => void): B
    }
    interface DoubleStream$DoubleMapMultiConsumer {
        accept(arg0: number, arg1: Internal.DoubleConsumer): void
    }
    interface GatheringByteChannel implements Internal.WritableByteChannel {
        isOpen(): boolean
        close(): void
        write(arg0: Internal.ByteBuffer[], arg1: number, arg2: number): number
        write(arg0: Internal.ByteBuffer[]): number
        write(arg0: Internal.ByteBuffer): number
    }
    interface Reference2FloatFunction <K> implements Internal.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: number): number
        applyAsDouble(arg0: K): number
        andThenShort(arg0: Internal.Float2ShortFunction): Internal.Reference2ShortFunction<K>
        composeByte(arg0: Internal.Byte2ReferenceFunction<K>): Internal.Byte2FloatFunction
        getFloat(arg0: object): number
        andThenInt(arg0: Internal.Float2IntFunction): Internal.Reference2IntFunction<K>
        composeReference<T>(arg0: (arg0: T) => K): Internal.Reference2FloatFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: K) => T
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: object, arg1: object): object
        remove(arg0: object): number
        remove(arg0: object): object
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: Internal.Float2DoubleFunction): Internal.Reference2DoubleFunction<K>
        andThenObject<T>(arg0: Internal.Float2ObjectFunction<T>): (arg0: K) => T
        get(arg0: object): object
        get(arg0: object): number
        andThenLong(arg0: Internal.Float2LongFunction): Internal.Reference2LongFunction<K>
        composeLong(arg0: Internal.Long2ReferenceFunction<K>): Internal.Long2FloatFunction
        andThenByte(arg0: Internal.Float2ByteFunction): Internal.Reference2ByteFunction<K>
        andThenFloat(arg0: Internal.Float2FloatFunction): Internal.Reference2FloatFunction<K>
        removeFloat(arg0: object): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ReferenceFunction<K>): Internal.Int2FloatFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ReferenceFunction<K>): Internal.Float2FloatFunction
        andThenChar(arg0: Internal.Float2CharFunction): Internal.Reference2CharFunction<K>
        composeObject<T>(arg0: (arg0: T) => K): Internal.Object2FloatFunction<T>
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ReferenceFunction<K>): Internal.Short2FloatFunction
        andThenReference<T>(arg0: Internal.Float2ReferenceFunction<T>): (arg0: K) => T
        composeChar(arg0: Internal.Char2ReferenceFunction<K>): Internal.Char2FloatFunction
        composeDouble(arg0: Internal.Double2ReferenceFunction<K>): Internal.Double2FloatFunction
    }
    interface Byte2LongFunction implements Internal.Function<number, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Long2ShortFunction): Internal.Byte2ShortFunction
        composeByte(arg0: Internal.Byte2ByteFunction): Internal.Byte2LongFunction
        andThenInt(arg0: Internal.Long2IntFunction): Internal.Byte2IntFunction
        composeReference<T>(arg0: Internal.Reference2ByteFunction<T>): Internal.Reference2LongFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Long2DoubleFunction): Internal.Byte2DoubleFunction
        andThenObject<T>(arg0: Internal.Long2ObjectFunction<T>): Internal.Byte2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Long2LongFunction): Internal.Byte2LongFunction
        composeLong(arg0: Internal.Long2ByteFunction): Internal.Long2LongFunction
        andThenByte(arg0: Internal.Long2ByteFunction): Internal.Byte2ByteFunction
        andThenFloat(arg0: Internal.Long2FloatFunction): Internal.Byte2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ByteFunction): Internal.Int2LongFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ByteFunction): Internal.Float2LongFunction
        andThenChar(arg0: Internal.Long2CharFunction): Internal.Byte2CharFunction
        applyAsLong(arg0: number): number
        composeObject<T>(arg0: Internal.Object2ByteFunction<T>): Internal.Object2LongFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2ByteFunction): Internal.Short2LongFunction
        andThenReference<T>(arg0: Internal.Long2ReferenceFunction<T>): Internal.Byte2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ByteFunction): Internal.Char2LongFunction
        composeDouble(arg0: Internal.Double2ByteFunction): Internal.Double2LongFunction
    }
    class ClassLoader {
        static getSystemResources(arg0: string): Internal.Enumeration<Internal.URL>
        getParent(): Internal.ClassLoader
        getResource(arg0: string): Internal.URL
        static getPlatformClassLoader(): Internal.ClassLoader
        getName(): string
        getResourceAsStream(arg0: string): Internal.InputStream
        setDefaultAssertionStatus(arg0: boolean): void
        resources(arg0: string): Internal.Stream<Internal.URL>
        static getSystemClassLoader(): Internal.ClassLoader
        static getSystemResource(arg0: string): Internal.URL
        setPackageAssertionStatus(arg0: string, arg1: boolean): void
        setClassAssertionStatus(arg0: string, arg1: boolean): void
        getDefinedPackage(arg0: string): Internal.Package
        static getSystemResourceAsStream(arg0: string): Internal.InputStream
        clearAssertionStatus(): void
        isRegisteredAsParallelCapable(): boolean
        getResources(arg0: string): Internal.Enumeration<Internal.URL>
        loadClass(arg0: string): Internal.Class<object>
        getDefinedPackages(): Internal.Package[]
        getUnnamedModule(): Internal.Module
        get parent(): Internal.ClassLoader;
        get platformClassLoader(): Internal.ClassLoader;
        get name(): string;
        set defaultAssertionStatus(arg0: boolean);
        get systemClassLoader(): Internal.ClassLoader;
        get definedPackages(): Internal.Package[];
        get unnamedModule(): Internal.Module;
    }
    class RecordCodecBuilder$Mu <O> implements Internal.K1 {
    }
    class NativeContinuation extends Internal.IdScriptableObject implements dev.latvian.mods.rhino.Function {
        call(cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: object[]): object
        static init(cx: Internal.Context, scope: Internal.Scriptable, sealed: boolean): void
        getImplementation(): object
        static equalImplementations(c1: Internal.NativeContinuation, c2: Internal.NativeContinuation): boolean
        execIdCall(f: Internal.IdFunctionObject, cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: object[]): object
        construct(cx: Internal.Context, scope: Internal.Scriptable, args: object[]): Internal.Scriptable
        getClassName(): string
        initImplementation(implementation: object): void
        static isContinuationConstructor(f: Internal.IdFunctionObject): boolean
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : object;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get implementation(): object;
        get className(): string;
    }
    interface Color implements Internal.SpecialEquality {
        getRgbKJS(): number
        createTextColorKJS(): Internal.TextColor
        getHexKJS(): string
        getArgbKJS(): number
        getFireworkColorKJS(): number
        getSerializeKJS(): string
        specialEquals(o: object, shallow: boolean): boolean
        get rgbKJS(): number;
        get hexKJS(): string;
        get argbKJS(): number;
        get fireworkColorKJS(): number;
        get serializeKJS(): string;
    }
    interface MinecraftAccess {
        getFontManager(): Internal.FontManager
        get fontManager(): Internal.FontManager;
    }
    class NativeJavaClass extends Internal.NativeJavaObject implements dev.latvian.mods.rhino.Function {
        call(cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: object[]): object
        hasInstance(value: Internal.Scriptable): boolean
        get(name: string, start: Internal.Scriptable): object
        getIds(): object[]
        toString(): string
        getClassObject(): Internal.Class<object>
        construct(cx: Internal.Context, scope: Internal.Scriptable, args: object[]): Internal.Scriptable
        has(name: string, start: Internal.Scriptable): boolean
        getClassName(): string
        put(name: string, start: Internal.Scriptable, value: object): void
        getDefaultValue(hint: Internal.Class<object>): object
        static readonly NOT_FOUND : object;
        get ids(): object[];
        get classObject(): Internal.Class<object>;
        get className(): string;
    }
    class VertexFormat implements Internal.BufferVertexFormat {
        hasColor(): boolean
        getStride(): number
        hasPosition(): boolean
        hasNormal(): boolean
        hashCode(): number
        getOffset(arg0: number): number
        equals(arg0: object): boolean
        toString(): string
        getElementMapping(): Internal.ImmutableMap<string, Internal.VertexFormatElement>
        hasUV(arg0: number): boolean
        get stride(): number;
        get elementMapping(): Internal.ImmutableMap<string, Internal.VertexFormatElement>;
    }
    class ClientEventJS extends Internal.EventJS {
        getLevel(): Internal.ClientLevelJS
        getPlayer(): Internal.ClientPlayerJS
        post(id: string, sub: string): boolean
        post(id: string): boolean
        getEntity(): Internal.EntityJS
        get level(): Internal.ClientLevelJS;
        get player(): Internal.ClientPlayerJS;
        get entity(): Internal.EntityJS;
    }
    class Locale$IsoCountryCode extends Internal.Enum<Internal.Locale$IsoCountryCode> {
        static valueOf(arg0: string): Internal.Locale$IsoCountryCode
        static values(): Internal.Locale$IsoCountryCode[]
        static readonly PART3 : Internal.Locale$IsoCountryCode;
        static readonly PART1_ALPHA2 : Internal.Locale$IsoCountryCode;
        static readonly PART1_ALPHA3 : Internal.Locale$IsoCountryCode;
    }
    class AbstractInstance implements Internal.Instance, Internal.LightListener {
        init(): void
        getVolume(): Internal.ImmutableBox
        onLightUpdate(arg0: Internal.LightProvider, arg1: Internal.LightLayer, arg2: Internal.ImmutableBox): void
        onLightPacket(arg0: Internal.LightProvider, arg1: number, arg2: number): void
        update(): void
        updateLight(): void
        shouldReset(): boolean
        remove(): void
        getWorldPosition(): BlockPos
        status(): Internal.ListenerStatus
        readonly world : Internal.Level;
        get volume(): Internal.ImmutableBox;
        get worldPosition(): BlockPos;
    }
    class PathNavigation {
    }
    class Either <L, R> implements Internal.App<Internal.Either$Mu<R>, L> {
        mapRight<T>(arg0: (arg0: R) => T): Internal.Either<L, T>
        flatMap<L2>(arg0: (arg0: L) => Internal.Either<L2, R>): Internal.Either<L2, R>
        swap(): Internal.Either<R, L>
        static left<L, R>(arg0: L): Internal.Either<L, R>
        left(): Internal.Optional<L>
        static unbox<L, R>(arg0: Internal.App<Internal.Either$Mu<R>, L>): Internal.Either<L, R>
        mapLeft<T>(arg0: (arg0: L) => T): Internal.Either<T, R>
        ifLeft(arg0: (arg0: L) => void): Internal.Either<L, R>
        mapBoth<C, D>(arg0: (arg0: L) => C, arg1: (arg0: R) => D): Internal.Either<C, D>
        static right<L, R>(arg0: R): Internal.Either<L, R>
        right(): Internal.Optional<R>
        map<T>(arg0: (arg0: L) => T, arg1: (arg0: R) => T): T
        ifRight(arg0: (arg0: R) => void): Internal.Either<L, R>
        orThrow(): L
    }
    class ModelResourceLocation extends ResourceLocation {
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
    }
    class AttributeKey <T> extends Internal.AbstractConstant<Internal.AttributeKey<T>> {
        static valueOf<T>(arg0: string): Internal.AttributeKey<T>
        static valueOf<T>(arg0: Internal.Class<object>, arg1: string): Internal.AttributeKey<T>
        static exists(arg0: string): boolean
        static newInstance<T>(arg0: string): Internal.AttributeKey<T>
    }
    interface Function12 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R> {
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function3<T10, T11, T12, R>>
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12): R
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function5<T8, T9, T10, T11, T12, R>>
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function4<T9, T10, T11, T12, R>>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function7<T6, T7, T8, T9, T10, T11, T12, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function6<T7, T8, T9, T10, T11, T12, R>>
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, (arg0: T11, arg1: T12) => R>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function9<T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, (arg0: T12) => R>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function8<T5, T6, T7, T8, T9, T10, T11, T12, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function10<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>
        curry(): (arg0: T1) => Internal.Function11<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>
    }
    class Provider$Service {
        getAttribute(arg0: string): string
        getType(): string
        getAlgorithm(): string
        getProvider(): Internal.Provider
        newInstance(arg0: object): object
        toString(): string
        getClassName(): string
        supportsParameter(arg0: object): boolean
        get type(): string;
        get algorithm(): string;
        get provider(): Internal.Provider;
        get className(): string;
    }
    interface MovingListener implements Internal.LightListener {
        getVolume(): Internal.ImmutableBox
        onLightUpdate(arg0: Internal.LightProvider, arg1: Internal.LightLayer, arg2: Internal.ImmutableBox): void
        onLightPacket(arg0: Internal.LightProvider, arg1: number, arg2: number): void
        update(arg0: Internal.LightProvider): boolean
        status(): Internal.ListenerStatus
        get volume(): Internal.ImmutableBox;
    }
    interface RecipeType <T> {
    }
    class Connection extends Internal.SimpleChannelInboundHandler<Internal.Packet<object>> implements Internal.ConfigurableAutoFlush, Internal.ClientConnectionEncryptionExtension {
        channelInactive(arg0: Internal.ChannelHandlerContext): void
        setShouldAutoFlush(shouldAutoFlush: boolean): void
        handler$zec000$setCompressionThreshold(compressionThreshold: number, validate: boolean, ci: Internal.CallbackInfo): void
        getDirection(): Internal.PacketFlow
        setupEncryption(key: Internal.SecretKey): void
        channel(): Internal.Channel
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void
        channelActive(arg0: Internal.ChannelHandlerContext): void
        redirect$zdm000$disableForcedFlushEveryTick(clientConnection: Internal.Connection): Internal.Channel
        set shouldAutoFlush(shouldAutoFlush: boolean);
        get direction(): Internal.PacketFlow;
        set upEncryption(key: Internal.SecretKey);
    }
    class DamageSourcePredicateBuilderJS implements Internal.LootItemCondition$Builder {
        isFire(arg0: boolean): Internal.DamageSourcePredicateBuilderJS
        anyType(arg0: string[]): Internal.DamageSourcePredicateBuilderJS
        isMagic(arg0: boolean): Internal.DamageSourcePredicateBuilderJS
        isLightning(arg0: boolean): Internal.DamageSourcePredicateBuilderJS
        isExplosion(arg0: boolean): Internal.DamageSourcePredicateBuilderJS
        isProjectile(arg0: boolean): Internal.DamageSourcePredicateBuilderJS
        doesBypassInvulnerability(arg0: boolean): Internal.DamageSourcePredicateBuilderJS
        matchDirectEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.DamageSourcePredicateBuilderJS
        doesBypassMagic(arg0: boolean): Internal.DamageSourcePredicateBuilderJS
        matchSourceEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.DamageSourcePredicateBuilderJS
        doesBypassArmor(arg0: boolean): Internal.DamageSourcePredicateBuilderJS
    }
    interface ScriptSource {
        createStream(arg0: Internal.ScriptFileInfo): Internal.InputStream
    }
    class DynamicConstantDesc <T> implements Internal.ConstantDesc {
        static ofCanonical<T>(arg0: Internal.DirectMethodHandleDesc, arg1: string, arg2: Internal.ClassDesc, arg3: Internal.ConstantDesc[]): Internal.ConstantDesc
        constantType(): Internal.ClassDesc
        bootstrapMethod(): Internal.DirectMethodHandleDesc
        constantName(): string
        hashCode(): number
        bootstrapArgsList(): Internal.List<Internal.ConstantDesc>
        bootstrapArgs(): Internal.ConstantDesc[]
        static of<T>(arg0: Internal.DirectMethodHandleDesc, arg1: Internal.ConstantDesc[]): Internal.DynamicConstantDesc<T>
        static of<T>(arg0: Internal.DirectMethodHandleDesc): Internal.DynamicConstantDesc<T>
        equals(arg0: object): boolean
        static ofNamed<T>(arg0: Internal.DirectMethodHandleDesc, arg1: string, arg2: Internal.ClassDesc, arg3: Internal.ConstantDesc[]): Internal.DynamicConstantDesc<T>
        toString(): string
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): T
    }
    class ImmutableList$Builder <E> extends Internal.ImmutableCollection$Builder<E> {
        add(arg0: object): Internal.ImmutableCollection$Builder<any>
        add(arg0: E): Internal.ImmutableList$Builder<E>
        add(arg0: object[]): Internal.ImmutableCollection$Builder<any>
        add(arg0: E[]): Internal.ImmutableList$Builder<E>
        build(): Internal.ImmutableCollection<any>
        build(): Internal.ImmutableList<E>
        addAll(arg0: Internal.Iterator<E>): Internal.ImmutableList$Builder<E>
        addAll(arg0: Internal.Iterator<any>): Internal.ImmutableCollection$Builder<any>
        addAll(arg0: Internal.Iterable<any>): Internal.ImmutableCollection$Builder<any>
        addAll(arg0: Internal.Iterable<E>): Internal.ImmutableList$Builder<E>
    }
    class ScriptManager {
        loadFromDirectory(): void
        load(): void
        isClassAllowed(name: string): boolean
        loadJavaClass(scope: Internal.Scriptable, args: object[]): Internal.NativeJavaClass
        unload(): void
        readonly exampleScript : string;
        readonly type : Internal.ScriptType;
        firstLoad : boolean;
        readonly directory : Internal.Path;
        readonly packs : Map<string, Internal.ScriptPack>;
        readonly events : Internal.EventsJS;
    }
    class ClientPlayerDataJS extends Internal.PlayerDataJS<Internal.Player, Internal.ClientPlayerJS> {
        getLevel(): Internal.ClientLevelJS
        getPlayer(): Internal.PlayerJS<any>
        getPlayer(): Internal.ClientPlayerJS
        getMinecraftPlayer(): Internal.Player
        getName(): string
        getProfile(): Internal.GameProfile
        getId(): Internal.UUID
        getOverworld(): Internal.LevelJS
        get level(): Internal.ClientLevelJS;
        get player(): Internal.PlayerJS<any>;
        get player(): Internal.ClientPlayerJS;
        get minecraftPlayer(): Internal.Player;
        get name(): string;
        get profile(): Internal.GameProfile;
        get id(): Internal.UUID;
        get overworld(): Internal.LevelJS;
    }
    interface BinaryOperator <T> implements Internal.BiFunction<T, T, T> {
        apply(arg0: T, arg1: U): R
        static maxBy<T>(arg0: Internal.Comparator<T>): Internal.BinaryOperator<T>
        static minBy<T>(arg0: Internal.Comparator<T>): Internal.BinaryOperator<T>
        andThen<V>(arg0: (arg0: R) => V): (arg0: T, arg1: U) => V
    }
    class PaintEventJS extends Internal.ClientEventJS {
        pop(): void
        bindTexture(tex: ResourceLocation): void
        getMatrix(): Internal.Matrix4f
        vertex(m: Internal.Matrix4f, x: number, y: number, z: number, col: number): void
        vertex(m: Internal.Matrix4f, x: number, y: number, z: number, col: number, u: number, v: number): void
        setTextureEnabled(enabled: boolean): void
        beginQuads(texture: boolean): void
        beginQuads(format: Internal.VertexFormat): void
        getTextureAtlas(): Internal.TextureAtlas
        scale(x: number, y: number, z: number): void
        end(): void
        begin(type: Internal.VertexFormat$Mode, format: Internal.VertexFormat): void
        translate(x: number, y: number, z: number): void
        push(): void
        readonly mc : Internal.Minecraft;
        readonly delta : number;
        readonly screen : Internal.Screen;
        readonly tesselator : Internal.Tesselator;
        readonly buffer : Internal.BufferBuilder;
        readonly matrices : Internal.PoseStack;
        readonly font : Internal.Font;
        get matrix(): Internal.Matrix4f;
        set textureEnabled(enabled: boolean);
        get textureAtlas(): Internal.TextureAtlas;
    }
    class AtlasSet implements Internal.AutoCloseable {
        close(): void
    }
    interface DoubleStream implements Internal.BaseStream<number, Internal.DoubleStream> {
        average(): Internal.OptionalDouble
        sequential(): Internal.BaseStream<any, any>
        sequential(): Internal.DoubleStream
        takeWhile(arg0: Internal.DoublePredicate): Internal.DoubleStream
        distinct(): Internal.DoubleStream
        findFirst(): Internal.OptionalDouble
        sum(): number
        skip(arg0: number): Internal.DoubleStream
        allMatch(arg0: Internal.DoublePredicate): boolean
        mapToObj<U>(arg0: Internal.DoubleFunction<U>): Internal.Stream<U>
        static empty(): Internal.DoubleStream
        mapMulti(arg0: Internal.DoubleStream$DoubleMapMultiConsumer): Internal.DoubleStream
        iterator(): Internal.PrimitiveIterator$OfDouble
        iterator(): Internal.Iterator<any>
        min(): Internal.OptionalDouble
        mapToLong(arg0: Internal.DoubleToLongFunction): Internal.LongStream
        parallel(): Internal.BaseStream<any, any>
        parallel(): Internal.DoubleStream
        noneMatch(arg0: Internal.DoublePredicate): boolean
        findAny(): Internal.OptionalDouble
        static of(arg0: number[]): Internal.DoubleStream
        static of(arg0: number): Internal.DoubleStream
        isParallel(): boolean
        limit(arg0: number): Internal.DoubleStream
        static builder(): Internal.DoubleStream$Builder
        toArray(): number[]
        forEachOrdered(arg0: Internal.DoubleConsumer): void
        close(): void
        static generate(arg0: Internal.DoubleSupplier): Internal.DoubleStream
        anyMatch(arg0: Internal.DoublePredicate): boolean
        map(arg0: Internal.DoubleUnaryOperator): Internal.DoubleStream
        static iterate(arg0: number, arg1: Internal.DoublePredicate, arg2: Internal.DoubleUnaryOperator): Internal.DoubleStream
        static iterate(arg0: number, arg1: Internal.DoubleUnaryOperator): Internal.DoubleStream
        unordered(): S
        reduce(arg0: number, arg1: Internal.DoubleBinaryOperator): number
        reduce(arg0: Internal.DoubleBinaryOperator): Internal.OptionalDouble
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.Spliterator$OfDouble
        max(): Internal.OptionalDouble
        forEach(arg0: Internal.DoubleConsumer): void
        count(): number
        static concat(arg0: Internal.DoubleStream, arg1: Internal.DoubleStream): Internal.DoubleStream
        dropWhile(arg0: Internal.DoublePredicate): Internal.DoubleStream
        peek(arg0: Internal.DoubleConsumer): Internal.DoubleStream
        flatMap(arg0: Internal.DoubleFunction<Internal.DoubleStream>): Internal.DoubleStream
        filter(arg0: Internal.DoublePredicate): Internal.DoubleStream
        onClose(arg0: Internal.Runnable): S
        sorted(): Internal.DoubleStream
        boxed(): Internal.Stream<number>
        summaryStatistics(): Internal.DoubleSummaryStatistics
        mapToInt(arg0: Internal.DoubleToIntFunction): Internal.IntStream
        collect<R>(arg0: () => R, arg1: Internal.ObjDoubleConsumer<R>, arg2: (arg0: R, arg1: R) => void): R
    }
    class ConstantUnit extends Internal.FixedUnit {
        append(sb: Internal.StringBuilder): void
        static readonly ZERO : Internal.FixedUnit;
        static readonly ONE : Internal.FixedUnit;
        static readonly POS_INFINITY : Internal.FixedUnit;
        static readonly NEG_INFINITY : Internal.FixedUnit;
        readonly name : string;
        static readonly NAN : Internal.FixedUnit;
    }
    class BlockHitResult extends Internal.HitResult {
    }
    class MaterialJS {
        getMinecraftMaterial(): net.minecraft.world.level.material.Material
        getId(): string
        getSound(): Internal.SoundType
        get minecraftMaterial(): net.minecraft.world.level.material.Material;
        get id(): string;
        get sound(): Internal.SoundType;
    }
    class RecipeManager extends Internal.SimpleJsonResourceReloadListener implements Internal.RecipeManagerAccessor, Internal.RecipeManagerKJS {
        customRecipesKJS(jsonMap: Map<ResourceLocation, Internal.JsonObject>): void
        getRecipeMap(arg0: Internal.RecipeType<any>): Map<any, any>
        getByNameKJS(): Map<any, any>
        setByNameKJS(arg0: Map<any, any>): void
        setRecipesKJS(arg0: Map<any, any>): void
        getRecipesKJS(): Map<any, any>
        get byNameKJS(): Map<any, any>;
        set byNameKJS(arg0: Map<any, any>);
        set recipesKJS(arg0: Map<any, any>);
        get recipesKJS(): Map<any, any>;
    }
    interface LongToDoubleFunction {
        applyAsDouble(arg0: number): number
    }
    class FireworksJS$Shape extends Internal.Enum<Internal.FireworksJS$Shape> {
        static valueOf(name: string): Internal.FireworksJS$Shape
        static values(): Internal.FireworksJS$Shape[]
        static get(name: string): Internal.FireworksJS$Shape
        static readonly SMALL_BALL : Internal.FireworksJS$Shape;
        static readonly LARGE_BALL : Internal.FireworksJS$Shape;
        static readonly STAR : Internal.FireworksJS$Shape;
        static readonly CREEPER : Internal.FireworksJS$Shape;
        static readonly BURST : Internal.FireworksJS$Shape;
        static readonly VALUES : Internal.FireworksJS$Shape[];
        readonly type : number;
    }
    interface DefaultedListAccessor <T> {
        getDelegate(): Internal.List<T>
        get delegate(): Internal.List<T>;
    }
    interface ObjectIterable <K> implements Internal.Iterable<K> {
        iterator(): Internal.Iterator<any>
        iterator(): Internal.ObjectIterator<K>
        spliterator(): Internal.ObjectSpliterator<K>
        spliterator(): Internal.Spliterator<any>
        forEach(arg0: (arg0: T) => void): void
    }
    interface ILootHandler implements Internal.Predicate<Internal.LootContext> {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        test(arg0: T): boolean
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
    }
    interface SharedSuggestionProvider {
    }
    interface ByteChannel implements Internal.ReadableByteChannel, Internal.WritableByteChannel {
        isOpen(): boolean
        read(arg0: Internal.ByteBuffer): number
        write(arg0: Internal.ByteBuffer): number
        close(): void
    }
    interface TriPredicate <T, U, V> {
        or(arg0: Internal.TriPredicate<T, U, V>): Internal.TriPredicate<T, U, V>
        test(arg0: T, arg1: U, arg2: V): boolean
        and(arg0: Internal.TriPredicate<T, U, V>): Internal.TriPredicate<T, U, V>
        negate(): Internal.TriPredicate<T, U, V>
    }
    class AbstractMultimap <K, V> implements Internal.Multimap<K, V> {
        containsEntry(arg0: object, arg1: object): boolean
        containsKey(arg0: object): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        asMap(): Map<K, Internal.Collection<V>>
        keys(): Internal.Multiset<K>
        values(): Internal.Collection<V>
        clear(): void
        isEmpty(): boolean
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.Collection<V>
        containsValue(arg0: object): boolean
        put(arg0: K, arg1: V): boolean
        remove(arg0: object, arg1: object): boolean
        removeAll(arg0: object): Internal.Collection<V>
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>
        size(): number
        hashCode(): number
        get(arg0: K): Internal.Collection<V>
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean
        putAll(arg0: Internal.Multimap<K, V>): boolean
        equals(arg0: object): boolean
        toString(): string
        keySet(): Internal.Set<K>
    }
    interface IIngredientType <T> {
        getIngredientClass(): Internal.Class<T>
        get ingredientClass(): Internal.Class<T>;
    }
    interface SecretKey implements Internal.Key, Internal.Destroyable {
        getEncoded(): number[]
        isDestroyed(): boolean
        getAlgorithm(): string
        destroy(): void
        getFormat(): string
        static readonly serialVersionUID : 6603384152749567654;
        get encoded(): number[];
        get algorithm(): string;
        get format(): string;
    }
    interface IForgeFluidState {
        getExplosionResistance(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): number
        isEntityInside(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity, arg3: number, arg4: Internal.SetTag<Internal.Fluid>, arg5: boolean): boolean
    }
    class PersistentEntitySectionManager <T> implements Internal.AutoCloseable, Internal.ServerEntityManagerAccessor, me.jellysquid.mods.lithium.mixin.chunk.entity_class_groups.ServerEntityManagerAccessor {
        getCache(): Internal.EntitySectionStorage<any>
        addNewEntityWithoutEvent(arg0: T): boolean
        close(): void
        get cache(): Internal.EntitySectionStorage<any>;
    }
    class Reader implements Internal.Readable, Internal.Closeable {
        read(arg0: string[]): number
        read(arg0: string[], arg1: number, arg2: number): number
        read(arg0: Internal.CharBuffer): number
        read(): number
        static nullReader(): Internal.Reader
        ready(): boolean
        markSupported(): boolean
        reset(): void
        skip(arg0: number): number
        transferTo(arg0: Internal.Writer): number
        close(): void
        mark(arg0: number): void
    }
    class EntityPotionEffectsJS {
        add(mobEffect: Internal.MobEffect, duration: number): void
        add(mobEffect: Internal.MobEffect, duration: number, amplifier: number): void
        add(mobEffect: Internal.MobEffect): void
        add(mobEffect: Internal.MobEffect, duration: number, amplifier: number, ambient: boolean, showParticles: boolean): void
        getDuration(mobEffect: Internal.MobEffect): number
        isApplicable(effect: Internal.MobEffectInstance): boolean
        clear(): void
        getActive(mobEffect: Internal.MobEffect): Internal.MobEffectInstance
        getActive(): Internal.Collection<Internal.MobEffectInstance>
        isActive(mobEffect: Internal.MobEffect): boolean
        getMap(): Map<Internal.MobEffect, Internal.MobEffectInstance>
        get active(): Internal.Collection<Internal.MobEffectInstance>;
        get map(): Map<Internal.MobEffect, Internal.MobEffectInstance>;
    }
    interface PrimitiveIterator <T, T_CONS> implements Internal.Iterator<T> {
        next(): E
        hasNext(): boolean
        forEachRemaining(arg0: T_CONS): void
        forEachRemaining(arg0: (arg0: E) => void): void
        remove(): void
    }
    class Parameter implements Internal.AnnotatedElement {
        getDeclaringExecutable(): Internal.Executable
        isNamePresent(): boolean
        getName(): string
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        isVarArgs(): boolean
        isSynthetic(): boolean
        getAnnotations(): Internal.Annotation[]
        getParameterizedType(): Internal.Type
        getDeclaredAnnotations(): Internal.Annotation[]
        isImplicit(): boolean
        getAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getType(): Internal.Class<object>
        getDeclaredAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getAnnotation<T>(arg0: Internal.Class<T>): T
        hashCode(): number
        equals(arg0: object): boolean
        getDeclaredAnnotation<T>(arg0: Internal.Class<T>): T
        toString(): string
        getModifiers(): number
        getAnnotatedType(): Internal.AnnotatedType
        get declaringExecutable(): Internal.Executable;
        get name(): string;
        get annotations(): Internal.Annotation[];
        get parameterizedType(): Internal.Type;
        get declaredAnnotations(): Internal.Annotation[];
        get type(): Internal.Class<object>;
        get modifiers(): number;
        get annotatedType(): Internal.AnnotatedType;
    }
    class Writer implements Internal.Appendable, Internal.Closeable, Internal.Flushable {
        flush(): void
        static nullWriter(): Internal.Writer
        close(): void
        write(arg0: string, arg1: number, arg2: number): void
        write(arg0: number): void
        write(arg0: string): void
        write(arg0: string[], arg1: number, arg2: number): void
        write(arg0: string[]): void
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Writer
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: string): Internal.Writer
        append(arg0: string): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.Writer
    }
    interface ExecutorService implements Internal.Executor {
        submit(arg0: Internal.Runnable): Internal.Future<object>
        submit<T>(arg0: Internal.Runnable, arg1: T): Internal.Future<T>
        submit<T>(arg0: java_.util.concurrent.Callable<T>): Internal.Future<T>
        isTerminated(): boolean
        invokeAll<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<Internal.Future<T>>
        invokeAll<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>): Internal.List<Internal.Future<T>>
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean
        invokeAny<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>): T
        invokeAny<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>, arg1: number, arg2: Internal.TimeUnit): T
        shutdownNow(): Internal.List<Internal.Runnable>
        execute(arg0: Internal.Runnable): void
        shutdown(): void
        isShutdown(): boolean
    }
    interface Scriptable implements Internal.IdEnumerationIterator {
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: object) => void): boolean
        hasInstance(arg0: Internal.Scriptable): boolean
        setParentScope(arg0: Internal.Scriptable): void
        getIds(): object[]
        getAllIds(): object[]
        delete(arg0: string): void
        delete(arg0: number): void
        put(arg0: number, arg1: Internal.Scriptable, arg2: object): void
        put(arg0: string, arg1: Internal.Scriptable, arg2: object): void
        getDefaultValue(arg0: Internal.Class<object>): object
        setPrototype(arg0: Internal.Scriptable): void
        getPrototype(): Internal.Scriptable
        get(arg0: number, arg1: Internal.Scriptable): object
        get(arg0: string, arg1: Internal.Scriptable): object
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: object) => void): boolean
        has(arg0: number, arg1: Internal.Scriptable): boolean
        has(arg0: string, arg1: Internal.Scriptable): boolean
        getClassName(): string
        getParentScope(): Internal.Scriptable
        static readonly NOT_FOUND : object;
        set parentScope(arg0: Internal.Scriptable);
        get ids(): object[];
        get allIds(): object[];
        set prototype(arg0: Internal.Scriptable);
        get prototype(): Internal.Scriptable;
        get className(): string;
        get parentScope(): Internal.Scriptable;
    }
    class ForwardingObject {
        toString(): string
    }
    class ModelGenerator$Element {
        face(direction: Internal.Direction, consumer: (arg0: Internal.ModelGenerator$Face) => void): void
        toJson(): Internal.JsonObject
        box(b: Internal.AABB): Internal.ModelGenerator$Element
    }
    class Date implements Internal.Serializable, Internal.Cloneable, Internal.Comparable<Internal.Date> {
        static UTC(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): number
        before(arg0: Internal.Date): boolean
        getTime(): number
        compareTo(arg0: object): number
        compareTo(arg0: Internal.Date): number
        getHours(): number
        setHours(arg0: number): void
        setSeconds(arg0: number): void
        hashCode(): number
        getDate(): number
        static from(arg0: Internal.Instant): Internal.Date
        getMonth(): number
        after(arg0: Internal.Date): boolean
        setTime(arg0: number): void
        setMonth(arg0: number): void
        setMinutes(arg0: number): void
        static parse(arg0: string): number
        setYear(arg0: number): void
        toInstant(): Internal.Instant
        getDay(): number
        getMinutes(): number
        toGMTString(): string
        getTimezoneOffset(): number
        getSeconds(): number
        getYear(): number
        equals(arg0: object): boolean
        clone(): object
        setDate(arg0: number): void
        toString(): string
        toLocaleString(): string
        get time(): number;
        get hours(): number;
        set hours(arg0: number);
        set seconds(arg0: number);
        get date(): number;
        get month(): number;
        set time(arg0: number);
        set month(arg0: number);
        set minutes(arg0: number);
        set year(arg0: number);
        get day(): number;
        get minutes(): number;
        get timezoneOffset(): number;
        get seconds(): number;
        get year(): number;
        set date(arg0: number);
    }
    class BlastFurnaceRecipeJS extends Internal.IERecipeJS {
        serialize(): void
        create(args: Internal.ListJS): void
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<object>;
        readonly inputFluids : Internal.List<Internal.FluidTagInput>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        serializeInputs : boolean;
    }
    interface Key implements Internal.Serializable {
        getEncoded(): number[]
        getAlgorithm(): string
        getFormat(): string
        static readonly serialVersionUID : 6603384152749567654;
        get encoded(): number[];
        get algorithm(): string;
        get format(): string;
    }
    class ByteOrder {
        static nativeOrder(): Internal.ByteOrder
        toString(): string
        static readonly BIG_ENDIAN : Internal.ByteOrder;
        static readonly LITTLE_ENDIAN : Internal.ByteOrder;
    }
    class SWMRNibbleArray {
        getVisible(arg0: number): number
        getVisible(arg0: number, arg1: number, arg2: number): number
        getSaveState(): Internal.SWMRNibbleArray$SaveState
        set(arg0: number, arg1: number, arg2: number, arg3: number): void
        set(arg0: number, arg1: number): void
        setNull(): void
        isNullNibbleVisible(): boolean
        isUninitialisedVisible(): boolean
        setUninitialised(): void
        static fromVanilla(arg0: Internal.DataLayer): Internal.SWMRNibbleArray
        toVanillaNibble(): Internal.DataLayer
        updateVisible(): boolean
        isInitialisedUpdating(): boolean
        isNullNibbleUpdating(): boolean
        isUninitialisedUpdating(): boolean
        getUpdating(arg0: number, arg1: number, arg2: number): number
        getUpdating(arg0: number): number
        isDirty(): boolean
        isHiddenUpdating(): boolean
        isInitialisedVisible(): boolean
        setHidden(): void
        isHiddenVisible(): boolean
        setZero(): void
        toString(): string
        setNonNull(): void
        setFull(): void
        extrudeLower(arg0: Internal.SWMRNibbleArray): void
        static readonly ARRAY_SIZE : 2048;
        get saveState(): Internal.SWMRNibbleArray$SaveState;
    }
    interface ObjectSet <K> implements Internal.ObjectCollection<K>, Internal.Set<K> {
        add(arg0: E): boolean
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.ObjectSpliterator<K>
        forEach(arg0: (arg0: T) => void): void
        containsAll(arg0: Internal.Collection<object>): boolean
        isEmpty(): boolean
        clear(): void
        remove(arg0: object): boolean
        removeIf(arg0: (arg0: E) => boolean): boolean
        removeAll(arg0: Internal.Collection<object>): boolean
        contains(arg0: object): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.ObjectIterator<K>
        size(): number
        addAll(arg0: Internal.Collection<E>): boolean
        stream(): Internal.Stream<E>
        hashCode(): number
        equals(arg0: object): boolean
        static of<K>(arg0: K, arg1: K): Internal.ObjectSet<K>
        static of<K>(arg0: K[]): Internal.ObjectSet<K>
        static of<K>(arg0: K, arg1: K, arg2: K): Internal.ObjectSet<K>
        static of<K>(): Internal.ObjectSet<K>
        static of<K>(arg0: K): Internal.ObjectSet<K>
        toArray<T>(arg0: T[]): T[]
        toArray<T>(arg0: Internal.IntFunction<T[]>): T[]
        toArray(): object[]
        parallelStream(): Internal.Stream<E>
        retainAll(arg0: Internal.Collection<object>): boolean
    }
    interface ExternalArrayData {
        setArrayElement(arg0: number, arg1: object): void
        getArrayLength(): number
        getArrayElement(arg0: number): object
        get arrayLength(): number;
    }
    interface Map$Entry <K, V> {
        getKey(): K
        getValue(): V
        hashCode(): number
        setValue(arg0: V): V
        equals(arg0: object): boolean
        static comparingByValue<K, V>(): Internal.Comparator<Internal.Map$Entry<K, V>>
        static comparingByValue<K, V>(arg0: Internal.Comparator<V>): Internal.Comparator<Internal.Map$Entry<K, V>>
        static copyOf<K, V>(arg0: Internal.Map$Entry<K, V>): Internal.Map$Entry<K, V>
        static comparingByKey<K, V>(arg0: Internal.Comparator<K>): Internal.Comparator<Internal.Map$Entry<K, V>>
        static comparingByKey<K, V>(): Internal.Comparator<Internal.Map$Entry<K, V>>
        get key(): K;
        get value(): V;
        set value(arg0: V);
    }
    interface ICitadelDataEntity {
        setCitadelEntityData(arg0: Internal.CompoundTag): void
        getCitadelEntityData(): Internal.CompoundTag
        set citadelEntityData(arg0: Internal.CompoundTag);
        get citadelEntityData(): Internal.CompoundTag;
    }
    class StonecuttingRecipeJS extends Internal.RecipeJS {
        serialize(): void
        create(args: Internal.ListJS): void
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<object>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
    }
    class Month extends Internal.Enum<Internal.Month> implements Internal.TemporalAccessor, Internal.TemporalAdjuster {
        firstMonthOfQuarter(): Internal.Month
        minus(arg0: number): Internal.Month
        firstDayOfYear(arg0: boolean): number
        static valueOf(arg0: string): Internal.Month
        minLength(): number
        query<R>(arg0: Internal.TemporalQuery<R>): R
        static values(): Internal.Month[]
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        length(arg0: boolean): number
        range(arg0: Internal.TemporalField): Internal.ValueRange
        isSupported(arg0: Internal.TemporalField): boolean
        plus(arg0: number): Internal.Month
        getLong(arg0: Internal.TemporalField): number
        getValue(): number
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        static of(arg0: number): Internal.Month
        get(arg0: Internal.TemporalField): number
        static from(arg0: Internal.TemporalAccessor): Internal.Month
        maxLength(): number
        static readonly JANUARY : Internal.Month;
        static readonly JUNE : Internal.Month;
        static readonly MAY : Internal.Month;
        static readonly OCTOBER : Internal.Month;
        static readonly DECEMBER : Internal.Month;
        static readonly MARCH : Internal.Month;
        static readonly FEBRUARY : Internal.Month;
        static readonly AUGUST : Internal.Month;
        static readonly JULY : Internal.Month;
        static readonly SEPTEMBER : Internal.Month;
        static readonly NOVEMBER : Internal.Month;
        static readonly APRIL : Internal.Month;
        get value(): number;
    }
    interface OrderedEventExecutor implements Internal.EventExecutor {
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<object>
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<object>
        next(): Internal.EventExecutor
        terminationFuture(): io.netty.util.concurrent.Future<object>
        parent(): Internal.EventExecutorGroup
        newProgressivePromise<V>(): Internal.ProgressivePromise<V>
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit): io.netty.util.concurrent.Future<object>
        shutdownGracefully(): io.netty.util.concurrent.Future<object>
        submit<T>(arg0: Internal.Runnable, arg1: T): io.netty.util.concurrent.Future<T>
        submit<T>(arg0: Internal.Runnable, arg1: T): Internal.Future<T>
        submit<T>(arg0: java_.util.concurrent.Callable<T>): io.netty.util.concurrent.Future<T>
        submit<T>(arg0: java_.util.concurrent.Callable<T>): Internal.Future<T>
        submit(arg0: Internal.Runnable): io.netty.util.concurrent.Future<object>
        submit(arg0: Internal.Runnable): Internal.Future<object>
        spliterator(): Internal.Spliterator<T>
        isTerminated(): boolean
        forEach(arg0: (arg0: T) => void): void
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<object>
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<object>
        invokeAll<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<Internal.Future<T>>
        invokeAll<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>): Internal.List<Internal.Future<T>>
        newFailedFuture<V>(arg0: Internal.Throwable): io.netty.util.concurrent.Future<V>
        execute(arg0: Internal.Runnable): void
        inEventLoop(arg0: Internal.Thread): boolean
        inEventLoop(): boolean
        isShuttingDown(): boolean
        schedule<V>(arg0: java_.util.concurrent.Callable<V>, arg1: number, arg2: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<V>
        schedule<V>(arg0: java_.util.concurrent.Callable<V>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<object>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<object>
        iterator(): Internal.Iterator<Internal.EventExecutor>
        newSucceededFuture<V>(arg0: V): io.netty.util.concurrent.Future<V>
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean
        invokeAny<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>): T
        invokeAny<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>, arg1: number, arg2: Internal.TimeUnit): T
        shutdownNow(): Internal.List<Internal.Runnable>
        shutdown(): void
        isShutdown(): boolean
        newPromise<V>(): Internal.Promise<V>
    }
    class ItemEntity extends Internal.Entity implements Internal.ItemEntityAccess {
        setAge(arg0: number): void
        handler$zzn000$fireImmuneHead(arg0: Internal.CallbackInfoReturnable<any>): void
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        backpackedMoved : boolean;
        lifespan : number;
        set age(arg0: number);
    }
    class Products$P12 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> {
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>): Internal.App<F, R>
    }
    interface Delayed implements Internal.Comparable<Internal.Delayed> {
        getDelay(arg0: Internal.TimeUnit): number
        compareTo(arg0: T): number
    }
    class Item extends Internal.ForgeRegistryEntry<Internal.Item> implements Internal.ItemLike, Internal.IForgeItem, Internal.IPlaceableItem, Internal.ItemKJS {
        canElytraFly(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setBurnTime(i: number): void
        getTags(): Internal.Set<ResourceLocation>
        setDamage(arg0: Internal.ItemStack, arg1: number): void
        canPerformAction(arg0: Internal.ItemStack, arg1: Internal.ToolAction): boolean
        damageItem<T>(arg0: Internal.ItemStack, arg1: number, arg2: T, arg3: (arg0: T) => void): number
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getItemEnchantability(arg0: Internal.ItemStack): number
        setFireResistantKJS(arg0: boolean): void
        shouldCauseReequipAnimation(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: boolean): boolean
        getXpRepairRatio(arg0: Internal.ItemStack): number
        readShareTag(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): void
        onEntityItemUpdate(arg0: Internal.ItemStack, arg1: Internal.ItemEntity): boolean
        getDamage(arg0: Internal.ItemStack): number
        setFoodPropertiesKJS(arg0: Internal.FoodProperties): void
        isBookEnchantable(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.LivingEntity, arg3: Internal.LivingEntity): boolean
        onUsingTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): void
        createEntity(arg0: Internal.Level, arg1: Internal.Entity, arg2: Internal.ItemStack): Internal.Entity
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>
        isPiglinCurrency(arg0: Internal.ItemStack): boolean
        getSweepHitBox(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): Internal.AABB
        isRepairable(arg0: Internal.ItemStack): boolean
        getShareTag(arg0: Internal.ItemStack): Internal.CompoundTag
        isDamageable(arg0: Internal.ItemStack): boolean
        getBurnTime(arg0: Internal.ItemStack, arg1: Internal.RecipeType<object>): number
        onDroppedByPlayer(arg0: Internal.ItemStack, arg1: Internal.Player): boolean
        onEntitySwing(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        setItemBuilderKJS(b: Internal.ItemBuilder): void
        elytraFlightTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        getItemBuilderKJS(): Internal.ItemBuilder
        setMaxStackSizeKJS(arg0: number): void
        getBlockItemOverride(): Internal.BlockItem
        getAttributeModifiers(arg0: EquipmentSlot, arg1: Internal.ItemStack): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>
        onLeftClickEntity(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): boolean
        canEquip(arg0: Internal.ItemStack, arg1: EquipmentSlot, arg2: Internal.Entity): boolean
        getId(): string
        onBlockStartBreak(arg0: Internal.ItemStack, arg1: BlockPos, arg2: Internal.Player): boolean
        onHorseArmorTick(arg0: Internal.ItemStack, arg1: Internal.Level, arg2: Internal.Mob): void
        canContinueUsing(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getEntityLifespan(arg0: Internal.ItemStack, arg1: Internal.Level): number
        getRenderPropertiesInternal(): object
        getArmorTexture(arg0: Internal.ItemStack, arg1: Internal.Entity, arg2: EquipmentSlot, arg3: string): string
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack): number
        hasCustomEntity(arg0: Internal.ItemStack): boolean
        setMaxDamageKJS(arg0: number): void
        setCraftingRemainderKJS(arg0: Internal.Item): void
        getHighlightTip(arg0: Internal.ItemStack, arg1: Internal.Component): Internal.Component
        initializeClient(arg0: (arg0: Internal.IItemRenderProperties) => void): void
        getMaxDamage(arg0: Internal.ItemStack): number
        getCreatorModId(arg0: Internal.ItemStack): string
        setRarityKJS(arg0: Internal.Rarity): void
        isDamaged(arg0: Internal.ItemStack): boolean
        onArmorTick(arg0: Internal.ItemStack, arg1: Internal.Level, arg2: Internal.Player): void
        addPlaceable(arg0: Internal.Block): void
        hasContainerItem(arg0: Internal.ItemStack): boolean
        doesSneakBypassUse(arg0: Internal.ItemStack, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Player): boolean
        onItemUseFirst(arg0: Internal.ItemStack, arg1: Internal.UseOnContext): Internal.InteractionResult
        getContainerItem(arg0: Internal.ItemStack): Internal.ItemStack
        handler$zgl000$overrideOtherStackedOnMe(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.Slot, arg3: Internal.ClickAction, arg4: Internal.Player, arg5: Internal.SlotAccess, arg6: Internal.CallbackInfoReturnable<any>): void
        handler$zgl000$overrideStackedOnOther(arg0: Internal.ItemStack, arg1: Internal.Slot, arg2: Internal.ClickAction, arg3: Internal.Player, arg4: Internal.CallbackInfoReturnable<any>): void
        isCorrectToolForDrops(arg0: Internal.ItemStack, arg1: Internal.BlockState): boolean
        getEquipmentSlot(arg0: Internal.ItemStack): EquipmentSlot
        getItemStackLimit(arg0: Internal.ItemStack): number
        initCapabilities(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): Internal.ICapabilityProvider
        makesPiglinsNeutral(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        toString(): string
        isEnderMask(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.EnderMan): boolean
        canApplyAtEnchantingTable(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
        readonly delegate : () => V;
        renderProperties : object;
        set burnTime(i: number);
        get tags(): Internal.Set<ResourceLocation>;
        set fireResistantKJS(arg0: boolean);
        set foodPropertiesKJS(arg0: Internal.FoodProperties);
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        set itemBuilderKJS(b: Internal.ItemBuilder);
        get itemBuilderKJS(): Internal.ItemBuilder;
        set maxStackSizeKJS(arg0: number);
        get blockItemOverride(): Internal.BlockItem;
        get id(): string;
        get renderPropertiesInternal(): object;
        set maxDamageKJS(arg0: number);
        set craftingRemainderKJS(arg0: Internal.Item);
        set rarityKJS(arg0: Internal.Rarity);
    }
    class ExplosionJS {
        strength(f: number): Internal.ExplosionJS
        damagesTerrain(b: boolean): Internal.ExplosionJS
        explode(): void
        exploder(entity: Internal.EntityJS): Internal.ExplosionJS
        causesFire(b: boolean): Internal.ExplosionJS
        destroysTerrain(b: boolean): Internal.ExplosionJS
        explosionMode : Internal.Explosion$BlockInteraction;
        readonly x : number;
        readonly y : number;
        readonly z : number;
    }
    class ArcFurnaceRecipeJS extends Internal.IERecipeJS {
        serialize(): void
        create(args: Internal.ListJS): void
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<object>;
        readonly inputFluids : Internal.List<Internal.FluidTagInput>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        serializeInputs : boolean;
    }
    interface IForgeMinecraft {
        popGuiLayer(): void
        pushGuiLayer(arg0: Internal.Screen): void
    }
    interface ByteBufAllocator {
        directBuffer(): Internal.ByteBuf
        directBuffer(arg0: number, arg1: number): Internal.ByteBuf
        directBuffer(arg0: number): Internal.ByteBuf
        isDirectBufferPooled(): boolean
        calculateNewCapacity(arg0: number, arg1: number): number
        compositeDirectBuffer(arg0: number): Internal.CompositeByteBuf
        compositeDirectBuffer(): Internal.CompositeByteBuf
        ioBuffer(): Internal.ByteBuf
        ioBuffer(arg0: number): Internal.ByteBuf
        ioBuffer(arg0: number, arg1: number): Internal.ByteBuf
        compositeHeapBuffer(arg0: number): Internal.CompositeByteBuf
        compositeHeapBuffer(): Internal.CompositeByteBuf
        compositeBuffer(arg0: number): Internal.CompositeByteBuf
        compositeBuffer(): Internal.CompositeByteBuf
        buffer(): Internal.ByteBuf
        buffer(arg0: number, arg1: number): Internal.ByteBuf
        buffer(arg0: number): Internal.ByteBuf
        heapBuffer(): Internal.ByteBuf
        heapBuffer(arg0: number): Internal.ByteBuf
        heapBuffer(arg0: number, arg1: number): Internal.ByteBuf
        static readonly DEFAULT : Internal.ByteBufAllocator;
    }
    interface InstantSource {
        withZone(arg0: Internal.ZoneId): Internal.Clock
        static system(): Internal.InstantSource
        static offset(arg0: Internal.InstantSource, arg1: Internal.Duration): Internal.InstantSource
        static fixed(arg0: Internal.Instant): Internal.InstantSource
        static tick(arg0: Internal.InstantSource, arg1: Internal.Duration): Internal.InstantSource
        millis(): number
        instant(): Internal.Instant
    }
    class DefaultedVertexConsumer implements Internal.VertexConsumer {
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer): number
        createSink(factory: Internal.VertexType<any>): Internal.VertexSink
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void
        applyBakedNormals(arg0: Internal.Vector3f, arg1: Internal.ByteBuffer, arg2: Internal.Matrix3f): void
    }
    interface Float2ObjectFunction <V> implements Internal.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: number, arg1: V): V
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Object2ShortFunction<V>): Internal.Float2ShortFunction
        composeByte(arg0: Internal.Byte2FloatFunction): Internal.Byte2ObjectFunction<V>
        andThenInt(arg0: Internal.Object2IntFunction<V>): Internal.Float2IntFunction
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: Internal.Reference2FloatFunction<T>): (arg0: T) => V
        put(arg0: number, arg1: V): V
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: object): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: Internal.Object2DoubleFunction<V>): Internal.Float2DoubleFunction
        andThenObject<T>(arg0: (arg0: V) => T): Internal.Float2ObjectFunction<T>
        get(arg0: object): V
        get(arg0: number): V
        andThenLong(arg0: Internal.Object2LongFunction<V>): Internal.Float2LongFunction
        composeLong(arg0: Internal.Long2FloatFunction): Internal.Long2ObjectFunction<V>
        andThenByte(arg0: Internal.Object2ByteFunction<V>): Internal.Float2ByteFunction
        andThenFloat(arg0: Internal.Object2FloatFunction<V>): Internal.Float2FloatFunction
        apply(arg0: number): V
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2FloatFunction): Internal.Int2ObjectFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2FloatFunction): Internal.Float2ObjectFunction<V>
        andThenChar(arg0: Internal.Object2CharFunction<V>): Internal.Float2CharFunction
        composeObject<T>(arg0: Internal.Object2FloatFunction<T>): (arg0: T) => V
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => V
        composeShort(arg0: Internal.Short2FloatFunction): Internal.Short2ObjectFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): Internal.Float2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2FloatFunction): Internal.Char2ObjectFunction<V>
        composeDouble(arg0: Internal.Double2FloatFunction): Internal.Double2ObjectFunction<V>
    }
    interface ReferenceCounted {
        refCnt(): number
        release(arg0: number): boolean
        release(): boolean
        retain(arg0: number): Internal.ReferenceCounted
        retain(): Internal.ReferenceCounted
        touch(): Internal.ReferenceCounted
        touch(arg0: object): Internal.ReferenceCounted
    }
    class ModuleDescriptor$Modifier extends Internal.Enum<Internal.ModuleDescriptor$Modifier> {
        static valueOf(arg0: string): Internal.ModuleDescriptor$Modifier
        static values(): Internal.ModuleDescriptor$Modifier[]
        static readonly AUTOMATIC : Internal.ModuleDescriptor$Modifier;
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Modifier;
        static readonly OPEN : Internal.ModuleDescriptor$Modifier;
    }
    interface IAntiqueTextProvider {
        setAntiqueInk(arg0: boolean): void
        hasAntiqueInk(): boolean
        set antiqueInk(arg0: boolean);
    }
    class LevelSettings {
    }
    class ModuleDescriptor$Opens$Modifier extends Internal.Enum<Internal.ModuleDescriptor$Opens$Modifier> {
        static valueOf(arg0: string): Internal.ModuleDescriptor$Opens$Modifier
        static values(): Internal.ModuleDescriptor$Opens$Modifier[]
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Opens$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Opens$Modifier;
    }
    class Hashtable <K, V> extends Internal.Dictionary<K, V> implements Map<K, V>, Internal.Cloneable, Internal.Serializable {
        getOrDefault(arg0: object, arg1: V): V
        keys(): Internal.Enumeration<K>
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V
        values(): Internal.Collection<V>
        replace(arg0: K, arg1: V): V
        replace(arg0: K, arg1: V, arg2: V): boolean
        replaceAll(arg0: (arg0: K, arg1: V) => V): void
        containsValue(arg0: object): boolean
        put(arg0: K, arg1: V): V
        remove(arg0: object): V
        remove(arg0: object, arg1: object): boolean
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        hashCode(): number
        putAll(arg0: Map<K, V>): void
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        get(arg0: object): V
        keySet(): Internal.Set<K>
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>
        containsKey(arg0: object): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        isEmpty(): boolean
        clear(): void
        contains(arg0: object): boolean
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        size(): number
        elements(): Internal.Enumeration<V>
        equals(arg0: object): boolean
        clone(): object
        toString(): string
        putIfAbsent(arg0: K, arg1: V): V
    }
    class ScriptStackElement implements Internal.Serializable {
        renderJavaStyle(sb: Internal.StringBuilder): void
        renderMozillaStyle(sb: Internal.StringBuilder): void
        toString(): string
        readonly fileName : string;
        readonly functionName : string;
        readonly lineNumber : number;
    }
    interface PrivilegedAction <T> {
        run(): T
    }
    class Block extends Internal.BlockBehaviour implements Internal.ItemLike, Internal.IForgeBlock, Internal.BlockPathingBehavior {
        rotate(arg0: Internal.BlockState, arg1: Internal.LevelAccessor, arg2: BlockPos, arg3: Internal.Rotation): Internal.BlockState
        getStateAtViewpoint(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Vec3): Internal.BlockState
        onBlockExploded(arg0: Internal.BlockState, arg1: Internal.Level, arg2: BlockPos, arg3: Internal.Explosion): void
        getBedDirection(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): Internal.Direction
        getTags(): Internal.Set<ResourceLocation>
        isBed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean
        canHarvestBlock(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Player): boolean
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.BlockState): boolean
        isLadder(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean
        shouldDisplayFluidOverlay(arg0: Internal.BlockState, arg1: Internal.BlockAndTintGetter, arg2: BlockPos, arg3: Internal.FluidState): boolean
        canStickTo(arg0: Internal.BlockState, arg1: Internal.BlockState): boolean
        onNeighborChange(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): void
        getWeakChanges(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): boolean
        canEntityDestroy(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean
        isBurning(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean
        getFriction(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): number
        isValidSpawn(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.SpawnPlacements$Type, arg4: Internal.EntityType<object>): boolean
        isPortalFrame(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean
        getExplosionResistance(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): number
        getPathNodeType(state: Internal.BlockState): Internal.BlockPathTypes
        isScaffolding(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean
        canSustainPlant(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.IPlantable): boolean
        canDropFromExplosion(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): boolean
        isStickyBlock(arg0: Internal.BlockState): boolean
        isFertile(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean
        getAiPathNodeType(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Mob): Internal.BlockPathTypes
        isSlimeBlock(arg0: Internal.BlockState): boolean
        getFireSpreadSpeed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number
        getToolModifiedState(arg0: Internal.BlockState, arg1: Internal.Level, arg2: BlockPos, arg3: Internal.Player, arg4: Internal.ItemStack, arg5: Internal.ToolAction): Internal.BlockState
        getBeaconColorMultiplier(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): number[]
        getExpDrop(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: number, arg4: number): number
        isConduitFrame(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): boolean
        getPathNodeTypeAsNeighbor(state: Internal.BlockState): Internal.BlockPathTypes
        getLightEmission(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): number
        onDestroyedByPlayer(arg0: Internal.BlockState, arg1: Internal.Level, arg2: BlockPos, arg3: Internal.Player, arg4: boolean, arg5: Internal.FluidState): boolean
        getId(): string
        shouldCheckWeakPower(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean
        collisionExtendsVertically(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean
        addLandingEffects(arg0: Internal.BlockState, arg1: Internal.ServerLevel, arg2: BlockPos, arg3: Internal.BlockState, arg4: Internal.LivingEntity, arg5: number): boolean
        getRenderPropertiesInternal(): object
        getSoundType(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): Internal.SoundType
        addRunningEffects(arg0: Internal.BlockState, arg1: Internal.Level, arg2: BlockPos, arg3: Internal.Entity): boolean
        initializeClient(arg0: (arg0: Internal.IBlockRenderProperties) => void): void
        getCloneItemStack(arg0: Internal.BlockState, arg1: Internal.HitResult, arg2: Internal.BlockGetter, arg3: BlockPos, arg4: Internal.Player): Internal.ItemStack
        isFlammable(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean
        onCaughtFire(arg0: Internal.BlockState, arg1: Internal.Level, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.LivingEntity): void
        getEnchantPowerBonus(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): number
        setBedOccupied(arg0: Internal.BlockState, arg1: Internal.Level, arg2: BlockPos, arg3: Internal.LivingEntity, arg4: boolean): void
        isFireSource(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean
        getRespawnPosition(arg0: Internal.BlockState, arg1: Internal.EntityType<object>, arg2: Internal.LevelReader, arg3: BlockPos, arg4: number, arg5: Internal.LivingEntity): Internal.Optional<Vec3>
        canConnectRedstone(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean
        toString(): string
        getFlammability(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number
        readonly delegate : () => V;
        get tags(): Internal.Set<ResourceLocation>;
        get id(): string;
        get renderPropertiesInternal(): object;
    }
    interface MatrixWrite {
        flywheel$writeUnsafe(arg0: number): void
        flywheel$write(arg0: Internal.VecBuffer): void
    }
    class ClientLevel extends Internal.Level implements Internal.ClientLevelExtension, Internal.WorldEntityByChunkAccess, Internal.ClientWorldAccessor, Internal.BiomeSeedProvider, Internal.ExtendedWorld {
        getChunkAtImmediately(arg0: number, arg1: number): Internal.LevelChunk
        getAnyChunkImmediately(arg0: number, arg1: number): Internal.ChunkAccess
        handler$bdp000$onDisconnect(arg0: Internal.CallbackInfo): void
        toString(): string
        getEntityManager(): Internal.TransientEntitySectionManager<any>
        getEntitiesInChunk(chunkX: number, chunkZ: number): Internal.Collection<any>
        getBiomeSeed(): number
        flywheel$getAllLoadedEntities(): Internal.Iterable<any>
        restoringBlockSnapshots : boolean;
        capturedBlockSnapshots : Internal.ArrayList<Internal.BlockSnapshot>;
        captureBlockSnapshots : boolean;
        get entityManager(): Internal.TransientEntitySectionManager<any>;
        get biomeSeed(): number;
    }
    class ImmutableMultisetGwtSerializationDependencies <E> extends Internal.ImmutableCollection<E> {
    }
    interface Int2ShortFunction implements Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Short2ShortFunction): Internal.Int2ShortFunction
        composeByte(arg0: Internal.Byte2IntFunction): Internal.Byte2ShortFunction
        andThenInt(arg0: Internal.Short2IntFunction): Internal.Int2IntFunction
        composeReference<T>(arg0: Internal.Reference2IntFunction<T>): Internal.Reference2ShortFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Short2DoubleFunction): Internal.Int2DoubleFunction
        andThenObject<T>(arg0: Internal.Short2ObjectFunction<T>): Internal.Int2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Short2LongFunction): Internal.Int2LongFunction
        composeLong(arg0: Internal.Long2IntFunction): Internal.Long2ShortFunction
        andThenByte(arg0: Internal.Short2ByteFunction): Internal.Int2ByteFunction
        andThenFloat(arg0: Internal.Short2FloatFunction): Internal.Int2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2IntFunction): Internal.Int2ShortFunction
        clear(): void
        composeFloat(arg0: Internal.Float2IntFunction): Internal.Float2ShortFunction
        andThenChar(arg0: Internal.Short2CharFunction): Internal.Int2CharFunction
        composeObject<T>(arg0: Internal.Object2IntFunction<T>): Internal.Object2ShortFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2IntFunction): Internal.Short2ShortFunction
        andThenReference<T>(arg0: Internal.Short2ReferenceFunction<T>): Internal.Int2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2IntFunction): Internal.Char2ShortFunction
        composeDouble(arg0: Internal.Double2IntFunction): Internal.Double2ShortFunction
    }
    class InetAddress implements Internal.Serializable {
        isMCSiteLocal(): boolean
        isReachable(arg0: number): boolean
        isReachable(arg0: Internal.NetworkInterface, arg1: number, arg2: number): boolean
        isMCGlobal(): boolean
        static getAllByName(arg0: string): Internal.InetAddress[]
        getHostName(): string
        isMCOrgLocal(): boolean
        getCanonicalHostName(): string
        isAnyLocalAddress(): boolean
        isLinkLocalAddress(): boolean
        static getLocalHost(): Internal.InetAddress
        isMCLinkLocal(): boolean
        isLoopbackAddress(): boolean
        isSiteLocalAddress(): boolean
        isMulticastAddress(): boolean
        hashCode(): number
        equals(arg0: object): boolean
        static getByName(arg0: string): Internal.InetAddress
        static getLoopbackAddress(): Internal.InetAddress
        static getByAddress(arg0: number[]): Internal.InetAddress
        static getByAddress(arg0: string, arg1: number[]): Internal.InetAddress
        getAddress(): number[]
        toString(): string
        getHostAddress(): string
        isMCNodeLocal(): boolean
        get hostName(): string;
        get canonicalHostName(): string;
        get localHost(): Internal.InetAddress;
        get loopbackAddress(): Internal.InetAddress;
        get address(): number[];
        get hostAddress(): string;
    }
    class BufferLayout {
        getStride(): number
        getLayoutItems(): Internal.List<Internal.LayoutItem>
        static builder(): Internal.BufferLayout$Builder
        getAttributeCount(): number
        get stride(): number;
        get layoutItems(): Internal.List<Internal.LayoutItem>;
        get attributeCount(): number;
    }
    class JsonNull extends Internal.JsonElement {
        hashCode(): number
        equals(arg0: object): boolean
        deepCopy(): Internal.JsonNull
        deepCopy(): Internal.JsonElement
        static readonly INSTANCE : Internal.JsonNull;
    }
    class InteractionResult extends Internal.Enum<Internal.InteractionResult> {
        static valueOf(arg0: string): Internal.InteractionResult
        static values(): Internal.InteractionResult[]
        static readonly SUCCESS : Internal.InteractionResult;
        static readonly PASS : Internal.InteractionResult;
        static readonly CONSUME_PARTIAL : Internal.InteractionResult;
        static readonly CONSUME : Internal.InteractionResult;
        static readonly FAIL : Internal.InteractionResult;
    }
    class BlockPos$MutableBlockPos extends BlockPos {
    }
    class RecordCodecBuilder <O, F> implements Internal.App<Internal.RecordCodecBuilder$Mu<O>, F> {
        static instance<O>(): Internal.RecordCodecBuilder$Instance<O>
        static mapCodec<O>(arg0: (arg0: Internal.RecordCodecBuilder$Instance<O>) => Internal.App<Internal.RecordCodecBuilder$Mu<O>, O>): Internal.MapCodec<O>
        static build<O>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, O>): Internal.MapCodec<O>
        static stable<O, F>(arg0: F): Internal.RecordCodecBuilder<O, F>
        static unbox<O, F>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, F>): Internal.RecordCodecBuilder<O, F>
        static deprecated<O, F>(arg0: F, arg1: number): Internal.RecordCodecBuilder<O, F>
        static of<O, F>(arg0: (arg0: O) => F, arg1: string, arg2: Internal.Codec<F>): Internal.RecordCodecBuilder<O, F>
        static of<O, F>(arg0: (arg0: O) => F, arg1: Internal.MapCodec<F>): Internal.RecordCodecBuilder<O, F>
        static create<O>(arg0: (arg0: Internal.RecordCodecBuilder$Instance<O>) => Internal.App<Internal.RecordCodecBuilder$Mu<O>, O>): Internal.Codec<O>
        dependent<E>(arg0: (arg0: O) => E, arg1: Internal.MapEncoder<E>, arg2: (arg0: F) => Internal.MapDecoder<E>): Internal.RecordCodecBuilder<O, E>
        static point<O, F>(arg0: F): Internal.RecordCodecBuilder<O, F>
        static point<O, F>(arg0: F, arg1: Internal.Lifecycle): Internal.RecordCodecBuilder<O, F>
    }
    interface MethodHandleDesc implements Internal.ConstantDesc {
        static ofMethod(arg0: Internal.DirectMethodHandleDesc$Kind, arg1: Internal.ClassDesc, arg2: string, arg3: Internal.MethodTypeDesc): Internal.DirectMethodHandleDesc
        invocationType(): Internal.MethodTypeDesc
        static ofConstructor(arg0: Internal.ClassDesc, arg1: Internal.ClassDesc[]): Internal.DirectMethodHandleDesc
        static of(arg0: Internal.DirectMethodHandleDesc$Kind, arg1: Internal.ClassDesc, arg2: string, arg3: string): Internal.DirectMethodHandleDesc
        equals(arg0: object): boolean
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): object
        static ofField(arg0: Internal.DirectMethodHandleDesc$Kind, arg1: Internal.ClassDesc, arg2: string, arg3: Internal.ClassDesc): Internal.DirectMethodHandleDesc
        asType(arg0: Internal.MethodTypeDesc): Internal.MethodHandleDesc
    }
    interface IntStream$Builder implements java_.util.function_.IntConsumer {
        add(arg0: number): Internal.IntStream$Builder
        build(): Internal.IntStream
        andThen(arg0: java_.util.function_.IntConsumer): java_.util.function_.IntConsumer
        accept(arg0: number): void
    }
    interface Spliterator$OfInt implements Internal.Spliterator$OfPrimitive<number, java_.util.function_.IntConsumer, Internal.Spliterator$OfInt> {
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>
        trySplit(): Internal.Spliterator<any>
        trySplit(): Internal.Spliterator$OfInt
        characteristics(): number
        tryAdvance(arg0: java_.util.function_.IntConsumer): boolean
        tryAdvance(arg0: (arg0: number) => void): boolean
        tryAdvance(arg0: object): boolean
        getComparator(): Internal.Comparator<T>
        getExactSizeIfKnown(): number
        estimateSize(): number
        hasCharacteristics(arg0: number): boolean
        forEachRemaining(arg0: object): void
        forEachRemaining(arg0: java_.util.function_.IntConsumer): void
        forEachRemaining(arg0: (arg0: number) => void): void
        static readonly NONNULL : 256;
        static readonly SUBSIZED : 16384;
        static readonly ORDERED : 16;
        static readonly DISTINCT : 1;
        static readonly SIZED : 64;
        static readonly IMMUTABLE : 1024;
        static readonly CONCURRENT : 4096;
        static readonly SORTED : 4;
        get comparator(): Internal.Comparator<T>;
        get exactSizeIfKnown(): number;
    }
    interface PublicKey implements Internal.Key {
        getEncoded(): number[]
        getAlgorithm(): string
        getFormat(): string
        static readonly serialVersionUID : 6603384152749567654;
        get encoded(): number[];
        get algorithm(): string;
        get format(): string;
    }
    class Class <T> implements Internal.Serializable, Internal.GenericDeclaration, Internal.Type, Internal.AnnotatedElement, Internal.TypeDescriptor$OfField<Internal.Class<object>>, Internal.Constable {
        getModule(): Internal.Module
        isSealed(): boolean
        getResource(arg0: string): Internal.URL
        getName(): string
        isLocalClass(): boolean
        isSynthetic(): boolean
        getCanonicalName(): string
        getMethod(arg0: string, arg1: Internal.Class<object>[]): Internal.Method
        describeConstable(): Internal.Optional<Internal.ClassDesc>
        getDeclaredFields(): Internal.Field[]
        isMemberClass(): boolean
        cast(arg0: object): T
        isInstance(arg0: object): boolean
        getEnclosingMethod(): Internal.Method
        getPermittedSubclasses(): Internal.Class<object>[]
        getSigners(): object[]
        getTypeParameters(): Internal.TypeVariable<Internal.Class<T>>[]
        isInterface(): boolean
        getPackage(): Internal.Package
        arrayType(): Internal.TypeDescriptor$OfField<any>
        arrayType(): Internal.Class<object>
        getNestHost(): Internal.Class<object>
        asSubclass<U>(arg0: Internal.Class<U>): Internal.Class<U>
        getField(arg0: string): Internal.Field
        descriptorString(): string
        getInterfaces(): Internal.Class<object>[]
        getAnnotatedInterfaces(): Internal.AnnotatedType[]
        newInstance(): T
        getFields(): Internal.Field[]
        getAnnotation<A>(arg0: Internal.Class<A>): A
        getRecordComponents(): Internal.RecordComponent[]
        getComponentType(): Internal.Class<object>
        getDeclaredAnnotation<A>(arg0: Internal.Class<A>): A
        getSimpleName(): string
        isArray(): boolean
        getPackageName(): string
        getMethods(): Internal.Method[]
        isPrimitive(): boolean
        isAnnotation(): boolean
        getProtectionDomain(): Internal.ProtectionDomain
        getDeclaredConstructors(): Internal.Constructor<object>[]
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        desiredAssertionStatus(): boolean
        getNestMembers(): Internal.Class<object>[]
        getGenericInterfaces(): Internal.Type[]
        getClassLoader(): Internal.ClassLoader
        isAssignableFrom(arg0: Internal.Class<object>): boolean
        getDeclaredAnnotations(): Internal.Annotation[]
        getDeclaredMethods(): Internal.Method[]
        getDeclaringClass(): Internal.Class<object>
        getAnnotationsByType<A>(arg0: Internal.Class<A>): A[]
        getConstructors(): Internal.Constructor<object>[]
        getAnnotatedSuperclass(): Internal.AnnotatedType
        toGenericString(): string
        getModifiers(): number
        getTypeName(): string
        getEnclosingConstructor(): Internal.Constructor<object>
        isNestmateOf(arg0: Internal.Class<object>): boolean
        getClasses(): Internal.Class<object>[]
        getSuperclass(): Internal.Class<T>
        getDeclaredField(arg0: string): Internal.Field
        componentType(): Internal.TypeDescriptor$OfField<any>
        componentType(): Internal.Class<object>
        static forName(arg0: string, arg1: boolean, arg2: Internal.ClassLoader): Internal.Class<object>
        static forName(arg0: string): Internal.Class<object>
        static forName(arg0: Internal.Module, arg1: string): Internal.Class<object>
        getResourceAsStream(arg0: string): Internal.InputStream
        isRecord(): boolean
        getDeclaredMethod(arg0: string, arg1: Internal.Class<object>[]): Internal.Method
        isEnum(): boolean
        getDeclaredConstructor(arg0: Internal.Class<object>[]): Internal.Constructor<T>
        getAnnotations(): Internal.Annotation[]
        getConstructor(arg0: Internal.Class<object>[]): Internal.Constructor<T>
        getEnumConstants(): T[]
        isHidden(): boolean
        getDeclaredAnnotationsByType<A>(arg0: Internal.Class<A>): A[]
        getDeclaredClasses(): Internal.Class<object>[]
        isAnonymousClass(): boolean
        getEnclosingClass(): Internal.Class<object>
        toString(): string
        getGenericSuperclass(): Internal.Type
        get module(): Internal.Module;
        get name(): string;
        get canonicalName(): string;
        get declaredFields(): Internal.Field[];
        get enclosingMethod(): Internal.Method;
        get permittedSubclasses(): Internal.Class<object>[];
        get signers(): object[];
        get typeParameters(): Internal.TypeVariable<Internal.Class<T>>[];
        get package(): Internal.Package;
        get nestHost(): Internal.Class<object>;
        get interfaces(): Internal.Class<object>[];
        get annotatedInterfaces(): Internal.AnnotatedType[];
        get fields(): Internal.Field[];
        get recordComponents(): Internal.RecordComponent[];
        get simpleName(): string;
        get packageName(): string;
        get methods(): Internal.Method[];
        get protectionDomain(): Internal.ProtectionDomain;
        get declaredConstructors(): Internal.Constructor<object>[];
        get nestMembers(): Internal.Class<object>[];
        get genericInterfaces(): Internal.Type[];
        get classLoader(): Internal.ClassLoader;
        get declaredAnnotations(): Internal.Annotation[];
        get declaredMethods(): Internal.Method[];
        get declaringClass(): Internal.Class<object>;
        get constructors(): Internal.Constructor<object>[];
        get annotatedSuperclass(): Internal.AnnotatedType;
        get modifiers(): number;
        get typeName(): string;
        get enclosingConstructor(): Internal.Constructor<object>;
        get classes(): Internal.Class<object>[];
        get superclass(): Internal.Class<T>;
        get annotations(): Internal.Annotation[];
        get enumConstants(): T[];
        get declaredClasses(): Internal.Class<object>[];
        get enclosingClass(): Internal.Class<object>;
        get genericSuperclass(): Internal.Type;
    }
    class FontManager implements Internal.AutoCloseable, Internal.FontResourceManagerAccess {
        getFontSets(): Map<any, any>
        close(): void
        get fontSets(): Map<any, any>;
    }
    class ChunkPos {
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
    }
    interface LightProvider {
        getLight(arg0: Internal.LightLayer, arg1: number, arg2: number, arg3: number): number
        getPackedLight(arg0: number, arg1: number, arg2: number): number
    }
    class RecipeFunction extends Internal.BaseFunction implements Internal.WrappedJS {
        call(cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args0: object[]): Internal.RecipeJS
        call(arg0: Internal.Context, arg1: Internal.Scriptable, arg2: Internal.Scriptable, arg3: object[]): object
        createRecipe(args0: object[]): Internal.RecipeJS
        toString(): string
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : object;
        static readonly UNINITIALIZED_CONST : 8;
        readonly typeID : ResourceLocation;
        readonly type : Internal.RecipeTypeJS;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
    }
    interface Instancer <D> {
        notifyRemoval(): void
        createInstance(): D
        createInstances(arg0: D[]): void
        notifyDirty(): void
        stealInstance(arg0: D): void
    }
    class ServerPlayerJS extends Internal.PlayerJS<Internal.ServerPlayer> {
        setCreativeMode(mode: boolean): void
        getStats(): Internal.PlayerStatsJS
        sendData(channel: string, data: Internal.CompoundTag): void
        isAdvancementDone(id: ResourceLocation): boolean
        getHasClientMod(): boolean
        paint(renderer: Internal.CompoundTag): void
        unlockAdvancement(id: ResourceLocation): void
        setSpawnLocation(c: Internal.BlockContainerJS): void
        getSpawnLocation(): Internal.BlockContainerJS
        setGameMode(mode: string): void
        revokeAdvancement(id: ResourceLocation): void
        ban(banner: string, reason: string, expiresInMillis: number): void
        isMiningBlock(): boolean
        setSelectedSlot(index: number): void
        kick(reason: Internal.Component): void
        kick(): void
        setMouseItem(item: Internal.ItemStackJS): void
        isOp(): boolean
        readonly server : Internal.ServerJS;
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftPlayer : E;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        set creativeMode(mode: boolean);
        get stats(): Internal.PlayerStatsJS;
        get hasClientMod(): boolean;
        set spawnLocation(c: Internal.BlockContainerJS);
        get spawnLocation(): Internal.BlockContainerJS;
        set gameMode(mode: string);
        set selectedSlot(index: number);
        set mouseItem(item: Internal.ItemStackJS);
    }
    interface Comparable <T> {
        compareTo(arg0: T): number
    }
    interface Supplier <T> {
        get(): T
    }
    class MathContext implements Internal.Serializable {
        getRoundingMode(): Internal.RoundingMode
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        getPrecision(): number
        static readonly DECIMAL128 : Internal.MathContext;
        static readonly DECIMAL64 : Internal.MathContext;
        static readonly DECIMAL32 : Internal.MathContext;
        static readonly UNLIMITED : Internal.MathContext;
        get roundingMode(): Internal.RoundingMode;
        get precision(): number;
    }
    class CallbackInfoReturnable <R> extends Internal.CallbackInfo {
        setReturnValue(arg0: R): void
        getReturnValue(): R
        getReturnValueB(): number
        getReturnValueI(): number
        getReturnValueZ(): boolean
        getReturnValueJ(): number
        getReturnValueC(): string
        getReturnValueS(): number
        getReturnValueD(): number
        getReturnValueF(): number
        set returnValue(arg0: R);
        get returnValue(): R;
        get returnValueB(): number;
        get returnValueI(): number;
        get returnValueZ(): boolean;
        get returnValueJ(): number;
        get returnValueC(): string;
        get returnValueS(): number;
        get returnValueD(): number;
        get returnValueF(): number;
    }
    interface MovementTrackerCache {
        deduplicate<S>(arg0: S): S
        remove(arg0: Internal.SectionedEntityMovementTracker<object, object>): void
    }
    interface Channel$Unsafe {
        disconnect(arg0: Internal.ChannelPromise): void
        deregister(arg0: Internal.ChannelPromise): void
        recvBufAllocHandle(): Internal.RecvByteBufAllocator$Handle
        closeForcibly(): void
        beginRead(): void
        bind(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): void
        voidPromise(): Internal.ChannelPromise
        flush(): void
        localAddress(): Internal.SocketAddress
        outboundBuffer(): Internal.ChannelOutboundBuffer
        close(arg0: Internal.ChannelPromise): void
        write(arg0: object, arg1: Internal.ChannelPromise): void
        remoteAddress(): Internal.SocketAddress
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress, arg2: Internal.ChannelPromise): void
        register(arg0: Internal.EventLoop, arg1: Internal.ChannelPromise): void
    }
    interface Set <E> implements Internal.Collection<E> {
        add(arg0: E): boolean
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: T) => void): void
        containsAll(arg0: Internal.Collection<object>): boolean
        isEmpty(): boolean
        clear(): void
        static copyOf<E>(arg0: Internal.Collection<E>): Internal.Set<E>
        remove(arg0: object): boolean
        removeIf(arg0: (arg0: E) => boolean): boolean
        removeAll(arg0: Internal.Collection<object>): boolean
        contains(arg0: object): boolean
        iterator(): Internal.Iterator<E>
        size(): number
        stream(): Internal.Stream<E>
        addAll(arg0: Internal.Collection<E>): boolean
        hashCode(): number
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): Internal.Set<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): Internal.Set<E>
        static of<E>(arg0: E): Internal.Set<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E): Internal.Set<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): Internal.Set<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): Internal.Set<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): Internal.Set<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): Internal.Set<E>
        static of<E>(arg0: E[]): Internal.Set<E>
        static of<E>(arg0: E, arg1: E, arg2: E): Internal.Set<E>
        static of<E>(): Internal.Set<E>
        static of<E>(arg0: E, arg1: E): Internal.Set<E>
        equals(arg0: object): boolean
        toArray<T>(arg0: T[]): T[]
        toArray(): object[]
        toArray<T>(arg0: Internal.IntFunction<T[]>): T[]
        parallelStream(): Internal.Stream<E>
        retainAll(arg0: Internal.Collection<object>): boolean
    }
    class StringBuffer extends Internal.AbstractStringBuilder implements Internal.Serializable, Internal.Comparable<Internal.StringBuffer>, Internal.CharSequence {
        deleteCharAt(arg0: number): Internal.StringBuffer
        deleteCharAt(arg0: number): Internal.AbstractStringBuilder
        codePointAt(arg0: number): number
        setCharAt(arg0: number, arg1: string): void
        replace(arg0: number, arg1: number, arg2: string): Internal.AbstractStringBuilder
        replace(arg0: number, arg1: number, arg2: string): Internal.StringBuffer
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuffer
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string): Internal.StringBuffer
        insert(arg0: number, arg1: boolean): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: boolean): Internal.StringBuffer
        insert(arg0: number, arg1: Internal.CharSequence, arg2: number, arg3: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: Internal.CharSequence, arg2: number, arg3: number): Internal.StringBuffer
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuffer
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuffer
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.StringBuffer
        insert(arg0: number, arg1: object): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: object): Internal.StringBuffer
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.StringBuffer
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string): Internal.StringBuffer
        insert(arg0: number, arg1: string[]): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string[]): Internal.StringBuffer
        insert(arg0: number, arg1: Internal.CharSequence): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: Internal.CharSequence): Internal.StringBuffer
        compareTo(arg0: Internal.StringBuffer): number
        compareTo(arg0: object): number
        delete(arg0: number, arg1: number): Internal.AbstractStringBuilder
        delete(arg0: number, arg1: number): Internal.StringBuffer
        substring(arg0: number, arg1: number): string
        substring(arg0: number): string
        capacity(): number
        appendCodePoint(arg0: number): Internal.AbstractStringBuilder
        appendCodePoint(arg0: number): Internal.StringBuffer
        codePointBefore(arg0: number): number
        indexOf(arg0: string): number
        indexOf(arg0: string, arg1: number): number
        codePointCount(arg0: number, arg1: number): number
        codePoints(): Internal.IntStream
        trimToSize(): void
        getChars(arg0: number, arg1: number, arg2: string[], arg3: number): void
        length(): number
        subSequence(arg0: number, arg1: number): Internal.CharSequence
        reverse(): Internal.StringBuffer
        reverse(): Internal.AbstractStringBuilder
        lastIndexOf(arg0: string, arg1: number): number
        lastIndexOf(arg0: string): number
        setLength(arg0: number): void
        toString(): string
        ensureCapacity(arg0: number): void
        chars(): Internal.IntStream
        offsetByCodePoints(arg0: number, arg1: number): number
        charAt(arg0: number): string
        append(arg0: string[]): Internal.AbstractStringBuilder
        append(arg0: string[]): Internal.StringBuffer
        append(arg0: number): Internal.StringBuffer
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.StringBuffer
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.StringBuffer
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: string[], arg1: number, arg2: number): Internal.StringBuffer
        append(arg0: string[], arg1: number, arg2: number): Internal.AbstractStringBuilder
        append(arg0: boolean): Internal.StringBuffer
        append(arg0: boolean): Internal.AbstractStringBuilder
        append(arg0: string): Internal.StringBuffer
        append(arg0: string): Internal.AbstractStringBuilder
        append(arg0: string): Internal.Appendable
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.StringBuffer
        append(arg0: string): Internal.AbstractStringBuilder
        append(arg0: string): Internal.StringBuffer
        append(arg0: Internal.StringBuffer): Internal.AbstractStringBuilder
        append(arg0: Internal.StringBuffer): Internal.StringBuffer
        append(arg0: Internal.CharSequence): Internal.AbstractStringBuilder
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence): Internal.StringBuffer
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.StringBuffer
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.AbstractStringBuilder
        append(arg0: object): Internal.AbstractStringBuilder
        append(arg0: object): Internal.StringBuffer
    }
    class RenderStateShard implements Internal.RenderTypeAccess {
        getName(): string
        toString(): string
        get name(): string;
    }
    class AbstractChronology implements Internal.Chronology {
        localDateTime(arg0: Internal.TemporalAccessor): Internal.ChronoLocalDateTime<Internal.ChronoLocalDate>
        date(arg0: Internal.TemporalAccessor): Internal.ChronoLocalDate
        date(arg0: Internal.Era, arg1: number, arg2: number, arg3: number): Internal.ChronoLocalDate
        date(arg0: number, arg1: number, arg2: number): Internal.ChronoLocalDate
        period(arg0: number, arg1: number, arg2: number): Internal.ChronoPeriod
        dateYearDay(arg0: Internal.Era, arg1: number, arg2: number): Internal.ChronoLocalDate
        dateYearDay(arg0: number, arg1: number): Internal.ChronoLocalDate
        getCalendarType(): string
        resolveDate(arg0: Map<Internal.TemporalField, number>, arg1: Internal.ResolverStyle): Internal.ChronoLocalDate
        isLeapYear(arg0: number): boolean
        range(arg0: Internal.ChronoField): Internal.ValueRange
        dateEpochDay(arg0: number): Internal.ChronoLocalDate
        getId(): string
        compareTo(arg0: object): number
        compareTo(arg0: Internal.Chronology): number
        dateNow(): Internal.ChronoLocalDate
        dateNow(arg0: Internal.ZoneId): Internal.ChronoLocalDate
        dateNow(arg0: Internal.Clock): Internal.ChronoLocalDate
        eraOf(arg0: number): Internal.Era
        eras(): Internal.List<Internal.Era>
        prolepticYear(arg0: Internal.Era, arg1: number): number
        zonedDateTime(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.ChronoZonedDateTime<Internal.ChronoLocalDate>
        zonedDateTime(arg0: Internal.TemporalAccessor): Internal.ChronoZonedDateTime<Internal.ChronoLocalDate>
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        hashCode(): number
        equals(arg0: object): boolean
        epochSecond(arg0: Internal.Era, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneOffset): number
        epochSecond(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.ZoneOffset): number
        toString(): string
        get calendarType(): string;
        get id(): string;
    }
    class Buffer {
        hasArray(): boolean
        hasRemaining(): boolean
        clear(): Internal.Buffer
        duplicate(): Internal.Buffer
        remaining(): number
        capacity(): number
        isReadOnly(): boolean
        rewind(): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.Buffer
        slice(): Internal.Buffer
        array(): object
        limit(arg0: number): Internal.Buffer
        limit(): number
        reset(): Internal.Buffer
        arrayOffset(): number
        position(): number
        position(arg0: number): Internal.Buffer
        flip(): Internal.Buffer
        isDirect(): boolean
        mark(): Internal.Buffer
    }
    interface CompletionStage <T> {
        exceptionallyAsync(arg0: (arg0: Internal.Throwable) => T, arg1: Internal.Executor): Internal.CompletionStage<T>
        exceptionallyAsync(arg0: (arg0: Internal.Throwable) => T): Internal.CompletionStage<T>
        thenRunAsync(arg0: Internal.Runnable): Internal.CompletionStage<void>
        thenRunAsync(arg0: Internal.Runnable, arg1: Internal.Executor): Internal.CompletionStage<void>
        runAfterBothAsync(arg0: Internal.CompletionStage<object>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletionStage<void>
        runAfterBothAsync(arg0: Internal.CompletionStage<object>, arg1: Internal.Runnable): Internal.CompletionStage<void>
        applyToEitherAsync<U>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U, arg2: Internal.Executor): Internal.CompletionStage<U>
        applyToEitherAsync<U>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U): Internal.CompletionStage<U>
        acceptEitherAsync(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void): Internal.CompletionStage<void>
        acceptEitherAsync(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void, arg2: Internal.Executor): Internal.CompletionStage<void>
        runAfterEitherAsync(arg0: Internal.CompletionStage<object>, arg1: Internal.Runnable): Internal.CompletionStage<void>
        runAfterEitherAsync(arg0: Internal.CompletionStage<object>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletionStage<void>
        acceptEither(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void): Internal.CompletionStage<void>
        thenAcceptBoth<U>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => void): Internal.CompletionStage<void>
        exceptionallyCompose(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>): Internal.CompletionStage<T>
        applyToEither<U>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U): Internal.CompletionStage<U>
        runAfterEither(arg0: Internal.CompletionStage<object>, arg1: Internal.Runnable): Internal.CompletionStage<void>
        thenApply<U>(arg0: (arg0: T) => U): Internal.CompletionStage<U>
        thenComposeAsync<U>(arg0: (arg0: T) => Internal.CompletionStage<U>, arg1: Internal.Executor): Internal.CompletionStage<U>
        thenComposeAsync<U>(arg0: (arg0: T) => Internal.CompletionStage<U>): Internal.CompletionStage<U>
        thenAccept(arg0: (arg0: T) => void): Internal.CompletionStage<void>
        thenRun(arg0: Internal.Runnable): Internal.CompletionStage<void>
        runAfterBoth(arg0: Internal.CompletionStage<object>, arg1: Internal.Runnable): Internal.CompletionStage<void>
        exceptionally(arg0: (arg0: Internal.Throwable) => T): Internal.CompletionStage<T>
        handleAsync<U>(arg0: (arg0: T, arg1: Internal.Throwable) => U, arg1: Internal.Executor): Internal.CompletionStage<U>
        handleAsync<U>(arg0: (arg0: T, arg1: Internal.Throwable) => U): Internal.CompletionStage<U>
        handle<U>(arg0: (arg0: T, arg1: Internal.Throwable) => U): Internal.CompletionStage<U>
        thenCompose<U>(arg0: (arg0: T) => Internal.CompletionStage<U>): Internal.CompletionStage<U>
        thenCombineAsync<U, V>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => V, arg2: Internal.Executor): Internal.CompletionStage<V>
        thenCombineAsync<U, V>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => V): Internal.CompletionStage<V>
        thenAcceptBothAsync<U>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => void, arg2: Internal.Executor): Internal.CompletionStage<void>
        thenAcceptBothAsync<U>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => void): Internal.CompletionStage<void>
        whenComplete(arg0: (arg0: T, arg1: Internal.Throwable) => void): Internal.CompletionStage<T>
        exceptionallyComposeAsync(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>, arg1: Internal.Executor): Internal.CompletionStage<T>
        exceptionallyComposeAsync(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>): Internal.CompletionStage<T>
        thenCombine<U, V>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => V): Internal.CompletionStage<V>
        whenCompleteAsync(arg0: (arg0: T, arg1: Internal.Throwable) => void): Internal.CompletionStage<T>
        whenCompleteAsync(arg0: (arg0: T, arg1: Internal.Throwable) => void, arg1: Internal.Executor): Internal.CompletionStage<T>
        toCompletableFuture(): Internal.CompletableFuture<T>
        thenApplyAsync<U>(arg0: (arg0: T) => U, arg1: Internal.Executor): Internal.CompletionStage<U>
        thenApplyAsync<U>(arg0: (arg0: T) => U): Internal.CompletionStage<U>
        thenAcceptAsync(arg0: (arg0: T) => void): Internal.CompletionStage<void>
        thenAcceptAsync(arg0: (arg0: T) => void, arg1: Internal.Executor): Internal.CompletionStage<void>
    }
    interface IForgeLevel implements Internal.ICapabilityProvider {
        getCapability<T>(arg0: Internal.Capability<T>, arg1: Internal.Direction): Internal.LazyOptional<T>
        getCapability<T>(arg0: Internal.Capability<T>): Internal.LazyOptional<T>
        increaseMaxEntityRadius(arg0: number): number
        getMaxEntityRadius(): number
        get maxEntityRadius(): number;
    }
    interface SlotAccess {
    }
    class InventoryJS {
        getBlock(level: Internal.LevelJS): Internal.BlockContainerJS
        countNonEmpty(ingredient: Internal.IngredientJS): number
        countNonEmpty(): number
        set(slot: number, item: Internal.ItemStack): void
        markDirty(): void
        count(): number
        count(ingredient: Internal.IngredientJS): number
        isEmpty(): boolean
        clear(): void
        clear(ingredient: Internal.IngredientJS): void
        isItemValid(slot: number, item: Internal.ItemStack): boolean
        insert(slot: number, item: Internal.ItemStack, simulate: boolean): Internal.ItemStackJS
        getWidth(): number
        getHeight(): number
        getSize(): number
        extract(slot: number, amount: number, simulate: boolean): Internal.ItemStackJS
        find(ingredient: Internal.IngredientJS): number
        find(): number
        getSlotLimit(slot: number): number
        get(slot: number): Internal.ItemStackJS
        toString(): string
        readonly minecraftInventory : Internal.ItemHandler;
        get width(): number;
        get height(): number;
        get size(): number;
    }
    class ServerJS implements Internal.MessageSender, Internal.WithAttachedData {
        getAdvancement(id: ResourceLocation): Internal.AdvancementJS
        getPlayer(minecraftPlayer: Internal.Player): Internal.ServerPlayerJS
        getPlayer(uuid: Internal.UUID): Internal.ServerPlayerJS
        getPlayer(name: string): Internal.ServerPlayerJS
        getName(): Internal.Text
        updateWorldList(): void
        release(): void
        tell(message: Internal.Component): void
        getAllLevels(): Internal.List<Internal.ServerLevelJS>
        getHardcore(): boolean
        getMotd(): string
        getOverworld(): Internal.ServerLevelJS
        runCommandSilent(command: string): number
        scheduleInTicks(ticks: number, data: object, event: Internal.IScheduledEventCallback): Internal.ScheduledEvent
        scheduleInTicks(ticks: number, event: Internal.IScheduledEventCallback): Internal.ScheduledEvent
        isRunning(): boolean
        setMotd(text: Internal.Component): void
        runCommand(command: string): number
        isSinglePlayer(): boolean
        getPlayers(): Internal.EntityArrayList
        getData(): Internal.AttachedData
        setStatusMessage(message: Internal.Component): void
        sendDataToAll(channel: string, data: Internal.CompoundTag): void
        isDedicated(): boolean
        schedule(timer: number, event: Internal.IScheduledEventCallback): Internal.ScheduledEvent
        schedule(timer: number, data: object, event: Internal.IScheduledEventCallback): Internal.ScheduledEvent
        getLevel(minecraftLevel: Internal.Level): Internal.LevelJS
        getLevel(dimension: string): Internal.LevelJS
        getMinecraftServer(): Internal.MinecraftServer
        stop(): void
        getDisplayName(): Internal.Text
        getEntities(): Internal.EntityArrayList
        getEntities(filter: string): Internal.EntityArrayList
        toString(): string
        readonly playerMap : Map<Internal.UUID, Internal.ServerPlayerDataJS>;
        readonly serverScriptManager : Internal.ServerScriptManager;
        static instance : Internal.ServerJS;
        readonly allLevels : Internal.List<Internal.ServerLevelJS>;
        readonly persistentData : Internal.CompoundTag;
        readonly fakePlayerMap : Map<Internal.UUID, Internal.FakeServerPlayerDataJS>;
        readonly scheduledEvents : Internal.List<Internal.ScheduledEvent>;
        readonly levelMap : Map<string, Internal.ServerLevelJS>;
        overworld : Internal.ServerLevelJS;
        readonly scheduledTickEvents : Internal.List<Internal.ScheduledEvent>;
        get name(): Internal.Text;
        get hardcore(): boolean;
        get motd(): string;
        set motd(text: Internal.Component);
        get players(): Internal.EntityArrayList;
        get data(): Internal.AttachedData;
        set statusMessage(message: Internal.Component);
        get minecraftServer(): Internal.MinecraftServer;
        get displayName(): Internal.Text;
        get entities(): Internal.EntityArrayList;
    }
    interface TemporalField {
        resolve(arg0: Map<Internal.TemporalField, number>, arg1: Internal.TemporalAccessor, arg2: Internal.ResolverStyle): Internal.TemporalAccessor
        getBaseUnit(): Internal.TemporalUnit
        rangeRefinedBy(arg0: Internal.TemporalAccessor): Internal.ValueRange
        getDisplayName(arg0: Internal.Locale): string
        isTimeBased(): boolean
        adjustInto<R>(arg0: R, arg1: number): R
        range(): Internal.ValueRange
        getRangeUnit(): Internal.TemporalUnit
        toString(): string
        isDateBased(): boolean
        getFrom(arg0: Internal.TemporalAccessor): number
        isSupportedBy(arg0: Internal.TemporalAccessor): boolean
        get baseUnit(): Internal.TemporalUnit;
        get rangeUnit(): Internal.TemporalUnit;
    }
    interface ChannelId implements Internal.Serializable, Internal.Comparable<Internal.ChannelId> {
        asShortText(): string
        compareTo(arg0: T): number
        asLongText(): string
    }
    interface Component implements Internal.Message, Internal.FormattedText {
        getString(): string
        get string(): string;
    }
    interface ClientWorldAccessor {
        getEntityManager(): Internal.TransientEntitySectionManager<Internal.Entity>
        get entityManager(): Internal.TransientEntitySectionManager<Internal.Entity>;
    }
    interface BaseMapCodec <K, V> {
        encode<T>(arg0: Map<K, V>, arg1: Internal.DynamicOps<T>, arg2: Internal.RecordBuilder<T>): Internal.RecordBuilder<T>
        elementCodec(): Internal.Codec<V>
        keyCodec(): Internal.Codec<K>
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: Internal.MapLike<T>): Internal.DataResult<Map<K, V>>
    }
    class ScriptPack {
        readonly manager : Internal.ScriptManager;
        scope : Internal.Scriptable;
        context : Internal.Context;
        readonly scripts : Internal.List<Internal.ScriptFile>;
        readonly info : Internal.ScriptPackInfo;
    }
    class FixedUnit extends dev.latvian.mods.rhino.util.unit.Unit {
        sub(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        mod(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        mul(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        log(): dev.latvian.mods.rhino.util.unit.Unit
        log1p(): dev.latvian.mods.rhino.util.unit.Unit
        log10(): dev.latvian.mods.rhino.util.unit.Unit
        cos(): dev.latvian.mods.rhino.util.unit.Unit
        deg(): dev.latvian.mods.rhino.util.unit.Unit
        atan(): dev.latvian.mods.rhino.util.unit.Unit
        div(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        neg(): dev.latvian.mods.rhino.util.unit.Unit
        shiftLeft(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        min(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        rad(): dev.latvian.mods.rhino.util.unit.Unit
        sqrt(): dev.latvian.mods.rhino.util.unit.Unit
        static of(value: number): Internal.FixedUnit
        get(): number
        pow(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        sin(): dev.latvian.mods.rhino.util.unit.Unit
        floor(): dev.latvian.mods.rhino.util.unit.Unit
        isFixed(): boolean
        sq(): dev.latvian.mods.rhino.util.unit.Unit
        atan2(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        tan(): dev.latvian.mods.rhino.util.unit.Unit
        add(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        newValue(v: number): dev.latvian.mods.rhino.util.unit.Unit
        max(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        ceil(): dev.latvian.mods.rhino.util.unit.Unit
        shiftRight(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        abs(): dev.latvian.mods.rhino.util.unit.Unit
        append(sb: Internal.StringBuilder): void
        static readonly ZERO : Internal.FixedUnit;
        static readonly ONE : Internal.FixedUnit;
        static readonly POS_INFINITY : Internal.FixedUnit;
        static readonly NEG_INFINITY : Internal.FixedUnit;
        static readonly NAN : Internal.FixedUnit;
    }
    interface ChannelInboundHandler implements Internal.ChannelHandler {
        channelInactive(arg0: Internal.ChannelHandlerContext): void
        channelUnregistered(arg0: Internal.ChannelHandlerContext): void
        channelReadComplete(arg0: Internal.ChannelHandlerContext): void
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void
        channelActive(arg0: Internal.ChannelHandlerContext): void
        handlerAdded(arg0: Internal.ChannelHandlerContext): void
        userEventTriggered(arg0: Internal.ChannelHandlerContext, arg1: object): void
        channelRegistered(arg0: Internal.ChannelHandlerContext): void
        handlerRemoved(arg0: Internal.ChannelHandlerContext): void
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext): void
        channelRead(arg0: Internal.ChannelHandlerContext, arg1: object): void
    }
    class Executable extends Internal.AccessibleObject implements Internal.Member, Internal.GenericDeclaration {
        getName(): string
        getParameterCount(): number
        isVarArgs(): boolean
        isSynthetic(): boolean
        getAnnotatedParameterTypes(): Internal.AnnotatedType[]
        getParameterTypes(): Internal.Class<object>[]
        getGenericExceptionTypes(): Internal.Type[]
        getAnnotatedReceiverType(): Internal.AnnotatedType
        getDeclaredAnnotations(): Internal.Annotation[]
        getAnnotatedExceptionTypes(): Internal.AnnotatedType[]
        getExceptionTypes(): Internal.Class<object>[]
        getDeclaringClass(): Internal.Class<object>
        getGenericParameterTypes(): Internal.Type[]
        getAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getAnnotation<T>(arg0: Internal.Class<T>): T
        toGenericString(): string
        getParameters(): Internal.Parameter[]
        getTypeParameters(): Internal.TypeVariable<object>[]
        getModifiers(): number
        getAnnotatedReturnType(): Internal.AnnotatedType
        getParameterAnnotations(): Internal.Annotation[][]
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get name(): string;
        get parameterCount(): number;
        get annotatedParameterTypes(): Internal.AnnotatedType[];
        get parameterTypes(): Internal.Class<object>[];
        get genericExceptionTypes(): Internal.Type[];
        get annotatedReceiverType(): Internal.AnnotatedType;
        get declaredAnnotations(): Internal.Annotation[];
        get annotatedExceptionTypes(): Internal.AnnotatedType[];
        get exceptionTypes(): Internal.Class<object>[];
        get declaringClass(): Internal.Class<object>;
        get genericParameterTypes(): Internal.Type[];
        get parameters(): Internal.Parameter[];
        get typeParameters(): Internal.TypeVariable<object>[];
        get modifiers(): number;
        get annotatedReturnType(): Internal.AnnotatedType;
        get parameterAnnotations(): Internal.Annotation[][];
    }
    class Permission implements Internal.Guard, Internal.Serializable {
        getName(): string
        checkGuard(arg0: object): void
        newPermissionCollection(): Internal.PermissionCollection
        hashCode(): number
        equals(arg0: object): boolean
        getActions(): string
        toString(): string
        implies(arg0: Internal.Permission): boolean
        get name(): string;
        get actions(): string;
    }
    interface ByteProcessor {
        process(arg0: number): boolean
        static readonly FIND_NUL : Internal.ByteProcessor;
        static readonly FIND_COMMA : Internal.ByteProcessor;
        static readonly FIND_CR : Internal.ByteProcessor;
        static readonly FIND_ASCII_SPACE : Internal.ByteProcessor;
        static readonly FIND_NON_CR : Internal.ByteProcessor;
        static readonly FIND_NON_CRLF : Internal.ByteProcessor;
        static readonly FIND_LF : Internal.ByteProcessor;
        static readonly FIND_LINEAR_WHITESPACE : Internal.ByteProcessor;
        static readonly FIND_NON_LINEAR_WHITESPACE : Internal.ByteProcessor;
        static readonly FIND_SEMI_COLON : Internal.ByteProcessor;
        static readonly FIND_NON_NUL : Internal.ByteProcessor;
        static readonly FIND_CRLF : Internal.ByteProcessor;
        static readonly FIND_NON_LF : Internal.ByteProcessor;
    }
    class UnmodifiableListIterator <E> extends Internal.UnmodifiableIterator<E> implements Internal.ListIterator<E> {
        next(): E
        add(arg0: E): void
        set(arg0: E): void
        previous(): E
        hasPrevious(): boolean
        hasNext(): boolean
        nextIndex(): number
        previousIndex(): number
    }
    interface DoubleUnaryOperator {
        applyAsDouble(arg0: number): number
        compose(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        static identity(): Internal.DoubleUnaryOperator
        andThen(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
    }
    interface EntityAccessor {
        getEntityChangeListener(): Internal.EntityInLevelCallback
        get entityChangeListener(): Internal.EntityInLevelCallback;
    }
    interface ModelQuadView {
        getLight(arg0: number): number
        getTexV(arg0: number): number
        getNormal(arg0: number): number
        getTexU(arg0: number): number
        getX(arg0: number): number
        getColorIndex(): number
        getY(arg0: number): number
        getZ(arg0: number): number
        getColor(arg0: number): number
        getFlags(): number
        getSprite(): Internal.TextureAtlasSprite
        get colorIndex(): number;
        get flags(): number;
        get sprite(): Internal.TextureAtlasSprite;
    }
    interface LightListener {
        getVolume(): Internal.ImmutableBox
        onLightUpdate(arg0: Internal.LightProvider, arg1: Internal.LightLayer, arg2: Internal.ImmutableBox): void
        onLightPacket(arg0: Internal.LightProvider, arg1: number, arg2: number): void
        status(): Internal.ListenerStatus
        get volume(): Internal.ImmutableBox;
    }
    class FileChannel extends Internal.AbstractInterruptibleChannel implements Internal.SeekableByteChannel, Internal.GatheringByteChannel, Internal.ScatteringByteChannel {
        transferFrom(arg0: Internal.ReadableByteChannel, arg1: number, arg2: number): number
        read(arg0: Internal.ByteBuffer): number
        read(arg0: Internal.ByteBuffer, arg1: number): number
        read(arg0: Internal.ByteBuffer[]): number
        read(arg0: Internal.ByteBuffer[], arg1: number, arg2: number): number
        truncate(arg0: number): Internal.SeekableByteChannel
        truncate(arg0: number): Internal.FileChannel
        size(): number
        lock(): Internal.FileLock
        lock(arg0: number, arg1: number, arg2: boolean): Internal.FileLock
        force(arg0: boolean): void
        position(arg0: number): Internal.SeekableByteChannel
        position(arg0: number): Internal.FileChannel
        position(): number
        transferTo(arg0: number, arg1: number, arg2: Internal.WritableByteChannel): number
        write(arg0: Internal.ByteBuffer, arg1: number): number
        write(arg0: Internal.ByteBuffer): number
        write(arg0: Internal.ByteBuffer[], arg1: number, arg2: number): number
        write(arg0: Internal.ByteBuffer[]): number
        map(arg0: Internal.FileChannel$MapMode, arg1: number, arg2: number): Internal.MappedByteBuffer
        tryLock(arg0: number, arg1: number, arg2: boolean): Internal.FileLock
        tryLock(): Internal.FileLock
        static open(arg0: Internal.Path, arg1: Internal.Set<Internal.OpenOption>, arg2: Internal.FileAttribute<object>[]): Internal.FileChannel
        static open(arg0: Internal.Path, arg1: Internal.OpenOption[]): Internal.FileChannel
    }
    interface Translate <Self> {
        translateZ(arg0: number): Self
        translateAll(arg0: number): Self
        translateY(arg0: number): Self
        translateX(arg0: number): Self
        centre(): Self
        unCentre(): Self
        translate(arg0: number, arg1: number, arg2: number): Self
        translate(arg0: Internal.Vector3f): Self
        translate(arg0: Vec3): Self
        translate(arg0: Vec3i): Self
        translateBack(arg0: Vec3): Self
        translateBack(arg0: Vec3i): Self
        translateBack(arg0: number, arg1: number, arg2: number): Self
        nudge(arg0: number): Self
    }
    class ZoneOffsetTransitionRule implements Internal.Serializable {
        getOffsetBefore(): Internal.ZoneOffset
        getOffsetAfter(): Internal.ZoneOffset
        isMidnightEndOfDay(): boolean
        getDayOfWeek(): Internal.DayOfWeek
        getLocalTime(): Internal.LocalTime
        hashCode(): number
        static of(arg0: Internal.Month, arg1: number, arg2: Internal.DayOfWeek, arg3: Internal.LocalTime, arg4: boolean, arg5: Internal.ZoneOffsetTransitionRule$TimeDefinition, arg6: Internal.ZoneOffset, arg7: Internal.ZoneOffset, arg8: Internal.ZoneOffset): Internal.ZoneOffsetTransitionRule
        equals(arg0: object): boolean
        getStandardOffset(): Internal.ZoneOffset
        toString(): string
        getTimeDefinition(): Internal.ZoneOffsetTransitionRule$TimeDefinition
        getMonth(): Internal.Month
        createTransition(arg0: number): Internal.ZoneOffsetTransition
        getDayOfMonthIndicator(): number
        get offsetBefore(): Internal.ZoneOffset;
        get offsetAfter(): Internal.ZoneOffset;
        get dayOfWeek(): Internal.DayOfWeek;
        get localTime(): Internal.LocalTime;
        get standardOffset(): Internal.ZoneOffset;
        get timeDefinition(): Internal.ZoneOffsetTransitionRule$TimeDefinition;
        get month(): Internal.Month;
        get dayOfMonthIndicator(): number;
    }
    interface ParticleManagerAccess {
        invokeMakeParticle<T>(arg0: T, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Internal.Particle
    }
    class Format$Field extends Internal.AttributedCharacterIterator$Attribute {
        static readonly LANGUAGE : Internal.AttributedCharacterIterator$Attribute;
        static readonly INPUT_METHOD_SEGMENT : Internal.AttributedCharacterIterator$Attribute;
        static readonly READING : Internal.AttributedCharacterIterator$Attribute;
    }
    class CoderResult {
        static malformedForLength(arg0: number): Internal.CoderResult
        isMalformed(): boolean
        isError(): boolean
        static unmappableForLength(arg0: number): Internal.CoderResult
        isOverflow(): boolean
        isUnmappable(): boolean
        isUnderflow(): boolean
        length(): number
        toString(): string
        throwException(): void
        static readonly OVERFLOW : Internal.CoderResult;
        static readonly UNDERFLOW : Internal.CoderResult;
    }
    class ItemColors implements Internal.ItemColorsExtended {
        getColorProvider(stack: Internal.ItemStack): Internal.ItemColor
    }
    interface WatchEvent$Modifier {
        name(): string
    }
    /**
    */
    class RecipeEventJS extends Internal.EventJS {
        printTypes(): void
        getRecipeFunction(id: string): Internal.RecipeFunction
        custom(o: object): Internal.RecipeJS
        countRecipes(filter: Internal.RecipeFilter): number
        forEachRecipe(filter: Internal.RecipeFilter, consumer: (arg0: Internal.RecipeJS) => void): void
        forEachRecipeAsync(filter: Internal.RecipeFilter, consumer: (arg0: Internal.RecipeJS) => void): void
        remove(filter: Internal.RecipeFilter): number
        addRecipe(r: Internal.RecipeJS, type: Internal.RecipeTypeJS, args1: Internal.ListJS): Internal.RecipeJS
        printExamples(type: string): void
        replaceOutput(ingredient: Internal.IngredientJS, with_: Internal.ItemStackJS): number
        replaceOutput(filter: Internal.RecipeFilter, ingredient: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): number
        replaceOutput(filter: Internal.RecipeFilter, ingredient: Internal.IngredientJS, with_: Internal.ItemStackJS): number
        stage(filter: Internal.RecipeFilter, stage: string): void
        replaceInput(filter: Internal.RecipeFilter, ingredient: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): number
        replaceInput(ingredient: Internal.IngredientJS, with_: Internal.IngredientJS): number
        replaceInput(filter: Internal.RecipeFilter, ingredient: Internal.IngredientJS, with_: Internal.IngredientJS): number
        printAllTypes(): void
        customFilter(filter: Internal.RecipeFilter): Internal.RecipeFilter
        /**
        * Holds all the recipes collected from documents.
        */
        getRecipes(): Document.RecipeHolder
        setItemErrors(b: boolean): void
        readonly smithing : Internal.RecipeFunction;
        static instance : Internal.RecipeEventJS;
        readonly stonecutting : Internal.RecipeFunction;
        readonly shaped : Internal.RecipeFunction;
        readonly smoking : Internal.RecipeFunction;
        static readonly FORGE_CONDITIONAL : "forge:conditional";
        readonly campfireCooking : Internal.RecipeFunction;
        static customIngredientMap : Map<Internal.UUID, Internal.IngredientWithCustomPredicateJS>;
        readonly shapeless : Internal.RecipeFunction;
        readonly smelting : Internal.RecipeFunction;
        readonly blasting : Internal.RecipeFunction;
        /**
        * Holds all the recipes collected from documents.
        */
        get recipes(): Document.RecipeHolder;
        set itemErrors(b: boolean);
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Furnaces.
        */
        smelting(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Smokers.
        */
        smoking(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Blast Furnaces.
        */
        blasting(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a shaped crafting recipe.
        */
        shaped(output: Internal.ItemStackJS, pattern: string[], items: Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        /**
        * Adds a shapeless crafting recipe.
        */
        shapeless(output: Internal.ItemStackJS, inputs: Internal.IngredientJS[]): Internal.ShapelessRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Camefire.
        */
        campfireCooking(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a stonecutting recipe.
        */
        stonecutting(output: Internal.ItemStackJS, inputs: Internal.IngredientJS): Internal.StonecuttingRecipeJS;
        /**
        * Adds a smithing recipe.
        */
        smithing(output: Internal.ItemStackJS, base: Internal.IngredientJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
    }
    class ClientLevelJS extends Internal.LevelJS {
        getMinecraftPlayer(): Internal.LocalPlayer
        getPlayerData(arg0: Internal.Player): Internal.PlayerDataJS<any, any>
        getPlayerData(player: Internal.Player): Internal.ClientPlayerDataJS
        getSide(): Internal.ScriptType
        getEntities(): Internal.EntityArrayList
        toString(): string
        static getInstance(): Internal.ClientLevelJS
        getMinecraft(): Internal.Minecraft
        static setInstance(instance: Internal.ClientLevelJS): void
        getMinecraftLevel(): Internal.Level
        getMinecraftLevel(): Internal.ClientLevel
        readonly clientPlayerData : Internal.ClientPlayerDataJS;
        readonly minecraftLevel : Internal.Level;
        get minecraftPlayer(): Internal.LocalPlayer;
        get side(): Internal.ScriptType;
        get entities(): Internal.EntityArrayList;
        get instance(): Internal.ClientLevelJS;
        get minecraft(): Internal.Minecraft;
        set instance(instance: Internal.ClientLevelJS);
    }
    interface RecipeFilter implements Internal.Predicate<Internal.RecipeJS> {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        test(arg0: Internal.RecipeJS): boolean
        test(arg0: object): boolean
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
        static of(o: object): Internal.RecipeFilter
        static readonly ALWAYS_TRUE : Internal.RecipeFilter;
        static readonly ALWAYS_FALSE : Internal.RecipeFilter;
    }
    interface CustomJavaObjectWrapper$AsMap implements Internal.CustomJavaObjectWrapper {
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, staticType: Internal.Class<object>): Internal.Scriptable
        wrapAsJavaMap(): Map<object, object>
    }
    interface Function4 <T1, T2, T3, T4, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4): R
        curry3(): Internal.Function3<T1, T2, T3, (arg0: T4) => R>
        curry2(): (arg0: T1, arg1: T2) => (arg0: T3, arg1: T4) => R
        curry(): (arg0: T1) => Internal.Function3<T2, T3, T4, R>
    }
    class BakedQuad implements Internal.IVertexProducer, Internal.ModelQuadView {
        getLight(idx: number): number
        getTexV(idx: number): number
        getNormal(idx: number): number
        getTexU(idx: number): number
        getX(idx: number): number
        getColorIndex(): number
        getY(idx: number): number
        getZ(idx: number): number
        getColor(idx: number): number
        pipe(arg0: Internal.IVertexConsumer): void
        getFlags(): number
        getSprite(): Internal.TextureAtlasSprite
        get colorIndex(): number;
        get flags(): number;
        get sprite(): Internal.TextureAtlasSprite;
    }
    class EntityLootEventJS extends Internal.LootEventJS {
        addEntity(type: Internal.EntityType<object>, b: (arg0: Internal.LootBuilder) => void): void
        getType(): string
        modifyEntity(type: Internal.EntityType<object>, b: (arg0: Internal.LootBuilder) => void): void
        getDirectory(): string
        get type(): string;
        get directory(): string;
    }
    interface AnnotatedElement {
        getAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getDeclaredAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getAnnotation<T>(arg0: Internal.Class<T>): T
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        getDeclaredAnnotation<T>(arg0: Internal.Class<T>): T
        getAnnotations(): Internal.Annotation[]
        getDeclaredAnnotations(): Internal.Annotation[]
        get annotations(): Internal.Annotation[];
        get declaredAnnotations(): Internal.Annotation[];
    }
    class LivingEntityEventJS extends Internal.EntityEventJS {
    }
    interface JsonSerializable {
        toJson(): Internal.JsonElement
    }
    class EffectRenderingInventoryScreen <T> extends Internal.AbstractContainerScreen<T> {
    }
    interface WatchEvent <T> {
        kind(): Internal.WatchEvent$Kind<T>
        count(): number
        context(): T
    }
    interface TypeDescriptor {
        descriptorString(): string
    }
    class SocketAddress implements Internal.Serializable {
    }
    interface SortedMap <K, V> implements Map<K, V> {
        getOrDefault(arg0: object, arg1: V): V
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V
        values(): Internal.Collection<V>
        replace(arg0: K, arg1: V): V
        replace(arg0: K, arg1: V, arg2: V): boolean
        replaceAll(arg0: (arg0: K, arg1: V) => V): void
        containsValue(arg0: object): boolean
        put(arg0: K, arg1: V): V
        remove(arg0: object): V
        remove(arg0: object, arg1: object): boolean
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        hashCode(): number
        putAll(arg0: Map<K, V>): void
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V
        get(arg0: object): V
        lastKey(): K
        keySet(): Internal.Set<K>
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>
        containsKey(arg0: object): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        subMap(arg0: K, arg1: K): Internal.SortedMap<K, V>
        isEmpty(): boolean
        clear(): void
        comparator(): Internal.Comparator<K>
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V
        size(): number
        firstKey(): K
        equals(arg0: object): boolean
        headMap(arg0: K): Internal.SortedMap<K, V>
        putIfAbsent(arg0: K, arg1: V): V
        tailMap(arg0: K): Internal.SortedMap<K, V>
    }
    class ClickAction extends Internal.Enum<Internal.ClickAction> {
        static valueOf(arg0: string): Internal.ClickAction
        static values(): Internal.ClickAction[]
        static readonly SECONDARY : Internal.ClickAction;
        static readonly PRIMARY : Internal.ClickAction;
    }
    interface EntityAccess {
    }
    class BufferLayout$Builder {
        build(): Internal.BufferLayout
        addItems(arg0: Internal.LayoutItem[]): Internal.BufferLayout$Builder
    }
    interface BackpackedInventoryAccess {
        getBackpackedInventory(): Internal.BackpackInventory
        get backpackedInventory(): Internal.BackpackInventory;
    }
    class BlockItemBuilder extends Internal.ItemBuilder {
        getBuilderType(): string
        maxStackSize : number;
        color : Internal.Int2IntOpenHashMap;
        translationKey : string;
        toolTier : Internal.Tier;
        displayName : string;
        maxDamage : number;
        readonly tooltip : Internal.List<Internal.Component>;
        foodBuilder : Internal.FoodBuilder;
        type : Internal.ItemType;
        containerItem : string;
        defaultTags : Internal.Set<ResourceLocation>;
        subtypes : (arg0: Internal.ItemStackJS) => Internal.Collection<Internal.ItemStackJS>;
        armorTier : Internal.ArmorMaterial;
        modelJson : Internal.JsonObject;
        static readonly ARMOR_TIERS : Map<string, Internal.ArmorMaterial>;
        burnTime : number;
        readonly id : ResourceLocation;
        parentModel : string;
        attackDamage : number;
        group : Internal.CreativeModeTab;
        item : Internal.Item;
        attackSpeedBaseline : number;
        static readonly TOOL_TIERS : Map<string, Internal.Tier>;
        texture : string;
        blockBuilder : Internal.BlockBuilder;
        miningSpeed : number;
        attackDamageBaseline : number;
        attackSpeed : number;
        blockItem : Internal.BlockItem;
        glow : boolean;
        rarity : Rarity;
        get builderType(): string;
    }
    class CompositeByteBuf extends Internal.AbstractReferenceCountedByteBuf implements Internal.Iterable<Internal.ByteBuf> {
        markReaderIndex(): Internal.ByteBuf
        markReaderIndex(): Internal.CompositeByteBuf
        getByte(arg0: number): number
        readerIndex(arg0: number): Internal.ByteBuf
        readerIndex(arg0: number): Internal.CompositeByteBuf
        writeZero(arg0: number): Internal.ByteBuf
        writeZero(arg0: number): Internal.CompositeByteBuf
        addComponent(arg0: Internal.ByteBuf): Internal.CompositeByteBuf
        addComponent(arg0: boolean, arg1: Internal.ByteBuf): Internal.CompositeByteBuf
        addComponent(arg0: number, arg1: Internal.ByteBuf): Internal.CompositeByteBuf
        addComponent(arg0: boolean, arg1: number, arg2: Internal.ByteBuf): Internal.CompositeByteBuf
        setShort(arg0: number, arg1: number): Internal.ByteBuf
        setShort(arg0: number, arg1: number): Internal.CompositeByteBuf
        resetReaderIndex(): Internal.CompositeByteBuf
        resetReaderIndex(): Internal.ByteBuf
        writeFloat(arg0: number): Internal.CompositeByteBuf
        writeFloat(arg0: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.CompositeByteBuf
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.CompositeByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: number[]): Internal.CompositeByteBuf
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.CompositeByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.CompositeByteBuf
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.CompositeByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.CompositeByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel, arg2: number): number
        getBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        unwrap(): Internal.ByteBuf
        setDouble(arg0: number, arg1: number): Internal.CompositeByteBuf
        setDouble(arg0: number, arg1: number): Internal.ByteBuf
        setChar(arg0: number, arg1: number): Internal.CompositeByteBuf
        setChar(arg0: number, arg1: number): Internal.ByteBuf
        addComponents(arg0: number, arg1: Internal.Iterable<Internal.ByteBuf>): Internal.CompositeByteBuf
        addComponents(arg0: Internal.Iterable<Internal.ByteBuf>): Internal.CompositeByteBuf
        addComponents(arg0: number, arg1: Internal.ByteBuf[]): Internal.CompositeByteBuf
        addComponents(arg0: boolean, arg1: Internal.ByteBuf[]): Internal.CompositeByteBuf
        addComponents(arg0: boolean, arg1: Internal.Iterable<Internal.ByteBuf>): Internal.CompositeByteBuf
        addComponents(arg0: Internal.ByteBuf[]): Internal.CompositeByteBuf
        iterator(): Internal.Iterator<Internal.ByteBuf>
        toByteIndex(arg0: number): number
        order(): Internal.ByteOrder
        writeMedium(arg0: number): Internal.ByteBuf
        writeMedium(arg0: number): Internal.CompositeByteBuf
        writeByte(arg0: number): Internal.ByteBuf
        writeByte(arg0: number): Internal.CompositeByteBuf
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        resetWriterIndex(): Internal.CompositeByteBuf
        resetWriterIndex(): Internal.ByteBuf
        spliterator(): Internal.Spliterator<T>
        discardSomeReadBytes(): Internal.ByteBuf
        discardSomeReadBytes(): Internal.CompositeByteBuf
        touch(arg0: object): Internal.CompositeByteBuf
        touch(arg0: object): Internal.ByteBuf
        touch(arg0: object): Internal.ReferenceCounted
        touch(): Internal.ByteBuf
        touch(): Internal.CompositeByteBuf
        touch(): Internal.ReferenceCounted
        internalComponentAtOffset(arg0: number): Internal.ByteBuf
        writerIndex(arg0: number): Internal.ByteBuf
        writerIndex(arg0: number): Internal.CompositeByteBuf
        nioBufferCount(): number
        discardReadComponents(): Internal.CompositeByteBuf
        setInt(arg0: number, arg1: number): Internal.ByteBuf
        setInt(arg0: number, arg1: number): Internal.CompositeByteBuf
        removeComponent(arg0: number): Internal.CompositeByteBuf
        setLong(arg0: number, arg1: number): Internal.ByteBuf
        setLong(arg0: number, arg1: number): Internal.CompositeByteBuf
        componentAtOffset(arg0: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.CompositeByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.CompositeByteBuf
        writeBytes(arg0: Internal.ByteBuffer): Internal.CompositeByteBuf
        writeBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf): Internal.CompositeByteBuf
        writeBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.CompositeByteBuf
        writeBytes(arg0: number[]): Internal.ByteBuf
        writeBytes(arg0: number[]): Internal.CompositeByteBuf
        setIndex(arg0: number, arg1: number): Internal.CompositeByteBuf
        setIndex(arg0: number, arg1: number): Internal.ByteBuf
        markWriterIndex(): Internal.ByteBuf
        markWriterIndex(): Internal.CompositeByteBuf
        writeShort(arg0: number): Internal.CompositeByteBuf
        writeShort(arg0: number): Internal.ByteBuf
        alloc(): Internal.ByteBufAllocator
        removeComponents(arg0: number, arg1: number): Internal.CompositeByteBuf
        writeBoolean(arg0: boolean): Internal.CompositeByteBuf
        writeBoolean(arg0: boolean): Internal.ByteBuf
        addFlattenedComponents(arg0: boolean, arg1: Internal.ByteBuf): Internal.CompositeByteBuf
        numComponents(): number
        setByte(arg0: number, arg1: number): Internal.CompositeByteBuf
        setByte(arg0: number, arg1: number): Internal.ByteBuf
        toComponentIndex(arg0: number): number
        retain(arg0: number): Internal.CompositeByteBuf
        retain(arg0: number): Internal.ByteBuf
        retain(arg0: number): Internal.ReferenceCounted
        retain(): Internal.CompositeByteBuf
        retain(): Internal.ReferenceCounted
        retain(): Internal.ByteBuf
        decompose(arg0: number, arg1: number): Internal.List<Internal.ByteBuf>
        hasMemoryAddress(): boolean
        capacity(): number
        capacity(arg0: number): Internal.ByteBuf
        capacity(arg0: number): Internal.CompositeByteBuf
        writeLong(arg0: number): Internal.CompositeByteBuf
        writeLong(arg0: number): Internal.ByteBuf
        array(): number[]
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        internalComponent(arg0: number): Internal.ByteBuf
        arrayOffset(): number
        copy(arg0: number, arg1: number): Internal.ByteBuf
        writeDouble(arg0: number): Internal.CompositeByteBuf
        writeDouble(arg0: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.CompositeByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.CompositeByteBuf
        setBytes(arg0: number, arg1: Internal.InputStream, arg2: number): number
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.CompositeByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel, arg2: number): number
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.CompositeByteBuf
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.CompositeByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        setBytes(arg0: number, arg1: number[]): Internal.CompositeByteBuf
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        ensureWritable(arg0: number): Internal.CompositeByteBuf
        ensureWritable(arg0: number): Internal.ByteBuf
        maxNumComponents(): number
        writeInt(arg0: number): Internal.ByteBuf
        writeInt(arg0: number): Internal.CompositeByteBuf
        setFloat(arg0: number, arg1: number): Internal.ByteBuf
        setFloat(arg0: number, arg1: number): Internal.CompositeByteBuf
        hasArray(): boolean
        memoryAddress(): number
        consolidate(): Internal.CompositeByteBuf
        consolidate(arg0: number, arg1: number): Internal.CompositeByteBuf
        forEach(arg0: (arg0: T) => void): void
        clear(): Internal.CompositeByteBuf
        clear(): Internal.ByteBuf
        discardReadBytes(): Internal.CompositeByteBuf
        discardReadBytes(): Internal.ByteBuf
        nioBuffers(): Internal.ByteBuffer[]
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[]
        skipBytes(arg0: number): Internal.ByteBuf
        skipBytes(arg0: number): Internal.CompositeByteBuf
        writeChar(arg0: number): Internal.CompositeByteBuf
        writeChar(arg0: number): Internal.ByteBuf
        component(arg0: number): Internal.ByteBuf
        setZero(arg0: number, arg1: number): Internal.CompositeByteBuf
        setZero(arg0: number, arg1: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf): Internal.CompositeByteBuf
        readBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.CompositeByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.CompositeByteBuf
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.CompositeByteBuf
        readBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuffer): Internal.CompositeByteBuf
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.CompositeByteBuf
        readBytes(arg0: number[]): Internal.CompositeByteBuf
        readBytes(arg0: number[]): Internal.ByteBuf
        toString(): string
        setMedium(arg0: number, arg1: number): Internal.CompositeByteBuf
        setMedium(arg0: number, arg1: number): Internal.ByteBuf
        isDirect(): boolean
        setBoolean(arg0: number, arg1: boolean): Internal.CompositeByteBuf
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf
    }
    class ModuleDescriptor$Exports implements Internal.Comparable<Internal.ModuleDescriptor$Exports> {
        hashCode(): number
        equals(arg0: object): boolean
        isQualified(): boolean
        toString(): string
        source(): string
        compareTo(arg0: Internal.ModuleDescriptor$Exports): number
        compareTo(arg0: object): number
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Exports$Modifier>
        targets(): Internal.Set<string>
    }
    class GuiComponent {
    }
    interface IntToDoubleFunction {
        applyAsDouble(arg0: number): number
    }
    interface CoordinateConsumer {
        consume(arg0: number, arg1: number, arg2: number): void
    }
    class StageCreationEvent {
        getPlayer(): Internal.Player
        setPlayerStages(s: Internal.Stages): void
        getPlayerStages(): Internal.Stages
        get player(): Internal.Player;
        set playerStages(s: Internal.Stages);
        get playerStages(): Internal.Stages;
    }
    class LightTexture implements Internal.AutoCloseable {
        close(): void
    }
    interface ObjectList <K> implements Internal.List<K>, Internal.Comparable<Internal.List<K>>, Internal.ObjectCollection<K> {
        compareTo(arg0: T): number
        replaceAll(arg0: Internal.UnaryOperator<E>): void
        remove(arg0: object): boolean
        remove(arg0: number): E
        removeAll(arg0: Internal.Collection<object>): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.ObjectIterator<any>
        iterator(): Internal.ObjectListIterator<K>
        stream(): Internal.Stream<E>
        hashCode(): number
        addElements(arg0: number, arg1: K[], arg2: number, arg3: number): void
        addElements(arg0: number, arg1: K[]): void
        get(arg0: number): E
        static of<K>(arg0: K[]): Internal.ObjectList<K>
        static of<K>(arg0: K, arg1: K, arg2: K): Internal.ObjectList<K>
        static of<K>(arg0: K, arg1: K): Internal.ObjectList<K>
        static of<K>(): Internal.ObjectList<K>
        static of<K>(arg0: K): Internal.ObjectList<K>
        toArray(): object[]
        toArray<T>(arg0: T[]): T[]
        toArray<T>(arg0: Internal.IntFunction<T[]>): T[]
        parallelStream(): Internal.Stream<E>
        indexOf(arg0: object): number
        add(arg0: number, arg1: E): void
        add(arg0: E): boolean
        subList(arg0: number, arg1: number): Internal.ObjectList<K>
        subList(arg0: number, arg1: number): Internal.List<any>
        set(arg0: number, arg1: E): E
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.ObjectSpliterator<K>
        forEach(arg0: (arg0: T) => void): void
        containsAll(arg0: Internal.Collection<object>): boolean
        isEmpty(): boolean
        clear(): void
        setElements(arg0: K[]): void
        setElements(arg0: number, arg1: K[]): void
        setElements(arg0: number, arg1: K[], arg2: number, arg3: number): void
        sort(arg0: Internal.Comparator<K>): void
        removeElements(arg0: number, arg1: number): void
        removeIf(arg0: (arg0: E) => boolean): boolean
        lastIndexOf(arg0: object): number
        contains(arg0: object): boolean
        size(arg0: number): void
        size(): number
        addAll(arg0: Internal.ObjectList<K>): boolean
        addAll(arg0: number, arg1: Internal.ObjectList<K>): boolean
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean
        addAll(arg0: Internal.Collection<E>): boolean
        equals(arg0: object): boolean
        getElements(arg0: number, arg1: object[], arg2: number, arg3: number): void
        listIterator(arg0: number): Internal.ObjectListIterator<K>
        listIterator(arg0: number): Internal.ListIterator<any>
        listIterator(): Internal.ListIterator<any>
        listIterator(): Internal.ObjectListIterator<K>
        unstableSort(arg0: Internal.Comparator<K>): void
        retainAll(arg0: Internal.Collection<object>): boolean
        set elements(arg0: K[]);
    }
    class ImmutableSetMultimap <K, V> extends Internal.ImmutableMultimap<K, V> implements Internal.SetMultimap<K, V> {
        static flatteningToImmutableSetMultimap<T, K, V>(arg0: (arg0: T) => K, arg1: (arg0: T) => Internal.Stream<V>): Internal.Collector<T, object, Internal.ImmutableSetMultimap<K, V>>
        inverse(): Internal.ImmutableMultimap<any, any>
        inverse(): Internal.ImmutableSetMultimap<V, K>
        removeAll(arg0: object): Internal.Collection<any>
        removeAll(arg0: object): Internal.ImmutableCollection<any>
        removeAll(arg0: object): Internal.ImmutableSet<V>
        removeAll(arg0: object): Internal.Set<any>
        entries(): Internal.Collection<any>
        entries(): Internal.ImmutableCollection<any>
        entries(): Internal.Set<any>
        entries(): Internal.ImmutableSet<Internal.Map$Entry<K, V>>
        static of<K, V>(arg0: K, arg1: V): Internal.ImmutableSetMultimap<K, V>
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): Internal.ImmutableSetMultimap<K, V>
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): Internal.ImmutableSetMultimap<K, V>
        static of<K, V>(): Internal.ImmutableSetMultimap<K, V>
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): Internal.ImmutableSetMultimap<K, V>
        static of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): Internal.ImmutableSetMultimap<K, V>
        get(arg0: object): Internal.Collection<any>
        get(arg0: K): Internal.ImmutableSet<V>
        get(arg0: object): Internal.ImmutableCollection<any>
        get(arg0: object): Internal.Set<any>
        static builder<K, V>(): Internal.ImmutableSetMultimap$Builder<K, V>
        static copyOf<K, V>(arg0: Internal.Multimap<K, V>): Internal.ImmutableSetMultimap<K, V>
        static copyOf<K, V>(arg0: Internal.Iterable<Internal.Map$Entry<K, V>>): Internal.ImmutableSetMultimap<K, V>
        replaceValues(arg0: object, arg1: Internal.Iterable<any>): Internal.ImmutableCollection<any>
        replaceValues(arg0: object, arg1: Internal.Iterable<any>): Internal.Set<any>
        replaceValues(arg0: object, arg1: Internal.Iterable<any>): Internal.Collection<any>
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.ImmutableSet<V>
        static toImmutableSetMultimap<T, K, V>(arg0: (arg0: T) => K, arg1: (arg0: T) => V): Internal.Collector<T, object, Internal.ImmutableSetMultimap<K, V>>
    }
    interface Double2ShortFunction implements Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Short2ShortFunction): Internal.Double2ShortFunction
        composeByte(arg0: Internal.Byte2DoubleFunction): Internal.Byte2ShortFunction
        andThenInt(arg0: Internal.Short2IntFunction): Internal.Double2IntFunction
        composeReference<T>(arg0: Internal.Reference2DoubleFunction<T>): Internal.Reference2ShortFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Short2DoubleFunction): Internal.Double2DoubleFunction
        andThenObject<T>(arg0: Internal.Short2ObjectFunction<T>): Internal.Double2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Short2LongFunction): Internal.Double2LongFunction
        composeLong(arg0: Internal.Long2DoubleFunction): Internal.Long2ShortFunction
        andThenByte(arg0: Internal.Short2ByteFunction): Internal.Double2ByteFunction
        andThenFloat(arg0: Internal.Short2FloatFunction): Internal.Double2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2DoubleFunction): Internal.Int2ShortFunction
        clear(): void
        composeFloat(arg0: Internal.Float2DoubleFunction): Internal.Float2ShortFunction
        andThenChar(arg0: Internal.Short2CharFunction): Internal.Double2CharFunction
        composeObject<T>(arg0: Internal.Object2DoubleFunction<T>): Internal.Object2ShortFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2DoubleFunction): Internal.Short2ShortFunction
        andThenReference<T>(arg0: Internal.Short2ReferenceFunction<T>): Internal.Double2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2DoubleFunction): Internal.Char2ShortFunction
        composeDouble(arg0: Internal.Double2DoubleFunction): Internal.Double2ShortFunction
    }
    class Pattern implements Internal.Serializable {
        static quote(arg0: string): string
        split(arg0: Internal.CharSequence, arg1: number): string[]
        split(arg0: Internal.CharSequence): string[]
        static compile(arg0: string): Internal.Pattern
        static compile(arg0: string, arg1: number): Internal.Pattern
        splitAsStream(arg0: Internal.CharSequence): Internal.Stream<string>
        pattern(): string
        flags(): number
        toString(): string
        asMatchPredicate(): (arg0: string) => boolean
        asPredicate(): (arg0: string) => boolean
        matcher(arg0: Internal.CharSequence): Internal.Matcher
        static matches(arg0: string, arg1: Internal.CharSequence): boolean
        static readonly DOTALL : 32;
        static readonly UNICODE_CASE : 64;
        static readonly LITERAL : 16;
        static readonly UNICODE_CHARACTER_CLASS : 256;
        static readonly CASE_INSENSITIVE : 2;
        static readonly CANON_EQ : 128;
        static readonly COMMENTS : 4;
        static readonly UNIX_LINES : 1;
        static readonly MULTILINE : 8;
    }
    class FriendlyByteBuf extends Internal.ByteBuf implements Internal.IForgeFriendlyByteBuf {
        asReadOnly(): Internal.ByteBuf
        markReaderIndex(): Internal.ByteBuf
        getByte(arg0: number): number
        writeItemStack(arg0: Internal.ItemStack, arg1: boolean): Internal.FriendlyByteBuf
        release(arg0: number): boolean
        release(): boolean
        writeZero(arg0: number): Internal.ByteBuf
        resetReaderIndex(): Internal.ByteBuf
        writeFloat(arg0: number): Internal.ByteBuf
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf
        readRegistryId<T>(): T
        readRetainedSlice(arg0: number): Internal.ByteBuf
        slice(): Internal.ByteBuf
        slice(arg0: number, arg1: number): Internal.ByteBuf
        getMediumLE(arg0: number): number
        readUnsignedIntLE(): number
        readInt(): number
        order(arg0: Internal.ByteOrder): Internal.ByteBuf
        order(): Internal.ByteOrder
        writeMedium(arg0: number): Internal.ByteBuf
        resetWriterIndex(): Internal.ByteBuf
        writableBytes(): number
        getUnsignedShort(arg0: number): number
        maxCapacity(): number
        bytesBefore(arg0: number, arg1: number): number
        bytesBefore(arg0: number, arg1: number, arg2: number): number
        bytesBefore(arg0: number): number
        nioBufferCount(): number
        setInt(arg0: number, arg1: number): Internal.ByteBuf
        getInt(arg0: number): number
        markWriterIndex(): Internal.ByteBuf
        isReadable(): boolean
        isReadable(arg0: number): boolean
        writeBoolean(arg0: boolean): Internal.ByteBuf
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf
        writeLongLE(arg0: number): Internal.ByteBuf
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf
        retain(arg0: number): Internal.ReferenceCounted
        retain(arg0: number): Internal.ByteBuf
        retain(): Internal.ReferenceCounted
        retain(): Internal.ByteBuf
        isWritable(): boolean
        isWritable(arg0: number): boolean
        readChar(): string
        hasMemoryAddress(): boolean
        capacity(): number
        capacity(arg0: number): Internal.ByteBuf
        readRegistryIdSafe<T>(arg0: Internal.Class<T>): T
        readCharSequence(arg0: number, arg1: Internal.Charset): Internal.CharSequence
        isReadOnly(): boolean
        readUnsignedShortLE(): number
        readDouble(): number
        readFloat(): number
        getLongLE(arg0: number): number
        getBoolean(arg0: number): boolean
        copy(): Internal.ByteBuf
        copy(arg0: number, arg1: number): Internal.ByteBuf
        readShortLE(): number
        readUnsignedMedium(): number
        ensureWritable(arg0: number): Internal.ByteBuf
        ensureWritable(arg0: number, arg1: boolean): number
        writeInt(arg0: number): Internal.ByteBuf
        hasArray(): boolean
        memoryAddress(): number
        readableBytes(): number
        readSlice(arg0: number): Internal.ByteBuf
        getIntLE(arg0: number): number
        forEachByteDesc(arg0: Internal.ByteProcessor): number
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[]
        nioBuffers(): Internal.ByteBuffer[]
        skipBytes(arg0: number): Internal.ByteBuf
        getLong(arg0: number): number
        readLong(): number
        readShort(): number
        equals(arg0: object): boolean
        setZero(arg0: number, arg1: number): Internal.ByteBuf
        getUnsignedMedium(arg0: number): number
        readBytes(arg0: number): Internal.ByteBuf
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.ByteBuf
        readBytes(arg0: Internal.GatheringByteChannel, arg1: number): number
        readBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        readBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        readBytes(arg0: number[]): Internal.ByteBuf
        readBoolean(): boolean
        toString(): string
        toString(arg0: number, arg1: number, arg2: Internal.Charset): string
        toString(arg0: Internal.Charset): string
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf
        retainedSlice(): Internal.ByteBuf
        readMediumLE(): number
        setMedium(arg0: number, arg1: number): Internal.ByteBuf
        isDirect(): boolean
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf
        readerIndex(arg0: number): Internal.ByteBuf
        readerIndex(): number
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset): Internal.CharSequence
        setShort(arg0: number, arg1: number): Internal.ByteBuf
        compareTo(arg0: object): number
        compareTo(arg0: Internal.ByteBuf): number
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel, arg2: number): number
        unwrap(): Internal.ByteBuf
        setDouble(arg0: number, arg1: number): Internal.ByteBuf
        setChar(arg0: number, arg1: number): Internal.ByteBuf
        refCnt(): number
        getUnsignedIntLE(arg0: number): number
        getUnsignedInt(arg0: number): number
        writeRegistryIdUnsafe(arg0: Internal.IForgeRegistry<object>, arg1: ResourceLocation): void
        writeRegistryIdUnsafe<T>(arg0: Internal.IForgeRegistry<T>, arg1: T): void
        indexOf(arg0: number, arg1: number, arg2: number): number
        writeByte(arg0: number): Internal.ByteBuf
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        nioBuffer(): Internal.ByteBuffer
        discardSomeReadBytes(): Internal.ByteBuf
        touch(arg0: object): Internal.ReferenceCounted
        touch(arg0: object): Internal.ByteBuf
        touch(): Internal.ByteBuf
        touch(): Internal.ReferenceCounted
        readRegistryIdUnsafe<T>(arg0: Internal.IForgeRegistry<T>): T
        duplicate(): Internal.ByteBuf
        writerIndex(): number
        writerIndex(arg0: number): Internal.ByteBuf
        writeCharSequence(arg0: Internal.CharSequence, arg1: Internal.Charset): number
        readUnsignedInt(): number
        getUnsignedShortLE(arg0: number): number
        retainedDuplicate(): Internal.ByteBuf
        getChar(arg0: number): string
        setLong(arg0: number, arg1: number): Internal.ByteBuf
        readMedium(): number
        writeBytes(arg0: Internal.InputStream, arg1: number): number
        writeBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        writeBytes(arg0: Internal.ScatteringByteChannel, arg1: number): number
        writeBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        writeBytes(arg0: number[]): Internal.ByteBuf
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        forEachByte(arg0: Internal.ByteProcessor): number
        setIndex(arg0: number, arg1: number): Internal.ByteBuf
        writeShort(arg0: number): Internal.ByteBuf
        alloc(): Internal.ByteBufAllocator
        getShortLE(arg0: number): number
        getMedium(arg0: number): number
        readUnsignedShort(): number
        setByte(arg0: number, arg1: number): Internal.ByteBuf
        writeShortLE(arg0: number): Internal.ByteBuf
        maxWritableBytes(): number
        readFluidStack(): Internal.FluidStack
        getDouble(arg0: number): number
        getFloat(arg0: number): number
        writeLong(arg0: number): Internal.ByteBuf
        writeIntLE(arg0: number): Internal.ByteBuf
        array(): number[]
        setCharSequence(arg0: number, arg1: Internal.CharSequence, arg2: Internal.Charset): number
        hashCode(): number
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer
        arrayOffset(): number
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf
        readIntLE(): number
        readUnsignedByte(): number
        readUnsignedMediumLE(): number
        readLongLE(): number
        writeDouble(arg0: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.InputStream, arg2: number): number
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel, arg2: number): number
        setFloat(arg0: number, arg1: number): Internal.ByteBuf
        getShort(arg0: number): number
        writeMediumLE(arg0: number): Internal.ByteBuf
        clear(): Internal.ByteBuf
        writeRegistryId<T>(arg0: T): void
        getUnsignedByte(arg0: number): number
        writeFluidStack(arg0: Internal.FluidStack): void
        discardReadBytes(): Internal.ByteBuf
        writeChar(arg0: number): Internal.ByteBuf
        getUnsignedMediumLE(arg0: number): number
        readByte(): number
    }
    class Projectile extends Internal.Entity {
        backpackedMoved : boolean;
    }
    class TextureAtlasSprite implements Internal.AutoCloseable, Internal.SpriteExtended {
        getPixelRGBA(arg0: number, arg1: number, arg2: number): number
        setActive(active: boolean): void
        toString(): string
        isActive(): boolean
        close(): void
        set active(active: boolean);
    }
    class PoseStack$Pose {
    }
    interface BlockEntityPredicateDataCheck {
        checkData(arg0: Internal.CompoundTag): boolean
    }
    class ShapedRecipeJS extends Internal.RecipeJS {
        serialize(): void
        noMirror(): Internal.ShapedRecipeJS
        create(args: Internal.ListJS): void
        noShrink(): Internal.ShapedRecipeJS
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<object>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
    }
    interface CharSequence {
        static compare(arg0: Internal.CharSequence, arg1: Internal.CharSequence): number
        isEmpty(): boolean
        length(): number
        toString(): string
        subSequence(arg0: number, arg1: number): Internal.CharSequence
        chars(): Internal.IntStream
        charAt(arg0: number): string
        codePoints(): Internal.IntStream
    }
    interface ICapabilityProviderImpl <B> implements Internal.ICapabilityProvider {
        invalidateCaps(): void
        getCapability<T>(arg0: Internal.Capability<T>, arg1: Internal.Direction): Internal.LazyOptional<T>
        getCapability<T>(arg0: Internal.Capability<T>): Internal.LazyOptional<T>
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean
        areCapsCompatible(arg0: Internal.CapabilityProvider<B>): boolean
        reviveCaps(): void
    }
    interface HeadedModel {
    }
    class ZoneOffsetTransitionRule$TimeDefinition extends Internal.Enum<Internal.ZoneOffsetTransitionRule$TimeDefinition> {
        static valueOf(arg0: string): Internal.ZoneOffsetTransitionRule$TimeDefinition
        static values(): Internal.ZoneOffsetTransitionRule$TimeDefinition[]
        createDateTime(arg0: Internal.LocalDateTime, arg1: Internal.ZoneOffset, arg2: Internal.ZoneOffset): Internal.LocalDateTime
        static readonly WALL : Internal.ZoneOffsetTransitionRule$TimeDefinition;
        static readonly UTC : Internal.ZoneOffsetTransitionRule$TimeDefinition;
        static readonly STANDARD : Internal.ZoneOffsetTransitionRule$TimeDefinition;
    }
    interface IntStream$IntMapMultiConsumer {
        accept(arg0: number, arg1: java_.util.function_.IntConsumer): void
    }
    interface Keyable {
        keys<T>(arg0: Internal.DynamicOps<T>): Internal.Stream<T>
        static forStrings(arg0: () => Internal.Stream<string>): Internal.Keyable
    }
    interface IForgeFluid {
        getAttributes(): Internal.FluidAttributes
        getExplosionResistance(arg0: Internal.FluidState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): number
        getTags(): Internal.Set<ResourceLocation>
        isEntityInside(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity, arg4: number, arg5: Internal.SetTag<Internal.Fluid>, arg6: boolean): boolean
        isAABBInsideMaterial(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.AABB, arg4: net.minecraft.world.level.material.Material): boolean
        isAABBInsideLiquid(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.AABB): boolean
        get attributes(): Internal.FluidAttributes;
        get tags(): Internal.Set<ResourceLocation>;
    }
    class LootBuilderPool implements Internal.FunctionContainer, Internal.ConditionContainer {
        damage(damage: Internal.NumberProvider): Internal.FunctionContainer
        nbt(tag: Internal.CompoundTag): Internal.FunctionContainer
        enchantWithLevels(levels: Internal.NumberProvider, treasure: boolean): Internal.FunctionContainer
        survivesExplosion(): Internal.ConditionContainer
        addEmpty(weight: number): Internal.LootTableEntry
        addConditionalFunction(func: (arg0: Internal.ConditionalFunction) => void): Internal.FunctionContainer
        addCondition(o: Internal.JsonObject): Internal.LootBuilderPool
        addCondition(arg0: Internal.JsonObject): Internal.ConditionContainer
        addTag(tag: string, expand: boolean): Internal.LootTableEntry
        addItem(item: Internal.ItemStack): Internal.LootTableEntry
        addItem(item: Internal.ItemStack, weight: number): Internal.LootTableEntry
        addItem(item: Internal.ItemStack, weight: number, count: Internal.NumberProvider): Internal.LootTableEntry
        lootTable(table: ResourceLocation, seed: number): Internal.FunctionContainer
        setBinomialRolls(n: number, p: number): void
        killedByPlayer(): Internal.ConditionContainer
        randomChance(chance: number): Internal.ConditionContainer
        addFunction(arg0: Internal.JsonObject): Internal.FunctionContainer
        addFunction(o: Internal.JsonObject): Internal.LootBuilderPool
        count(count: Internal.NumberProvider): Internal.FunctionContainer
        lootingEnchant(count: Internal.NumberProvider, limit: number): Internal.FunctionContainer
        setUniformRolls(min: number, max: number): void
        toJson(): Internal.JsonObject
        entityScores(entity: Internal.LootContext$EntityTarget, scores: Map<string, object>): Internal.ConditionContainer
        copyName(source: Internal.CopyNameFunction$NameSource): Internal.FunctionContainer
        addEntry(json: Internal.JsonObject): Internal.LootTableEntry
        name(name: Internal.Text, entity: Internal.LootContext$EntityTarget): Internal.FunctionContainer
        name(name: Internal.Text): Internal.FunctionContainer
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer
        furnaceSmelt(): Internal.FunctionContainer
        addLootTable(table: ResourceLocation): Internal.LootTableEntry
        enchantRandomly(enchantments: ResourceLocation[]): Internal.FunctionContainer
        entityProperties(entity: Internal.LootContext$EntityTarget, properties: Internal.JsonObject): Internal.ConditionContainer
        readonly entries : Internal.JsonArray;
        readonly functions : Internal.JsonArray;
        rolls : Internal.NumberProvider;
        readonly conditions : Internal.JsonArray;
        bonusRolls : Internal.NumberProvider;
    }
    class FireworksJS$Explosion {
        trail : boolean;
        readonly fadeColors : Internal.IntOpenHashSet;
        shape : Internal.FireworksJS$Shape;
        flicker : boolean;
        readonly colors : Internal.IntOpenHashSet;
    }
    class InvertedLootItemCondition implements Internal.LootItemCondition {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        test(arg0: Internal.LootContext): boolean
        test(arg0: object): boolean
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
    }
    interface IModBusEvent {
    }
    interface ClassShutter {
        visibleToScripts(arg0: string, arg1: number): boolean
        static readonly TYPE_MEMBER : 1;
        static readonly TYPE_CLASS_IN_PACKAGE : 2;
        static readonly TYPE_UNKNOWN : 0;
        static readonly TYPE_EXCEPTION : 3;
    }
    interface Kind1 <F, Mu> implements Internal.App<Mu, F> {
        static unbox<F, Proof>(arg0: Internal.App<Proof, F>): Internal.Kind1<F, Proof>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>): Internal.Products$P11<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>): Internal.Products$P10<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>): Internal.Products$P9<F, T1, T2, T3, T4, T5, T6, T7, T8, T9>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>, arg13: Internal.App<F, T14>, arg14: Internal.App<F, T15>, arg15: Internal.App<F, T16>): Internal.Products$P16<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>, arg13: Internal.App<F, T14>, arg14: Internal.App<F, T15>): Internal.Products$P15<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>, arg13: Internal.App<F, T14>): Internal.Products$P14<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>): Internal.Products$P13<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>): Internal.Products$P12<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
        group<T1, T2, T3>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>): Internal.Products$P3<F, T1, T2, T3>
        group<T1, T2>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>): Internal.Products$P2<F, T1, T2>
        group<T1>(arg0: Internal.App<F, T1>): Internal.Products$P1<F, T1>
        group<T1, T2, T3, T4, T5, T6, T7, T8>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        group<T1, T2, T3, T4, T5, T6, T7>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        group<T1, T2, T3, T4, T5, T6>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>
        group<T1, T2, T3, T4, T5>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>
        group<T1, T2, T3, T4>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>): Internal.Products$P4<F, T1, T2, T3, T4>
    }
    interface Function8 <T1, T2, T3, T4, T5, T6, T7, T8, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8): R
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, (arg0: T8) => R>
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function3<T6, T7, T8, R>>
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, (arg0: T7, arg1: T8) => R>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function5<T4, T5, T6, T7, T8, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function4<T5, T6, T7, T8, R>>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function6<T3, T4, T5, T6, T7, T8, R>
        curry(): (arg0: T1) => Internal.Function7<T2, T3, T4, T5, T6, T7, T8, R>
    }
    class DirectVertexConsumer implements Internal.VertexConsumer {
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer): number
        createSink(factory: Internal.VertexType<any>): Internal.VertexSink
        split(arg0: number): Internal.DirectVertexConsumer
        memSetZero(): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void
        applyBakedNormals(arg0: Internal.Vector3f, arg1: Internal.ByteBuffer, arg2: Internal.Matrix3f): void
        hasOverlay(): boolean
        readonly format : Internal.VertexFormat;
        readonly startPos : number;
    }
    interface Era implements Internal.TemporalAccessor, Internal.TemporalAdjuster {
        getLong(arg0: Internal.TemporalField): number
        getValue(): number
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        query<R>(arg0: Internal.TemporalQuery<R>): R
        get(arg0: Internal.TemporalField): number
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        isSupported(arg0: Internal.TemporalField): boolean
        get value(): number;
    }
    class BlockLootEventJS extends Internal.LootEventJS {
        addSimpleBlock(blocks: BlockStatePredicate, item: Internal.ItemStack): void
        addSimpleBlock(blocks: BlockStatePredicate): void
        build(blocks: BlockStatePredicate, b: (arg0: Internal.LootBuilder) => void): void
        getType(): string
        addBlock(blocks: BlockStatePredicate, b: (arg0: Internal.LootBuilder) => void): void
        modifyBlock(blocks: BlockStatePredicate, b: (arg0: Internal.LootBuilder) => void): void
        getDirectory(): string
        get type(): string;
        get directory(): string;
    }
    class JsonReader implements Internal.Closeable {
        skipValue(): void
        isLenient(): boolean
        hasNext(): boolean
        nextInt(): number
        nextString(): string
        endArray(): void
        nextLong(): number
        setLenient(arg0: boolean): void
        nextDouble(): number
        endObject(): void
        peek(): Internal.JsonToken
        beginArray(): void
        beginObject(): void
        getPath(): string
        toString(): string
        nextBoolean(): boolean
        nextName(): string
        close(): void
        nextNull(): void
        set lenient(arg0: boolean);
        get path(): string;
    }
    interface VertexSink {
        flush(): void
        ensureCapacity(arg0: number): void
        getVertexCount(): number
        get vertexCount(): number;
    }
    class WorldPaintEventJS extends Internal.PaintEventJS {
        rotateRadY(angle: number): void
        rotateRadX(angle: number): void
        rotateDegZ(angle: number): void
        rotateDegY(angle: number): void
        scale(scale: number): void
        rotateDegX(angle: number): void
        rotateRadZ(angle: number): void
        readonly mc : Internal.Minecraft;
        readonly delta : number;
        readonly screen : Internal.Screen;
        readonly tesselator : Internal.Tesselator;
        readonly buffer : Internal.BufferBuilder;
        readonly matrices : Internal.PoseStack;
        readonly font : Internal.Font;
    }
    class ZoneId implements Internal.Serializable {
        static ofOffset(arg0: string, arg1: Internal.ZoneOffset): Internal.ZoneId
        static systemDefault(): Internal.ZoneId
        static getAvailableZoneIds(): Internal.Set<string>
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        normalized(): Internal.ZoneId
        hashCode(): number
        static of(arg0: string, arg1: Map<string, string>): Internal.ZoneId
        static of(arg0: string): Internal.ZoneId
        equals(arg0: object): boolean
        getId(): string
        static from(arg0: Internal.TemporalAccessor): Internal.ZoneId
        toString(): string
        getRules(): Internal.ZoneRules
        static readonly SHORT_IDS : Map<string, string>;
        get availableZoneIds(): Internal.Set<string>;
        get id(): string;
        get rules(): Internal.ZoneRules;
    }
    interface LivingEntityAccessor {
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void
    }
    interface Collection <E> implements Internal.Iterable<E> {
        add(arg0: E): boolean
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: T) => void): void
        containsAll(arg0: Internal.Collection<object>): boolean
        isEmpty(): boolean
        clear(): void
        remove(arg0: object): boolean
        removeIf(arg0: (arg0: E) => boolean): boolean
        removeAll(arg0: Internal.Collection<object>): boolean
        contains(arg0: object): boolean
        iterator(): Internal.Iterator<E>
        size(): number
        addAll(arg0: Internal.Collection<E>): boolean
        stream(): Internal.Stream<E>
        hashCode(): number
        equals(arg0: object): boolean
        toArray<T>(arg0: T[]): T[]
        toArray<T>(arg0: Internal.IntFunction<T[]>): T[]
        toArray(): object[]
        parallelStream(): Internal.Stream<E>
        retainAll(arg0: Internal.Collection<object>): boolean
    }
    interface WrappedJS {
    }
    class Transformation implements Internal.IForgeTransformation {
        getNormalMatrix(): Internal.Matrix3f
        applyOrigin(arg0: Internal.Vector3f): Internal.Transformation
        blockCornerToCenter(): Internal.Transformation
        hashCode(): number
        equals(arg0: object): boolean
        rotateTransform(arg0: Internal.Direction): Internal.Direction
        isIdentity(): boolean
        transformPosition(arg0: Internal.Vector4f): void
        transformNormal(arg0: Internal.Vector3f): void
        push(arg0: Internal.PoseStack): void
        blockCenterToCorner(): Internal.Transformation
        get normalMatrix(): Internal.Matrix3f;
    }
    interface IntFunction <R> {
        apply(arg0: number): R
    }
    interface Chronology implements Internal.Comparable<Internal.Chronology> {
        localDateTime(arg0: Internal.TemporalAccessor): Internal.ChronoLocalDateTime<Internal.ChronoLocalDate>
        date(arg0: Internal.TemporalAccessor): Internal.ChronoLocalDate
        date(arg0: Internal.Era, arg1: number, arg2: number, arg3: number): Internal.ChronoLocalDate
        date(arg0: number, arg1: number, arg2: number): Internal.ChronoLocalDate
        period(arg0: number, arg1: number, arg2: number): Internal.ChronoPeriod
        dateYearDay(arg0: Internal.Era, arg1: number, arg2: number): Internal.ChronoLocalDate
        dateYearDay(arg0: number, arg1: number): Internal.ChronoLocalDate
        getCalendarType(): string
        resolveDate(arg0: Map<Internal.TemporalField, number>, arg1: Internal.ResolverStyle): Internal.ChronoLocalDate
        static ofLocale(arg0: Internal.Locale): Internal.Chronology
        isLeapYear(arg0: number): boolean
        range(arg0: Internal.ChronoField): Internal.ValueRange
        dateEpochDay(arg0: number): Internal.ChronoLocalDate
        getId(): string
        static getAvailableChronologies(): Internal.Set<Internal.Chronology>
        compareTo(arg0: Internal.Chronology): number
        compareTo(arg0: object): number
        dateNow(): Internal.ChronoLocalDate
        dateNow(arg0: Internal.ZoneId): Internal.ChronoLocalDate
        dateNow(arg0: Internal.Clock): Internal.ChronoLocalDate
        eraOf(arg0: number): Internal.Era
        eras(): Internal.List<Internal.Era>
        prolepticYear(arg0: Internal.Era, arg1: number): number
        zonedDateTime(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.ChronoZonedDateTime<Internal.ChronoLocalDate>
        zonedDateTime(arg0: Internal.TemporalAccessor): Internal.ChronoZonedDateTime<Internal.ChronoLocalDate>
        getDisplayName(arg0: Internal.TextStyle, arg1: Internal.Locale): string
        hashCode(): number
        static of(arg0: string): Internal.Chronology
        equals(arg0: object): boolean
        epochSecond(arg0: Internal.Era, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneOffset): number
        epochSecond(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.ZoneOffset): number
        static from(arg0: Internal.TemporalAccessor): Internal.Chronology
        toString(): string
        get calendarType(): string;
        get id(): string;
        get availableChronologies(): Internal.Set<Internal.Chronology>;
    }
    interface FormattedCharSequence {
    }
    class Dynamic <T> extends Internal.DynamicLike<T> {
        updateGeneric(arg0: T, arg1: (arg0: T) => T): Internal.Dynamic<T>
        getElementGeneric(arg0: T): Internal.DataResult<T>
        updateMapValues(arg0: (arg0: com.mojang.datafixers.util.Pair<Internal.Dynamic<object>, Internal.Dynamic<object>>) => com.mojang.datafixers.util.Pair<Internal.Dynamic<object>, Internal.Dynamic<object>>): Internal.Dynamic<T>
        asLongStreamOpt(): Internal.DataResult<Internal.LongStream>
        asStreamOpt(): Internal.DataResult<Internal.Stream<Internal.Dynamic<T>>>
        update(arg0: string, arg1: (arg0: Internal.Dynamic<object>) => Internal.Dynamic<object>): Internal.Dynamic<T>
        static convert<S, T>(arg0: Internal.DynamicOps<S>, arg1: Internal.DynamicOps<T>, arg2: S): T
        convert<R>(arg0: Internal.DynamicOps<R>): Internal.Dynamic<R>
        decode<A>(arg0: Internal.Decoder<A>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
        asIntStreamOpt(): Internal.DataResult<Internal.IntStream>
        remove(arg0: string): Internal.Dynamic<T>
        getMapValues(): Internal.DataResult<Map<Internal.Dynamic<T>, Internal.Dynamic<T>>>
        into<V>(arg0: (arg0: Internal.Dynamic<T>) => V): V
        cast<U>(arg0: Internal.DynamicOps<U>): U
        hashCode(): number
        merge(arg0: Internal.Dynamic<object>): Internal.OptionalDynamic<T>
        merge(arg0: Internal.Dynamic<object>, arg1: Internal.Dynamic<object>): Internal.OptionalDynamic<T>
        get(arg0: string): Internal.OptionalDynamic<T>
        asString(): Internal.DataResult<string>
        map(arg0: (arg0: T) => T): Internal.Dynamic<T>
        asByteBufferOpt(): Internal.DataResult<Internal.ByteBuffer>
        set(arg0: string, arg1: Internal.Dynamic<object>): Internal.Dynamic<T>
        asNumber(): Internal.DataResult<Internal.Number>
        asMapOpt(): Internal.DataResult<Internal.Stream<com.mojang.datafixers.util.Pair<Internal.Dynamic<T>, Internal.Dynamic<T>>>>
        getGeneric(arg0: T): Internal.DataResult<T>
        castTyped<U>(arg0: Internal.DynamicOps<U>): Internal.Dynamic<U>
        getValue(): T
        getElement(arg0: string): Internal.DataResult<T>
        equals(arg0: object): boolean
        toString(): string
        get mapValues(): Internal.DataResult<Map<Internal.Dynamic<T>, Internal.Dynamic<T>>>;
        get value(): T;
    }
    interface Long2DoubleFunction implements Internal.Function<number, number>, Internal.LongToDoubleFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: Internal.Double2ShortFunction): Internal.Long2ShortFunction
        composeByte(arg0: Internal.Byte2LongFunction): Internal.Byte2DoubleFunction
        andThenInt(arg0: Internal.Double2IntFunction): Internal.Long2IntFunction
        composeReference<T>(arg0: Internal.Reference2LongFunction<T>): Internal.Reference2DoubleFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Double2DoubleFunction): Internal.Long2DoubleFunction
        andThenObject<T>(arg0: Internal.Double2ObjectFunction<T>): Internal.Long2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Double2LongFunction): Internal.Long2LongFunction
        composeLong(arg0: Internal.Long2LongFunction): Internal.Long2DoubleFunction
        andThenByte(arg0: Internal.Double2ByteFunction): Internal.Long2ByteFunction
        andThenFloat(arg0: Internal.Double2FloatFunction): Internal.Long2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2LongFunction): Internal.Int2DoubleFunction
        clear(): void
        composeFloat(arg0: Internal.Float2LongFunction): Internal.Float2DoubleFunction
        andThenChar(arg0: Internal.Double2CharFunction): Internal.Long2CharFunction
        composeObject<T>(arg0: Internal.Object2LongFunction<T>): Internal.Object2DoubleFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2LongFunction): Internal.Short2DoubleFunction
        andThenReference<T>(arg0: Internal.Double2ReferenceFunction<T>): Internal.Long2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2LongFunction): Internal.Char2DoubleFunction
        composeDouble(arg0: Internal.Double2LongFunction): Internal.Double2DoubleFunction
    }
    interface Byte2CharFunction implements Internal.Function<number, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: string): string
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: string): string
        andThenShort(arg0: Internal.Char2ShortFunction): Internal.Byte2ShortFunction
        composeByte(arg0: Internal.Byte2ByteFunction): Internal.Byte2CharFunction
        andThenInt(arg0: Internal.Char2IntFunction): Internal.Byte2IntFunction
        composeReference<T>(arg0: Internal.Reference2ByteFunction<T>): Internal.Reference2CharFunction<T>
        andThen<T>(arg0: (arg0: string) => T): (arg0: number) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: string): string
        put(arg0: number, arg1: string): string
        remove(arg0: number): string
        remove(arg0: object): object
        remove(arg0: object): string
        defaultReturnValue(): string
        defaultReturnValue(arg0: string): void
        andThenDouble(arg0: Internal.Char2DoubleFunction): Internal.Byte2DoubleFunction
        andThenObject<T>(arg0: Internal.Char2ObjectFunction<T>): Internal.Byte2ObjectFunction<T>
        get(arg0: object): string
        get(arg0: object): object
        get(arg0: number): string
        andThenLong(arg0: Internal.Char2LongFunction): Internal.Byte2LongFunction
        composeLong(arg0: Internal.Long2ByteFunction): Internal.Long2CharFunction
        andThenByte(arg0: Internal.Char2ByteFunction): Internal.Byte2ByteFunction
        andThenFloat(arg0: Internal.Char2FloatFunction): Internal.Byte2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ByteFunction): Internal.Int2CharFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ByteFunction): Internal.Float2CharFunction
        andThenChar(arg0: Internal.Char2CharFunction): Internal.Byte2CharFunction
        composeObject<T>(arg0: Internal.Object2ByteFunction<T>): Internal.Object2CharFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => string
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2ByteFunction): Internal.Short2CharFunction
        andThenReference<T>(arg0: Internal.Char2ReferenceFunction<T>): Internal.Byte2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ByteFunction): Internal.Char2CharFunction
        composeDouble(arg0: Internal.Double2ByteFunction): Internal.Double2CharFunction
    }
    class ModelRegistryEvent extends Internal.Event implements Internal.IModBusEvent {
        getListenerList(): Internal.ListenerList
        get listenerList(): Internal.ListenerList;
    }
    class Number implements Internal.Serializable {
        intValue(): number
        floatValue(): number
        shortValue(): number
        doubleValue(): number
        longValue(): number
        byteValue(): number
    }
    class ReentrantBlockableEventLoop <R> extends Internal.BlockableEventLoop<R> {
    }
    interface ObjectSpliterator <K> implements Internal.Spliterator<K> {
        trySplit(): Internal.Spliterator<any>
        trySplit(): Internal.ObjectSpliterator<K>
        tryAdvance(arg0: (arg0: T) => void): boolean
        characteristics(): number
        getComparator(): Internal.Comparator<T>
        getExactSizeIfKnown(): number
        estimateSize(): number
        skip(arg0: number): number
        hasCharacteristics(arg0: number): boolean
        forEachRemaining(arg0: (arg0: T) => void): void
        static readonly NONNULL : 256;
        static readonly SUBSIZED : 16384;
        static readonly ORDERED : 16;
        static readonly DISTINCT : 1;
        static readonly SIZED : 64;
        static readonly IMMUTABLE : 1024;
        static readonly CONCURRENT : 4096;
        static readonly SORTED : 4;
        get comparator(): Internal.Comparator<T>;
        get exactSizeIfKnown(): number;
    }
    interface DoubleToLongFunction {
        applyAsLong(arg0: number): number
    }
    interface FileAttribute <T> {
        name(): string
        value(): T
    }
    class RuleTest {
    }
    class PathfinderMob extends Internal.Mob {
        backpackedMoved : boolean;
    }
    class EnderMan extends Internal.Monster implements Internal.NeutralMob {
        backpackedMoved : boolean;
    }
    class Locale$FilteringMode extends Internal.Enum<Internal.Locale$FilteringMode> {
        static valueOf(arg0: string): Internal.Locale$FilteringMode
        static values(): Internal.Locale$FilteringMode[]
        static readonly IGNORE_EXTENDED_RANGES : Internal.Locale$FilteringMode;
        static readonly MAP_EXTENDED_RANGES : Internal.Locale$FilteringMode;
        static readonly AUTOSELECT_FILTERING : Internal.Locale$FilteringMode;
        static readonly REJECT_EXTENDED_RANGES : Internal.Locale$FilteringMode;
        static readonly EXTENDED_FILTERING : Internal.Locale$FilteringMode;
    }
    class Int2IntOpenHashMap extends Internal.AbstractInt2IntMap implements Internal.Serializable, Internal.Cloneable, Internal.Hash {
        getOrDefault(arg0: number, arg1: number): number
        computeIfAbsentNullable(arg0: number, arg1: Internal.IntFunction<number>): number
        containsKey(arg0: number): boolean
        computeIfAbsent(arg0: number, arg1: Internal.IntUnaryOperator): number
        computeIfAbsent(arg0: number, arg1: Internal.Int2IntFunction): number
        values(): Internal.Collection<any>
        values(): Internal.IntCollection
        replace(arg0: number, arg1: number, arg2: number): boolean
        replace(arg0: number, arg1: number): number
        isEmpty(): boolean
        clear(): void
        containsValue(arg0: number): boolean
        put(arg0: number, arg1: number): number
        remove(arg0: number, arg1: number): boolean
        remove(arg0: number): number
        int2IntEntrySet(): Internal.Int2IntMap$FastEntrySet
        int2IntEntrySet(): Internal.ObjectSet<any>
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number
        trim(): boolean
        trim(arg0: number): boolean
        size(): number
        hashCode(): number
        putAll(arg0: Map<number, number>): void
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number
        get(arg0: number): number
        clone(): Internal.Int2IntOpenHashMap
        clone(): object
        addTo(arg0: number, arg1: number): number
        keySet(): Internal.Set<any>
        keySet(): Internal.IntSet
        putIfAbsent(arg0: number, arg1: number): number
        static readonly DEFAULT_GROWTH_FACTOR : 16;
        static readonly FAST_LOAD_FACTOR : 0.5;
        static readonly DEFAULT_INITIAL_SIZE : 16;
        static readonly DEFAULT_LOAD_FACTOR : 0.75;
        static readonly OCCUPIED : -1;
        static readonly VERY_FAST_LOAD_FACTOR : 0.25;
        static readonly FREE : 0;
        static readonly PRIMES : number[];
        static readonly REMOVED : 1;
    }
    interface CommandSource {
    }
    interface TypeDescriptor$OfField <F> implements Internal.TypeDescriptor {
        componentType(): F
        arrayType(): F
        descriptorString(): string
        isArray(): boolean
        isPrimitive(): boolean
    }
    interface Long2ShortFunction implements Internal.Function<number, number>, Internal.LongToIntFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Short2ShortFunction): Internal.Long2ShortFunction
        composeByte(arg0: Internal.Byte2LongFunction): Internal.Byte2ShortFunction
        andThenInt(arg0: Internal.Short2IntFunction): Internal.Long2IntFunction
        composeReference<T>(arg0: Internal.Reference2LongFunction<T>): Internal.Reference2ShortFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Short2DoubleFunction): Internal.Long2DoubleFunction
        andThenObject<T>(arg0: Internal.Short2ObjectFunction<T>): Internal.Long2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Short2LongFunction): Internal.Long2LongFunction
        composeLong(arg0: Internal.Long2LongFunction): Internal.Long2ShortFunction
        andThenByte(arg0: Internal.Short2ByteFunction): Internal.Long2ByteFunction
        andThenFloat(arg0: Internal.Short2FloatFunction): Internal.Long2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2LongFunction): Internal.Int2ShortFunction
        clear(): void
        composeFloat(arg0: Internal.Float2LongFunction): Internal.Float2ShortFunction
        andThenChar(arg0: Internal.Short2CharFunction): Internal.Long2CharFunction
        composeObject<T>(arg0: Internal.Object2LongFunction<T>): Internal.Object2ShortFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2LongFunction): Internal.Short2ShortFunction
        andThenReference<T>(arg0: Internal.Short2ReferenceFunction<T>): Internal.Long2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2LongFunction): Internal.Char2ShortFunction
        composeDouble(arg0: Internal.Double2LongFunction): Internal.Double2ShortFunction
    }
    class LootActionsBuilderJS implements Internal.ConditionsContainer<Internal.LootActionsBuilderJS> {
        killerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B
        survivesExplosion(): B
        thenRemove(arg0: Internal.IngredientJS): Internal.LootActionsBuilderJS
        thenAdd(arg0: Internal.ItemStackJS[]): Internal.LootActionsBuilderJS
        addCondition(arg0: Internal.LootItemCondition): Internal.ConditionsContainer<any>
        addCondition(arg0: Internal.LootItemCondition): Internal.LootActionsBuilderJS
        addCondition(arg0: Internal.LootItemCondition$Builder): B
        customDistanceToPlayer(arg0: (arg0: Internal.DistancePredicateBuilder) => void): B
        matchFluid(arg0: string): B
        getLogName(arg0: string): string
        not(arg0: (arg0: Internal.NotConditionBuilder) => void): B
        directKillerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B
        thenAddWeighted(arg0: Internal.MinMaxBounds$Ints, arg1: boolean, arg2: Internal.ItemStackJS[]): Internal.LootActionsBuilderJS
        thenAddWeighted(arg0: Internal.MinMaxBounds$Ints, arg1: Internal.ItemStackJS[]): Internal.LootActionsBuilderJS
        thenAddWeighted(arg0: Internal.ItemStackJS[]): Internal.LootActionsBuilderJS
        matchEquip(arg0: EquipmentSlot, arg1: Internal.IngredientJS): B
        and(arg0: (arg0: Internal.AndConditionBuilder) => void): B
        thenRollPool(arg0: Internal.MinMaxBounds$Ints, arg1: (arg0: Internal.LootActionsBuilderJS) => void): Internal.LootActionsBuilderJS
        thenRollPool(arg0: (arg0: Internal.LootActionsBuilderJS) => void): Internal.LootActionsBuilderJS
        matchLoot(arg0: Internal.IngredientJS): B
        matchLoot(arg0: Internal.IngredientJS, arg1: boolean): B
        anyBiome(arg0: string[]): B
        distanceToKiller(arg0: Internal.MinMaxBounds$Doubles): B
        entityPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B
        matchEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        thenApply(arg0: (arg0: Internal.LootContextJS) => void): Internal.LootActionsBuilderJS
        anyDimension(arg0: ResourceLocation[]): B
        killedByPlayer(): B
        or(arg0: (arg0: Internal.OrConditionBuilder) => void): B
        timeCheck(arg0: number, arg1: number, arg2: number): B
        timeCheck(arg0: number, arg1: number): B
        matchOffHand(arg0: Internal.IngredientJS): B
        randomChance(arg0: number): B
        playerPredicate(arg0: (arg0: Internal.PlayerJS<object>) => boolean): B
        weatherCheck(arg0: Map<string, boolean>): B
        matchDirectKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        thenExplode(arg0: number, arg1: boolean, arg2: boolean): Internal.LootActionsBuilderJS
        matchBlockState(arg0: Internal.Block, arg1: Map<string, string>): B
        matchMainHand(arg0: Internal.IngredientJS): B
        matchPlayer(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        lightLevel(arg0: number, arg1: number): B
        logName(arg0: string): Internal.LootActionsBuilderJS
        biome(arg0: string[]): B
        customCondition(arg0: Internal.JsonObject): B
        matchKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        randomChanceWithLooting(arg0: number, arg1: number): B
        thenLightningStrike(arg0: boolean): Internal.LootActionsBuilderJS
        hasAnyStage(arg0: string[]): B
        thenReplace(arg0: Internal.IngredientJS, arg1: Internal.ItemStackJS): Internal.LootActionsBuilderJS
        randomChanceWithEnchantment(arg0: Internal.Enchantment, arg1: number[]): B
        anyStructure(arg0: ResourceLocation[], arg1: boolean): B
        matchDamageSource(arg0: (arg0: Internal.DamageSourcePredicateBuilderJS) => void): B
        thenModify(arg0: Internal.IngredientJS, arg1: (arg0: Internal.ItemStackJS) => Internal.ItemStackJS): Internal.LootActionsBuilderJS
    }
    class LevelEventJS extends Internal.EventJS {
        getServer(): Internal.ServerJS
        getLevel(): Internal.LevelJS
        post(id: string, sub: string): boolean
        post(id: string): boolean
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
    }
    class ServerLevel extends Internal.Level implements Internal.WorldGenLevel, Internal.WorldEntityByChunkAccess, me.jellysquid.mods.lithium.mixin.ai.nearby_entity_tracking.ServerWorldAccessor, Internal.ServerWorldAccessor, Internal.ServerWorldExtended, Internal.ExtendedWorld {
        setNavigationActive(mobEntity: Internal.Mob): void
        getChunkAtImmediately(arg0: number, arg1: number): Internal.LevelChunk
        getAnyChunkImmediately(arg0: number, arg1: number): Internal.ChunkAccess
        toString(): string
        removeEntityComplete(arg0: Internal.Entity, arg1: boolean): void
        getEntityManager(): Internal.PersistentEntitySectionManager<any>
        removeEntity(arg0: Internal.Entity): void
        removeEntity(arg0: Internal.Entity, arg1: boolean): void
        close(): void
        getEntitiesInChunk(chunkX: number, chunkZ: number): Internal.Collection<any>
        removePlayer(arg0: Internal.ServerPlayer, arg1: boolean): void
        setNavigationInactive(mobEntity: Internal.Mob): void
        isConsistent(): boolean
        handler$zdh000$wireBlockCallback(arg0: BlockPos, arg1: Internal.BlockState, arg2: Internal.BlockState, arg3: number, arg4: Internal.CallbackInfo): void
        restoringBlockSnapshots : boolean;
        capturedBlockSnapshots : Internal.ArrayList<Internal.BlockSnapshot>;
        captureBlockSnapshots : boolean;
        set navigationActive(mobEntity: Internal.Mob);
        get entityManager(): Internal.PersistentEntitySectionManager<any>;
        set navigationInactive(mobEntity: Internal.Mob);
    }
    interface PrimitiveIterator$OfLong implements Internal.PrimitiveIterator<number, Internal.LongConsumer> {
        next(): object
        next(): number
        hasNext(): boolean
        forEachRemaining(arg0: object): void
        forEachRemaining(arg0: Internal.LongConsumer): void
        forEachRemaining(arg0: (arg0: number) => void): void
        nextLong(): number
        remove(): void
    }
    class ItemStack extends Internal.CapabilityProvider<Internal.ItemStack> implements Internal.IForgeItemStack, Internal.ItemStackKJS, Internal.StorableItemStack {
        canElytraFly(arg0: Internal.LivingEntity): boolean
        canEquip(arg0: EquipmentSlot, arg1: Internal.Entity): boolean
        canPerformAction(arg0: Internal.ToolAction): boolean
        onBlockStartBreak(arg0: BlockPos, arg1: Internal.Player): boolean
        onHorseArmorTick(arg0: Internal.Level, arg1: Internal.Mob): void
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack): boolean
        getItemEnchantability(): number
        serializeNBT(): Internal.CompoundTag
        serializeNBT(): net.minecraft.nbt.Tag
        getEntityLifespan(arg0: Internal.Level): number
        getXpRepairRatio(): number
        getHighlightTip(arg0: Internal.Component): Internal.Component
        readShareTag(arg0: Internal.CompoundTag): void
        removeTagKJS(): void
        onEntityItemUpdate(arg0: Internal.ItemEntity): boolean
        onArmorTick(arg0: Internal.Level, arg1: Internal.Player): void
        unregisterFromInventory(myInventoryList: Internal.LithiumStackList): void
        registerToInventory(itemStacks: Internal.LithiumStackList, mySlot: number): void
        isBookEnchantable(arg0: Internal.ItemStack): boolean
        hasContainerItem(): boolean
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: Internal.LivingEntity): boolean
        doesSneakBypassUse(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Player): boolean
        onItemUseFirst(arg0: Internal.UseOnContext): Internal.InteractionResult
        getContainerItem(): Internal.ItemStack
        deserializeNBT(arg0: Internal.CompoundTag): void
        deserializeNBT(arg0: net.minecraft.nbt.Tag): void
        localvar$zkj000$updateInventory(count: number): number
        onUsingTick(arg0: Internal.LivingEntity, arg1: number): void
        isPiglinCurrency(): boolean
        asKJS(): object
        getSweepHitBox(arg0: Internal.Player, arg1: Internal.Entity): Internal.AABB
        isRepairable(): boolean
        getEquipmentSlot(): EquipmentSlot
        getShareTag(): Internal.CompoundTag
        getBurnTime(arg0: Internal.RecipeType<object>): number
        onDroppedByPlayer(arg0: Internal.Player): boolean
        onEntitySwing(arg0: Internal.LivingEntity): boolean
        equals(arg0: Internal.ItemStack, arg1: boolean): boolean
        elytraFlightTick(arg0: Internal.LivingEntity, arg1: number): boolean
        makesPiglinsNeutral(arg0: Internal.LivingEntity): boolean
        toString(): string
        isEnderMask(arg0: Internal.Player, arg1: Internal.EnderMan): boolean
        areShareTagsEqual(arg0: Internal.ItemStack): boolean
        canApplyAtEnchantingTable(arg0: Internal.Enchantment): boolean
        get itemEnchantability(): number;
        get xpRepairRatio(): number;
        get containerItem(): Internal.ItemStack;
        get equipmentSlot(): EquipmentSlot;
        get shareTag(): Internal.CompoundTag;
    }
    class TagEventJS$TagWrapper <T> {
        add(ids: object): Internal.TagEventJS$TagWrapper<T>
        removeAll(): Internal.TagEventJS$TagWrapper<T>
        toString(): string
        sort(): boolean
        setPriorityList(o: object): void
        remove(ids: object): Internal.TagEventJS$TagWrapper<T>
        set priorityList(o: object);
    }
    class FilterOutputStream extends Internal.OutputStream {
        flush(): void
        close(): void
        write(arg0: number[], arg1: number, arg2: number): void
        write(arg0: number[]): void
        write(arg0: number): void
    }
    class UseOnContext {
    }
    class MinMaxBounds$Ints extends Internal.MinMaxBounds<number> {
    }
    interface LevelTimeAccess implements Internal.LevelReader {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
    }
    class FieldAttributes {
        getDeclaringClass(): Internal.Class<object>
        getName(): string
        hasModifier(arg0: number): boolean
        getAnnotation<T>(arg0: Internal.Class<T>): T
        getDeclaredType(): Internal.Type
        getDeclaredClass(): Internal.Class<object>
        getAnnotations(): Internal.Collection<Internal.Annotation>
        get declaringClass(): Internal.Class<object>;
        get name(): string;
        get declaredType(): Internal.Type;
        get declaredClass(): Internal.Class<object>;
        get annotations(): Internal.Collection<Internal.Annotation>;
    }
    interface Destroyable {
        isDestroyed(): boolean
        destroy(): void
    }
    class StandardLevel extends Internal.Enum<Internal.StandardLevel> {
        static getStandardLevel(intLevel: number): Internal.StandardLevel
        static valueOf(name: string): Internal.StandardLevel
        static values(): Internal.StandardLevel[]
        intLevel(): number
        static readonly TRACE : Internal.StandardLevel;
        static readonly ALL : Internal.StandardLevel;
        static readonly ERROR : Internal.StandardLevel;
        static readonly INFO : Internal.StandardLevel;
        static readonly FATAL : Internal.StandardLevel;
        static readonly DEBUG : Internal.StandardLevel;
        static readonly OFF : Internal.StandardLevel;
        static readonly WARN : Internal.StandardLevel;
    }
    class BlockState extends Internal.BlockBehaviour$BlockStateBase implements Internal.IForgeBlockState {
        rotate(arg0: Internal.LevelAccessor, arg1: BlockPos, arg2: Internal.Rotation): Internal.BlockState
        getStateAtViewpoint(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Vec3): Internal.BlockState
        onBlockExploded(arg0: Internal.Level, arg1: BlockPos, arg2: Internal.Explosion): void
        getBedDirection(arg0: Internal.LevelReader, arg1: BlockPos): Internal.Direction
        getExpDrop(arg0: Internal.LevelReader, arg1: BlockPos, arg2: number, arg3: number): number
        isConduitFrame(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): boolean
        getLightEmission(arg0: Internal.BlockGetter, arg1: BlockPos): number
        onDestroyedByPlayer(arg0: Internal.Level, arg1: BlockPos, arg2: Internal.Player, arg3: boolean, arg4: Internal.FluidState): boolean
        isBed(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.LivingEntity): boolean
        canHarvestBlock(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Player): boolean
        shouldCheckWeakPower(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Direction): boolean
        collisionExtendsVertically(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Entity): boolean
        addLandingEffects(arg0: Internal.ServerLevel, arg1: BlockPos, arg2: Internal.BlockState, arg3: Internal.LivingEntity, arg4: number): boolean
        isLadder(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.LivingEntity): boolean
        shouldDisplayFluidOverlay(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidState): boolean
        getSoundType(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity): Internal.SoundType
        canStickTo(arg0: Internal.BlockState): boolean
        onNeighborChange(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): void
        addRunningEffects(arg0: Internal.Level, arg1: BlockPos, arg2: Internal.Entity): boolean
        getWeakChanges(arg0: Internal.LevelReader, arg1: BlockPos): boolean
        canEntityDestroy(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Entity): boolean
        isBurning(arg0: Internal.BlockGetter, arg1: BlockPos): boolean
        getCloneItemStack(arg0: Internal.HitResult, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Player): Internal.ItemStack
        getFriction(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity): number
        isFlammable(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): boolean
        isValidSpawn(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.SpawnPlacements$Type, arg3: Internal.EntityType<object>): boolean
        isPortalFrame(arg0: Internal.BlockGetter, arg1: BlockPos): boolean
        getBlockPathType(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Mob): Internal.BlockPathTypes
        getBlockPathType(arg0: Internal.BlockGetter, arg1: BlockPos): Internal.BlockPathTypes
        getExplosionResistance(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): number
        isScaffolding(arg0: Internal.LivingEntity): boolean
        canSustainPlant(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction, arg3: Internal.IPlantable): boolean
        onCaughtFire(arg0: Internal.Level, arg1: BlockPos, arg2: Internal.Direction, arg3: Internal.LivingEntity): void
        getEnchantPowerBonus(arg0: Internal.LevelReader, arg1: BlockPos): number
        setBedOccupied(arg0: Internal.Level, arg1: BlockPos, arg2: Internal.LivingEntity, arg3: boolean): void
        isFireSource(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Direction): boolean
        canDropFromExplosion(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): boolean
        getRespawnPosition(arg0: Internal.EntityType<object>, arg1: Internal.LevelReader, arg2: BlockPos, arg3: number, arg4: Internal.LivingEntity): Internal.Optional<Vec3>
        canRedstoneConnectTo(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): boolean
        isStickyBlock(): boolean
        isFertile(arg0: Internal.BlockGetter, arg1: BlockPos): boolean
        isSlimeBlock(): boolean
        getFireSpreadSpeed(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): number
        getFlammability(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): number
        getToolModifiedState(arg0: Internal.Level, arg1: BlockPos, arg2: Internal.Player, arg3: Internal.ItemStack, arg4: Internal.ToolAction): Internal.BlockState
        getBeaconColorMultiplier(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): number[]
    }
    class CraftingContainer implements Internal.Container, Internal.StackedContentsCompatible {
    }
    class PlayerJS <E> extends Internal.LivingEntityJS implements Internal.WithAttachedData {
        getXpLevel(): number
        isPlayer(): boolean
        getStats(): Internal.PlayerStatsJS
        sendData(channel: string, data: Internal.CompoundTag): void
        sendInventoryUpdate(): void
        paint(arg0: Internal.CompoundTag): void
        addXPLevels(l: number): void
        setXpLevel(l: number): void
        closeInventory(): void
        getOpenInventory(): Internal.AbstractContainerMenu
        setAirSupply(air: number): void
        getStages(): Internal.Stages
        setSelectedSlot(index: number): void
        getInventory(): Internal.InventoryJS
        addFood(f: number, m: number): void
        boostElytraFlight(): void
        addXP(xp: number): void
        getData(): Internal.AttachedData
        give(item: Internal.ItemStackJS): void
        setStatusMessage(message: Internal.Component): void
        giveInHand(item: Internal.ItemStackJS): void
        getAirSupply(): number
        getProfile(): Internal.GameProfile
        isCreativeMode(): boolean
        isMiningBlock(): boolean
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void
        getSelectedSlot(): number
        isSpectator(): boolean
        spawn(): void
        getXp(): number
        addItemCooldown(item: Internal.Item, ticks: number): void
        addExhaustion(exhaustion: number): void
        setMouseItem(item: Internal.ItemStackJS): void
        getMouseItem(): Internal.ItemStackJS
        setFoodLevel(foodLevel: number): void
        toString(): string
        getFoodLevel(): number
        isFake(): boolean
        setXp(xp: number): void
        getMaxAirSupply(): number
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftPlayer : E;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        get xpLevel(): number;
        get stats(): Internal.PlayerStatsJS;
        set xpLevel(l: number);
        get openInventory(): Internal.AbstractContainerMenu;
        set airSupply(air: number);
        get stages(): Internal.Stages;
        set selectedSlot(index: number);
        get inventory(): Internal.InventoryJS;
        get data(): Internal.AttachedData;
        set statusMessage(message: Internal.Component);
        get airSupply(): number;
        get profile(): Internal.GameProfile;
        get selectedSlot(): number;
        get xp(): number;
        set mouseItem(item: Internal.ItemStackJS);
        get mouseItem(): Internal.ItemStackJS;
        set foodLevel(foodLevel: number);
        get foodLevel(): number;
        set xp(xp: number);
        get maxAirSupply(): number;
    }
    interface RemovableBlockEntity {
        increaseRemoveCounter(): void
        getRemovedCountLithium(): number
        get removedCountLithium(): number;
    }
    interface MutableComponent implements Internal.Component {
        getString(): string
        get string(): string;
    }
    class RecordComponent implements Internal.AnnotatedElement {
        getGenericSignature(): string
        getName(): string
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        getAnnotations(): Internal.Annotation[]
        getDeclaredAnnotations(): Internal.Annotation[]
        getDeclaringRecord(): Internal.Class<object>
        getAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getDeclaredAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getType(): Internal.Class<object>
        getAnnotation<T>(arg0: Internal.Class<T>): T
        getAccessor(): Internal.Method
        getDeclaredAnnotation<T>(arg0: Internal.Class<T>): T
        toString(): string
        getGenericType(): Internal.Type
        getAnnotatedType(): Internal.AnnotatedType
        get genericSignature(): string;
        get name(): string;
        get annotations(): Internal.Annotation[];
        get declaredAnnotations(): Internal.Annotation[];
        get declaringRecord(): Internal.Class<object>;
        get type(): Internal.Class<object>;
        get accessor(): Internal.Method;
        get genericType(): Internal.Type;
        get annotatedType(): Internal.AnnotatedType;
    }
    class VoxelShape implements Internal.OffsetVoxelShapeCache {
        getOffsetSimplifiedShape(offset: number, direction: Internal.Direction): Internal.VoxelShape
        toString(): string
        setShape(offset: number, direction: Internal.Direction, offsetShape: Internal.VoxelShape): void
    }
    class DataResult$Mu implements Internal.K1 {
    }
    class ImmutableSet <E> extends Internal.ImmutableCollection<E> implements Internal.Set<E> {
        static builderWithExpectedSize<E>(arg0: number): Internal.ImmutableSet$Builder<E>
        iterator(): Internal.Iterator<any>
        iterator(): Internal.UnmodifiableIterator<E>
        hashCode(): number
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E): Internal.ImmutableSet<E>
        static of<E>(arg0: E, arg1: E, arg2: E): Internal.ImmutableSet<E>
        static of<E>(): Internal.ImmutableSet<E>
        static of<E>(arg0: E): Internal.ImmutableSet<E>
        static of<E>(arg0: E, arg1: E): Internal.ImmutableSet<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E[]): Internal.ImmutableSet<E>
        static of<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): Internal.ImmutableSet<E>
        equals(arg0: object): boolean
        static builder<E>(): Internal.ImmutableSet$Builder<E>
        static copyOf<E>(arg0: E[]): Internal.ImmutableSet<E>
        static copyOf<E>(arg0: Internal.Iterable<E>): Internal.ImmutableSet<E>
        static copyOf<E>(arg0: Internal.Collection<E>): Internal.ImmutableSet<E>
        static copyOf<E>(arg0: Internal.Iterator<E>): Internal.ImmutableSet<E>
        static toImmutableSet<E>(): Internal.Collector<E, object, Internal.ImmutableSet<E>>
    }
    class Thread implements Internal.Runnable {
        setName(arg0: string): void
        getThreadGroup(): Internal.ThreadGroup
        getName(): string
        static getAllStackTraces(): Map<Internal.Thread, Internal.StackTraceElement[]>
        static onSpinWait(): void
        getId(): number
        run(): void
        setContextClassLoader(arg0: Internal.ClassLoader): void
        static sleep(arg0: number): void
        static sleep(arg0: number, arg1: number): void
        getStackTrace(): Internal.StackTraceElement[]
        isDaemon(): boolean
        static yield(): void
        interrupt(): void
        static enumerate(arg0: Internal.Thread[]): number
        join(): void
        join(arg0: number, arg1: number): void
        join(arg0: number): void
        suspend(): void
        static activeCount(): number
        resume(): void
        static currentThread(): Internal.Thread
        setUncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler): void
        isInterrupted(): boolean
        static dumpStack(): void
        static setDefaultUncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler): void
        start(): void
        static interrupted(): boolean
        getUncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler
        checkAccess(): void
        static getDefaultUncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler
        isAlive(): boolean
        setDaemon(arg0: boolean): void
        static holdsLock(arg0: object): boolean
        getState(): Internal.Thread$State
        stop(): void
        getContextClassLoader(): Internal.ClassLoader
        getPriority(): number
        countStackFrames(): number
        toString(): string
        setPriority(arg0: number): void
        static readonly MIN_PRIORITY : 1;
        static readonly MAX_PRIORITY : 10;
        static readonly NORM_PRIORITY : 5;
        set name(arg0: string);
        get threadGroup(): Internal.ThreadGroup;
        get name(): string;
        get allStackTraces(): Map<Internal.Thread, Internal.StackTraceElement[]>;
        get id(): number;
        set contextClassLoader(arg0: Internal.ClassLoader);
        get stackTrace(): Internal.StackTraceElement[];
        set uncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler);
        set defaultUncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler);
        get uncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler;
        get defaultUncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler;
        set daemon(arg0: boolean);
        get state(): Internal.Thread$State;
        get contextClassLoader(): Internal.ClassLoader;
        get priority(): number;
        set priority(arg0: number);
    }
    class ItemTransforms$TransformType extends Internal.Enum<Internal.ItemTransforms$TransformType> {
        static valueOf(arg0: string): Internal.ItemTransforms$TransformType
        static values(): Internal.ItemTransforms$TransformType[]
        static readonly HEAD : Internal.ItemTransforms$TransformType;
        static readonly THIRD_PERSON_LEFT_HAND : Internal.ItemTransforms$TransformType;
        static readonly THIRD_PERSON_RIGHT_HAND : Internal.ItemTransforms$TransformType;
        static readonly FIRST_PERSON_RIGHT_HAND : Internal.ItemTransforms$TransformType;
        static readonly GROUND : Internal.ItemTransforms$TransformType;
        static readonly FIRST_PERSON_LEFT_HAND : Internal.ItemTransforms$TransformType;
        static readonly FIXED : Internal.ItemTransforms$TransformType;
        static readonly GUI : Internal.ItemTransforms$TransformType;
        static readonly NONE : Internal.ItemTransforms$TransformType;
    }
    interface ChannelProgressivePromise implements Internal.ProgressivePromise<void>, Internal.ChannelProgressiveFuture, Internal.ChannelPromise {
        cancel(arg0: boolean): boolean
        unvoid(): Internal.ChannelProgressivePromise
        unvoid(): Internal.ChannelPromise
        channel(): Internal.Channel
        setProgress(arg0: number, arg1: number): Internal.ChannelProgressivePromise
        setProgress(arg0: number, arg1: number): Internal.ProgressivePromise<V>
        cause(): Internal.Throwable
        awaitUninterruptibly(): Internal.ChannelProgressivePromise
        awaitUninterruptibly(): Internal.ProgressivePromise<V>
        awaitUninterruptibly(): Internal.Promise<V>
        awaitUninterruptibly(): io.netty.util.concurrent.Future<V>
        awaitUninterruptibly(): Internal.ProgressiveFuture<V>
        awaitUninterruptibly(): Internal.ChannelProgressiveFuture
        awaitUninterruptibly(): Internal.ChannelFuture
        awaitUninterruptibly(): Internal.ChannelPromise
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        trySuccess(arg0: V): boolean
        trySuccess(): boolean
        tryProgress(arg0: number, arg1: number): boolean
        syncUninterruptibly(): Internal.ChannelProgressivePromise
        syncUninterruptibly(): Internal.ProgressivePromise<V>
        syncUninterruptibly(): Internal.Promise<V>
        syncUninterruptibly(): io.netty.util.concurrent.Future<V>
        syncUninterruptibly(): Internal.ProgressiveFuture<V>
        syncUninterruptibly(): Internal.ChannelProgressiveFuture
        syncUninterruptibly(): Internal.ChannelFuture
        syncUninterruptibly(): Internal.ChannelPromise
        get(arg0: number, arg1: Internal.TimeUnit): V
        get(): V
        await(): Internal.ChannelProgressivePromise
        await(): Internal.ProgressivePromise<V>
        await(): Internal.Promise<V>
        await(): io.netty.util.concurrent.Future<V>
        await(): Internal.ProgressiveFuture<V>
        await(): Internal.ChannelProgressiveFuture
        await(): Internal.ChannelFuture
        await(): Internal.ChannelPromise
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        isSuccess(): boolean
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelProgressivePromise
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.ProgressivePromise<V>
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.Promise<V>
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.ProgressiveFuture<V>
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelProgressiveFuture
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelFuture
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelPromise
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelProgressivePromise
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.ProgressivePromise<V>
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.Promise<V>
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.ProgressiveFuture<V>
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelProgressiveFuture
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelFuture
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelPromise
        getNow(): V
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelProgressivePromise
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.ProgressivePromise<V>
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.Promise<V>
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.ProgressiveFuture<V>
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelProgressiveFuture
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelFuture
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>): Internal.ChannelPromise
        tryFailure(arg0: Internal.Throwable): boolean
        isDone(): boolean
        sync(): Internal.ChannelProgressivePromise
        sync(): Internal.ProgressivePromise<V>
        sync(): Internal.Promise<V>
        sync(): io.netty.util.concurrent.Future<V>
        sync(): Internal.ProgressiveFuture<V>
        sync(): Internal.ChannelProgressiveFuture
        sync(): Internal.ChannelFuture
        sync(): Internal.ChannelPromise
        setSuccess(arg0: void): Internal.ChannelProgressivePromise
        setSuccess(arg0: void): Internal.ChannelPromise
        setSuccess(): Internal.ChannelProgressivePromise
        setSuccess(): Internal.ChannelPromise
        setSuccess(arg0: V): Internal.ProgressivePromise<V>
        setSuccess(arg0: V): Internal.Promise<V>
        setFailure(arg0: Internal.Throwable): Internal.ChannelProgressivePromise
        setFailure(arg0: Internal.Throwable): Internal.ProgressivePromise<V>
        setFailure(arg0: Internal.Throwable): Internal.Promise<V>
        setFailure(arg0: Internal.Throwable): Internal.ChannelPromise
        isVoid(): boolean
        isCancellable(): boolean
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelProgressivePromise
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.ProgressivePromise<V>
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.Promise<V>
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.ProgressiveFuture<V>
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelProgressiveFuture
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelFuture
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<void>>[]): Internal.ChannelPromise
        setUncancellable(): boolean
        get now(): V;
        set success(arg0: void);
        set success(arg0: void);
        set success(arg0: V);
        set success(arg0: V);
        set failure(arg0: Internal.Throwable);
        set failure(arg0: Internal.Throwable);
        set failure(arg0: Internal.Throwable);
        set failure(arg0: Internal.Throwable);
    }
    class LogicalSide extends Internal.Enum<Internal.LogicalSide> {
        isServer(): boolean
        static valueOf(arg0: string): Internal.LogicalSide
        static values(): Internal.LogicalSide[]
        isClient(): boolean
        static readonly SERVER : Internal.LogicalSide;
        static readonly CLIENT : Internal.LogicalSide;
    }
    interface IEventHandler {
        onEvent(arg0: Internal.EventJS): void
    }
    interface AccessScreen {
        getRenderables(): Internal.List<Internal.Widget>
        get renderables(): Internal.List<Internal.Widget>;
    }
    interface BlockKJS {
        getBlockStatesKJS(): Internal.List<Internal.BlockState>
        setSoundTypeKJS(arg0: Internal.SoundType): void
        getBlockBuilderKJS(): Internal.BlockBuilder
        setExplosionResistanceKJS(arg0: number): void
        setSpeedFactorKJS(arg0: number): void
        setJumpFactorKJS(arg0: number): void
        setBlockBuilderKJS(arg0: Internal.BlockBuilder): void
        setFrictionKJS(arg0: number): void
        setIsRandomlyTickingKJS(arg0: boolean): void
        setHasCollisionKJS(arg0: boolean): void
        setMaterialKJS(arg0: net.minecraft.world.level.material.Material): void
        get blockStatesKJS(): Internal.List<Internal.BlockState>;
        set soundTypeKJS(arg0: Internal.SoundType);
        get blockBuilderKJS(): Internal.BlockBuilder;
        set explosionResistanceKJS(arg0: number);
        set speedFactorKJS(arg0: number);
        set jumpFactorKJS(arg0: number);
        set blockBuilderKJS(arg0: Internal.BlockBuilder);
        set frictionKJS(arg0: number);
        set isRandomlyTickingKJS(arg0: boolean);
        set hasCollisionKJS(arg0: boolean);
        set materialKJS(arg0: net.minecraft.world.level.material.Material);
    }
    class ContextFactory {
        enterContext(): Internal.Context
        enterContext(cx: Internal.Context): Internal.Context
        call<T>(action: Internal.ContextAction<T>): T
        isSealed(): boolean
        seal(): void
        static getGlobal(): Internal.ContextFactory
        getApplicationClassLoader(): Internal.ClassLoader
        removeListener(listener: Internal.ContextFactory$Listener): void
        addListener(listener: Internal.ContextFactory$Listener): void
        get global(): Internal.ContextFactory;
        get applicationClassLoader(): Internal.ClassLoader;
    }
    class LootBuilder implements Internal.FunctionContainer, Internal.ConditionContainer {
        damage(damage: Internal.NumberProvider): Internal.FunctionContainer
        nbt(tag: Internal.CompoundTag): Internal.FunctionContainer
        enchantWithLevels(levels: Internal.NumberProvider, treasure: boolean): Internal.FunctionContainer
        clearFunctions(): void
        survivesExplosion(): Internal.ConditionContainer
        killedByPlayer(): Internal.ConditionContainer
        randomChance(chance: number): Internal.ConditionContainer
        addFunction(arg0: Internal.JsonObject): Internal.FunctionContainer
        addFunction(o: Internal.JsonObject): Internal.LootBuilder
        count(count: Internal.NumberProvider): Internal.FunctionContainer
        addConditionalFunction(func: (arg0: Internal.ConditionalFunction) => void): Internal.FunctionContainer
        addCondition(o: Internal.JsonObject): Internal.LootBuilder
        addCondition(arg0: Internal.JsonObject): Internal.ConditionContainer
        lootingEnchant(count: Internal.NumberProvider, limit: number): Internal.FunctionContainer
        lootTable(table: ResourceLocation, seed: number): Internal.FunctionContainer
        toJson(): Internal.JsonObject
        entityScores(entity: Internal.LootContext$EntityTarget, scores: Map<string, object>): Internal.ConditionContainer
        copyName(source: Internal.CopyNameFunction$NameSource): Internal.FunctionContainer
        addPool(p: (arg0: Internal.LootBuilderPool) => void): void
        clearPools(): void
        name(name: Internal.Text, entity: Internal.LootContext$EntityTarget): Internal.FunctionContainer
        name(name: Internal.Text): Internal.FunctionContainer
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer
        furnaceSmelt(): Internal.FunctionContainer
        enchantRandomly(enchantments: ResourceLocation[]): Internal.FunctionContainer
        entityProperties(entity: Internal.LootContext$EntityTarget, properties: Internal.JsonObject): Internal.ConditionContainer
        clearConditions(): void
        functions : Internal.JsonArray;
        pools : Internal.JsonArray;
        type : string;
        conditions : Internal.JsonArray;
        customId : ResourceLocation;
    }
    class ModuleDescriptor$Provides implements Internal.Comparable<Internal.ModuleDescriptor$Provides> {
        service(): string
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        compareTo(arg0: object): number
        compareTo(arg0: Internal.ModuleDescriptor$Provides): number
        providers(): Internal.List<string>
    }
    interface Packet <T> {
    }
    class HumanoidModel <T> extends Internal.AgeableListModel<T> implements Internal.ArmedModel, Internal.HeadedModel {
        handler$bap000$poseLeftArm(arg0: Internal.LivingEntity, arg1: Internal.CallbackInfo): void
        handler$zdj000$rotationAngleCallback(arg0: Internal.LivingEntity, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.CallbackInfo): void
        handler$bap000$poseRightArm(arg0: Internal.LivingEntity, arg1: Internal.CallbackInfo): void
        handler$bap000$setupAnim(arg0: Internal.LivingEntity, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.CallbackInfo): void
        animationType : Internal.TwoHandedAnimation;
    }
    interface Float2LongFunction implements Internal.Function<number, number>, Internal.DoubleToLongFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Long2ShortFunction): Internal.Float2ShortFunction
        composeByte(arg0: Internal.Byte2FloatFunction): Internal.Byte2LongFunction
        andThenInt(arg0: Internal.Long2IntFunction): Internal.Float2IntFunction
        composeReference<T>(arg0: Internal.Reference2FloatFunction<T>): Internal.Reference2LongFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Long2DoubleFunction): Internal.Float2DoubleFunction
        andThenObject<T>(arg0: Internal.Long2ObjectFunction<T>): Internal.Float2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Long2LongFunction): Internal.Float2LongFunction
        composeLong(arg0: Internal.Long2FloatFunction): Internal.Long2LongFunction
        andThenByte(arg0: Internal.Long2ByteFunction): Internal.Float2ByteFunction
        andThenFloat(arg0: Internal.Long2FloatFunction): Internal.Float2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2FloatFunction): Internal.Int2LongFunction
        clear(): void
        composeFloat(arg0: Internal.Float2FloatFunction): Internal.Float2LongFunction
        andThenChar(arg0: Internal.Long2CharFunction): Internal.Float2CharFunction
        applyAsLong(arg0: number): number
        composeObject<T>(arg0: Internal.Object2FloatFunction<T>): Internal.Object2LongFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2FloatFunction): Internal.Short2LongFunction
        andThenReference<T>(arg0: Internal.Long2ReferenceFunction<T>): Internal.Float2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2FloatFunction): Internal.Char2LongFunction
        composeDouble(arg0: Internal.Double2FloatFunction): Internal.Double2LongFunction
    }
    interface Thread$UncaughtExceptionHandler {
        uncaughtException(arg0: Internal.Thread, arg1: Internal.Throwable): void
    }
    class PlayMessages$SpawnEntity {
        static encode(arg0: Internal.PlayMessages$SpawnEntity, arg1: Internal.FriendlyByteBuf): void
        getAdditionalData(): Internal.FriendlyByteBuf
        static handle(arg0: Internal.PlayMessages$SpawnEntity, arg1: () => Internal.NetworkEvent$Context): void
        getEntity(): Internal.Entity
        static decode(arg0: Internal.FriendlyByteBuf): Internal.PlayMessages$SpawnEntity
        getHeadYaw(): number
        getTypeId(): number
        getYaw(): number
        getPitch(): number
        getVelY(): number
        getVelZ(): number
        getUuid(): Internal.UUID
        getVelX(): number
        getPosZ(): number
        getEntityId(): number
        getPosX(): number
        getPosY(): number
        get additionalData(): Internal.FriendlyByteBuf;
        get entity(): Internal.Entity;
        get headYaw(): number;
        get typeId(): number;
        get yaw(): number;
        get pitch(): number;
        get velY(): number;
        get velZ(): number;
        get uuid(): Internal.UUID;
        get velX(): number;
        get posZ(): number;
        get entityId(): number;
        get posX(): number;
        get posY(): number;
    }
    class BlockPathTypes extends Internal.Enum<Internal.BlockPathTypes> {
        static valueOf(arg0: string): Internal.BlockPathTypes
        static values(): Internal.BlockPathTypes[]
        getDanger(): Internal.BlockPathTypes
        static readonly DAMAGE_CACTUS : Internal.BlockPathTypes;
        static readonly LAVA : Internal.BlockPathTypes;
        static readonly LEAVES : Internal.BlockPathTypes;
        static readonly BLOCKED : Internal.BlockPathTypes;
        static readonly WALKABLE : Internal.BlockPathTypes;
        static readonly DANGER_CACTUS : Internal.BlockPathTypes;
        static readonly TRAPDOOR : Internal.BlockPathTypes;
        static readonly BREACH : Internal.BlockPathTypes;
        static readonly POWDER_SNOW : Internal.BlockPathTypes;
        static readonly DOOR_WOOD_CLOSED : Internal.BlockPathTypes;
        static readonly DANGER_FIRE : Internal.BlockPathTypes;
        static readonly DAMAGE_FIRE : Internal.BlockPathTypes;
        static readonly WATER : Internal.BlockPathTypes;
        static readonly WATER_BORDER : Internal.BlockPathTypes;
        static readonly WALKABLE_DOOR : Internal.BlockPathTypes;
        static readonly DOOR_IRON_CLOSED : Internal.BlockPathTypes;
        static readonly FENCE : Internal.BlockPathTypes;
        static readonly OPEN : Internal.BlockPathTypes;
        static readonly RAIL : Internal.BlockPathTypes;
        static readonly DAMAGE_OTHER : Internal.BlockPathTypes;
        static readonly DOOR_OPEN : Internal.BlockPathTypes;
        static readonly UNPASSABLE_RAIL : Internal.BlockPathTypes;
        static readonly COCOA : Internal.BlockPathTypes;
        static readonly DANGER_OTHER : Internal.BlockPathTypes;
        static readonly STICKY_HONEY : Internal.BlockPathTypes;
        get danger(): Internal.BlockPathTypes;
    }
    interface Runnable {
        run(): void
    }
    interface DirectoryStream$Filter <T> {
        accept(arg0: T): boolean
    }
    interface RecvByteBufAllocator {
        newHandle(): Internal.RecvByteBufAllocator$Handle
    }
    class Mob extends Internal.LivingEntity implements Internal.NavigatingEntity, Internal.EquipmentEntity, Internal.EquipmentEntity$EquipmentTrackingEntity {
        updateNavigationRegistration(): void
        getRegisteredNavigation(): Internal.PathNavigation
        isRegisteredToWorld(): boolean
        setRegisteredToWorld(navigation: Internal.PathNavigation): void
        backpackedMoved : boolean;
        get registeredNavigation(): Internal.PathNavigation;
        set registeredToWorld(navigation: Internal.PathNavigation);
    }
    interface ReadableByteChannel implements java_.nio.channels.Channel {
        isOpen(): boolean
        read(arg0: Internal.ByteBuffer): number
        close(): void
    }
    class Format implements Internal.Serializable, Internal.Cloneable {
        formatToCharacterIterator(arg0: object): Internal.AttributedCharacterIterator
        format(arg0: object, arg1: Internal.StringBuffer, arg2: Internal.FieldPosition): Internal.StringBuffer
        format(arg0: object): string
        clone(): object
        parseObject(arg0: string): object
        parseObject(arg0: string, arg1: Internal.ParsePosition): object
    }
    interface ExtendedEntityFlagsPredicate$IBuilder <T> {
        isBaby(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>
        isIllegarMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>
        isSwimming(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>
        isInWater(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>
        isWaterMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>
        isCrouching(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>
        isUnderWater(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>
        isSprinting(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>
        isUndeadMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>
        isCreature(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>
        build(): T
        isMonster(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>
        isOnFire(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>
        isOnGround(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>
        isArthropodMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>
    }
    interface Int2IntMap$FastEntrySet implements Internal.ObjectSet<Internal.Int2IntMap$Entry> {
        add(arg0: E): boolean
        spliterator(): Internal.Spliterator<any>
        spliterator(): Internal.ObjectSpliterator<K>
        forEach(arg0: (arg0: T) => void): void
        containsAll(arg0: Internal.Collection<object>): boolean
        isEmpty(): boolean
        clear(): void
        fastIterator(): Internal.ObjectIterator<Internal.Int2IntMap$Entry>
        remove(arg0: object): boolean
        removeIf(arg0: (arg0: E) => boolean): boolean
        fastForEach(arg0: (arg0: Internal.Int2IntMap$Entry) => void): void
        removeAll(arg0: Internal.Collection<object>): boolean
        contains(arg0: object): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.ObjectIterator<K>
        size(): number
        addAll(arg0: Internal.Collection<E>): boolean
        stream(): Internal.Stream<E>
        hashCode(): number
        equals(arg0: object): boolean
        toArray<T>(arg0: T[]): T[]
        toArray<T>(arg0: Internal.IntFunction<T[]>): T[]
        toArray(): object[]
        parallelStream(): Internal.Stream<E>
        retainAll(arg0: Internal.Collection<object>): boolean
    }
    interface IPlaceableItem {
        addPlaceable(arg0: Internal.Block): void
        getBlockItemOverride(): Internal.BlockItem
        get blockItemOverride(): Internal.BlockItem;
    }
    interface LogBuilder {
        withLocation(): Internal.LogBuilder
        withLocation(location: Internal.StackTraceElement): Internal.LogBuilder
        log(message: string, p0: object, p1: object, p2: object, p3: object): void
        log(message: string, p0: object, p1: object, p2: object, p3: object, p4: object): void
        log(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object): void
        log(message: string, p0: object, p1: object, p2: object): void
        log(message: string, p0: object, p1: object): void
        log(message: string, p0: object): void
        log(): void
        log(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object, p9: object): void
        log(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object): void
        log(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object): void
        log(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object): void
        log(message: string, params: Internal.Supplier<object>[]): void
        log(message: string, params: object[]): void
        log(message: string): void
        log(message: Internal.CharSequence): void
        log(message: object): void
        log(messageSupplier: Internal.Supplier<org.apache.logging.log4j.message.Message>): void
        log(message: org.apache.logging.log4j.message.Message): void
        withMarker(marker: Internal.Marker): Internal.LogBuilder
        withThrowable(throwable: Internal.Throwable): Internal.LogBuilder
        static readonly NOOP : Internal.LogBuilder;
    }
    class Slot {
        getSlotIndex(): number
        isSameInventory(arg0: Internal.Slot): boolean
        setBackground(arg0: ResourceLocation, arg1: ResourceLocation): Internal.Slot
        get slotIndex(): number;
    }
    class ModuleDescriptor implements Internal.Comparable<Internal.ModuleDescriptor> {
        static read(arg0: Internal.InputStream): Internal.ModuleDescriptor
        static read(arg0: Internal.InputStream, arg1: () => Internal.Set<string>): Internal.ModuleDescriptor
        static read(arg0: Internal.ByteBuffer): Internal.ModuleDescriptor
        static read(arg0: Internal.ByteBuffer, arg1: () => Internal.Set<string>): Internal.ModuleDescriptor
        toNameAndVersion(): string
        mainClass(): Internal.Optional<string>
        exports(): Internal.Set<Internal.ModuleDescriptor$Exports>
        rawVersion(): Internal.Optional<string>
        compareTo(arg0: Internal.ModuleDescriptor): number
        compareTo(arg0: object): number
        packages(): Internal.Set<string>
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Modifier>
        version(): Internal.Optional<Internal.ModuleDescriptor$Version>
        static newAutomaticModule(arg0: string): Internal.ModuleDescriptor$Builder
        isOpen(): boolean
        provides(): Internal.Set<Internal.ModuleDescriptor$Provides>
        hashCode(): number
        static newOpenModule(arg0: string): Internal.ModuleDescriptor$Builder
        equals(arg0: object): boolean
        static newModule(arg0: string, arg1: Internal.Set<Internal.ModuleDescriptor$Modifier>): Internal.ModuleDescriptor$Builder
        static newModule(arg0: string): Internal.ModuleDescriptor$Builder
        name(): string
        opens(): Internal.Set<Internal.ModuleDescriptor$Opens>
        uses(): Internal.Set<string>
        toString(): string
        isAutomatic(): boolean
        requires(): Internal.Set<Internal.ModuleDescriptor$Requires>
    }
    class AbstractClientPlayer extends Internal.Player {
        backpackedMoved : boolean;
        backpackedInventory : Internal.BackpackInventory;
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
    }
    class CertPath implements Internal.Serializable {
        getType(): string
        getEncoded(arg0: string): number[]
        getEncoded(): number[]
        hashCode(): number
        equals(arg0: object): boolean
        getEncodings(): Internal.Iterator<string>
        getCertificates(): Internal.List<Internal.Certificate>
        toString(): string
        get type(): string;
        get encoded(): number[];
        get encodings(): Internal.Iterator<string>;
        get certificates(): Internal.List<Internal.Certificate>;
    }
    interface EntityTrackerSection {
        updateMovementTimestamps(arg0: number, arg1: number): void
        getMovementTimestampArray(): number[]
        removeListener(arg0: Internal.EntitySectionStorage<object>, arg1: Internal.SectionedEntityMovementTracker<object, object>): void
        removeListener(arg0: Internal.EntitySectionStorage<object>, arg1: Internal.NearbyEntityListener): void
        addListener(arg0: Internal.NearbyEntityListener): void
        addListener(arg0: Internal.SectionedEntityMovementTracker<object, object>): void
        get movementTimestampArray(): number[];
    }
    interface Reference2ObjectFunction <K, V> implements Internal.Function<K, V> {
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Object2ShortFunction<V>): Internal.Reference2ShortFunction<K>
        composeByte(arg0: Internal.Byte2ReferenceFunction<K>): Internal.Byte2ObjectFunction<V>
        andThenInt(arg0: Internal.Object2IntFunction<V>): Internal.Reference2IntFunction<K>
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: (arg0: T) => K): (arg0: T) => V
        put(arg0: K, arg1: V): V
        remove(arg0: object): V
        defaultReturnValue(): V
        defaultReturnValue(arg0: V): void
        andThenDouble(arg0: Internal.Object2DoubleFunction<V>): Internal.Reference2DoubleFunction<K>
        andThenObject<T>(arg0: (arg0: V) => T): (arg0: K) => T
        get(arg0: object): V
        andThenLong(arg0: Internal.Object2LongFunction<V>): Internal.Reference2LongFunction<K>
        composeLong(arg0: Internal.Long2ReferenceFunction<K>): Internal.Long2ObjectFunction<V>
        andThenByte(arg0: Internal.Object2ByteFunction<V>): Internal.Reference2ByteFunction<K>
        andThenFloat(arg0: Internal.Object2FloatFunction<V>): Internal.Reference2FloatFunction<K>
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ReferenceFunction<K>): Internal.Int2ObjectFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2ReferenceFunction<K>): Internal.Float2ObjectFunction<V>
        andThenChar(arg0: Internal.Object2CharFunction<V>): Internal.Reference2CharFunction<K>
        composeObject<T>(arg0: (arg0: T) => K): (arg0: T) => V
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ReferenceFunction<K>): Internal.Short2ObjectFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): (arg0: K) => T
        composeChar(arg0: Internal.Char2ReferenceFunction<K>): Internal.Char2ObjectFunction<V>
        composeDouble(arg0: Internal.Double2ReferenceFunction<K>): Internal.Double2ObjectFunction<V>
    }
    class ArrayList <E> extends Internal.AbstractList<E> implements Internal.List<E>, Internal.RandomAccess, Internal.Cloneable, Internal.Serializable {
        replaceAll(arg0: Internal.UnaryOperator<E>): void
        remove(arg0: object): boolean
        remove(arg0: number): E
        removeAll(arg0: Internal.Collection<object>): boolean
        iterator(): Internal.Iterator<E>
        hashCode(): number
        get(arg0: number): E
        toArray<T>(arg0: T[]): T[]
        toArray(): object[]
        indexOf(arg0: object): number
        add(arg0: E): boolean
        add(arg0: number, arg1: E): void
        subList(arg0: number, arg1: number): Internal.List<E>
        trimToSize(): void
        set(arg0: number, arg1: E): E
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        isEmpty(): boolean
        clear(): void
        sort(arg0: Internal.Comparator<E>): void
        removeIf(arg0: (arg0: E) => boolean): boolean
        lastIndexOf(arg0: object): number
        contains(arg0: object): boolean
        size(): number
        addAll(arg0: Internal.Collection<E>): boolean
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean
        equals(arg0: object): boolean
        clone(): object
        listIterator(): Internal.ListIterator<E>
        listIterator(arg0: number): Internal.ListIterator<E>
        ensureCapacity(arg0: number): void
        retainAll(arg0: Internal.Collection<object>): boolean
    }
    class VarHandle implements Internal.Constable {
        toMethodHandle(arg0: Internal.VarHandle$AccessMode): Internal.MethodHandle
        coordinateTypes(): Internal.List<Internal.Class<object>>
        weakCompareAndSetPlain(arg0: object[]): boolean
        getVolatile(arg0: object[]): object
        getAndBitwiseXor(arg0: object[]): object
        static storeStoreFence(): void
        compareAndExchange(arg0: object[]): object
        static fullFence(): void
        getAndSetRelease(arg0: object[]): object
        getAcquire(arg0: object[]): object
        getAndBitwiseAnd(arg0: object[]): object
        accessModeType(arg0: Internal.VarHandle$AccessMode): Internal.MethodType
        getAndBitwiseOr(arg0: object[]): object
        static acquireFence(): void
        hasInvokeExactBehavior(): boolean
        describeConstable(): Internal.Optional<Internal.VarHandle$VarHandleDesc>
        getAndBitwiseOrRelease(arg0: object[]): object
        getAndSetAcquire(arg0: object[]): object
        getOpaque(arg0: object[]): object
        varType(): Internal.Class<object>
        getAndBitwiseXorAcquire(arg0: object[]): object
        getAndBitwiseAndRelease(arg0: object[]): object
        getAndBitwiseOrAcquire(arg0: object[]): object
        setVolatile(arg0: object[]): void
        get(arg0: object[]): object
        static releaseFence(): void
        getAndAdd(arg0: object[]): object
        getAndSet(arg0: object[]): object
        weakCompareAndSetAcquire(arg0: object[]): boolean
        set(arg0: object[]): void
        weakCompareAndSetRelease(arg0: object[]): boolean
        weakCompareAndSet(arg0: object[]): boolean
        static loadLoadFence(): void
        getAndAddRelease(arg0: object[]): object
        getAndAddAcquire(arg0: object[]): object
        setOpaque(arg0: object[]): void
        isAccessModeSupported(arg0: Internal.VarHandle$AccessMode): boolean
        compareAndExchangeRelease(arg0: object[]): object
        compareAndSet(arg0: object[]): boolean
        compareAndExchangeAcquire(arg0: object[]): object
        getAndBitwiseXorRelease(arg0: object[]): object
        withInvokeBehavior(): Internal.VarHandle
        setRelease(arg0: object[]): void
        toString(): string
        withInvokeExactBehavior(): Internal.VarHandle
        getAndBitwiseAndAcquire(arg0: object[]): object
        set volatile(arg0: object[]);
        set opaque(arg0: object[]);
        set release(arg0: object[]);
    }
    class Vector3f {
        setY(arg0: number): void
        setX(arg0: number): void
        set(arg0: number[]): void
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        setZ(arg0: number): void
        set y(arg0: number);
        set x(arg0: number);
        set z(arg0: number);
    }
    class BaseImmutableMultimap <K, V> extends Internal.AbstractMultimap<K, V> {
    }
    interface Float2DoubleFunction implements Internal.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: Internal.Double2ShortFunction): Internal.Float2ShortFunction
        composeByte(arg0: Internal.Byte2FloatFunction): Internal.Byte2DoubleFunction
        andThenInt(arg0: Internal.Double2IntFunction): Internal.Float2IntFunction
        composeReference<T>(arg0: Internal.Reference2FloatFunction<T>): Internal.Reference2DoubleFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Double2DoubleFunction): Internal.Float2DoubleFunction
        andThenObject<T>(arg0: Internal.Double2ObjectFunction<T>): Internal.Float2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Double2LongFunction): Internal.Float2LongFunction
        composeLong(arg0: Internal.Long2FloatFunction): Internal.Long2DoubleFunction
        andThenByte(arg0: Internal.Double2ByteFunction): Internal.Float2ByteFunction
        andThenFloat(arg0: Internal.Double2FloatFunction): Internal.Float2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2FloatFunction): Internal.Int2DoubleFunction
        clear(): void
        composeFloat(arg0: Internal.Float2FloatFunction): Internal.Float2DoubleFunction
        andThenChar(arg0: Internal.Double2CharFunction): Internal.Float2CharFunction
        composeObject<T>(arg0: Internal.Object2FloatFunction<T>): Internal.Object2DoubleFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator
        composeShort(arg0: Internal.Short2FloatFunction): Internal.Short2DoubleFunction
        andThenReference<T>(arg0: Internal.Double2ReferenceFunction<T>): Internal.Float2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2FloatFunction): Internal.Char2DoubleFunction
        composeDouble(arg0: Internal.Double2FloatFunction): Internal.Double2DoubleFunction
    }
    interface DoubleStream$Builder implements Internal.DoubleConsumer {
        add(arg0: number): Internal.DoubleStream$Builder
        build(): Internal.DoubleStream
        andThen(arg0: Internal.DoubleConsumer): Internal.DoubleConsumer
        accept(arg0: number): void
    }
    interface FormattedText {
        getString(): string
        get string(): string;
    }
    interface IntToLongFunction {
        applyAsLong(arg0: number): number
    }
    class LinkedHashMap <K, V> extends Internal.HashMap<K, V> implements Map<K, V> {
        getOrDefault(arg0: object, arg1: V): V
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>
        forEach(arg0: (arg0: K, arg1: V) => void): void
        values(): Internal.Collection<V>
        get(arg0: object): V
        clear(): void
        keySet(): Internal.Set<K>
        replaceAll(arg0: (arg0: K, arg1: V) => V): void
        containsValue(arg0: object): boolean
    }
    interface Char2ObjectFunction <V> implements Internal.Function<string, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: string, arg1: V): V
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Object2ShortFunction<V>): Internal.Char2ShortFunction
        composeByte(arg0: Internal.Byte2CharFunction): Internal.Byte2ObjectFunction<V>
        andThenInt(arg0: Internal.Object2IntFunction<V>): Internal.Char2IntFunction
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: Internal.Reference2CharFunction<T>): (arg0: T) => V
        put(arg0: string, arg1: V): V
        put(arg0: object, arg1: object): object
        put(arg0: string, arg1: V): V
        remove(arg0: string): V
        remove(arg0: object): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: Internal.Object2DoubleFunction<V>): Internal.Char2DoubleFunction
        andThenObject<T>(arg0: (arg0: V) => T): Internal.Char2ObjectFunction<T>
        get(arg0: object): V
        get(arg0: string): V
        andThenLong(arg0: Internal.Object2LongFunction<V>): Internal.Char2LongFunction
        composeLong(arg0: Internal.Long2CharFunction): Internal.Long2ObjectFunction<V>
        andThenByte(arg0: Internal.Object2ByteFunction<V>): Internal.Char2ByteFunction
        andThenFloat(arg0: Internal.Object2FloatFunction<V>): Internal.Char2FloatFunction
        apply(arg0: number): V
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: string): boolean
        composeInt(arg0: Internal.Int2CharFunction): Internal.Int2ObjectFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2CharFunction): Internal.Float2ObjectFunction<V>
        andThenChar(arg0: Internal.Object2CharFunction<V>): Internal.Char2CharFunction
        composeObject<T>(arg0: Internal.Object2CharFunction<T>): (arg0: T) => V
        size(): number
        compose<T>(arg0: (arg0: T) => string): (arg0: T) => V
        composeShort(arg0: Internal.Short2CharFunction): Internal.Short2ObjectFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): Internal.Char2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2CharFunction): Internal.Char2ObjectFunction<V>
        composeDouble(arg0: Internal.Double2CharFunction): Internal.Double2ObjectFunction<V>
    }
    interface Object2IntFunction <K> implements Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: number): number
        andThenShort(arg0: Internal.Int2ShortFunction): Internal.Object2ShortFunction<K>
        composeByte(arg0: Internal.Byte2ObjectFunction<K>): Internal.Byte2IntFunction
        andThenInt(arg0: Internal.Int2IntFunction): Internal.Object2IntFunction<K>
        composeReference<T>(arg0: (arg0: T) => K): Internal.Reference2IntFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: K) => T
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: object, arg1: object): object
        remove(arg0: object): number
        remove(arg0: object): object
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: Internal.Int2DoubleFunction): Internal.Object2DoubleFunction<K>
        andThenObject<T>(arg0: Internal.Int2ObjectFunction<T>): (arg0: K) => T
        get(arg0: object): object
        get(arg0: object): number
        andThenLong(arg0: Internal.Int2LongFunction): Internal.Object2LongFunction<K>
        composeLong(arg0: Internal.Long2ObjectFunction<K>): Internal.Long2IntFunction
        andThenByte(arg0: Internal.Int2ByteFunction): Internal.Object2ByteFunction<K>
        andThenFloat(arg0: Internal.Int2FloatFunction): Internal.Object2FloatFunction<K>
        applyAsInt(arg0: K): number
        removeInt(arg0: object): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ObjectFunction<K>): Internal.Int2IntFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ObjectFunction<K>): Internal.Float2IntFunction
        andThenChar(arg0: Internal.Int2CharFunction): Internal.Object2CharFunction<K>
        getInt(arg0: object): number
        composeObject<T>(arg0: (arg0: T) => K): Internal.Object2IntFunction<T>
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ObjectFunction<K>): Internal.Short2IntFunction
        andThenReference<T>(arg0: Internal.Int2ReferenceFunction<T>): (arg0: K) => T
        composeChar(arg0: Internal.Char2ObjectFunction<K>): Internal.Char2IntFunction
        composeDouble(arg0: Internal.Double2ObjectFunction<K>): Internal.Double2IntFunction
    }
    class BlockBuilder extends Internal.BuilderBase {
        suffocating(b: boolean): Internal.BlockBuilder
        noItem(): Internal.BlockBuilder
        waterlogged(): Internal.BlockBuilder
        color(index: number, c: number): Internal.BlockBuilder
        getBuilderType(): string
        textureAll(tex: string): Internal.BlockBuilder
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder
        viewBlocking(b: boolean): Internal.BlockBuilder
        type(t: Internal.BlockType): Internal.BlockBuilder
        transparent(b: boolean): Internal.BlockBuilder
        tagBlock(tag: ResourceLocation): Internal.BlockBuilder
        fullBlock(f: boolean): Internal.BlockBuilder
        createProperties(): Internal.BlockBehaviour$Properties
        notSolid(): Internal.BlockBuilder
        noCollission(): Internal.BlockBuilder
        requiresTool(f: boolean): Internal.BlockBuilder
        unbreakable(): Internal.BlockBuilder
        model(m: string): Internal.BlockBuilder
        tag(tag: ResourceLocation): Internal.BlockBuilder
        tag(arg0: ResourceLocation): Internal.BuilderBase
        renderType(l: string): Internal.BlockBuilder
        jumpFactor(f: number): Internal.BlockBuilder
        tagBoth(tag: ResourceLocation): Internal.BlockBuilder
        createShape(): Internal.VoxelShape
        defaultCutout(): Internal.BlockBuilder
        item(i: (arg0: Internal.BlockItemBuilder) => void): Internal.BlockBuilder
        opaque(o: boolean): Internal.BlockBuilder
        randomTick(randomTickCallback: (arg0: Internal.RandomTickCallbackJS) => void): Internal.BlockBuilder
        texture(id: string, tex: string): Internal.BlockBuilder
        noDrops(): Internal.BlockBuilder
        speedFactor(f: number): Internal.BlockBuilder
        tagItem(tag: ResourceLocation): Internal.BlockBuilder
        noValidSpawns(b: boolean): Internal.BlockBuilder
        resistance(r: number): Internal.BlockBuilder
        hardness(h: number): Internal.BlockBuilder
        lightLevel(light: number): Internal.BlockBuilder
        defaultTranslucent(): Internal.BlockBuilder
        material(m: Internal.MaterialJS): Internal.BlockBuilder
        slipperiness(f: number): Internal.BlockBuilder
        redstoneConductor(b: boolean): Internal.BlockBuilder
        textureSide(direction: Internal.Direction, tex: string): Internal.BlockBuilder
        readonly textures : Internal.JsonObject;
        translationKey : string;
        displayName : string;
        defaultTags : Internal.Set<ResourceLocation>;
        static current : Internal.BlockBuilder;
        lootTable : (arg0: Internal.LootBuilder) => void;
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        block : Internal.Block;
        readonly id : ResourceLocation;
        customShape : Internal.List<Internal.AABB>;
        itemBuilder : Internal.BlockItemBuilder;
        randomTickCallback : (arg0: Internal.RandomTickCallbackJS) => void;
        get builderType(): string;
    }
    interface Float2ReferenceFunction <V> implements Internal.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: number, arg1: V): V
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Reference2ShortFunction<V>): Internal.Float2ShortFunction
        composeByte(arg0: Internal.Byte2FloatFunction): Internal.Byte2ReferenceFunction<V>
        andThenInt(arg0: Internal.Reference2IntFunction<V>): Internal.Float2IntFunction
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: Internal.Reference2FloatFunction<T>): (arg0: T) => V
        put(arg0: number, arg1: V): V
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: object): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: Internal.Reference2DoubleFunction<V>): Internal.Float2DoubleFunction
        andThenObject<T>(arg0: (arg0: V) => T): Internal.Float2ObjectFunction<T>
        get(arg0: object): V
        get(arg0: number): V
        andThenLong(arg0: Internal.Reference2LongFunction<V>): Internal.Float2LongFunction
        composeLong(arg0: Internal.Long2FloatFunction): Internal.Long2ReferenceFunction<V>
        andThenByte(arg0: Internal.Reference2ByteFunction<V>): Internal.Float2ByteFunction
        andThenFloat(arg0: Internal.Reference2FloatFunction<V>): Internal.Float2FloatFunction
        apply(arg0: number): V
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2FloatFunction): Internal.Int2ReferenceFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2FloatFunction): Internal.Float2ReferenceFunction<V>
        andThenChar(arg0: Internal.Reference2CharFunction<V>): Internal.Float2CharFunction
        composeObject<T>(arg0: Internal.Object2FloatFunction<T>): (arg0: T) => V
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => V
        composeShort(arg0: Internal.Short2FloatFunction): Internal.Short2ReferenceFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): Internal.Float2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2FloatFunction): Internal.Char2ReferenceFunction<V>
        composeDouble(arg0: Internal.Double2FloatFunction): Internal.Double2ReferenceFunction<V>
    }
    interface FeatureAccess {
    }
    class ScriptPackInfo {
        readonly displayName : Internal.Component;
        readonly namespace : string;
        readonly pathStart : string;
        readonly scripts : Internal.List<Internal.ScriptFileInfo>;
    }
    class ModuleDescriptor$Opens implements Internal.Comparable<Internal.ModuleDescriptor$Opens> {
        hashCode(): number
        equals(arg0: object): boolean
        isQualified(): boolean
        toString(): string
        source(): string
        compareTo(arg0: Internal.ModuleDescriptor$Opens): number
        compareTo(arg0: object): number
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Opens$Modifier>
        targets(): Internal.Set<string>
    }
    interface MultiBufferSource {
    }
    interface BiomeSeedProvider {
        getBiomeSeed(): number
        get biomeSeed(): number;
    }
    interface ErrorReporter {
        runtimeError(arg0: string, arg1: string, arg2: number, arg3: string, arg4: number): Internal.EvaluatorException
        warning(arg0: string, arg1: string, arg2: number, arg3: string, arg4: number): void
        error(arg0: string, arg1: string, arg2: number, arg3: string, arg4: number): void
    }
    class HitResult {
    }
    interface TemporalAccessor {
        getLong(arg0: Internal.TemporalField): number
        query<R>(arg0: Internal.TemporalQuery<R>): R
        get(arg0: Internal.TemporalField): number
        range(arg0: Internal.TemporalField): Internal.ValueRange
        isSupported(arg0: Internal.TemporalField): boolean
    }
    interface DoubleToIntFunction {
        applyAsInt(arg0: number): number
    }
    interface IMovedAccess {
        backpackedMoved(): boolean
    }
    class ProcessingRecipeJS extends Internal.RecipeJS {
        serialize(): void
        superheated(): Internal.ProcessingRecipeJS
        heatRequirement(req: string): Internal.ProcessingRecipeJS
        create(args: Internal.ListJS): void
        heated(): Internal.ProcessingRecipeJS
        processingTime(t: number): Internal.ProcessingRecipeJS
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<object>;
        readonly inputFluids : Internal.List<Internal.FluidIngredient>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        serializeInputs : boolean;
    }
    class SectionedEntityMovementTracker <E, S> {
        unRegister(world: Internal.ServerLevel): void
        hashCode(): number
        equals(obj: object): boolean
        onSectionLeftRange(section: Internal.EntityTrackerSection): void
        onSectionEnteredRange(section: Internal.EntityTrackerSection): void
        isUnchangedSince(lastCheckedTime: number): boolean
        register(world: Internal.ServerLevel): void
    }
    class Scoreboard {
    }
    class DecimalStyle {
        getPositiveSign(): string
        getDecimalSeparator(): string
        getNegativeSign(): string
        static ofDefaultLocale(): Internal.DecimalStyle
        getZeroDigit(): string
        withPositiveSign(arg0: string): Internal.DecimalStyle
        hashCode(): number
        withDecimalSeparator(arg0: string): Internal.DecimalStyle
        static of(arg0: Internal.Locale): Internal.DecimalStyle
        equals(arg0: object): boolean
        toString(): string
        withNegativeSign(arg0: string): Internal.DecimalStyle
        withZeroDigit(arg0: string): Internal.DecimalStyle
        static getAvailableLocales(): Internal.Set<Internal.Locale>
        static readonly STANDARD : Internal.DecimalStyle;
        get positiveSign(): string;
        get decimalSeparator(): string;
        get negativeSign(): string;
        get zeroDigit(): string;
        get availableLocales(): Internal.Set<Internal.Locale>;
    }
    class BlockEntityWithoutLevelRenderer implements Internal.ResourceManagerReloadListener {
    }
    interface Long2ObjectFunction <V> implements Internal.Function<number, V>, Internal.LongFunction<V> {
        getOrDefault(arg0: number, arg1: V): V
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Object2ShortFunction<V>): Internal.Long2ShortFunction
        composeByte(arg0: Internal.Byte2LongFunction): Internal.Byte2ObjectFunction<V>
        andThenInt(arg0: Internal.Object2IntFunction<V>): Internal.Long2IntFunction
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: Internal.Reference2LongFunction<T>): (arg0: T) => V
        put(arg0: number, arg1: V): V
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: object): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: Internal.Object2DoubleFunction<V>): Internal.Long2DoubleFunction
        andThenObject<T>(arg0: (arg0: V) => T): Internal.Long2ObjectFunction<T>
        get(arg0: object): V
        get(arg0: number): V
        andThenLong(arg0: Internal.Object2LongFunction<V>): Internal.Long2LongFunction
        composeLong(arg0: Internal.Long2LongFunction): Internal.Long2ObjectFunction<V>
        andThenByte(arg0: Internal.Object2ByteFunction<V>): Internal.Long2ByteFunction
        andThenFloat(arg0: Internal.Object2FloatFunction<V>): Internal.Long2FloatFunction
        apply(arg0: number): V
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2LongFunction): Internal.Int2ObjectFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2LongFunction): Internal.Float2ObjectFunction<V>
        andThenChar(arg0: Internal.Object2CharFunction<V>): Internal.Long2CharFunction
        composeObject<T>(arg0: Internal.Object2LongFunction<T>): (arg0: T) => V
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => V
        composeShort(arg0: Internal.Short2LongFunction): Internal.Short2ObjectFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): Internal.Long2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2LongFunction): Internal.Char2ObjectFunction<V>
        composeDouble(arg0: Internal.Double2LongFunction): Internal.Double2ObjectFunction<V>
    }
    interface LevelChunk$PostLoadProcessor {
    }
    class ChannelOutboundBuffer {
        currentProgress(): number
        bytesBeforeUnwritable(): number
        getUserDefinedWritability(arg0: number): boolean
        isEmpty(): boolean
        isWritable(): boolean
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[]
        nioBuffers(): Internal.ByteBuffer[]
        nioBufferCount(): number
        removeBytes(arg0: number): void
        addMessage(arg0: object, arg1: number, arg2: Internal.ChannelPromise): void
        remove(): boolean
        remove(arg0: Internal.Throwable): boolean
        addFlush(): void
        totalPendingWriteBytes(): number
        forEachFlushedMessage(arg0: Internal.ChannelOutboundBuffer$MessageProcessor): void
        current(): object
        setUserDefinedWritability(arg0: number, arg1: boolean): void
        size(): number
        nioBufferSize(): number
        recycle(): void
        progress(arg0: number): void
        bytesBeforeWritable(): number
    }
    class Ingredient implements Internal.Predicate<Internal.ItemStack>, Internal.IngredientKJS {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        getSerializer(): Internal.IIngredientSerializer<Internal.Ingredient>
        static invalidateAll(): void
        test(arg0: Internal.ItemStack): boolean
        test(arg0: object): boolean
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
        checkInvalidation(): boolean
        isVanilla(): boolean
        static merge(arg0: Internal.Collection<Internal.Ingredient>): Internal.Ingredient
        isSimple(): boolean
        getItemsKJS(): Internal.ItemStack[]
        asKJS(): object
        get serializer(): Internal.IIngredientSerializer<Internal.Ingredient>;
        get itemsKJS(): Internal.ItemStack[];
    }
    interface IPlantable {
        getPlantType(arg0: Internal.BlockGetter, arg1: BlockPos): Internal.PlantType
        getPlant(arg0: Internal.BlockGetter, arg1: BlockPos): Internal.BlockState
    }
    interface Nameable {
    }
    interface GroupPrincipal implements Internal.UserPrincipal {
        getName(): string
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        implies(arg0: Internal.Subject): boolean
        get name(): string;
    }
    interface Tag <T> {
    }
    interface TStack <Self> {
        pushPose(): Self
        popPose(): Self
    }
    class GlNumericType extends Internal.Enum<Internal.GlNumericType> {
        getGlEnum(): number
        static valueOf(arg0: string): Internal.GlNumericType
        castAndBuffer(arg0: Internal.ByteBuffer, arg1: number): void
        static values(): Internal.GlNumericType[]
        static byName(arg0: string): Internal.GlNumericType
        toString(): string
        getTypeName(): string
        getByteWidth(): number
        static readonly UBYTE : Internal.GlNumericType;
        static readonly FLOAT : Internal.GlNumericType;
        static readonly BYTE : Internal.GlNumericType;
        static readonly USHORT : Internal.GlNumericType;
        static readonly UINT : Internal.GlNumericType;
        static readonly INT : Internal.GlNumericType;
        static readonly SHORT : Internal.GlNumericType;
        get glEnum(): number;
        get typeName(): string;
        get byteWidth(): number;
    }
    class SmithingRecipeJS extends Internal.RecipeJS {
        serialize(): void
        create(args: Internal.ListJS): void
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<object>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
    }
    interface Int2LongFunction implements Internal.Function<number, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Long2ShortFunction): Internal.Int2ShortFunction
        composeByte(arg0: Internal.Byte2IntFunction): Internal.Byte2LongFunction
        andThenInt(arg0: Internal.Long2IntFunction): Internal.Int2IntFunction
        composeReference<T>(arg0: Internal.Reference2IntFunction<T>): Internal.Reference2LongFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Long2DoubleFunction): Internal.Int2DoubleFunction
        andThenObject<T>(arg0: Internal.Long2ObjectFunction<T>): Internal.Int2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Long2LongFunction): Internal.Int2LongFunction
        composeLong(arg0: Internal.Long2IntFunction): Internal.Long2LongFunction
        andThenByte(arg0: Internal.Long2ByteFunction): Internal.Int2ByteFunction
        andThenFloat(arg0: Internal.Long2FloatFunction): Internal.Int2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2IntFunction): Internal.Int2LongFunction
        clear(): void
        composeFloat(arg0: Internal.Float2IntFunction): Internal.Float2LongFunction
        andThenChar(arg0: Internal.Long2CharFunction): Internal.Int2CharFunction
        applyAsLong(arg0: number): number
        composeObject<T>(arg0: Internal.Object2IntFunction<T>): Internal.Object2LongFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2IntFunction): Internal.Short2LongFunction
        andThenReference<T>(arg0: Internal.Long2ReferenceFunction<T>): Internal.Int2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2IntFunction): Internal.Char2LongFunction
        composeDouble(arg0: Internal.Double2IntFunction): Internal.Double2LongFunction
    }
    class AttachedData extends Internal.HashMap<string, object> {
        getParent(): object
        get parent(): object;
    }
    interface Multimap <K, V> {
        containsEntry(arg0: object, arg1: object): boolean
        asMap(): Map<K, Internal.Collection<V>>
        keys(): Internal.Multiset<K>
        containsKey(arg0: object): boolean
        forEach(arg0: (arg0: K, arg1: V) => void): void
        values(): Internal.Collection<V>
        isEmpty(): boolean
        clear(): void
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.Collection<V>
        containsValue(arg0: object): boolean
        put(arg0: K, arg1: V): boolean
        remove(arg0: object, arg1: object): boolean
        removeAll(arg0: object): Internal.Collection<V>
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>
        size(): number
        hashCode(): number
        putAll(arg0: Internal.Multimap<K, V>): boolean
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean
        equals(arg0: object): boolean
        get(arg0: K): Internal.Collection<V>
        keySet(): Internal.Set<K>
    }
    class Pair <L, R> implements Internal.Map$Entry<L, R>, Internal.Comparable<Internal.Pair<L, R>>, Internal.Serializable {
        getKey(): L
        getValue(): R
        getRight(): R
        hashCode(): number
        setValue(arg0: V): V
        static of<L, R>(arg0: Internal.Map$Entry<L, R>): Internal.Pair<L, R>
        static of<L, R>(arg0: L, arg1: R): Internal.Pair<L, R>
        equals(arg0: object): boolean
        toString(arg0: string): string
        toString(): string
        static emptyArray<L, R>(): Internal.Pair<L, R>[]
        compareTo(arg0: object): number
        compareTo(arg0: Internal.Pair<L, R>): number
        getLeft(): L
        static readonly EMPTY_ARRAY : Internal.Pair<object, object>[];
        get key(): L;
        get value(): R;
        get right(): R;
        set value(arg0: V);
        get left(): L;
    }
    interface Logger {
        getName(): string
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: string, p0: object): void
        log(level: org.apache.logging.log4j.Level, messageSupplier: Internal.Supplier<object>, throwable: Internal.Throwable): void
        log(level: org.apache.logging.log4j.Level, messageSupplier: Internal.Supplier<object>): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: string, p0: object, p1: object): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: string, p0: object, p1: object, p2: object): void
        log(level: org.apache.logging.log4j.Level, message: object, throwable: Internal.Throwable): void
        log(level: org.apache.logging.log4j.Level, message: string): void
        log(level: org.apache.logging.log4j.Level, message: string, params: object[]): void
        log(level: org.apache.logging.log4j.Level, message: string, paramSuppliers: Internal.Supplier<object>[]): void
        log(level: org.apache.logging.log4j.Level, message: string, throwable: Internal.Throwable): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object, p9: object): void
        log(level: org.apache.logging.log4j.Level, message: string, p0: object): void
        log(level: org.apache.logging.log4j.Level, message: string, p0: object, p1: object): void
        log(level: org.apache.logging.log4j.Level, message: string, p0: object, p1: object, p2: object): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: object): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: object, throwable: Internal.Throwable): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: string): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: string, paramSuppliers: Internal.Supplier<object>[]): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: org.apache.logging.log4j.message.Message): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: Internal.CharSequence): void
        log(level: org.apache.logging.log4j.Level, messageSupplier: Internal.MessageSupplier): void
        log(level: org.apache.logging.log4j.Level, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        log(level: org.apache.logging.log4j.Level, message: Internal.CharSequence): void
        log(level: org.apache.logging.log4j.Level, message: Internal.CharSequence, throwable: Internal.Throwable): void
        log(level: org.apache.logging.log4j.Level, message: object): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: string, throwable: Internal.Throwable): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, messageSupplier: Internal.Supplier<object>): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, messageSupplier: Internal.Supplier<object>, throwable: Internal.Throwable): void
        log(level: org.apache.logging.log4j.Level, message: org.apache.logging.log4j.message.Message): void
        log(level: org.apache.logging.log4j.Level, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        log(level: org.apache.logging.log4j.Level, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object): void
        log(level: org.apache.logging.log4j.Level, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object): void
        log(level: org.apache.logging.log4j.Level, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object, p9: object): void
        log(level: org.apache.logging.log4j.Level, marker: Internal.Marker, message: string, params: object[]): void
        log(level: org.apache.logging.log4j.Level, message: string, p0: object, p1: object, p2: object, p3: object): void
        log(level: org.apache.logging.log4j.Level, message: string, p0: object, p1: object, p2: object, p3: object, p4: object): void
        log(level: org.apache.logging.log4j.Level, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object): void
        log(level: org.apache.logging.log4j.Level, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object): void
        logMessage(level: org.apache.logging.log4j.Level, marker: Internal.Marker, fqcn: string, location: Internal.StackTraceElement, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        atWarn(): Internal.LogBuilder
        atInfo(): Internal.LogBuilder
        isWarnEnabled(marker: Internal.Marker): boolean
        isWarnEnabled(): boolean
        error(message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        error(messageSupplier: Internal.MessageSupplier): void
        error(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        error(message: Internal.CharSequence): void
        error(message: org.apache.logging.log4j.message.Message): void
        error(marker: Internal.Marker, messageSupplier: Internal.Supplier<object>, throwable: Internal.Throwable): void
        error(marker: Internal.Marker, messageSupplier: Internal.Supplier<object>): void
        error(message: string, paramSuppliers: Internal.Supplier<object>[]): void
        error(message: string, params: object[]): void
        error(message: string): void
        error(message: object, throwable: Internal.Throwable): void
        error(message: object): void
        error(message: Internal.CharSequence, throwable: Internal.Throwable): void
        error(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void
        error(marker: Internal.Marker, message: Internal.CharSequence): void
        error(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        error(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void
        error(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        error(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message): void
        error(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void
        error(marker: Internal.Marker, message: string, paramSuppliers: Internal.Supplier<object>[]): void
        error(marker: Internal.Marker, message: string, params: object[]): void
        error(marker: Internal.Marker, message: string): void
        error(marker: Internal.Marker, message: object, throwable: Internal.Throwable): void
        error(marker: Internal.Marker, message: object): void
        error(message: string, p0: object, p1: object, p2: object, p3: object): void
        error(message: string, p0: object, p1: object, p2: object): void
        error(message: string, p0: object, p1: object): void
        error(message: string, p0: object): void
        error(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object, p9: object): void
        error(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object): void
        error(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object, p9: object): void
        error(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object): void
        error(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object): void
        error(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object): void
        error(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object): void
        error(message: string, p0: object, p1: object, p2: object, p3: object, p4: object): void
        error(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object): void
        error(marker: Internal.Marker, message: string, p0: object, p1: object): void
        error(marker: Internal.Marker, message: string, p0: object): void
        error(messageSupplier: Internal.Supplier<object>, throwable: Internal.Throwable): void
        error(messageSupplier: Internal.Supplier<object>): void
        error(message: string, throwable: Internal.Throwable): void
        error(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object): void
        error(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object): void
        error(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object): void
        error(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object): void
        error(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object): void
        fatal(message: object, throwable: Internal.Throwable): void
        fatal(message: object): void
        fatal(message: string): void
        fatal(message: string, params: object[]): void
        fatal(messageSupplier: Internal.MessageSupplier): void
        fatal(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        fatal(message: Internal.CharSequence): void
        fatal(message: Internal.CharSequence, throwable: Internal.Throwable): void
        fatal(marker: Internal.Marker, message: string, p0: object): void
        fatal(marker: Internal.Marker, message: string, p0: object, p1: object): void
        fatal(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object): void
        fatal(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object): void
        fatal(message: string, paramSuppliers: Internal.Supplier<object>[]): void
        fatal(message: string, throwable: Internal.Throwable): void
        fatal(messageSupplier: Internal.Supplier<object>): void
        fatal(messageSupplier: Internal.Supplier<object>, throwable: Internal.Throwable): void
        fatal(marker: Internal.Marker, message: Internal.CharSequence): void
        fatal(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void
        fatal(marker: Internal.Marker, message: object): void
        fatal(marker: Internal.Marker, message: object, throwable: Internal.Throwable): void
        fatal(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message): void
        fatal(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        fatal(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void
        fatal(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        fatal(marker: Internal.Marker, messageSupplier: Internal.Supplier<object>): void
        fatal(marker: Internal.Marker, messageSupplier: Internal.Supplier<object>, throwable: Internal.Throwable): void
        fatal(message: org.apache.logging.log4j.message.Message): void
        fatal(message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        fatal(marker: Internal.Marker, message: string): void
        fatal(marker: Internal.Marker, message: string, params: object[]): void
        fatal(marker: Internal.Marker, message: string, paramSuppliers: Internal.Supplier<object>[]): void
        fatal(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void
        fatal(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object): void
        fatal(message: string, p0: object, p1: object, p2: object, p3: object, p4: object): void
        fatal(message: string, p0: object, p1: object, p2: object, p3: object): void
        fatal(message: string, p0: object, p1: object, p2: object): void
        fatal(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object, p9: object): void
        fatal(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object): void
        fatal(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object): void
        fatal(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object): void
        fatal(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object): void
        fatal(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object): void
        fatal(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object): void
        fatal(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object): void
        fatal(message: string, p0: object, p1: object): void
        fatal(message: string, p0: object): void
        fatal(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object, p9: object): void
        fatal(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object): void
        printf(level: org.apache.logging.log4j.Level, format: string, params: object[]): void
        printf(level: org.apache.logging.log4j.Level, marker: Internal.Marker, format: string, params: object[]): void
        throwing<T>(throwable: T): T
        throwing<T>(level: org.apache.logging.log4j.Level, throwable: T): T
        atTrace(): Internal.LogBuilder
        trace(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void
        trace(message: object): void
        trace(message: Internal.CharSequence, throwable: Internal.Throwable): void
        trace(marker: Internal.Marker, message: string, paramSuppliers: Internal.Supplier<object>[]): void
        trace(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        trace(marker: Internal.Marker, messageSupplier: Internal.Supplier<object>, throwable: Internal.Throwable): void
        trace(message: org.apache.logging.log4j.message.Message): void
        trace(message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        trace(messageSupplier: Internal.MessageSupplier): void
        trace(marker: Internal.Marker, messageSupplier: Internal.Supplier<object>): void
        trace(message: Internal.CharSequence): void
        trace(marker: Internal.Marker, message: string, p0: object, p1: object): void
        trace(marker: Internal.Marker, message: string, p0: object): void
        trace(messageSupplier: Internal.Supplier<object>, throwable: Internal.Throwable): void
        trace(messageSupplier: Internal.Supplier<object>): void
        trace(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object): void
        trace(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object): void
        trace(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object): void
        trace(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object): void
        trace(message: object, throwable: Internal.Throwable): void
        trace(message: string): void
        trace(message: string, params: object[]): void
        trace(message: string, paramSuppliers: Internal.Supplier<object>[]): void
        trace(message: string, throwable: Internal.Throwable): void
        trace(message: string, p0: object): void
        trace(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object, p9: object): void
        trace(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object): void
        trace(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object): void
        trace(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object): void
        trace(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object): void
        trace(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object): void
        trace(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object): void
        trace(message: string, p0: object, p1: object, p2: object, p3: object, p4: object): void
        trace(message: string, p0: object, p1: object, p2: object, p3: object): void
        trace(message: string, p0: object, p1: object, p2: object): void
        trace(message: string, p0: object, p1: object): void
        trace(marker: Internal.Marker, message: Internal.CharSequence): void
        trace(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void
        trace(marker: Internal.Marker, message: object): void
        trace(marker: Internal.Marker, message: object, throwable: Internal.Throwable): void
        trace(marker: Internal.Marker, message: string): void
        trace(marker: Internal.Marker, message: string, params: object[]): void
        trace(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object): void
        trace(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message): void
        trace(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        trace(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void
        trace(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        trace(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object, p9: object): void
        isInfoEnabled(marker: Internal.Marker): boolean
        isInfoEnabled(): boolean
        traceEntry(paramSuppliers: Internal.Supplier<object>[]): Internal.EntryMessage
        traceEntry(format: string, params: object[]): Internal.EntryMessage
        traceEntry(): Internal.EntryMessage
        traceEntry(format: string, paramSuppliers: Internal.Supplier<object>[]): Internal.EntryMessage
        traceEntry(message: org.apache.logging.log4j.message.Message): Internal.EntryMessage
        isErrorEnabled(): boolean
        isErrorEnabled(marker: Internal.Marker): boolean
        isTraceEnabled(): boolean
        isTraceEnabled(marker: Internal.Marker): boolean
        atLevel(level: org.apache.logging.log4j.Level): Internal.LogBuilder
        info(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        info(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void
        info(marker: Internal.Marker, message: Internal.CharSequence): void
        info(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void
        info(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        info(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object): void
        info(marker: Internal.Marker, message: string, paramSuppliers: Internal.Supplier<object>[]): void
        info(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object): void
        info(marker: Internal.Marker, message: string, params: object[]): void
        info(marker: Internal.Marker, message: string): void
        info(marker: Internal.Marker, message: object, throwable: Internal.Throwable): void
        info(marker: Internal.Marker, message: object): void
        info(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object): void
        info(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object): void
        info(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message): void
        info(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object): void
        info(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object): void
        info(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object, p9: object): void
        info(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object, p9: object): void
        info(message: string, p0: object, p1: object): void
        info(message: string, p0: object, p1: object, p2: object): void
        info(message: string, p0: object, p1: object, p2: object, p3: object): void
        info(message: string, p0: object, p1: object, p2: object, p3: object, p4: object): void
        info(marker: Internal.Marker, message: string, p0: object): void
        info(messageSupplier: Internal.Supplier<object>, throwable: Internal.Throwable): void
        info(messageSupplier: Internal.Supplier<object>): void
        info(message: string, throwable: Internal.Throwable): void
        info(message: string, paramSuppliers: Internal.Supplier<object>[]): void
        info(message: string, params: object[]): void
        info(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object): void
        info(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object): void
        info(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object): void
        info(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object): void
        info(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object): void
        info(marker: Internal.Marker, message: string, p0: object, p1: object): void
        info(messageSupplier: Internal.MessageSupplier): void
        info(message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        info(message: org.apache.logging.log4j.message.Message): void
        info(marker: Internal.Marker, messageSupplier: Internal.Supplier<object>, throwable: Internal.Throwable): void
        info(marker: Internal.Marker, messageSupplier: Internal.Supplier<object>): void
        info(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void
        info(message: string): void
        info(message: object, throwable: Internal.Throwable): void
        info(message: object): void
        info(message: Internal.CharSequence, throwable: Internal.Throwable): void
        info(message: Internal.CharSequence): void
        info(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        info(message: string, p0: object): void
        always(): Internal.LogBuilder
        getMessageFactory<MF>(): MF
        catching(level: org.apache.logging.log4j.Level, throwable: Internal.Throwable): void
        catching(throwable: Internal.Throwable): void
        debug(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object): void
        debug(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object): void
        debug(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object): void
        debug(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object): void
        debug(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object): void
        debug(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object): void
        debug(message: string, paramSuppliers: Internal.Supplier<object>[]): void
        debug(message: string, throwable: Internal.Throwable): void
        debug(messageSupplier: Internal.Supplier<object>): void
        debug(messageSupplier: Internal.Supplier<object>, throwable: Internal.Throwable): void
        debug(marker: Internal.Marker, message: string, p0: object): void
        debug(marker: Internal.Marker, message: string, p0: object, p1: object): void
        debug(message: string, p0: object, p1: object, p2: object, p3: object, p4: object): void
        debug(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object): void
        debug(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object): void
        debug(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object): void
        debug(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object): void
        debug(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object, p9: object): void
        debug(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object): void
        debug(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object, p9: object): void
        debug(message: string, p0: object): void
        debug(message: string, p0: object, p1: object): void
        debug(message: string, p0: object, p1: object, p2: object): void
        debug(message: string, p0: object, p1: object, p2: object, p3: object): void
        debug(marker: Internal.Marker, message: object): void
        debug(marker: Internal.Marker, message: object, throwable: Internal.Throwable): void
        debug(marker: Internal.Marker, message: string): void
        debug(marker: Internal.Marker, message: string, params: object[]): void
        debug(marker: Internal.Marker, message: string, paramSuppliers: Internal.Supplier<object>[]): void
        debug(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void
        debug(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message): void
        debug(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        debug(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void
        debug(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        debug(marker: Internal.Marker, message: Internal.CharSequence): void
        debug(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void
        debug(message: Internal.CharSequence): void
        debug(message: Internal.CharSequence, throwable: Internal.Throwable): void
        debug(message: object): void
        debug(message: object, throwable: Internal.Throwable): void
        debug(message: string): void
        debug(message: string, params: object[]): void
        debug(marker: Internal.Marker, messageSupplier: Internal.Supplier<object>): void
        debug(marker: Internal.Marker, messageSupplier: Internal.Supplier<object>, throwable: Internal.Throwable): void
        debug(message: org.apache.logging.log4j.message.Message): void
        debug(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        debug(messageSupplier: Internal.MessageSupplier): void
        debug(message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        atError(): Internal.LogBuilder
        traceExit(): void
        traceExit<R>(format: string, result: R): R
        traceExit(message: Internal.EntryMessage): void
        traceExit<R>(result: R): R
        traceExit<R>(message: Internal.EntryMessage, result: R): R
        traceExit<R>(message: org.apache.logging.log4j.message.Message, result: R): R
        atFatal(): Internal.LogBuilder
        isFatalEnabled(): boolean
        isFatalEnabled(marker: Internal.Marker): boolean
        getLevel(): org.apache.logging.log4j.Level
        warn(message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        warn(messageSupplier: Internal.MessageSupplier): void
        warn(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        warn(message: Internal.CharSequence): void
        warn(message: org.apache.logging.log4j.message.Message): void
        warn(marker: Internal.Marker, messageSupplier: Internal.Supplier<object>): void
        warn(marker: Internal.Marker, messageSupplier: Internal.Supplier<object>, throwable: Internal.Throwable): void
        warn(message: string, paramSuppliers: Internal.Supplier<object>[]): void
        warn(message: string, params: object[]): void
        warn(message: string): void
        warn(message: object, throwable: Internal.Throwable): void
        warn(message: object): void
        warn(message: Internal.CharSequence, throwable: Internal.Throwable): void
        warn(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void
        warn(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void
        warn(marker: Internal.Marker, message: Internal.CharSequence): void
        warn(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void
        warn(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message, throwable: Internal.Throwable): void
        warn(marker: Internal.Marker, message: org.apache.logging.log4j.message.Message): void
        warn(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object, p9: object): void
        warn(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void
        warn(marker: Internal.Marker, message: string, paramSuppliers: Internal.Supplier<object>[]): void
        warn(marker: Internal.Marker, message: string, params: object[]): void
        warn(marker: Internal.Marker, message: string): void
        warn(marker: Internal.Marker, message: object, throwable: Internal.Throwable): void
        warn(marker: Internal.Marker, message: object): void
        warn(message: string, p0: object, p1: object, p2: object): void
        warn(message: string, p0: object, p1: object): void
        warn(message: string, p0: object): void
        warn(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object, p9: object): void
        warn(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object): void
        warn(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object): void
        warn(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object, p8: object): void
        warn(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object, p7: object): void
        warn(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object): void
        warn(message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object): void
        warn(message: string, p0: object, p1: object, p2: object, p3: object, p4: object): void
        warn(message: string, p0: object, p1: object, p2: object, p3: object): void
        warn(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object): void
        warn(marker: Internal.Marker, message: string, p0: object, p1: object): void
        warn(marker: Internal.Marker, message: string, p0: object): void
        warn(messageSupplier: Internal.Supplier<object>, throwable: Internal.Throwable): void
        warn(messageSupplier: Internal.Supplier<object>): void
        warn(message: string, throwable: Internal.Throwable): void
        warn(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object): void
        warn(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object): void
        warn(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object, p6: object): void
        warn(marker: Internal.Marker, message: string, p0: object, p1: object, p2: object, p3: object, p4: object, p5: object): void
        entry(): void
        entry(params: object[]): void
        exit<R>(result: R): R
        exit(): void
        isEnabled(level: org.apache.logging.log4j.Level): boolean
        isEnabled(level: org.apache.logging.log4j.Level, marker: Internal.Marker): boolean
        isDebugEnabled(): boolean
        isDebugEnabled(marker: Internal.Marker): boolean
        atDebug(): Internal.LogBuilder
        get name(): string;
        get messageFactory(): MF;
        get level(): org.apache.logging.log4j.Level;
    }
    class SectionPos extends Vec3i {
    }
    class ClocheRenderFunction$ClocheRenderReference {
        serialize(): Internal.JsonObject
        getBlock(): Internal.Block
        static read(arg0: Internal.FriendlyByteBuf): Internal.ClocheRenderFunction$ClocheRenderReference
        getType(): string
        write(arg0: Internal.FriendlyByteBuf): void
        static deserialize(arg0: Internal.JsonObject): Internal.ClocheRenderFunction$ClocheRenderReference
        get block(): Internal.Block;
        get type(): string;
    }
    class BlockableEventLoop <R> implements Internal.ProfilerMeasured, Internal.ProcessorHandle<R>, Internal.Executor {
        close(): void
        execute(arg0: Internal.Runnable): void
    }
    interface TickAccess <T> {
    }
    class FluidAttributes {
        getOverlayTexture(): ResourceLocation
        getBlock(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidState): Internal.BlockState
        getStateForPlacement(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidStack): Internal.FluidState
        getTranslationKey(): string
        getTranslationKey(arg0: Internal.FluidStack): string
        isLighterThanAir(): boolean
        getColor(): number
        getColor(arg0: Internal.FluidStack): number
        getColor(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): number
        getFillSound(): Internal.SoundEvent
        getFillSound(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): Internal.SoundEvent
        getFillSound(arg0: Internal.FluidStack): Internal.SoundEvent
        isGaseous(): boolean
        isGaseous(arg0: Internal.FluidStack): boolean
        isGaseous(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): boolean
        getRarity(): Internal.Rarity
        getRarity(arg0: Internal.FluidStack): Internal.Rarity
        getRarity(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): Internal.Rarity
        getDensity(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): number
        getDensity(): number
        getDensity(arg0: Internal.FluidStack): number
        getEmptySound(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): Internal.SoundEvent
        getEmptySound(): Internal.SoundEvent
        getEmptySound(arg0: Internal.FluidStack): Internal.SoundEvent
        getLuminosity(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): number
        getLuminosity(arg0: Internal.FluidStack): number
        getLuminosity(): number
        getBucket(arg0: Internal.FluidStack): Internal.ItemStack
        doesVaporize(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidStack): boolean
        getViscosity(): number
        getViscosity(arg0: Internal.FluidStack): number
        getViscosity(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): number
        getFlowingTexture(arg0: Internal.FluidStack): ResourceLocation
        getFlowingTexture(): ResourceLocation
        getFlowingTexture(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): ResourceLocation
        canBePlacedInWorld(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidState): boolean
        canBePlacedInWorld(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidStack): boolean
        getDisplayName(arg0: Internal.FluidStack): Internal.Component
        static builder(arg0: ResourceLocation, arg1: ResourceLocation): Internal.FluidAttributes$Builder
        getTextures(): Internal.Stream<ResourceLocation>
        vaporize(arg0: Internal.Player, arg1: Internal.Level, arg2: BlockPos, arg3: Internal.FluidStack): void
        getTemperature(): number
        getTemperature(arg0: Internal.FluidStack): number
        getTemperature(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): number
        getStillTexture(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): ResourceLocation
        getStillTexture(): ResourceLocation
        getStillTexture(arg0: Internal.FluidStack): ResourceLocation
        static readonly BUCKET_VOLUME : 1000;
        get overlayTexture(): ResourceLocation;
        get translationKey(): string;
        get color(): number;
        get fillSound(): Internal.SoundEvent;
        get rarity(): Internal.Rarity;
        get density(): number;
        get emptySound(): Internal.SoundEvent;
        get luminosity(): number;
        get viscosity(): number;
        get flowingTexture(): ResourceLocation;
        get textures(): Internal.Stream<ResourceLocation>;
        get temperature(): number;
        get stillTexture(): ResourceLocation;
    }
    class SimpleChannelInboundHandler <I> extends Internal.ChannelInboundHandlerAdapter {
        acceptInboundMessage(arg0: object): boolean
        channelRead(arg0: Internal.ChannelHandlerContext, arg1: object): void
    }
    class TextStyle extends Internal.Enum<Internal.TextStyle> {
        asNormal(): Internal.TextStyle
        static valueOf(arg0: string): Internal.TextStyle
        isStandalone(): boolean
        static values(): Internal.TextStyle[]
        asStandalone(): Internal.TextStyle
        static readonly SHORT_STANDALONE : Internal.TextStyle;
        static readonly NARROW_STANDALONE : Internal.TextStyle;
        static readonly FULL_STANDALONE : Internal.TextStyle;
        static readonly FULL : Internal.TextStyle;
        static readonly SHORT : Internal.TextStyle;
        static readonly NARROW : Internal.TextStyle;
    }
    class AABB {
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
    }
    class Thread$State extends Internal.Enum<Internal.Thread$State> {
        static valueOf(arg0: string): Internal.Thread$State
        static values(): Internal.Thread$State[]
        static readonly NEW : Internal.Thread$State;
        static readonly TERMINATED : Internal.Thread$State;
        static readonly RUNNABLE : Internal.Thread$State;
        static readonly BLOCKED : Internal.Thread$State;
        static readonly WAITING : Internal.Thread$State;
        static readonly TIMED_WAITING : Internal.Thread$State;
    }
    class ShapelessRecipeJS extends Internal.RecipeJS {
        serialize(): void
        create(args: Internal.ListJS): void
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<object>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
    }
    interface NonNullFunction <T, R> {
        apply(arg0: T): R
    }
    interface ContainerAccess {
        getRemoteSlots(): Internal.NonNullList<Internal.ItemStack>
        getLastSlots(): Internal.NonNullList<Internal.ItemStack>
        get remoteSlots(): Internal.NonNullList<Internal.ItemStack>;
        get lastSlots(): Internal.NonNullList<Internal.ItemStack>;
    }
    class FontSet implements Internal.AutoCloseable {
        close(): void
    }
    interface TemporalQuery <R> {
        queryFrom(arg0: Internal.TemporalAccessor): R
    }
    interface TooltipComponent {
    }
    interface Iterator <E> {
        next(): E
        hasNext(): boolean
        forEachRemaining(arg0: (arg0: E) => void): void
        remove(): void
    }
    class RegistryAccess$RegistryHolder extends Internal.RegistryAccess {
    }
    interface EquipmentEntity$EquipmentTrackingEntity {
    }
    class EffectRenderer {
        renderInventoryEffect(arg0: Internal.MobEffectInstance, arg1: Internal.EffectRenderingInventoryScreen<object>, arg2: Internal.PoseStack, arg3: number, arg4: number, arg5: number): void
        shouldRenderHUD(arg0: Internal.MobEffectInstance): boolean
        shouldRender(arg0: Internal.MobEffectInstance): boolean
        shouldRenderInvText(arg0: Internal.MobEffectInstance): boolean
        renderHUDEffect(arg0: Internal.MobEffectInstance, arg1: Internal.GuiComponent, arg2: Internal.PoseStack, arg3: number, arg4: number, arg5: number, arg6: number): void
        static readonly DUMMY : Internal.EffectRenderer;
    }
    class RegistryAccess {
    }
    interface ContainerEventHandler implements Internal.GuiEventListener {
    }
    class HideJEIEventJS <T> extends Internal.EventJS {
        hide(o: object): void
        getAllIngredients(): Internal.Collection<T>
        hideAll(): void
        get allIngredients(): Internal.Collection<T>;
    }
    interface StringBuilderAppendable {
        appendString(arg0: Internal.StringBuilder): void
    }
    interface ChannelOutboundBuffer$MessageProcessor {
        processMessage(arg0: object): boolean
    }
    class IERecipeJS extends Internal.RecipeJS {
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS
        time(t: number): Internal.IERecipeJS
        parseResultItem(o: object): Internal.ItemStackJS
        energy(e: number): Internal.IERecipeJS
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<object>;
        readonly inputFluids : Internal.List<Internal.FluidTagInput>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        serializeInputs : boolean;
    }
    interface CustomJavaObjectWrapper$AsList implements Internal.CustomJavaObjectWrapper {
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, staticType: Internal.Class<object>): Internal.Scriptable
        wrapAsJavaList(): Internal.List<object>
    }
    class Duration implements Internal.TemporalAmount, Internal.Comparable<Internal.Duration>, Internal.Serializable {
        negated(): Internal.Duration
        plusHours(arg0: number): Internal.Duration
        compareTo(arg0: object): number
        compareTo(arg0: Internal.Duration): number
        multipliedBy(arg0: number): Internal.Duration
        plusSeconds(arg0: number): Internal.Duration
        toMillis(): number
        static from(arg0: Internal.TemporalAmount): Internal.Duration
        plusNanos(arg0: number): Internal.Duration
        static ofMinutes(arg0: number): Internal.Duration
        static between(arg0: Internal.Temporal, arg1: Internal.Temporal): Internal.Duration
        static ofSeconds(arg0: number, arg1: number): Internal.Duration
        static ofSeconds(arg0: number): Internal.Duration
        truncatedTo(arg0: Internal.TemporalUnit): Internal.Duration
        minusNanos(arg0: number): Internal.Duration
        getNano(): number
        toMillisPart(): number
        plus(arg0: Internal.Duration): Internal.Duration
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Duration
        toMinutesPart(): number
        toNanos(): number
        toMinutes(): number
        toHours(): number
        plusMillis(arg0: number): Internal.Duration
        subtractFrom(arg0: Internal.Temporal): Internal.Temporal
        toSecondsPart(): number
        static ofMillis(arg0: number): Internal.Duration
        minus(arg0: Internal.Duration): Internal.Duration
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Duration
        minusHours(arg0: number): Internal.Duration
        withSeconds(arg0: number): Internal.Duration
        minusMillis(arg0: number): Internal.Duration
        plusMinutes(arg0: number): Internal.Duration
        toSeconds(): number
        dividedBy(arg0: number): Internal.Duration
        dividedBy(arg0: Internal.Duration): number
        minusMinutes(arg0: number): Internal.Duration
        plusDays(arg0: number): Internal.Duration
        hashCode(): number
        static of(arg0: number, arg1: Internal.TemporalUnit): Internal.Duration
        get(arg0: Internal.TemporalUnit): number
        isZero(): boolean
        toDays(): number
        toNanosPart(): number
        isNegative(): boolean
        static ofDays(arg0: number): Internal.Duration
        static parse(arg0: Internal.CharSequence): Internal.Duration
        minusDays(arg0: number): Internal.Duration
        toHoursPart(): number
        toDaysPart(): number
        static ofNanos(arg0: number): Internal.Duration
        getSeconds(): number
        abs(): Internal.Duration
        static ofHours(arg0: number): Internal.Duration
        withNanos(arg0: number): Internal.Duration
        equals(arg0: object): boolean
        getUnits(): Internal.List<Internal.TemporalUnit>
        addTo(arg0: Internal.Temporal): Internal.Temporal
        toString(): string
        minusSeconds(arg0: number): Internal.Duration
        static readonly ZERO : Internal.Duration;
        get nano(): number;
        get seconds(): number;
        get units(): Internal.List<Internal.TemporalUnit>;
    }
    interface DomainCombiner {
        combine(arg0: Internal.ProtectionDomain[], arg1: Internal.ProtectionDomain[]): Internal.ProtectionDomain[]
    }
    interface Promise <V> implements io.netty.util.concurrent.Future<V> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.Promise<V>
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        getNow(): V
        cause(): Internal.Throwable
        awaitUninterruptibly(): Internal.Promise<V>
        awaitUninterruptibly(): io.netty.util.concurrent.Future<V>
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.Promise<V>
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        tryFailure(arg0: Internal.Throwable): boolean
        isDone(): boolean
        sync(): Internal.Promise<V>
        sync(): io.netty.util.concurrent.Future<V>
        setSuccess(arg0: V): Internal.Promise<V>
        setFailure(arg0: Internal.Throwable): Internal.Promise<V>
        trySuccess(arg0: V): boolean
        syncUninterruptibly(): Internal.Promise<V>
        syncUninterruptibly(): io.netty.util.concurrent.Future<V>
        get(arg0: number, arg1: Internal.TimeUnit): V
        get(): V
        isCancellable(): boolean
        await(): Internal.Promise<V>
        await(): io.netty.util.concurrent.Future<V>
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.Promise<V>
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        isSuccess(): boolean
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.Promise<V>
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        setUncancellable(): boolean
        get now(): V;
        set success(arg0: V);
        set failure(arg0: Internal.Throwable);
    }
    class StartupEventJS extends Internal.EventJS {
        post(id: string): boolean
        post(id: string, sub: string): boolean
    }
    class ServerSettings {
        static exportData(): void
        logInvalidRecipeHandlers : boolean;
        useOriginalRecipeForFilters : boolean;
        dataPackOutput : boolean;
        logSkippedRecipes : boolean;
        static instance : Internal.ServerSettings;
        logOverrides : boolean;
        logErroringRecipes : boolean;
        static source : Internal.CommandSourceStack;
        logAddedRecipes : boolean;
        logRemovedRecipes : boolean;
        static dataExport : Internal.JsonObject;
    }
    class ChannelMetadata {
        hasDisconnect(): boolean
        defaultMaxMessagesPerRead(): number
    }
    class MapJS extends Internal.LinkedHashMap<string, object> implements Internal.StringBuilderAppendable, Internal.ChangeListener<object>, Internal.Copyable, Internal.JsonSerializable, Internal.NBTSerializable {
        static nbt(map: object): Internal.CompoundTag
        appendString(builder: Internal.StringBuilder): void
        onChanged(o: object): void
        containsAll(other: Internal.MapJS): boolean
        containsAny(other: Internal.MapJS): boolean
        clear(): void
        static isNbt(o: object): boolean
        put(key: string, value: object): object
        put(arg0: object, arg1: object): object
        remove(key: object): object
        toJson(): Internal.JsonObject
        toJson(): Internal.JsonElement
        toNBT(): Internal.CompoundTag
        toNBT(): net.minecraft.nbt.Tag
        getOrNewList(id: string): Internal.ListJS
        getOrNewMap(id: string): Internal.MapJS
        putAll(m: Map<string, object>): void
        static of(o: object): Internal.MapJS
        static json(map: object): Internal.JsonObject
        getLength(): number
        toString(): string
        copy(): Internal.MapJS
        copy(): Internal.Copyable
        changeListener : Internal.ChangeListener<Internal.MapJS>;
        get length(): number;
    }
    class OrCondition implements Internal.IExtendedLootCondition {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        test(arg0: Internal.LootContext): boolean
        test(arg0: object): boolean
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
    }
    class LocalDate implements Internal.Temporal, Internal.TemporalAdjuster, Internal.ChronoLocalDate, Internal.Serializable {
        atStartOfDay(arg0: Internal.ZoneId): Internal.ZonedDateTime
        atStartOfDay(): Internal.LocalDateTime
        toEpochDay(): number
        isEqual(arg0: Internal.ChronoLocalDate): boolean
        compareTo(arg0: object): number
        compareTo(arg0: Internal.ChronoLocalDate): number
        getDayOfWeek(): Internal.DayOfWeek
        lengthOfMonth(): number
        getEra(): Internal.IsoEra
        getEra(): Internal.Era
        static from(arg0: Internal.TemporalAccessor): Internal.LocalDate
        getMonth(): Internal.Month
        static ofYearDay(arg0: number, arg1: number): Internal.LocalDate
        plusMonths(arg0: number): Internal.LocalDate
        plusYears(arg0: number): Internal.LocalDate
        query<R>(arg0: Internal.TemporalQuery<R>): R
        format(arg0: Internal.DateTimeFormatter): string
        isSupported(arg0: Internal.TemporalUnit): boolean
        isSupported(arg0: Internal.TemporalField): boolean
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDate
        plus(arg0: Internal.TemporalAmount): Internal.LocalDate
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDate
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.LocalDate
        atTime(arg0: Internal.LocalTime): Internal.ChronoLocalDateTime<any>
        atTime(arg0: Internal.LocalTime): Internal.LocalDateTime
        atTime(arg0: number, arg1: number, arg2: number, arg3: number): Internal.LocalDateTime
        atTime(arg0: Internal.OffsetTime): Internal.OffsetDateTime
        atTime(arg0: number, arg1: number): Internal.LocalDateTime
        atTime(arg0: number, arg1: number, arg2: number): Internal.LocalDateTime
        getYear(): number
        toEpochSecond(arg0: Internal.LocalTime, arg1: Internal.ZoneOffset): number
        withDayOfMonth(arg0: number): Internal.LocalDate
        withMonth(arg0: number): Internal.LocalDate
        isAfter(arg0: Internal.ChronoLocalDate): boolean
        static ofInstant(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.LocalDate
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDate
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.LocalDate
        minus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDate
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: Internal.TemporalAmount): Internal.LocalDate
        datesUntil(arg0: Internal.LocalDate, arg1: Internal.Period): Internal.Stream<Internal.LocalDate>
        datesUntil(arg0: Internal.LocalDate): Internal.Stream<Internal.LocalDate>
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        withYear(arg0: number): Internal.LocalDate
        lengthOfYear(): number
        plusDays(arg0: number): Internal.LocalDate
        hashCode(): number
        static now(arg0: Internal.Clock): Internal.LocalDate
        static now(): Internal.LocalDate
        static now(arg0: Internal.ZoneId): Internal.LocalDate
        static of(arg0: number, arg1: number, arg2: number): Internal.LocalDate
        static of(arg0: number, arg1: Internal.Month, arg2: number): Internal.LocalDate
        get(arg0: Internal.TemporalField): number
        getDayOfYear(): number
        plusWeeks(arg0: number): Internal.LocalDate
        getChronology(): Internal.Chronology
        getChronology(): Internal.IsoChronology
        static ofEpochDay(arg0: number): Internal.LocalDate
        getMonthValue(): number
        minusYears(arg0: number): Internal.LocalDate
        minusWeeks(arg0: number): Internal.LocalDate
        withDayOfYear(arg0: number): Internal.LocalDate
        isLeapYear(): boolean
        static parse(arg0: Internal.CharSequence): Internal.LocalDate
        static parse(arg0: Internal.CharSequence, arg1: Internal.DateTimeFormatter): Internal.LocalDate
        isBefore(arg0: Internal.ChronoLocalDate): boolean
        minusDays(arg0: number): Internal.LocalDate
        getLong(arg0: Internal.TemporalField): number
        minusMonths(arg0: number): Internal.LocalDate
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.ChronoLocalDate
        with(arg0: Internal.TemporalAdjuster): Internal.LocalDate
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalField, arg1: number): Internal.ChronoLocalDate
        with(arg0: Internal.TemporalField, arg1: number): Internal.LocalDate
        equals(arg0: object): boolean
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        until(arg0: Internal.ChronoLocalDate): Internal.ChronoPeriod
        until(arg0: Internal.ChronoLocalDate): Internal.Period
        toString(): string
        getDayOfMonth(): number
        static readonly MIN : Internal.LocalDate;
        static readonly MAX : Internal.LocalDate;
        static readonly EPOCH : Internal.LocalDate;
        get dayOfWeek(): Internal.DayOfWeek;
        get era(): Internal.IsoEra;
        get era(): Internal.Era;
        get month(): Internal.Month;
        get year(): number;
        get dayOfYear(): number;
        get chronology(): Internal.Chronology;
        get chronology(): Internal.IsoChronology;
        get monthValue(): number;
        get dayOfMonth(): number;
    }
    interface IForgeItem {
        canElytraFly(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        getTags(): Internal.Set<ResourceLocation>
        setDamage(arg0: Internal.ItemStack, arg1: number): void
        canPerformAction(arg0: Internal.ItemStack, arg1: Internal.ToolAction): boolean
        damageItem<T>(arg0: Internal.ItemStack, arg1: number, arg2: T, arg3: (arg0: T) => void): number
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getItemEnchantability(arg0: Internal.ItemStack): number
        shouldCauseReequipAnimation(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: boolean): boolean
        getXpRepairRatio(arg0: Internal.ItemStack): number
        readShareTag(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): void
        onEntityItemUpdate(arg0: Internal.ItemStack, arg1: Internal.ItemEntity): boolean
        getDamage(arg0: Internal.ItemStack): number
        isBookEnchantable(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.LivingEntity, arg3: Internal.LivingEntity): boolean
        onUsingTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): void
        createEntity(arg0: Internal.Level, arg1: Internal.Entity, arg2: Internal.ItemStack): Internal.Entity
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>
        isPiglinCurrency(arg0: Internal.ItemStack): boolean
        getSweepHitBox(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): Internal.AABB
        isRepairable(arg0: Internal.ItemStack): boolean
        getShareTag(arg0: Internal.ItemStack): Internal.CompoundTag
        isDamageable(arg0: Internal.ItemStack): boolean
        getBurnTime(arg0: Internal.ItemStack, arg1: Internal.RecipeType<object>): number
        onDroppedByPlayer(arg0: Internal.ItemStack, arg1: Internal.Player): boolean
        onEntitySwing(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        elytraFlightTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean
        getAttributeModifiers(arg0: EquipmentSlot, arg1: Internal.ItemStack): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>
        onLeftClickEntity(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): boolean
        canEquip(arg0: Internal.ItemStack, arg1: EquipmentSlot, arg2: Internal.Entity): boolean
        onBlockStartBreak(arg0: Internal.ItemStack, arg1: BlockPos, arg2: Internal.Player): boolean
        onHorseArmorTick(arg0: Internal.ItemStack, arg1: Internal.Level, arg2: Internal.Mob): void
        canContinueUsing(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean
        getEntityLifespan(arg0: Internal.ItemStack, arg1: Internal.Level): number
        getArmorTexture(arg0: Internal.ItemStack, arg1: Internal.Entity, arg2: EquipmentSlot, arg3: string): string
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack): number
        hasCustomEntity(arg0: Internal.ItemStack): boolean
        getHighlightTip(arg0: Internal.ItemStack, arg1: Internal.Component): Internal.Component
        getMaxDamage(arg0: Internal.ItemStack): number
        getCreatorModId(arg0: Internal.ItemStack): string
        isDamaged(arg0: Internal.ItemStack): boolean
        onArmorTick(arg0: Internal.ItemStack, arg1: Internal.Level, arg2: Internal.Player): void
        hasContainerItem(arg0: Internal.ItemStack): boolean
        doesSneakBypassUse(arg0: Internal.ItemStack, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Player): boolean
        onItemUseFirst(arg0: Internal.ItemStack, arg1: Internal.UseOnContext): Internal.InteractionResult
        getContainerItem(arg0: Internal.ItemStack): Internal.ItemStack
        isCorrectToolForDrops(arg0: Internal.ItemStack, arg1: Internal.BlockState): boolean
        getEquipmentSlot(arg0: Internal.ItemStack): EquipmentSlot
        getItemStackLimit(arg0: Internal.ItemStack): number
        initCapabilities(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): Internal.ICapabilityProvider
        makesPiglinsNeutral(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean
        isEnderMask(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.EnderMan): boolean
        canApplyAtEnchantingTable(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean
        get tags(): Internal.Set<ResourceLocation>;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
    }
    interface FunctionContainer {
        lootingEnchant(count: Internal.NumberProvider, limit: number): Internal.FunctionContainer
        damage(damage: Internal.NumberProvider): Internal.FunctionContainer
        nbt(tag: Internal.CompoundTag): Internal.FunctionContainer
        enchantWithLevels(levels: Internal.NumberProvider, treasure: boolean): Internal.FunctionContainer
        lootTable(table: ResourceLocation, seed: number): Internal.FunctionContainer
        addFunction(arg0: Internal.JsonObject): Internal.FunctionContainer
        copyName(source: Internal.CopyNameFunction$NameSource): Internal.FunctionContainer
        count(count: Internal.NumberProvider): Internal.FunctionContainer
        name(name: Internal.Text, entity: Internal.LootContext$EntityTarget): Internal.FunctionContainer
        name(name: Internal.Text): Internal.FunctionContainer
        furnaceSmelt(): Internal.FunctionContainer
        addConditionalFunction(func: (arg0: Internal.ConditionalFunction) => void): Internal.FunctionContainer
        enchantRandomly(enchantments: ResourceLocation[]): Internal.FunctionContainer
    }
    interface PrimitiveIterator$OfDouble implements Internal.PrimitiveIterator<number, Internal.DoubleConsumer> {
        next(): object
        next(): number
        hasNext(): boolean
        forEachRemaining(arg0: object): void
        forEachRemaining(arg0: Internal.DoubleConsumer): void
        forEachRemaining(arg0: (arg0: number) => void): void
        remove(): void
        nextDouble(): number
    }
    interface ServerLevelAccessor implements Internal.LevelAccessor {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
    }
    interface CustomIngredientActionCallback {
        transform(arg0: Internal.ItemStackJS, arg1: number, arg2: Internal.InventoryJS): object
    }
    class InterfaceAddress {
        getBroadcast(): Internal.InetAddress
        hashCode(): number
        equals(arg0: object): boolean
        getNetworkPrefixLength(): number
        getAddress(): Internal.InetAddress
        toString(): string
        get broadcast(): Internal.InetAddress;
        get networkPrefixLength(): number;
        get address(): Internal.InetAddress;
    }
    interface Short2ObjectFunction <V> implements Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: number, arg1: V): V
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Object2ShortFunction<V>): Internal.Short2ShortFunction
        composeByte(arg0: Internal.Byte2ShortFunction): Internal.Byte2ObjectFunction<V>
        andThenInt(arg0: Internal.Object2IntFunction<V>): Internal.Short2IntFunction
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: Internal.Reference2ShortFunction<T>): (arg0: T) => V
        put(arg0: number, arg1: V): V
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: object): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: Internal.Object2DoubleFunction<V>): Internal.Short2DoubleFunction
        andThenObject<T>(arg0: (arg0: V) => T): Internal.Short2ObjectFunction<T>
        get(arg0: object): V
        get(arg0: number): V
        andThenLong(arg0: Internal.Object2LongFunction<V>): Internal.Short2LongFunction
        composeLong(arg0: Internal.Long2ShortFunction): Internal.Long2ObjectFunction<V>
        andThenByte(arg0: Internal.Object2ByteFunction<V>): Internal.Short2ByteFunction
        andThenFloat(arg0: Internal.Object2FloatFunction<V>): Internal.Short2FloatFunction
        apply(arg0: number): V
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ShortFunction): Internal.Int2ObjectFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2ShortFunction): Internal.Float2ObjectFunction<V>
        andThenChar(arg0: Internal.Object2CharFunction<V>): Internal.Short2CharFunction
        composeObject<T>(arg0: Internal.Object2ShortFunction<T>): (arg0: T) => V
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => V
        composeShort(arg0: Internal.Short2ShortFunction): Internal.Short2ObjectFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): Internal.Short2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ShortFunction): Internal.Char2ObjectFunction<V>
        composeDouble(arg0: Internal.Double2ShortFunction): Internal.Double2ObjectFunction<V>
    }
    class Quaternion {
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
    }
    interface Long2FloatFunction implements Internal.Function<number, number>, Internal.LongToDoubleFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: Internal.Float2ShortFunction): Internal.Long2ShortFunction
        composeByte(arg0: Internal.Byte2LongFunction): Internal.Byte2FloatFunction
        andThenInt(arg0: Internal.Float2IntFunction): Internal.Long2IntFunction
        composeReference<T>(arg0: Internal.Reference2LongFunction<T>): Internal.Reference2FloatFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Float2DoubleFunction): Internal.Long2DoubleFunction
        andThenObject<T>(arg0: Internal.Float2ObjectFunction<T>): Internal.Long2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Float2LongFunction): Internal.Long2LongFunction
        composeLong(arg0: Internal.Long2LongFunction): Internal.Long2FloatFunction
        andThenByte(arg0: Internal.Float2ByteFunction): Internal.Long2ByteFunction
        andThenFloat(arg0: Internal.Float2FloatFunction): Internal.Long2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2LongFunction): Internal.Int2FloatFunction
        clear(): void
        composeFloat(arg0: Internal.Float2LongFunction): Internal.Float2FloatFunction
        andThenChar(arg0: Internal.Float2CharFunction): Internal.Long2CharFunction
        composeObject<T>(arg0: Internal.Object2LongFunction<T>): Internal.Object2FloatFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2LongFunction): Internal.Short2FloatFunction
        andThenReference<T>(arg0: Internal.Float2ReferenceFunction<T>): Internal.Long2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2LongFunction): Internal.Char2FloatFunction
        composeDouble(arg0: Internal.Double2LongFunction): Internal.Double2FloatFunction
    }
    class Properties extends Internal.Hashtable<object, object> {
        getOrDefault(arg0: object, arg1: object): object
        loadFromXML(arg0: Internal.InputStream): void
        keys(): Internal.Enumeration<object>
        computeIfAbsent(arg0: object, arg1: (arg0: object) => object): object
        values(): Internal.Collection<object>
        save(arg0: Internal.OutputStream, arg1: string): void
        replace(arg0: object, arg1: object, arg2: object): boolean
        replace(arg0: object, arg1: object): object
        replaceAll(arg0: (arg0: object, arg1: object) => object): void
        containsValue(arg0: object): boolean
        put(arg0: object, arg1: object): object
        remove(arg0: object): object
        remove(arg0: object, arg1: object): boolean
        compute(arg0: object, arg1: (arg0: object, arg1: object) => object): object
        load(arg0: Internal.Reader): void
        load(arg0: Internal.InputStream): void
        hashCode(): number
        putAll(arg0: Map<object, object>): void
        merge(arg0: object, arg1: object, arg2: (arg0: object, arg1: object) => object): object
        get(arg0: object): object
        keySet(): Internal.Set<object>
        getProperty(arg0: string): string
        getProperty(arg0: string, arg1: string): string
        entrySet(): Internal.Set<Internal.Map$Entry<object, object>>
        containsKey(arg0: object): boolean
        forEach(arg0: (arg0: object, arg1: object) => void): void
        stringPropertyNames(): Internal.Set<string>
        isEmpty(): boolean
        clear(): void
        store(arg0: Internal.OutputStream, arg1: string): void
        store(arg0: Internal.Writer, arg1: string): void
        list(arg0: Internal.PrintStream): void
        list(arg0: Internal.PrintWriter): void
        storeToXML(arg0: Internal.OutputStream, arg1: string, arg2: string): void
        storeToXML(arg0: Internal.OutputStream, arg1: string): void
        storeToXML(arg0: Internal.OutputStream, arg1: string, arg2: Internal.Charset): void
        contains(arg0: object): boolean
        computeIfPresent(arg0: object, arg1: (arg0: object, arg1: object) => object): object
        size(): number
        propertyNames(): Internal.Enumeration<object>
        setProperty(arg0: string, arg1: string): object
        elements(): Internal.Enumeration<object>
        equals(arg0: object): boolean
        clone(): object
        toString(): string
        putIfAbsent(arg0: object, arg1: object): object
    }
    class ScriptType extends Internal.Enum<Internal.ScriptType> {
        isServer(): boolean
        static valueOf(name: string): Internal.ScriptType
        static of(level: Internal.LevelReader): Internal.ScriptType
        static values(): Internal.ScriptType[]
        isClient(): boolean
        getLogFile(): Internal.Path
        readonly console : Internal.ConsoleJS;
        readonly manager : () => Internal.ScriptManager;
        static readonly SERVER : Internal.ScriptType;
        readonly executor : Internal.ExecutorService;
        readonly warnings : Internal.List<string>;
        readonly name : string;
        static readonly STARTUP : Internal.ScriptType;
        static readonly CLIENT : Internal.ScriptType;
        readonly errors : Internal.List<string>;
        get logFile(): Internal.Path;
    }
    class ImmutableMap$Builder <K, V> {
        buildOrThrow(): Internal.ImmutableMap<K, V>
        build(): Internal.ImmutableMap<K, V>
        putAll(arg0: Internal.Iterable<Internal.Map$Entry<K, V>>): Internal.ImmutableMap$Builder<K, V>
        putAll(arg0: Map<K, V>): Internal.ImmutableMap$Builder<K, V>
        orderEntriesByValue(arg0: Internal.Comparator<V>): Internal.ImmutableMap$Builder<K, V>
        put(arg0: K, arg1: V): Internal.ImmutableMap$Builder<K, V>
        put(arg0: Internal.Map$Entry<K, V>): Internal.ImmutableMap$Builder<K, V>
    }
    interface WithAttachedData {
        getData(): Internal.AttachedData
        get data(): Internal.AttachedData;
    }
    class ModuleDescriptor$Requires$Modifier extends Internal.Enum<Internal.ModuleDescriptor$Requires$Modifier> {
        static valueOf(arg0: string): Internal.ModuleDescriptor$Requires$Modifier
        static values(): Internal.ModuleDescriptor$Requires$Modifier[]
        static readonly TRANSITIVE : Internal.ModuleDescriptor$Requires$Modifier;
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Requires$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Requires$Modifier;
        static readonly STATIC : Internal.ModuleDescriptor$Requires$Modifier;
    }
    interface Serializable {
    }
    class EntityInstance <E> extends Internal.AbstractInstance implements Internal.LightListener, Internal.MovingListener {
        getVolume(): Internal.GridAlignedBB
        getVolume(): Internal.ImmutableBox
        getInstancePosition(arg0: number): Internal.Vector3f
        getInstancePosition(): Internal.Vector3f
        update(arg0: Internal.LightProvider): boolean
        getWorldPosition(): BlockPos
        readonly world : Internal.Level;
        get volume(): Internal.GridAlignedBB;
        get volume(): Internal.ImmutableBox;
        get instancePosition(): Internal.Vector3f;
        get worldPosition(): BlockPos;
    }
    class ChannelHandlerAdapter implements Internal.ChannelHandler {
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void
        handlerAdded(arg0: Internal.ChannelHandlerContext): void
        isSharable(): boolean
        handlerRemoved(arg0: Internal.ChannelHandlerContext): void
    }
    interface ObjectCollection <K> implements Internal.Collection<K>, Internal.ObjectIterable<K> {
        add(arg0: E): boolean
        spliterator(): Internal.ObjectSpliterator<K>
        spliterator(): Internal.Spliterator<any>
        forEach(arg0: (arg0: T) => void): void
        containsAll(arg0: Internal.Collection<object>): boolean
        isEmpty(): boolean
        clear(): void
        remove(arg0: object): boolean
        removeIf(arg0: (arg0: E) => boolean): boolean
        removeAll(arg0: Internal.Collection<object>): boolean
        contains(arg0: object): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.ObjectIterator<K>
        size(): number
        addAll(arg0: Internal.Collection<E>): boolean
        stream(): Internal.Stream<E>
        hashCode(): number
        equals(arg0: object): boolean
        toArray<T>(arg0: T[]): T[]
        toArray<T>(arg0: Internal.IntFunction<T[]>): T[]
        toArray(): object[]
        parallelStream(): Internal.Stream<E>
        retainAll(arg0: Internal.Collection<object>): boolean
    }
    interface ScheduledExecutorService implements Internal.ExecutorService {
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<object>
        schedule<V>(arg0: java_.util.concurrent.Callable<V>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<object>
        submit(arg0: Internal.Runnable): Internal.Future<object>
        submit<T>(arg0: Internal.Runnable, arg1: T): Internal.Future<T>
        submit<T>(arg0: java_.util.concurrent.Callable<T>): Internal.Future<T>
        isTerminated(): boolean
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<object>
        invokeAll<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<Internal.Future<T>>
        invokeAll<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>): Internal.List<Internal.Future<T>>
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean
        invokeAny<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>): T
        invokeAny<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>, arg1: number, arg2: Internal.TimeUnit): T
        shutdownNow(): Internal.List<Internal.Runnable>
        execute(arg0: Internal.Runnable): void
        shutdown(): void
        isShutdown(): boolean
    }
    interface Byte2IntFunction implements Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Int2ShortFunction): Internal.Byte2ShortFunction
        composeByte(arg0: Internal.Byte2ByteFunction): Internal.Byte2IntFunction
        andThenInt(arg0: Internal.Int2IntFunction): Internal.Byte2IntFunction
        composeReference<T>(arg0: Internal.Reference2ByteFunction<T>): Internal.Reference2IntFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Int2DoubleFunction): Internal.Byte2DoubleFunction
        andThenObject<T>(arg0: Internal.Int2ObjectFunction<T>): Internal.Byte2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Int2LongFunction): Internal.Byte2LongFunction
        composeLong(arg0: Internal.Long2ByteFunction): Internal.Long2IntFunction
        andThenByte(arg0: Internal.Int2ByteFunction): Internal.Byte2ByteFunction
        andThenFloat(arg0: Internal.Int2FloatFunction): Internal.Byte2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ByteFunction): Internal.Int2IntFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ByteFunction): Internal.Float2IntFunction
        andThenChar(arg0: Internal.Int2CharFunction): Internal.Byte2CharFunction
        composeObject<T>(arg0: Internal.Object2ByteFunction<T>): Internal.Object2IntFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2ByteFunction): Internal.Short2IntFunction
        andThenReference<T>(arg0: Internal.Int2ReferenceFunction<T>): Internal.Byte2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ByteFunction): Internal.Char2IntFunction
        composeDouble(arg0: Internal.Double2ByteFunction): Internal.Double2IntFunction
    }
    interface Reference2ReferenceFunction <K, V> implements Internal.Function<K, V> {
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Reference2ShortFunction<V>): Internal.Reference2ShortFunction<K>
        composeByte(arg0: Internal.Byte2ReferenceFunction<K>): Internal.Byte2ReferenceFunction<V>
        andThenInt(arg0: Internal.Reference2IntFunction<V>): Internal.Reference2IntFunction<K>
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: (arg0: T) => K): (arg0: T) => V
        put(arg0: K, arg1: V): V
        remove(arg0: object): V
        defaultReturnValue(): V
        defaultReturnValue(arg0: V): void
        andThenDouble(arg0: Internal.Reference2DoubleFunction<V>): Internal.Reference2DoubleFunction<K>
        andThenObject<T>(arg0: (arg0: V) => T): (arg0: K) => T
        get(arg0: object): V
        andThenLong(arg0: Internal.Reference2LongFunction<V>): Internal.Reference2LongFunction<K>
        composeLong(arg0: Internal.Long2ReferenceFunction<K>): Internal.Long2ReferenceFunction<V>
        andThenByte(arg0: Internal.Reference2ByteFunction<V>): Internal.Reference2ByteFunction<K>
        andThenFloat(arg0: Internal.Reference2FloatFunction<V>): Internal.Reference2FloatFunction<K>
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ReferenceFunction<K>): Internal.Int2ReferenceFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2ReferenceFunction<K>): Internal.Float2ReferenceFunction<V>
        andThenChar(arg0: Internal.Reference2CharFunction<V>): Internal.Reference2CharFunction<K>
        composeObject<T>(arg0: (arg0: T) => K): (arg0: T) => V
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ReferenceFunction<K>): Internal.Short2ReferenceFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): (arg0: K) => T
        composeChar(arg0: Internal.Char2ReferenceFunction<K>): Internal.Char2ReferenceFunction<V>
        composeDouble(arg0: Internal.Double2ReferenceFunction<K>): Internal.Double2ReferenceFunction<V>
    }
    class Registry <T> implements Internal.Keyable, Internal.IdMap<T> {
        iterator(): Internal.Iterator<T>
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
        keys<U>(arg0: Internal.DynamicOps<U>): Internal.Stream<U>
        toString(): string
    }
    interface Object2ByteFunction <K> implements Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: number): number
        getByte(arg0: object): number
        andThenShort(arg0: Internal.Byte2ShortFunction): Internal.Object2ShortFunction<K>
        composeByte(arg0: Internal.Byte2ObjectFunction<K>): Internal.Byte2ByteFunction
        andThenInt(arg0: Internal.Byte2IntFunction): Internal.Object2IntFunction<K>
        composeReference<T>(arg0: (arg0: T) => K): Internal.Reference2ByteFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: K) => T
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: object, arg1: object): object
        remove(arg0: object): number
        remove(arg0: object): object
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: Internal.Byte2DoubleFunction): Internal.Object2DoubleFunction<K>
        andThenObject<T>(arg0: Internal.Byte2ObjectFunction<T>): (arg0: K) => T
        get(arg0: object): object
        get(arg0: object): number
        andThenLong(arg0: Internal.Byte2LongFunction): Internal.Object2LongFunction<K>
        composeLong(arg0: Internal.Long2ObjectFunction<K>): Internal.Long2ByteFunction
        removeByte(arg0: object): number
        andThenByte(arg0: Internal.Byte2ByteFunction): Internal.Object2ByteFunction<K>
        andThenFloat(arg0: Internal.Byte2FloatFunction): Internal.Object2FloatFunction<K>
        applyAsInt(arg0: K): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ObjectFunction<K>): Internal.Int2ByteFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ObjectFunction<K>): Internal.Float2ByteFunction
        andThenChar(arg0: Internal.Byte2CharFunction): Internal.Object2CharFunction<K>
        composeObject<T>(arg0: (arg0: T) => K): Internal.Object2ByteFunction<T>
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ObjectFunction<K>): Internal.Short2ByteFunction
        andThenReference<T>(arg0: Internal.Byte2ReferenceFunction<T>): (arg0: K) => T
        composeChar(arg0: Internal.Char2ObjectFunction<K>): Internal.Char2ByteFunction
        composeDouble(arg0: Internal.Double2ObjectFunction<K>): Internal.Double2ByteFunction
    }
    interface ContextAction <T> {
        run(arg0: Internal.Context): T
    }
    interface BlockPredicate {
        check(arg0: Internal.BlockContainerJS): boolean
    }
    class MultipartBlockStateGenerator {
        toJson(): Internal.JsonObject
        part(when: string, model: string): void
        part(when: string, consumer: (arg0: Internal.MultipartBlockStateGenerator$Part) => void): void
    }
    class PlantType {
        getName(): string
        static get(arg0: string): Internal.PlantType
        static readonly BEACH : Internal.PlantType;
        static readonly CAVE : Internal.PlantType;
        static readonly NETHER : Internal.PlantType;
        static readonly PLAINS : Internal.PlantType;
        static readonly DESERT : Internal.PlantType;
        static readonly WATER : Internal.PlantType;
        static readonly CROP : Internal.PlantType;
        get name(): string;
    }
    class Products$P8 <F, T1, T2, T3, T4, T5, T6, T7, T8> {
        t4(): Internal.App<F, T4>
        t5(): Internal.App<F, T5>
        t6(): Internal.App<F, T6>
        t7(): Internal.App<F, T7>
        t8(): Internal.App<F, T8>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>>): Internal.App<F, R>
        t1(): Internal.App<F, T1>
        t2(): Internal.App<F, T2>
        t3(): Internal.App<F, T3>
    }
    class Instant implements Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.Instant>, Internal.Serializable {
        static ofEpochSecond(arg0: number, arg1: number): Internal.Instant
        static ofEpochSecond(arg0: number): Internal.Instant
        minus(arg0: Internal.TemporalAmount): Internal.Instant
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Instant
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        static ofEpochMilli(arg0: number): Internal.Instant
        range(arg0: Internal.TemporalField): Internal.ValueRange
        minusMillis(arg0: number): Internal.Instant
        compareTo(arg0: Internal.Instant): number
        compareTo(arg0: object): number
        hashCode(): number
        static now(): Internal.Instant
        static now(arg0: Internal.Clock): Internal.Instant
        get(arg0: Internal.TemporalField): number
        plusSeconds(arg0: number): Internal.Instant
        static from(arg0: Internal.TemporalAccessor): Internal.Instant
        plusNanos(arg0: number): Internal.Instant
        atOffset(arg0: Internal.ZoneOffset): Internal.OffsetDateTime
        truncatedTo(arg0: Internal.TemporalUnit): Internal.Instant
        query<R>(arg0: Internal.TemporalQuery<R>): R
        minusNanos(arg0: number): Internal.Instant
        getNano(): number
        toEpochMilli(): number
        static parse(arg0: Internal.CharSequence): Internal.Instant
        isSupported(arg0: Internal.TemporalField): boolean
        isSupported(arg0: Internal.TemporalUnit): boolean
        atZone(arg0: Internal.ZoneId): Internal.ZonedDateTime
        isBefore(arg0: Internal.Instant): boolean
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        plus(arg0: Internal.TemporalAmount): Internal.Instant
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Instant
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        getLong(arg0: Internal.TemporalField): number
        with(arg0: Internal.TemporalAdjuster): Internal.Instant
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        with(arg0: Internal.TemporalField, arg1: number): Internal.Instant
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        plusMillis(arg0: number): Internal.Instant
        equals(arg0: object): boolean
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        toString(): string
        minusSeconds(arg0: number): Internal.Instant
        getEpochSecond(): number
        isAfter(arg0: Internal.Instant): boolean
        static readonly MIN : Internal.Instant;
        static readonly MAX : Internal.Instant;
        static readonly EPOCH : Internal.Instant;
        get nano(): number;
        get epochSecond(): number;
    }
    class CopyNameFunction$NameSource extends Internal.Enum<Internal.CopyNameFunction$NameSource> {
        static valueOf(arg0: string): Internal.CopyNameFunction$NameSource
        static values(): Internal.CopyNameFunction$NameSource[]
        static readonly KILLER_PLAYER : Internal.CopyNameFunction$NameSource;
        static readonly KILLER : Internal.CopyNameFunction$NameSource;
        static readonly BLOCK_ENTITY : Internal.CopyNameFunction$NameSource;
        static readonly THIS : Internal.CopyNameFunction$NameSource;
    }
    interface Short2ReferenceFunction <V> implements Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: number, arg1: V): V
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Reference2ShortFunction<V>): Internal.Short2ShortFunction
        composeByte(arg0: Internal.Byte2ShortFunction): Internal.Byte2ReferenceFunction<V>
        andThenInt(arg0: Internal.Reference2IntFunction<V>): Internal.Short2IntFunction
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: Internal.Reference2ShortFunction<T>): (arg0: T) => V
        put(arg0: number, arg1: V): V
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: V): V
        remove(arg0: number): V
        remove(arg0: object): V
        defaultReturnValue(arg0: V): void
        defaultReturnValue(): V
        andThenDouble(arg0: Internal.Reference2DoubleFunction<V>): Internal.Short2DoubleFunction
        andThenObject<T>(arg0: (arg0: V) => T): Internal.Short2ObjectFunction<T>
        get(arg0: object): V
        get(arg0: number): V
        andThenLong(arg0: Internal.Reference2LongFunction<V>): Internal.Short2LongFunction
        composeLong(arg0: Internal.Long2ShortFunction): Internal.Long2ReferenceFunction<V>
        andThenByte(arg0: Internal.Reference2ByteFunction<V>): Internal.Short2ByteFunction
        andThenFloat(arg0: Internal.Reference2FloatFunction<V>): Internal.Short2FloatFunction
        apply(arg0: number): V
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ShortFunction): Internal.Int2ReferenceFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2ShortFunction): Internal.Float2ReferenceFunction<V>
        andThenChar(arg0: Internal.Reference2CharFunction<V>): Internal.Short2CharFunction
        composeObject<T>(arg0: Internal.Object2ShortFunction<T>): (arg0: T) => V
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => V
        composeShort(arg0: Internal.Short2ShortFunction): Internal.Short2ReferenceFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): Internal.Short2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ShortFunction): Internal.Char2ReferenceFunction<V>
        composeDouble(arg0: Internal.Double2ShortFunction): Internal.Double2ReferenceFunction<V>
    }
    interface Encoder <A> {
        encode<T>(arg0: A, arg1: Internal.DynamicOps<T>, arg2: T): Internal.DataResult<T>
        flatComap<B>(arg0: (arg0: B) => Internal.DataResult<A>): Internal.Encoder<B>
        comap<B>(arg0: (arg0: B) => A): Internal.Encoder<B>
        fieldOf(arg0: string): Internal.MapEncoder<A>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Encoder<A>
        static error<A>(arg0: string): Internal.Encoder<A>
        encodeStart<T>(arg0: Internal.DynamicOps<T>, arg1: A): Internal.DataResult<T>
        static empty<A>(): Internal.MapEncoder<A>
    }
    interface CopyOption {
    }
    interface IntSet implements Internal.IntCollection, Internal.Set<number> {
        intIterator(): Internal.IntIterator
        intSpliterator(): Internal.IntSpliterator
        remove(arg0: number): boolean
        remove(arg0: object): boolean
        intStream(): Internal.IntStream
        removeAll(arg0: Internal.IntCollection): boolean
        removeAll(arg0: Internal.Collection<object>): boolean
        iterator(): Internal.Iterator<any>
        iterator(): Internal.IntIterator
        stream(): Internal.Stream<number>
        hashCode(): number
        toIntArray(arg0: number[]): number[]
        toIntArray(): number[]
        static of(arg0: number, arg1: number): Internal.IntSet
        static of(): Internal.IntSet
        static of(arg0: number[]): Internal.IntSet
        static of(arg0: number): Internal.IntSet
        static of(arg0: number, arg1: number, arg2: number): Internal.IntSet
        toArray(arg0: number[]): number[]
        toArray<T>(arg0: T[]): T[]
        toArray<T>(arg0: Internal.IntFunction<T[]>): T[]
        toArray(): object[]
        parallelStream(): Internal.Stream<number>
        rem(arg0: number): boolean
        add(arg0: number): boolean
        add(arg0: object): boolean
        add(arg0: number): boolean
        spliterator(): Internal.IntSpliterator
        spliterator(): Internal.Spliterator<any>
        forEach(arg0: (arg0: number) => void): void
        forEach(arg0: java_.util.function_.IntConsumer): void
        forEach(arg0: Internal.IntConsumer): void
        containsAll(arg0: Internal.IntCollection): boolean
        containsAll(arg0: Internal.Collection<object>): boolean
        isEmpty(): boolean
        clear(): void
        removeIf(arg0: (arg0: number) => boolean): boolean
        removeIf(arg0: Internal.IntPredicate): boolean
        removeIf(arg0: it.unimi.dsi.fastutil.ints.IntPredicate): boolean
        contains(arg0: object): boolean
        contains(arg0: number): boolean
        size(): number
        addAll(arg0: Internal.IntCollection): boolean
        addAll(arg0: Internal.Collection<E>): boolean
        equals(arg0: object): boolean
        intParallelStream(): Internal.IntStream
        retainAll(arg0: Internal.IntCollection): boolean
        retainAll(arg0: Internal.Collection<object>): boolean
    }
    class Biome$BiomeCategory extends Internal.Enum<Internal.Biome$BiomeCategory> implements Internal.StringRepresentable {
        static valueOf(arg0: string): Internal.Biome$BiomeCategory
        static values(): Internal.Biome$BiomeCategory[]
        static readonly BEACH : Internal.Biome$BiomeCategory;
        static readonly UNDERGROUND : Internal.Biome$BiomeCategory;
        static readonly MESA : Internal.Biome$BiomeCategory;
        static readonly SAVANNA : Internal.Biome$BiomeCategory;
        static readonly THEEND : Internal.Biome$BiomeCategory;
        static readonly JUNGLE : Internal.Biome$BiomeCategory;
        static readonly OCEAN : Internal.Biome$BiomeCategory;
        static readonly TAIGA : Internal.Biome$BiomeCategory;
        static readonly MOUNTAIN : Internal.Biome$BiomeCategory;
        static readonly DESERT : Internal.Biome$BiomeCategory;
        static readonly RIVER : Internal.Biome$BiomeCategory;
        static readonly FOREST : Internal.Biome$BiomeCategory;
        static readonly MUSHROOM : Internal.Biome$BiomeCategory;
        static readonly NETHER : Internal.Biome$BiomeCategory;
        static readonly PLAINS : Internal.Biome$BiomeCategory;
        static readonly SWAMP : Internal.Biome$BiomeCategory;
        static readonly NONE : Internal.Biome$BiomeCategory;
        static readonly EXTREME_HILLS : Internal.Biome$BiomeCategory;
        static readonly ICY : Internal.Biome$BiomeCategory;
    }
    class Event {
        setCanceled(arg0: boolean): void
        getListenerList(): Internal.ListenerList
        isCanceled(): boolean
        setResult(arg0: Internal.Event$Result): void
        getResult(): Internal.Event$Result
        hasResult(): boolean
        isCancelable(): boolean
        getPhase(): Internal.EventPriority
        setPhase(arg0: Internal.EventPriority): void
        set canceled(arg0: boolean);
        get listenerList(): Internal.ListenerList;
        set result(arg0: Internal.Event$Result);
        get result(): Internal.Event$Result;
        get phase(): Internal.EventPriority;
        set phase(arg0: Internal.EventPriority);
    }
    class Clock implements Internal.InstantSource {
        withZone(arg0: Internal.ZoneId): Internal.Clock
        static tickMinutes(arg0: Internal.ZoneId): Internal.Clock
        static tickMillis(arg0: Internal.ZoneId): Internal.Clock
        static offset(arg0: Internal.Clock, arg1: Internal.Duration): Internal.Clock
        getZone(): Internal.ZoneId
        static tick(arg0: Internal.Clock, arg1: Internal.Duration): Internal.Clock
        instant(): Internal.Instant
        static system(arg0: Internal.ZoneId): Internal.Clock
        hashCode(): number
        equals(arg0: object): boolean
        static tickSeconds(arg0: Internal.ZoneId): Internal.Clock
        static systemDefaultZone(): Internal.Clock
        static systemUTC(): Internal.Clock
        static fixed(arg0: Internal.Instant, arg1: Internal.ZoneId): Internal.Clock
        millis(): number
        get zone(): Internal.ZoneId;
    }
    class AbstractTexture implements Internal.AutoCloseable {
        restoreLastBlurMipmap(): void
        setBlurMipmap(arg0: boolean, arg1: boolean): void
        close(): void
    }
    class IngredientStackJS implements Internal.IngredientJS {
        anyStackMatches(ingredient: Internal.IngredientJS): boolean
        getItemIds(): Internal.Set<string>
        testVanillaItem(item: Internal.Item): boolean
        test(stack: Internal.ItemStackJS): boolean
        getStacks(): Internal.Set<Internal.ItemStackJS>
        getVanillaItems(): Internal.Set<Internal.Item>
        isEmpty(): boolean
        isInvalidRecipeIngredient(): boolean
        asIngredientStack(): Internal.IngredientStackJS
        getVanillaPredicate(): (arg0: Internal.ItemStack) => boolean
        filter(filter: Internal.IngredientJS): Internal.IngredientJS
        createVanillaIngredient(): Internal.Ingredient
        toJson(): Internal.JsonElement
        not(): Internal.IngredientJS
        withCount(count: number): Internal.IngredientJS
        getIngredient(): Internal.IngredientJS
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>
        getFirst(): Internal.ItemStackJS
        testVanilla(stack: Internal.ItemStack): boolean
        x(c: number): Internal.IngredientJS
        toString(): string
        static stackOf(in_: Internal.IngredientJS): Internal.IngredientStackJS
        copy(): Internal.Copyable
        copy(): Internal.IngredientJS
        getCount(): number
        ingredientKey : string;
        ingredient : Internal.IngredientJS;
        countKey : string;
        get itemIds(): Internal.Set<string>;
        get stacks(): Internal.Set<Internal.ItemStackJS>;
        get vanillaItems(): Internal.Set<Internal.Item>;
        get vanillaPredicate(): (arg0: Internal.ItemStack) => boolean;
        get first(): Internal.ItemStackJS;
        get count(): number;
    }
    interface TickContainerAccess <T> implements Internal.TickAccess<T> {
    }
    class BlastFurnaceFuelRecipeJS extends Internal.IERecipeJS {
        serialize(): void
        create(args: Internal.ListJS): void
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<object>;
        readonly inputFluids : Internal.List<Internal.FluidTagInput>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        serializeInputs : boolean;
    }
    class ServerResources implements Internal.AutoCloseable {
        close(): void
    }
    class Enum <E> implements Internal.Constable, Internal.Comparable<E>, Internal.Serializable {
        getDeclaringClass(): Internal.Class<E>
        static valueOf<T>(arg0: Internal.Class<T>, arg1: string): T
        hashCode(): number
        equals(arg0: object): boolean
        name(): string
        toString(): string
        compareTo(arg0: object): number
        compareTo(arg0: E): number
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<E>>
        ordinal(): number
        get declaringClass(): Internal.Class<E>;
    }
    interface ObjectBidirectionalIterator <K> implements Internal.ObjectIterator<K>, Internal.BidirectionalIterator<K> {
        next(): E
        previous(): K
        hasPrevious(): boolean
        back(arg0: number): number
        hasNext(): boolean
        skip(arg0: number): number
        forEachRemaining(arg0: (arg0: E) => void): void
        remove(): void
    }
    class LivingEntity extends Internal.Entity implements Internal.ICitadelDataEntity, Internal.LivingEntityKJS, Internal.BlockCachingEntity, Internal.EquipmentEntity, Internal.LivingEntityAccessor {
        invalidateCaps(): void
        shouldRiderFaceForward(arg0: Internal.Player): boolean
        getCapability<T>(arg0: Internal.Capability<T>, arg1: Internal.Direction): Internal.LazyOptional<T>
        foodEatenKJS(is: Internal.ItemStack): void
        setCitadelEntityData(arg0: Internal.CompoundTag): void
        curePotionEffects(arg0: Internal.ItemStack): boolean
        getCitadelEntityData(): Internal.CompoundTag
        lithiumOnEquipmentChanged(): void
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void
        reviveCaps(): void
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listenForCachedBlockChanges: boolean): void
        lithiumOnBlockCacheDeleted(): void
        backpackedMoved : boolean;
        set citadelEntityData(arg0: Internal.CompoundTag);
        get citadelEntityData(): Internal.CompoundTag;
    }
    interface BidirectionalIterator <K> implements Internal.Iterator<K> {
        next(): E
        previous(): K
        hasPrevious(): boolean
        hasNext(): boolean
        forEachRemaining(arg0: (arg0: E) => void): void
        remove(): void
    }
    interface Int2ByteFunction implements Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Byte2ShortFunction): Internal.Int2ShortFunction
        composeByte(arg0: Internal.Byte2IntFunction): Internal.Byte2ByteFunction
        andThenInt(arg0: Internal.Byte2IntFunction): Internal.Int2IntFunction
        composeReference<T>(arg0: Internal.Reference2IntFunction<T>): Internal.Reference2ByteFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Byte2DoubleFunction): Internal.Int2DoubleFunction
        andThenObject<T>(arg0: Internal.Byte2ObjectFunction<T>): Internal.Int2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Byte2LongFunction): Internal.Int2LongFunction
        composeLong(arg0: Internal.Long2IntFunction): Internal.Long2ByteFunction
        andThenByte(arg0: Internal.Byte2ByteFunction): Internal.Int2ByteFunction
        andThenFloat(arg0: Internal.Byte2FloatFunction): Internal.Int2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2IntFunction): Internal.Int2ByteFunction
        clear(): void
        composeFloat(arg0: Internal.Float2IntFunction): Internal.Float2ByteFunction
        andThenChar(arg0: Internal.Byte2CharFunction): Internal.Int2CharFunction
        composeObject<T>(arg0: Internal.Object2IntFunction<T>): Internal.Object2ByteFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2IntFunction): Internal.Short2ByteFunction
        andThenReference<T>(arg0: Internal.Byte2ReferenceFunction<T>): Internal.Int2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2IntFunction): Internal.Char2ByteFunction
        composeDouble(arg0: Internal.Double2IntFunction): Internal.Double2ByteFunction
    }
    interface ArmedModel {
    }
    interface BlockPathingBehavior {
        getPathNodeType(arg0: Internal.BlockState): Internal.BlockPathTypes
        getPathNodeTypeAsNeighbor(arg0: Internal.BlockState): Internal.BlockPathTypes
    }
    class BlockSnapshot {
        getLevel(): Internal.LevelAccessor
        restore(arg0: boolean): boolean
        restore(): boolean
        restore(arg0: boolean, arg1: boolean): boolean
        getBlockEntity(): Internal.BlockEntity
        getPos(): BlockPos
        hashCode(): number
        equals(arg0: object): boolean
        restoreToLocation(arg0: Internal.LevelAccessor, arg1: BlockPos, arg2: boolean, arg3: boolean): boolean
        static create(arg0: Internal.ResourceKey<Internal.Level>, arg1: Internal.LevelAccessor, arg2: BlockPos): Internal.BlockSnapshot
        static create(arg0: Internal.ResourceKey<Internal.Level>, arg1: Internal.LevelAccessor, arg2: BlockPos, arg3: number): Internal.BlockSnapshot
        toString(): string
        getTag(): Internal.CompoundTag
        getReplacedBlock(): Internal.BlockState
        getFlag(): number
        getCurrentBlock(): Internal.BlockState
        get level(): Internal.LevelAccessor;
        get blockEntity(): Internal.BlockEntity;
        get pos(): BlockPos;
        get tag(): Internal.CompoundTag;
        get replacedBlock(): Internal.BlockState;
        get flag(): number;
        get currentBlock(): Internal.BlockState;
    }
    class EventPriority extends Internal.Enum<Internal.EventPriority> implements Internal.IEventListener {
        static valueOf(arg0: string): Internal.EventPriority
        listenerName(): string
        static values(): Internal.EventPriority[]
        invoke(arg0: Internal.Event): void
        static readonly LOWEST : Internal.EventPriority;
        static readonly HIGH : Internal.EventPriority;
        static readonly LOW : Internal.EventPriority;
        static readonly HIGHEST : Internal.EventPriority;
        static readonly NORMAL : Internal.EventPriority;
    }
    class Frustum$Visibility extends Internal.Enum<Internal.Frustum$Visibility> {
        static valueOf(name: string): Internal.Frustum$Visibility
        static values(): Internal.Frustum$Visibility[]
        static readonly OUTSIDE : Internal.Frustum$Visibility;
        static readonly INTERSECT : Internal.Frustum$Visibility;
        static readonly INSIDE : Internal.Frustum$Visibility;
    }
    class VertexFormatElement {
        getElementCount(): number
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        get elementCount(): number;
    }
    class LootEventJS extends Internal.EventJS {
        modify(id: ResourceLocation, b: (arg0: Internal.LootBuilder) => void): void
        removeAll(): void
        getType(): string
        getDirectory(): string
        addJson(id: ResourceLocation, json: Internal.JsonObject): void
        get type(): string;
        get directory(): string;
    }
    interface FuncSupplier {
        create(arg0: Internal.List<dev.latvian.mods.rhino.util.unit.Unit>): dev.latvian.mods.rhino.util.unit.Unit
    }
    class DamageSourceJS {
        getLevel(): Internal.LevelJS
        getPlayer(): Internal.PlayerJS<object>
        getActual(): Internal.EntityJS
        getType(): string
        getImmediate(): Internal.EntityJS
        readonly source : Internal.DamageSource;
        get level(): Internal.LevelJS;
        get player(): Internal.PlayerJS<object>;
        get actual(): Internal.EntityJS;
        get type(): string;
        get immediate(): Internal.EntityJS;
    }
    interface IntStream implements Internal.BaseStream<number, Internal.IntStream> {
        average(): Internal.OptionalDouble
        sequential(): Internal.BaseStream<any, any>
        sequential(): Internal.IntStream
        takeWhile(arg0: Internal.IntPredicate): Internal.IntStream
        static range(arg0: number, arg1: number): Internal.IntStream
        distinct(): Internal.IntStream
        findFirst(): Internal.OptionalInt
        sum(): number
        skip(arg0: number): Internal.IntStream
        asLongStream(): Internal.LongStream
        allMatch(arg0: Internal.IntPredicate): boolean
        mapToObj<U>(arg0: Internal.IntFunction<U>): Internal.Stream<U>
        static empty(): Internal.IntStream
        mapMulti(arg0: Internal.IntStream$IntMapMultiConsumer): Internal.IntStream
        iterator(): Internal.Iterator<any>
        iterator(): Internal.PrimitiveIterator$OfInt
        asDoubleStream(): Internal.DoubleStream
        min(): Internal.OptionalInt
        mapToLong(arg0: Internal.IntToLongFunction): Internal.LongStream
        parallel(): Internal.IntStream
        parallel(): Internal.BaseStream<any, any>
        noneMatch(arg0: Internal.IntPredicate): boolean
        findAny(): Internal.OptionalInt
        static of(arg0: number): Internal.IntStream
        static of(arg0: number[]): Internal.IntStream
        isParallel(): boolean
        limit(arg0: number): Internal.IntStream
        static builder(): Internal.IntStream$Builder
        toArray(): number[]
        forEachOrdered(arg0: java_.util.function_.IntConsumer): void
        close(): void
        static generate(arg0: Internal.IntSupplier): Internal.IntStream
        anyMatch(arg0: Internal.IntPredicate): boolean
        map(arg0: Internal.IntUnaryOperator): Internal.IntStream
        mapToDouble(arg0: Internal.IntToDoubleFunction): Internal.DoubleStream
        static iterate(arg0: number, arg1: Internal.IntPredicate, arg2: Internal.IntUnaryOperator): Internal.IntStream
        static iterate(arg0: number, arg1: Internal.IntUnaryOperator): Internal.IntStream
        unordered(): S
        reduce(arg0: number, arg1: java_.util.function_.IntBinaryOperator): number
        reduce(arg0: java_.util.function_.IntBinaryOperator): Internal.OptionalInt
        spliterator(): Internal.Spliterator$OfInt
        spliterator(): Internal.Spliterator<any>
        max(): Internal.OptionalInt
        forEach(arg0: java_.util.function_.IntConsumer): void
        count(): number
        static concat(arg0: Internal.IntStream, arg1: Internal.IntStream): Internal.IntStream
        dropWhile(arg0: Internal.IntPredicate): Internal.IntStream
        peek(arg0: java_.util.function_.IntConsumer): Internal.IntStream
        flatMap(arg0: Internal.IntFunction<Internal.IntStream>): Internal.IntStream
        filter(arg0: Internal.IntPredicate): Internal.IntStream
        onClose(arg0: Internal.Runnable): S
        sorted(): Internal.IntStream
        boxed(): Internal.Stream<number>
        summaryStatistics(): Internal.IntSummaryStatistics
        static rangeClosed(arg0: number, arg1: number): Internal.IntStream
        collect<R>(arg0: () => R, arg1: Internal.ObjIntConsumer<R>, arg2: (arg0: R, arg1: R) => void): R
    }
    interface IVertexProducer {
        pipe(arg0: Internal.IVertexConsumer): void
    }
    class Lifecycle {
        add(arg0: Internal.Lifecycle): Internal.Lifecycle
        static stable(): Internal.Lifecycle
        static deprecated(arg0: number): Internal.Lifecycle
        static experimental(): Internal.Lifecycle
    }
    class Proxy$Type extends Internal.Enum<Internal.Proxy$Type> {
        static valueOf(arg0: string): Internal.Proxy$Type
        static values(): Internal.Proxy$Type[]
        static readonly SOCKS : Internal.Proxy$Type;
        static readonly HTTP : Internal.Proxy$Type;
        static readonly DIRECT : Internal.Proxy$Type;
    }
    class AssetJsonGenerator extends Internal.JsonGenerator {
        multipartState(id: ResourceLocation, consumer: (arg0: Internal.MultipartBlockStateGenerator) => void): void
        blockState(id: ResourceLocation, consumer: (arg0: Internal.VariantBlockStateGenerator) => void): void
        blockModel(id: ResourceLocation, consumer: (arg0: Internal.ModelGenerator) => void): void
        itemModel(id: ResourceLocation, consumer: (arg0: Internal.ModelGenerator) => void): void
    }
    class LootTableEntry implements Internal.FunctionContainer, Internal.ConditionContainer {
        damage(damage: Internal.NumberProvider): Internal.FunctionContainer
        nbt(tag: Internal.CompoundTag): Internal.FunctionContainer
        enchantWithLevels(levels: Internal.NumberProvider, treasure: boolean): Internal.FunctionContainer
        survivesExplosion(): Internal.ConditionContainer
        killedByPlayer(): Internal.ConditionContainer
        randomChance(chance: number): Internal.ConditionContainer
        addFunction(arg0: Internal.JsonObject): Internal.FunctionContainer
        addFunction(o: Internal.JsonObject): Internal.LootTableEntry
        count(count: Internal.NumberProvider): Internal.FunctionContainer
        weight(weight: number): Internal.LootTableEntry
        addConditionalFunction(func: (arg0: Internal.ConditionalFunction) => void): Internal.FunctionContainer
        addCondition(arg0: Internal.JsonObject): Internal.ConditionContainer
        addCondition(o: Internal.JsonObject): Internal.LootTableEntry
        quality(quality: number): Internal.LootTableEntry
        lootingEnchant(count: Internal.NumberProvider, limit: number): Internal.FunctionContainer
        lootTable(table: ResourceLocation, seed: number): Internal.FunctionContainer
        entityScores(entity: Internal.LootContext$EntityTarget, scores: Map<string, object>): Internal.ConditionContainer
        copyName(source: Internal.CopyNameFunction$NameSource): Internal.FunctionContainer
        name(name: Internal.Text, entity: Internal.LootContext$EntityTarget): Internal.FunctionContainer
        name(name: Internal.Text): Internal.FunctionContainer
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer
        furnaceSmelt(): Internal.FunctionContainer
        enchantRandomly(enchantments: ResourceLocation[]): Internal.FunctionContainer
        entityProperties(entity: Internal.LootContext$EntityTarget, properties: Internal.JsonObject): Internal.ConditionContainer
        readonly json : Internal.JsonObject;
    }
    interface UserPrincipal implements Internal.Principal {
        getName(): string
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        implies(arg0: Internal.Subject): boolean
        get name(): string;
    }
    class AttributeModifier {
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
    }
    interface EntityKJS implements Internal.AsKJS {
        getPersistentDataKJS(): Internal.CompoundTag
        asKJS(): object
        get persistentDataKJS(): Internal.CompoundTag;
    }
    interface LongConsumer {
        andThen(arg0: Internal.LongConsumer): Internal.LongConsumer
        accept(arg0: number): void
    }
    interface EventExecutorGroup implements Internal.ScheduledExecutorService, Internal.Iterable<Internal.EventExecutor> {
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<object>
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<object>
        next(): Internal.EventExecutor
        terminationFuture(): io.netty.util.concurrent.Future<object>
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit): io.netty.util.concurrent.Future<object>
        shutdownGracefully(): io.netty.util.concurrent.Future<object>
        submit<T>(arg0: Internal.Runnable, arg1: T): io.netty.util.concurrent.Future<T>
        submit<T>(arg0: Internal.Runnable, arg1: T): Internal.Future<T>
        submit<T>(arg0: java_.util.concurrent.Callable<T>): io.netty.util.concurrent.Future<T>
        submit<T>(arg0: java_.util.concurrent.Callable<T>): Internal.Future<T>
        submit(arg0: Internal.Runnable): io.netty.util.concurrent.Future<object>
        submit(arg0: Internal.Runnable): Internal.Future<object>
        spliterator(): Internal.Spliterator<T>
        isTerminated(): boolean
        forEach(arg0: (arg0: T) => void): void
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<object>
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<object>
        invokeAll<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<Internal.Future<T>>
        invokeAll<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>): Internal.List<Internal.Future<T>>
        execute(arg0: Internal.Runnable): void
        isShuttingDown(): boolean
        schedule<V>(arg0: java_.util.concurrent.Callable<V>, arg1: number, arg2: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<V>
        schedule<V>(arg0: java_.util.concurrent.Callable<V>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): io.netty.util.concurrent.ScheduledFuture<object>
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<object>
        iterator(): Internal.Iterator<Internal.EventExecutor>
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean
        invokeAny<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>): T
        invokeAny<T>(arg0: Internal.Collection<java_.util.concurrent.Callable<T>>, arg1: number, arg2: Internal.TimeUnit): T
        shutdownNow(): Internal.List<Internal.Runnable>
        shutdown(): void
        isShutdown(): boolean
    }
    class AbstractStringBuilder implements Internal.Appendable, Internal.CharSequence {
        deleteCharAt(arg0: number): Internal.AbstractStringBuilder
        codePointAt(arg0: number): number
        setCharAt(arg0: number, arg1: string): void
        replace(arg0: number, arg1: number, arg2: string): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: Internal.CharSequence): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string[]): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: object): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: boolean): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: Internal.CharSequence, arg2: number, arg3: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder
        delete(arg0: number, arg1: number): Internal.AbstractStringBuilder
        substring(arg0: number): string
        substring(arg0: number, arg1: number): string
        capacity(): number
        appendCodePoint(arg0: number): Internal.AbstractStringBuilder
        codePointBefore(arg0: number): number
        indexOf(arg0: string): number
        indexOf(arg0: string, arg1: number): number
        codePointCount(arg0: number, arg1: number): number
        codePoints(): Internal.IntStream
        trimToSize(): void
        getChars(arg0: number, arg1: number, arg2: string[], arg3: number): void
        isEmpty(): boolean
        length(): number
        subSequence(arg0: number, arg1: number): Internal.CharSequence
        reverse(): Internal.AbstractStringBuilder
        lastIndexOf(arg0: string): number
        lastIndexOf(arg0: string, arg1: number): number
        setLength(arg0: number): void
        toString(): string
        ensureCapacity(arg0: number): void
        chars(): Internal.IntStream
        offsetByCodePoints(arg0: number, arg1: number): number
        charAt(arg0: number): string
        append(arg0: Internal.CharSequence): Internal.AbstractStringBuilder
        append(arg0: Internal.CharSequence): Internal.Appendable
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.AbstractStringBuilder
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable
        append(arg0: string[]): Internal.AbstractStringBuilder
        append(arg0: object): Internal.AbstractStringBuilder
        append(arg0: Internal.StringBuffer): Internal.AbstractStringBuilder
        append(arg0: string): Internal.AbstractStringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: number): Internal.AbstractStringBuilder
        append(arg0: string): Internal.AbstractStringBuilder
        append(arg0: string): Internal.Appendable
        append(arg0: boolean): Internal.AbstractStringBuilder
        append(arg0: string[], arg1: number, arg2: number): Internal.AbstractStringBuilder
    }
    interface LevelKJS implements Internal.AsKJS {
        asKJS(): object
    }
    class UnmodifiableIterator <E> implements Internal.Iterator<E> {
        next(): E
        hasNext(): boolean
        forEachRemaining(arg0: (arg0: E) => void): void
        remove(): void
    }
    class BlockType {
        applyDefaults(builder: Internal.BlockBuilder): void
        generateBlockModels(builder: Internal.BlockBuilder): Map<ResourceLocation, Internal.JsonObject>
        createBlock(arg0: Internal.BlockBuilder): Internal.Block
        generateData(builder: Internal.BlockBuilder, generator: Internal.DataJsonGenerator): void
        generateAssets(b: Internal.BlockBuilder, generator: Internal.AssetJsonGenerator): void
        readonly name : string;
    }
    interface Reference2ByteFunction <K> implements Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: number): number
        getByte(arg0: object): number
        andThenShort(arg0: Internal.Byte2ShortFunction): Internal.Reference2ShortFunction<K>
        composeByte(arg0: Internal.Byte2ReferenceFunction<K>): Internal.Byte2ByteFunction
        andThenInt(arg0: Internal.Byte2IntFunction): Internal.Reference2IntFunction<K>
        composeReference<T>(arg0: (arg0: T) => K): Internal.Reference2ByteFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: K) => T
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: object, arg1: object): object
        remove(arg0: object): number
        remove(arg0: object): object
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: Internal.Byte2DoubleFunction): Internal.Reference2DoubleFunction<K>
        andThenObject<T>(arg0: Internal.Byte2ObjectFunction<T>): (arg0: K) => T
        get(arg0: object): object
        get(arg0: object): number
        andThenLong(arg0: Internal.Byte2LongFunction): Internal.Reference2LongFunction<K>
        composeLong(arg0: Internal.Long2ReferenceFunction<K>): Internal.Long2ByteFunction
        removeByte(arg0: object): number
        andThenByte(arg0: Internal.Byte2ByteFunction): Internal.Reference2ByteFunction<K>
        andThenFloat(arg0: Internal.Byte2FloatFunction): Internal.Reference2FloatFunction<K>
        applyAsInt(arg0: K): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ReferenceFunction<K>): Internal.Int2ByteFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ReferenceFunction<K>): Internal.Float2ByteFunction
        andThenChar(arg0: Internal.Byte2CharFunction): Internal.Reference2CharFunction<K>
        composeObject<T>(arg0: (arg0: T) => K): Internal.Object2ByteFunction<T>
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ReferenceFunction<K>): Internal.Short2ByteFunction
        andThenReference<T>(arg0: Internal.Byte2ReferenceFunction<T>): (arg0: K) => T
        composeChar(arg0: Internal.Char2ReferenceFunction<K>): Internal.Char2ByteFunction
        composeDouble(arg0: Internal.Double2ReferenceFunction<K>): Internal.Double2ByteFunction
    }
    interface Reference2LongFunction <K> implements Internal.Function<K, number>, Internal.ToLongFunction<K> {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: number): number
        andThenShort(arg0: Internal.Long2ShortFunction): Internal.Reference2ShortFunction<K>
        composeByte(arg0: Internal.Byte2ReferenceFunction<K>): Internal.Byte2LongFunction
        andThenInt(arg0: Internal.Long2IntFunction): Internal.Reference2IntFunction<K>
        composeReference<T>(arg0: (arg0: T) => K): Internal.Reference2LongFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: K) => T
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: object, arg1: object): object
        remove(arg0: object): number
        remove(arg0: object): object
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: Internal.Long2DoubleFunction): Internal.Reference2DoubleFunction<K>
        andThenObject<T>(arg0: Internal.Long2ObjectFunction<T>): (arg0: K) => T
        removeLong(arg0: object): number
        get(arg0: object): object
        get(arg0: object): number
        andThenLong(arg0: Internal.Long2LongFunction): Internal.Reference2LongFunction<K>
        composeLong(arg0: Internal.Long2ReferenceFunction<K>): Internal.Long2LongFunction
        andThenByte(arg0: Internal.Long2ByteFunction): Internal.Reference2ByteFunction<K>
        andThenFloat(arg0: Internal.Long2FloatFunction): Internal.Reference2FloatFunction<K>
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ReferenceFunction<K>): Internal.Int2LongFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ReferenceFunction<K>): Internal.Float2LongFunction
        andThenChar(arg0: Internal.Long2CharFunction): Internal.Reference2CharFunction<K>
        getLong(arg0: object): number
        applyAsLong(arg0: K): number
        composeObject<T>(arg0: (arg0: T) => K): Internal.Object2LongFunction<T>
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ReferenceFunction<K>): Internal.Short2LongFunction
        andThenReference<T>(arg0: Internal.Long2ReferenceFunction<T>): (arg0: K) => T
        composeChar(arg0: Internal.Char2ReferenceFunction<K>): Internal.Char2LongFunction
        composeDouble(arg0: Internal.Double2ReferenceFunction<K>): Internal.Double2LongFunction
    }
    interface MapLike <T> {
        entries(): Internal.Stream<com.mojang.datafixers.util.Pair<T, T>>
        get(arg0: T): T
        get(arg0: string): T
        static forMap<T>(arg0: Map<T, T>, arg1: Internal.DynamicOps<T>): Internal.MapLike<T>
    }
    interface ItemSupplier {
    }
    class BlockEntity extends Internal.CapabilityProvider<Internal.BlockEntity> implements Internal.IForgeBlockEntity, Internal.RemovableBlockEntity {
        requestModelDataUpdate(): void
        increaseRemoveCounter(): void
        serializeNBT(): net.minecraft.nbt.Tag
        serializeNBT(): Internal.CompoundTag
        getModelData(): Internal.IModelData
        getTileData(): Internal.CompoundTag
        getRenderBoundingBox(): Internal.AABB
        onChunkUnloaded(): void
        onDataPacket(arg0: Internal.Connection, arg1: Internal.ClientboundBlockEntityDataPacket): void
        deserializeNBT(arg0: net.minecraft.nbt.Tag): void
        deserializeNBT(arg0: Internal.CompoundTag): void
        onLoad(): void
        handleUpdateTag(arg0: Internal.CompoundTag): void
        getRemovedCountLithium(): number
        static readonly INFINITE_EXTENT_AABB : Internal.AABB;
        get modelData(): Internal.IModelData;
        get tileData(): Internal.CompoundTag;
        get renderBoundingBox(): Internal.AABB;
        get removedCountLithium(): number;
    }
    interface BaseStream <T, S> implements Internal.AutoCloseable {
        unordered(): S
        onClose(arg0: Internal.Runnable): S
        iterator(): Internal.Iterator<T>
        parallel(): S
        spliterator(): Internal.Spliterator<T>
        sequential(): S
        isParallel(): boolean
        close(): void
    }
    class Particle {
        shouldCull(): boolean
        toString(): string
    }
    class InformationJEIEventJS extends Internal.EventJS {
        add(o: object, s: Internal.Text[]): void
        addForType<T>(type: Internal.IIngredientType<T>, o: object, s: Internal.Text[]): void
        static toComponent(s: Internal.Text[]): Internal.Component[]
    }
    class LootContextJS {
        getBlockPos(): BlockPos
        cancel(): void
        findLoot(arg0: Internal.IngredientJS): Internal.List<Internal.ItemStackJS>
        getPlayer(): Internal.PlayerJS<object>
        isCanceled(): boolean
        getCustomData(): Map<string, object>
        getTool(): Internal.ItemStackJS
        getLootTableId(): ResourceLocation
        lootSize(): number
        getRandom(): Internal.Random
        isExploded(): boolean
        forEachLoot(arg0: (arg0: Internal.ItemStackJS) => void): void
        getVanillaContext(): Internal.LootContext
        getDestroyedBlock(): Internal.BlockContainerJS
        getServer(): Internal.ServerJS
        hasLoot(arg0: Internal.IngredientJS): boolean
        getLuck(): number
        getEntity(): Internal.EntityJS
        getLooting(): number
        addLoot(arg0: Internal.ItemStackJS): void
        getLevel(): Internal.LevelJS
        getPosition(): Vec3
        getDamageSource(): Internal.DamageSourceJS
        getType(): LootType
        getExplosionRadius(): number
        removeLoot(arg0: Internal.IngredientJS): void
        getKillerEntity(): Internal.EntityJS
        get blockPos(): BlockPos;
        get player(): Internal.PlayerJS<object>;
        get customData(): Map<string, object>;
        get tool(): Internal.ItemStackJS;
        get lootTableId(): ResourceLocation;
        get random(): Internal.Random;
        get vanillaContext(): Internal.LootContext;
        get destroyedBlock(): Internal.BlockContainerJS;
        get server(): Internal.ServerJS;
        get luck(): number;
        get entity(): Internal.EntityJS;
        get looting(): number;
        get level(): Internal.LevelJS;
        get position(): Vec3;
        get damageSource(): Internal.DamageSourceJS;
        get type(): LootType;
        get explosionRadius(): number;
        get killerEntity(): Internal.EntityJS;
    }
    class EntityPredicate {
    }
    interface Stream <T> implements Internal.BaseStream<T, Internal.Stream<T>> {
        static ofNullable<T>(arg0: T): Internal.Stream<T>
        sequential(): S
        takeWhile(arg0: (arg0: T) => boolean): Internal.Stream<T>
        distinct(): Internal.Stream<T>
        findFirst(): Internal.Optional<T>
        skip(arg0: number): Internal.Stream<T>
        toList(): Internal.List<T>
        allMatch(arg0: (arg0: T) => boolean): boolean
        mapMultiToDouble(arg0: (arg0: T, arg1: Internal.DoubleConsumer) => void): Internal.DoubleStream
        static empty<T>(): Internal.Stream<T>
        iterator(): Internal.Iterator<T>
        mapMulti<R>(arg0: (arg0: T, arg1: (arg0: R) => void) => void): Internal.Stream<R>
        flatMapToInt(arg0: (arg0: T) => Internal.IntStream): Internal.IntStream
        min(arg0: Internal.Comparator<T>): Internal.Optional<T>
        flatMapToLong(arg0: (arg0: T) => Internal.LongStream): Internal.LongStream
        parallel(): S
        mapToLong(arg0: Internal.ToLongFunction<T>): Internal.LongStream
        noneMatch(arg0: (arg0: T) => boolean): boolean
        findAny(): Internal.Optional<T>
        static of<T>(arg0: T[]): Internal.Stream<T>
        static of<T>(arg0: T): Internal.Stream<T>
        isParallel(): boolean
        limit(arg0: number): Internal.Stream<T>
        static builder<T>(): (arg0: T) => void
        toArray(): object[]
        toArray<A>(arg0: Internal.IntFunction<A[]>): A[]
        forEachOrdered(arg0: (arg0: T) => void): void
        close(): void
        static generate<T>(arg0: () => T): Internal.Stream<T>
        anyMatch(arg0: (arg0: T) => boolean): boolean
        map<R>(arg0: (arg0: T) => R): Internal.Stream<R>
        mapToDouble(arg0: Internal.ToDoubleFunction<T>): Internal.DoubleStream
        static iterate<T>(arg0: T, arg1: (arg0: T) => boolean, arg2: Internal.UnaryOperator<T>): Internal.Stream<T>
        static iterate<T>(arg0: T, arg1: Internal.UnaryOperator<T>): Internal.Stream<T>
        unordered(): S
        mapMultiToLong(arg0: (arg0: T, arg1: Internal.LongConsumer) => void): Internal.LongStream
        mapMultiToInt(arg0: (arg0: T, arg1: java_.util.function_.IntConsumer) => void): Internal.IntStream
        reduce<U>(arg0: U, arg1: (arg0: U, arg1: T) => U, arg2: Internal.BinaryOperator<U>): U
        reduce(arg0: T, arg1: Internal.BinaryOperator<T>): T
        reduce(arg0: Internal.BinaryOperator<T>): Internal.Optional<T>
        spliterator(): Internal.Spliterator<T>
        max(arg0: Internal.Comparator<T>): Internal.Optional<T>
        forEach(arg0: (arg0: T) => void): void
        count(): number
        static concat<T>(arg0: Internal.Stream<T>, arg1: Internal.Stream<T>): Internal.Stream<T>
        dropWhile(arg0: (arg0: T) => boolean): Internal.Stream<T>
        flatMapToDouble(arg0: (arg0: T) => Internal.DoubleStream): Internal.DoubleStream
        peek(arg0: (arg0: T) => void): Internal.Stream<T>
        flatMap<R>(arg0: (arg0: T) => Internal.Stream<R>): Internal.Stream<R>
        filter(arg0: (arg0: T) => boolean): Internal.Stream<T>
        onClose(arg0: Internal.Runnable): S
        sorted(arg0: Internal.Comparator<T>): Internal.Stream<T>
        sorted(): Internal.Stream<T>
        mapToInt(arg0: Internal.ToIntFunction<T>): Internal.IntStream
        collect<R>(arg0: () => R, arg1: (arg0: R, arg1: T) => void, arg2: (arg0: R, arg1: R) => void): R
        collect<R, A>(arg0: Internal.Collector<T, A, R>): R
    }
    interface BlockStateFlagHolder {
        getAllFlags(): number
        get allFlags(): number;
    }
    class AbstractReferenceCountedByteBuf extends Internal.AbstractByteBuf {
        refCnt(): number
        release(): boolean
        release(arg0: number): boolean
        retain(): Internal.ReferenceCounted
        retain(): Internal.ByteBuf
        retain(arg0: number): Internal.ByteBuf
        retain(arg0: number): Internal.ReferenceCounted
        touch(arg0: object): Internal.ReferenceCounted
        touch(arg0: object): Internal.ByteBuf
        touch(): Internal.ReferenceCounted
        touch(): Internal.ByteBuf
    }
    interface SpecialEquality {
        specialEquals(o: object, shallow: boolean): boolean
    }
    class AsynchronousFileChannel implements Internal.AsynchronousChannel {
        isOpen(): boolean
        read(arg0: Internal.ByteBuffer, arg1: number): Internal.Future<number>
        read<A>(arg0: Internal.ByteBuffer, arg1: number, arg2: A, arg3: Internal.CompletionHandler<number, A>): void
        truncate(arg0: number): Internal.AsynchronousFileChannel
        size(): number
        lock(arg0: number, arg1: number, arg2: boolean): Internal.Future<Internal.FileLock>
        lock<A>(arg0: A, arg1: Internal.CompletionHandler<Internal.FileLock, A>): void
        lock<A>(arg0: number, arg1: number, arg2: boolean, arg3: A, arg4: Internal.CompletionHandler<Internal.FileLock, A>): void
        lock(): Internal.Future<Internal.FileLock>
        force(arg0: boolean): void
        close(): void
        write(arg0: Internal.ByteBuffer, arg1: number): Internal.Future<number>
        write<A>(arg0: Internal.ByteBuffer, arg1: number, arg2: A, arg3: Internal.CompletionHandler<number, A>): void
        tryLock(): Internal.FileLock
        tryLock(arg0: number, arg1: number, arg2: boolean): Internal.FileLock
        static open(arg0: Internal.Path, arg1: Internal.Set<Internal.OpenOption>, arg2: Internal.ExecutorService, arg3: Internal.FileAttribute<object>[]): Internal.AsynchronousFileChannel
        static open(arg0: Internal.Path, arg1: Internal.OpenOption[]): Internal.AsynchronousFileChannel
    }
    class SimpleMapCodec <K, V> extends Internal.MapCodec<Map<K, V>> implements Internal.BaseMapCodec<K, V> {
        encode(arg0: object, arg1: Internal.DynamicOps<any>, arg2: Internal.RecordBuilder<any>): Internal.RecordBuilder<any>
        encode<T>(arg0: Map<K, V>, arg1: Internal.DynamicOps<T>, arg2: Internal.RecordBuilder<T>): Internal.RecordBuilder<T>
        elementCodec(): Internal.Codec<V>
        keyCodec(): Internal.Codec<K>
        keys<T>(arg0: Internal.DynamicOps<T>): Internal.Stream<T>
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: Internal.MapLike<T>): Internal.DataResult<Map<K, V>>
    }
    class ImmutableCollection$Builder <E> {
        add(arg0: E): Internal.ImmutableCollection$Builder<E>
        add(arg0: E[]): Internal.ImmutableCollection$Builder<E>
        build(): Internal.ImmutableCollection<E>
        addAll(arg0: Internal.Iterator<E>): Internal.ImmutableCollection$Builder<E>
        addAll(arg0: Internal.Iterable<E>): Internal.ImmutableCollection$Builder<E>
    }
    class MobCategory extends Internal.Enum<Internal.MobCategory> implements Internal.StringRepresentable, Internal.IExtensibleEnum {
        init(): void
        static valueOf(arg0: string): Internal.MobCategory
        static values(): Internal.MobCategory[]
        static create(arg0: string, arg1: string, arg2: number, arg3: boolean, arg4: boolean, arg5: number): Internal.MobCategory
        static readonly UNDERGROUND_WATER_CREATURE : Internal.MobCategory;
        static readonly WATER_CREATURE : Internal.MobCategory;
        static readonly WATER_AMBIENT : Internal.MobCategory;
        static readonly AXOLOTLS : Internal.MobCategory;
        static readonly AMBIENT : Internal.MobCategory;
        static readonly CREATURE : Internal.MobCategory;
        static readonly MISC : Internal.MobCategory;
        static readonly MONSTER : Internal.MobCategory;
    }
    class ModuleDescriptor$Builder {
        mainClass(arg0: string): Internal.ModuleDescriptor$Builder
        build(): Internal.ModuleDescriptor
        provides(arg0: Internal.ModuleDescriptor$Provides): Internal.ModuleDescriptor$Builder
        provides(arg0: string, arg1: Internal.List<string>): Internal.ModuleDescriptor$Builder
        exports(arg0: string): Internal.ModuleDescriptor$Builder
        exports(arg0: Internal.Set<Internal.ModuleDescriptor$Exports$Modifier>, arg1: string, arg2: Internal.Set<string>): Internal.ModuleDescriptor$Builder
        exports(arg0: string, arg1: Internal.Set<string>): Internal.ModuleDescriptor$Builder
        exports(arg0: Internal.Set<Internal.ModuleDescriptor$Exports$Modifier>, arg1: string): Internal.ModuleDescriptor$Builder
        exports(arg0: Internal.ModuleDescriptor$Exports): Internal.ModuleDescriptor$Builder
        opens(arg0: string): Internal.ModuleDescriptor$Builder
        opens(arg0: Internal.Set<Internal.ModuleDescriptor$Opens$Modifier>, arg1: string, arg2: Internal.Set<string>): Internal.ModuleDescriptor$Builder
        opens(arg0: string, arg1: Internal.Set<string>): Internal.ModuleDescriptor$Builder
        opens(arg0: Internal.ModuleDescriptor$Opens): Internal.ModuleDescriptor$Builder
        opens(arg0: Internal.Set<Internal.ModuleDescriptor$Opens$Modifier>, arg1: string): Internal.ModuleDescriptor$Builder
        uses(arg0: string): Internal.ModuleDescriptor$Builder
        packages(arg0: Internal.Set<string>): Internal.ModuleDescriptor$Builder
        version(arg0: string): Internal.ModuleDescriptor$Builder
        version(arg0: Internal.ModuleDescriptor$Version): Internal.ModuleDescriptor$Builder
        requires(arg0: Internal.ModuleDescriptor$Requires): Internal.ModuleDescriptor$Builder
        requires(arg0: Internal.Set<Internal.ModuleDescriptor$Requires$Modifier>, arg1: string, arg2: Internal.ModuleDescriptor$Version): Internal.ModuleDescriptor$Builder
        requires(arg0: string): Internal.ModuleDescriptor$Builder
        requires(arg0: Internal.Set<Internal.ModuleDescriptor$Requires$Modifier>, arg1: string): Internal.ModuleDescriptor$Builder
    }
    interface GeneratedClassLoader {
        defineClass(arg0: string, arg1: number[]): Internal.Class<object>
        linkClass(arg0: Internal.Class<object>): void
    }
    interface CharacterIterator implements Internal.Cloneable {
        next(): string
        current(): string
        getIndex(): number
        previous(): string
        last(): string
        getEndIndex(): number
        setIndex(arg0: number): string
        clone(): object
        getBeginIndex(): number
        first(): string
        static readonly DONE : "￿";
        get index(): number;
        get endIndex(): number;
        set index(arg0: number);
        get beginIndex(): number;
    }
    interface ServerWorldExtended {
        setNavigationActive(arg0: Internal.Mob): void
        setNavigationInactive(arg0: Internal.Mob): void
        set navigationActive(arg0: Internal.Mob);
        set navigationInactive(arg0: Internal.Mob);
    }
    class ShortBuffer extends Internal.Buffer implements Internal.Comparable<Internal.ShortBuffer> {
        hasArray(): boolean
        compact(): Internal.ShortBuffer
        clear(): Internal.Buffer
        clear(): Internal.ShortBuffer
        duplicate(): Internal.ShortBuffer
        duplicate(): Internal.Buffer
        compareTo(arg0: object): number
        compareTo(arg0: Internal.ShortBuffer): number
        asReadOnlyBuffer(): Internal.ShortBuffer
        put(arg0: number[]): Internal.ShortBuffer
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ShortBuffer
        put(arg0: number, arg1: number[]): Internal.ShortBuffer
        put(arg0: number[], arg1: number, arg2: number): Internal.ShortBuffer
        put(arg0: number, arg1: Internal.ShortBuffer, arg2: number, arg3: number): Internal.ShortBuffer
        put(arg0: Internal.ShortBuffer): Internal.ShortBuffer
        put(arg0: number, arg1: number): Internal.ShortBuffer
        put(arg0: number): Internal.ShortBuffer
        static allocate(arg0: number): Internal.ShortBuffer
        rewind(): Internal.Buffer
        rewind(): Internal.ShortBuffer
        slice(): Internal.Buffer
        slice(): Internal.ShortBuffer
        slice(arg0: number, arg1: number): Internal.Buffer
        slice(arg0: number, arg1: number): Internal.ShortBuffer
        array(): number[]
        array(): object
        hashCode(): number
        mismatch(arg0: Internal.ShortBuffer): number
        equals(arg0: object): boolean
        get(): number
        get(arg0: number, arg1: number[]): Internal.ShortBuffer
        get(arg0: number): number
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ShortBuffer
        get(arg0: number[], arg1: number, arg2: number): Internal.ShortBuffer
        get(arg0: number[]): Internal.ShortBuffer
        limit(arg0: number): Internal.ShortBuffer
        limit(arg0: number): Internal.Buffer
        reset(): Internal.Buffer
        reset(): Internal.ShortBuffer
        arrayOffset(): number
        toString(): string
        position(arg0: number): Internal.ShortBuffer
        position(arg0: number): Internal.Buffer
        flip(): Internal.Buffer
        flip(): Internal.ShortBuffer
        isDirect(): boolean
        static wrap(arg0: number[]): Internal.ShortBuffer
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.ShortBuffer
        mark(): Internal.Buffer
        mark(): Internal.ShortBuffer
        order(): Internal.ByteOrder
    }
    interface Short2IntFunction implements Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Int2ShortFunction): Internal.Short2ShortFunction
        composeByte(arg0: Internal.Byte2ShortFunction): Internal.Byte2IntFunction
        andThenInt(arg0: Internal.Int2IntFunction): Internal.Short2IntFunction
        composeReference<T>(arg0: Internal.Reference2ShortFunction<T>): Internal.Reference2IntFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Int2DoubleFunction): Internal.Short2DoubleFunction
        andThenObject<T>(arg0: Internal.Int2ObjectFunction<T>): Internal.Short2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Int2LongFunction): Internal.Short2LongFunction
        composeLong(arg0: Internal.Long2ShortFunction): Internal.Long2IntFunction
        andThenByte(arg0: Internal.Int2ByteFunction): Internal.Short2ByteFunction
        andThenFloat(arg0: Internal.Int2FloatFunction): Internal.Short2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ShortFunction): Internal.Int2IntFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ShortFunction): Internal.Float2IntFunction
        andThenChar(arg0: Internal.Int2CharFunction): Internal.Short2CharFunction
        composeObject<T>(arg0: Internal.Object2ShortFunction<T>): Internal.Object2IntFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2ShortFunction): Internal.Short2IntFunction
        andThenReference<T>(arg0: Internal.Int2ReferenceFunction<T>): Internal.Short2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ShortFunction): Internal.Char2IntFunction
        composeDouble(arg0: Internal.Double2ShortFunction): Internal.Double2IntFunction
    }
    class Item$Properties {
        setNoRepair(): Internal.Item$Properties
    }
    interface Char2DoubleFunction implements Internal.Function<string, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: string, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: Internal.Double2ShortFunction): Internal.Char2ShortFunction
        composeByte(arg0: Internal.Byte2CharFunction): Internal.Byte2DoubleFunction
        andThenInt(arg0: Internal.Double2IntFunction): Internal.Char2IntFunction
        composeReference<T>(arg0: Internal.Reference2CharFunction<T>): Internal.Reference2DoubleFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: string) => T
        put(arg0: object, arg1: object): object
        put(arg0: string, arg1: number): number
        put(arg0: string, arg1: number): number
        remove(arg0: string): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Double2DoubleFunction): Internal.Char2DoubleFunction
        andThenObject<T>(arg0: Internal.Double2ObjectFunction<T>): Internal.Char2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: string): number
        andThenLong(arg0: Internal.Double2LongFunction): Internal.Char2LongFunction
        composeLong(arg0: Internal.Long2CharFunction): Internal.Long2DoubleFunction
        andThenByte(arg0: Internal.Double2ByteFunction): Internal.Char2ByteFunction
        andThenFloat(arg0: Internal.Double2FloatFunction): Internal.Char2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: string): boolean
        composeInt(arg0: Internal.Int2CharFunction): Internal.Int2DoubleFunction
        clear(): void
        composeFloat(arg0: Internal.Float2CharFunction): Internal.Float2DoubleFunction
        andThenChar(arg0: Internal.Double2CharFunction): Internal.Char2CharFunction
        composeObject<T>(arg0: Internal.Object2CharFunction<T>): Internal.Object2DoubleFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => string): (arg0: T) => number
        composeShort(arg0: Internal.Short2CharFunction): Internal.Short2DoubleFunction
        andThenReference<T>(arg0: Internal.Double2ReferenceFunction<T>): Internal.Char2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2CharFunction): Internal.Char2DoubleFunction
        composeDouble(arg0: Internal.Double2CharFunction): Internal.Double2DoubleFunction
    }
    interface Predicate <T> {
        static not<T>(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        test(arg0: T): boolean
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
        static isEqual<T>(arg0: object): (arg0: T) => boolean
    }
    class Matrix4f implements Internal.MatrixWrite, Internal.Matrix4fExtended {
        multiplyBackward(arg0: Internal.Matrix4f): void
        rotate(quaternion: Internal.Quaternion): void
        hashCode(): number
        flywheel$writeUnsafe(arg0: number): void
        equals(arg0: object): boolean
        transformVecZ(x: number, y: number, z: number): number
        transformVecY(x: number, y: number, z: number): number
        flywheel$write(arg0: Internal.VecBuffer): void
        setTranslation(arg0: number, arg1: number, arg2: number): void
        toString(): string
        transformVecX(x: number, y: number, z: number): number
        translate(x: number, y: number, z: number): void
    }
    class BlockBehaviour$BlockStateBase extends Internal.StateHolder<Internal.Block, Internal.BlockState> implements Internal.BlockStateKJS, Internal.BlockStateLightInfoAccess, Internal.BlockStatePathingCache, Internal.BlockStateFlagHolder, Internal.ExtendedAbstractBlockState {
        handler$bba000$initLightAccessState(arg0: Internal.CallbackInfo): void
        setDestroySpeedKJS(arg0: number): void
        getNeighborPathNodeType(): Internal.BlockPathTypes
        setLightEmissionKJS(arg0: number): void
        getPathNodeType(): Internal.BlockPathTypes
        getLightInfo(): Internal.BlockStateLightInfo
        handler$zdg000$onBlockCollision(arg0: Internal.Level, arg1: BlockPos, arg2: Internal.Entity, arg3: Internal.CallbackInfo): void
        getAllFlags(): number
        getOpacityIfCached(): number
        setRequiresToolKJS(arg0: boolean): void
        setMaterialKJS(arg0: net.minecraft.world.level.material.Material): void
        isConditionallyFullOpaque(): boolean
        set destroySpeedKJS(arg0: number);
        get neighborPathNodeType(): Internal.BlockPathTypes;
        set lightEmissionKJS(arg0: number);
        get pathNodeType(): Internal.BlockPathTypes;
        get lightInfo(): Internal.BlockStateLightInfo;
        get allFlags(): number;
        get opacityIfCached(): number;
        set requiresToolKJS(arg0: boolean);
        set materialKJS(arg0: net.minecraft.world.level.material.Material);
    }
    interface Function6 <T1, T2, T3, T4, T5, T6, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6): R
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, (arg0: T6) => R>
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function3<T4, T5, T6, R>>
        curry4(): Internal.Function4<T1, T2, T3, T4, (arg0: T5, arg1: T6) => R>
        curry2(): (arg0: T1, arg1: T2) => Internal.Function4<T3, T4, T5, T6, R>
        curry(): (arg0: T1) => Internal.Function5<T2, T3, T4, T5, T6, R>
    }
    class Products$P13 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> {
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>): Internal.App<F, R>
    }
    interface Float2ShortFunction implements Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Short2ShortFunction): Internal.Float2ShortFunction
        composeByte(arg0: Internal.Byte2FloatFunction): Internal.Byte2ShortFunction
        andThenInt(arg0: Internal.Short2IntFunction): Internal.Float2IntFunction
        composeReference<T>(arg0: Internal.Reference2FloatFunction<T>): Internal.Reference2ShortFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Short2DoubleFunction): Internal.Float2DoubleFunction
        andThenObject<T>(arg0: Internal.Short2ObjectFunction<T>): Internal.Float2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Short2LongFunction): Internal.Float2LongFunction
        composeLong(arg0: Internal.Long2FloatFunction): Internal.Long2ShortFunction
        andThenByte(arg0: Internal.Short2ByteFunction): Internal.Float2ByteFunction
        andThenFloat(arg0: Internal.Short2FloatFunction): Internal.Float2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2FloatFunction): Internal.Int2ShortFunction
        clear(): void
        composeFloat(arg0: Internal.Float2FloatFunction): Internal.Float2ShortFunction
        andThenChar(arg0: Internal.Short2CharFunction): Internal.Float2CharFunction
        composeObject<T>(arg0: Internal.Object2FloatFunction<T>): Internal.Object2ShortFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2FloatFunction): Internal.Short2ShortFunction
        andThenReference<T>(arg0: Internal.Short2ReferenceFunction<T>): Internal.Float2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2FloatFunction): Internal.Char2ShortFunction
        composeDouble(arg0: Internal.Double2FloatFunction): Internal.Double2ShortFunction
    }
    interface FireworkRocketEntityKJS {
        setLifetimeKJS(arg0: number): void
        set lifetimeKJS(arg0: number);
    }
    class StageChangeEvent {
        getStage(): string
        getPlayer(): Internal.Player
        getPlayerStages(): Internal.Stages
        get stage(): string;
        get player(): Internal.Player;
        get playerStages(): Internal.Stages;
    }
    class ChannelOption <T> extends Internal.AbstractConstant<Internal.ChannelOption<T>> {
        static valueOf<T>(arg0: string): Internal.ChannelOption<T>
        static valueOf<T>(arg0: Internal.Class<object>, arg1: string): Internal.ChannelOption<T>
        static exists(arg0: string): boolean
        static newInstance<T>(arg0: string): Internal.ChannelOption<T>
        validate(arg0: T): void
        static readonly WRITE_BUFFER_HIGH_WATER_MARK : Internal.ChannelOption<number>;
        static readonly WRITE_BUFFER_LOW_WATER_MARK : Internal.ChannelOption<number>;
        static readonly DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION : Internal.ChannelOption<boolean>;
        static readonly IP_TOS : Internal.ChannelOption<number>;
        static readonly SINGLE_EVENTEXECUTOR_PER_GROUP : Internal.ChannelOption<boolean>;
        static readonly SO_SNDBUF : Internal.ChannelOption<number>;
        static readonly IP_MULTICAST_IF : Internal.ChannelOption<Internal.NetworkInterface>;
        static readonly WRITE_BUFFER_WATER_MARK : Internal.ChannelOption<Internal.WriteBufferWaterMark>;
        static readonly TCP_NODELAY : Internal.ChannelOption<boolean>;
        static readonly TCP_FASTOPEN : Internal.ChannelOption<number>;
        static readonly SO_LINGER : Internal.ChannelOption<number>;
        static readonly SO_RCVBUF : Internal.ChannelOption<number>;
        static readonly SO_KEEPALIVE : Internal.ChannelOption<boolean>;
        static readonly ALLOCATOR : Internal.ChannelOption<Internal.ByteBufAllocator>;
        static readonly IP_MULTICAST_ADDR : Internal.ChannelOption<Internal.InetAddress>;
        static readonly IP_MULTICAST_LOOP_DISABLED : Internal.ChannelOption<boolean>;
        static readonly TCP_FASTOPEN_CONNECT : Internal.ChannelOption<boolean>;
        static readonly MESSAGE_SIZE_ESTIMATOR : Internal.ChannelOption<Internal.MessageSizeEstimator>;
        static readonly WRITE_SPIN_COUNT : Internal.ChannelOption<number>;
        static readonly SO_TIMEOUT : Internal.ChannelOption<number>;
        static readonly SO_REUSEADDR : Internal.ChannelOption<boolean>;
        static readonly CONNECT_TIMEOUT_MILLIS : Internal.ChannelOption<number>;
        static readonly ALLOW_HALF_CLOSURE : Internal.ChannelOption<boolean>;
        static readonly SO_BACKLOG : Internal.ChannelOption<number>;
        static readonly MAX_MESSAGES_PER_READ : Internal.ChannelOption<number>;
        static readonly AUTO_CLOSE : Internal.ChannelOption<boolean>;
        static readonly MAX_MESSAGES_PER_WRITE : Internal.ChannelOption<number>;
        static readonly SO_BROADCAST : Internal.ChannelOption<boolean>;
        static readonly AUTO_READ : Internal.ChannelOption<boolean>;
        static readonly IP_MULTICAST_TTL : Internal.ChannelOption<number>;
        static readonly RCVBUF_ALLOCATOR : Internal.ChannelOption<Internal.RecvByteBufAllocator>;
    }
    interface WorldGenLevel implements Internal.ServerLevelAccessor {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
    }
    interface ConditionsContainer <B> {
        killerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B
        survivesExplosion(): B
        addCondition(arg0: Internal.LootItemCondition$Builder): B
        addCondition(arg0: Internal.LootItemCondition): B
        customDistanceToPlayer(arg0: (arg0: Internal.DistancePredicateBuilder) => void): B
        matchFluid(arg0: string): B
        not(arg0: (arg0: Internal.NotConditionBuilder) => void): B
        directKillerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B
        matchEquip(arg0: EquipmentSlot, arg1: Internal.IngredientJS): B
        and(arg0: (arg0: Internal.AndConditionBuilder) => void): B
        matchLoot(arg0: Internal.IngredientJS): B
        matchLoot(arg0: Internal.IngredientJS, arg1: boolean): B
        anyBiome(arg0: string[]): B
        distanceToKiller(arg0: Internal.MinMaxBounds$Doubles): B
        entityPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B
        matchEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        anyDimension(arg0: ResourceLocation[]): B
        killedByPlayer(): B
        or(arg0: (arg0: Internal.OrConditionBuilder) => void): B
        timeCheck(arg0: number, arg1: number, arg2: number): B
        timeCheck(arg0: number, arg1: number): B
        matchOffHand(arg0: Internal.IngredientJS): B
        randomChance(arg0: number): B
        playerPredicate(arg0: (arg0: Internal.PlayerJS<object>) => boolean): B
        weatherCheck(arg0: Map<string, boolean>): B
        matchDirectKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        matchBlockState(arg0: Internal.Block, arg1: Map<string, string>): B
        matchMainHand(arg0: Internal.IngredientJS): B
        matchPlayer(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        lightLevel(arg0: number, arg1: number): B
        biome(arg0: string[]): B
        customCondition(arg0: Internal.JsonObject): B
        matchKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B
        randomChanceWithLooting(arg0: number, arg1: number): B
        hasAnyStage(arg0: string[]): B
        randomChanceWithEnchantment(arg0: Internal.Enchantment, arg1: number[]): B
        anyStructure(arg0: ResourceLocation[], arg1: boolean): B
        matchDamageSource(arg0: (arg0: Internal.DamageSourcePredicateBuilderJS) => void): B
    }
    interface VertexList {
        getLight(arg0: number): number
        getG(arg0: number): number
        isEmpty(): boolean
        getR(arg0: number): number
        getVertexCount(): number
        getU(arg0: number): number
        getV(arg0: number): number
        getX(arg0: number): number
        getY(arg0: number): number
        getZ(arg0: number): number
        getNZ(arg0: number): number
        getNY(arg0: number): number
        getNX(arg0: number): number
        getA(arg0: number): number
        getB(arg0: number): number
        get vertexCount(): number;
    }
    class RenderType extends Internal.RenderStateShard implements Internal.RenderTypeExtension {
        flywheel$getDrawBuffer(): Internal.DrawBuffer
        toString(): string
    }
    class AccessibleObject implements Internal.AnnotatedElement {
        trySetAccessible(): boolean
        isAccessible(): boolean
        setAccessible(arg0: boolean): void
        static setAccessible(arg0: Internal.AccessibleObject[], arg1: boolean): void
        getAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getDeclaredAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        getAnnotation<T>(arg0: Internal.Class<T>): T
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean
        canAccess(arg0: object): boolean
        getDeclaredAnnotation<T>(arg0: Internal.Class<T>): T
        getAnnotations(): Internal.Annotation[]
        getDeclaredAnnotations(): Internal.Annotation[]
        set accessible(arg0: boolean);
        get annotations(): Internal.Annotation[];
        get declaredAnnotations(): Internal.Annotation[];
    }
    interface Char2LongFunction implements Internal.Function<string, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: string, arg1: number): number
        andThenShort(arg0: Internal.Long2ShortFunction): Internal.Char2ShortFunction
        composeByte(arg0: Internal.Byte2CharFunction): Internal.Byte2LongFunction
        andThenInt(arg0: Internal.Long2IntFunction): Internal.Char2IntFunction
        composeReference<T>(arg0: Internal.Reference2CharFunction<T>): Internal.Reference2LongFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: string) => T
        put(arg0: object, arg1: object): object
        put(arg0: string, arg1: number): number
        put(arg0: string, arg1: number): number
        remove(arg0: string): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Long2DoubleFunction): Internal.Char2DoubleFunction
        andThenObject<T>(arg0: Internal.Long2ObjectFunction<T>): Internal.Char2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: string): number
        andThenLong(arg0: Internal.Long2LongFunction): Internal.Char2LongFunction
        composeLong(arg0: Internal.Long2CharFunction): Internal.Long2LongFunction
        andThenByte(arg0: Internal.Long2ByteFunction): Internal.Char2ByteFunction
        andThenFloat(arg0: Internal.Long2FloatFunction): Internal.Char2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: string): boolean
        composeInt(arg0: Internal.Int2CharFunction): Internal.Int2LongFunction
        clear(): void
        composeFloat(arg0: Internal.Float2CharFunction): Internal.Float2LongFunction
        andThenChar(arg0: Internal.Long2CharFunction): Internal.Char2CharFunction
        applyAsLong(arg0: number): number
        composeObject<T>(arg0: Internal.Object2CharFunction<T>): Internal.Object2LongFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => string): (arg0: T) => number
        composeShort(arg0: Internal.Short2CharFunction): Internal.Short2LongFunction
        andThenReference<T>(arg0: Internal.Long2ReferenceFunction<T>): Internal.Char2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2CharFunction): Internal.Char2LongFunction
        composeDouble(arg0: Internal.Double2CharFunction): Internal.Double2LongFunction
    }
    class AirItem extends Internal.Item {
        readonly delegate : () => V;
        renderProperties : object;
    }
    class JsonToken extends Internal.Enum<Internal.JsonToken> {
        static valueOf(arg0: string): Internal.JsonToken
        static values(): Internal.JsonToken[]
        static readonly NUMBER : Internal.JsonToken;
        static readonly NULL : Internal.JsonToken;
        static readonly END_DOCUMENT : Internal.JsonToken;
        static readonly BEGIN_OBJECT : Internal.JsonToken;
        static readonly END_ARRAY : Internal.JsonToken;
        static readonly STRING : Internal.JsonToken;
        static readonly END_OBJECT : Internal.JsonToken;
        static readonly BEGIN_ARRAY : Internal.JsonToken;
        static readonly BOOLEAN : Internal.JsonToken;
        static readonly NAME : Internal.JsonToken;
    }
    interface LithiumDefaultedList {
        setUnstableInteractionConditions(): void
        changedInteractionConditions(): void
    }
    class Camera {
        setAnglesInternal(arg0: number, arg1: number): void
        getBlockAtCamera(): Internal.BlockState
        get blockAtCamera(): Internal.BlockState;
    }
    interface IdMap <T> implements Internal.Iterable<T> {
        iterator(): Internal.Iterator<T>
        spliterator(): Internal.Spliterator<T>
        forEach(arg0: (arg0: T) => void): void
    }
    interface Reference2ShortFunction <K> implements Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        andThenShort(arg0: Internal.Short2ShortFunction): Internal.Reference2ShortFunction<K>
        composeByte(arg0: Internal.Byte2ReferenceFunction<K>): Internal.Byte2ShortFunction
        removeShort(arg0: object): number
        andThenInt(arg0: Internal.Short2IntFunction): Internal.Reference2IntFunction<K>
        composeReference<T>(arg0: (arg0: T) => K): Internal.Reference2ShortFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: K) => T
        put(arg0: K, arg1: number): number
        put(arg0: K, arg1: number): number
        put(arg0: object, arg1: object): object
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(arg0: number): void
        defaultReturnValue(): number
        andThenDouble(arg0: Internal.Short2DoubleFunction): Internal.Reference2DoubleFunction<K>
        andThenObject<T>(arg0: Internal.Short2ObjectFunction<T>): (arg0: K) => T
        get(arg0: object): number
        get(arg0: object): object
        andThenLong(arg0: Internal.Short2LongFunction): Internal.Reference2LongFunction<K>
        composeLong(arg0: Internal.Long2ReferenceFunction<K>): Internal.Long2ShortFunction
        andThenByte(arg0: Internal.Short2ByteFunction): Internal.Reference2ByteFunction<K>
        andThenFloat(arg0: Internal.Short2FloatFunction): Internal.Reference2FloatFunction<K>
        applyAsInt(arg0: K): number
        apply(arg0: K): V
        getShort(arg0: object): number
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ReferenceFunction<K>): Internal.Int2ShortFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ReferenceFunction<K>): Internal.Float2ShortFunction
        andThenChar(arg0: Internal.Short2CharFunction): Internal.Reference2CharFunction<K>
        composeObject<T>(arg0: (arg0: T) => K): Internal.Object2ShortFunction<T>
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ReferenceFunction<K>): Internal.Short2ShortFunction
        andThenReference<T>(arg0: Internal.Short2ReferenceFunction<T>): (arg0: K) => T
        composeChar(arg0: Internal.Char2ReferenceFunction<K>): Internal.Char2ShortFunction
        composeDouble(arg0: Internal.Double2ReferenceFunction<K>): Internal.Double2ShortFunction
    }
    class WriteBufferWaterMark {
        high(): number
        low(): number
        toString(): string
        static readonly DEFAULT : Internal.WriteBufferWaterMark;
    }
    class Player extends Internal.LivingEntity implements Internal.BackpackedInventoryAccess, Internal.PlayerKJS {
        getSuffixes(): Internal.Collection<Internal.MutableComponent>
        getCapability<T>(arg0: Internal.Capability<T>, arg1: Internal.Direction): Internal.LazyOptional<T>
        getPrefixes(): Internal.Collection<Internal.MutableComponent>
        handler$zba000$onFallFlying(arg0: number, arg1: number, arg2: number, arg3: Internal.CallbackInfo): void
        handler$zcb000$diet$constructPlayer(arg0: Internal.CallbackInfo): void
        getStagesRawKJS(): Internal.Stages
        getDigSpeed(arg0: Internal.BlockState, arg1: BlockPos): number
        handler$zba000$locateAmmo(arg0: Internal.ItemStack, arg1: Internal.CallbackInfoReturnable<any>, arg2: Internal.Predicate<any>): void
        getBackpackedInventory(): Internal.BackpackInventory
        refreshDisplayName(): void
        getStages(): Internal.Stages
        setForcedPose(arg0: Internal.Pose): void
        getForcedPose(): Internal.Pose
        backpackedMoved : boolean;
        backpackedInventory : Internal.BackpackInventory;
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
        get suffixes(): Internal.Collection<Internal.MutableComponent>;
        get prefixes(): Internal.Collection<Internal.MutableComponent>;
        get stagesRawKJS(): Internal.Stages;
        get stages(): Internal.Stages;
        set forcedPose(arg0: Internal.Pose);
        get forcedPose(): Internal.Pose;
    }
    interface Widget {
    }
    class FakeServerPlayerDataJS extends Internal.ServerPlayerDataJS {
        getMinecraftPlayer(): Internal.Player
        getMinecraftPlayer(): Internal.ServerPlayer
        getOverworld(): Internal.LevelJS
        player : Internal.ServerPlayer;
        get minecraftPlayer(): Internal.Player;
        get minecraftPlayer(): Internal.ServerPlayer;
        get overworld(): Internal.LevelJS;
    }
    interface Long2LongFunction implements Internal.Function<number, number>, Internal.LongUnaryOperator {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Long2ShortFunction): Internal.Long2ShortFunction
        composeByte(arg0: Internal.Byte2LongFunction): Internal.Byte2LongFunction
        andThenInt(arg0: Internal.Long2IntFunction): Internal.Long2IntFunction
        composeReference<T>(arg0: Internal.Reference2LongFunction<T>): Internal.Reference2LongFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.LongUnaryOperator): Internal.LongUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Long2DoubleFunction): Internal.Long2DoubleFunction
        andThenObject<T>(arg0: Internal.Long2ObjectFunction<T>): Internal.Long2ObjectFunction<T>
        static identity(): Internal.Long2LongFunction
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Long2LongFunction): Internal.Long2LongFunction
        composeLong(arg0: Internal.Long2LongFunction): Internal.Long2LongFunction
        andThenByte(arg0: Internal.Long2ByteFunction): Internal.Long2ByteFunction
        andThenFloat(arg0: Internal.Long2FloatFunction): Internal.Long2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2LongFunction): Internal.Int2LongFunction
        clear(): void
        composeFloat(arg0: Internal.Float2LongFunction): Internal.Float2LongFunction
        andThenChar(arg0: Internal.Long2CharFunction): Internal.Long2CharFunction
        applyAsLong(arg0: number): number
        composeObject<T>(arg0: Internal.Object2LongFunction<T>): Internal.Object2LongFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.LongUnaryOperator): Internal.LongUnaryOperator
        composeShort(arg0: Internal.Short2LongFunction): Internal.Short2LongFunction
        andThenReference<T>(arg0: Internal.Long2ReferenceFunction<T>): Internal.Long2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2LongFunction): Internal.Char2LongFunction
        composeDouble(arg0: Internal.Double2LongFunction): Internal.Double2LongFunction
    }
    interface IExtendedLootCondition implements Internal.LootItemCondition, Internal.ILootHandler {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        test(arg0: T): boolean
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean
        negate(): (arg0: T) => boolean
    }
    class LivingEntityJS extends Internal.EntityJS {
        getRevengeTimer(): number
        getLastAttackedEntity(): Internal.LivingEntityJS
        getAbsorptionAmount(): number
        getMaxHealth(): number
        getFeetArmorItem(): Internal.ItemStackJS
        isLiving(): boolean
        setMainHandItem(item: Internal.ItemStackJS): void
        getHeldItem(hand: Hand): Internal.ItemStackJS
        getRevengeTarget(): Internal.LivingEntityJS
        getOffHandItem(): Internal.ItemStackJS
        getEquipment(slot: EquipmentSlot): Internal.ItemStackJS
        damageHeldItem(hand: Hand, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void
        damageHeldItem(hand: Hand, amount: number): void
        damageHeldItem(): void
        getIdleTime(): number
        getMovementSpeed(): number
        getChestArmorItem(): Internal.ItemStackJS
        isUndead(): boolean
        isOnLadder(): boolean
        heal(hp: number): void
        setChestArmorItem(item: Internal.ItemStackJS): void
        setRevengeTarget(target: Internal.LivingEntityJS): void
        setMovementSpeed(speed: number): void
        setLegsArmorItem(item: Internal.ItemStackJS): void
        getMainHandItem(): Internal.ItemStackJS
        isChild(): boolean
        getHealth(): number
        setHealth(hp: number): void
        setFeetArmorItem(item: Internal.ItemStackJS): void
        setMaxHealth(hp: number): void
        getLastDamageSource(): Internal.DamageSourceJS
        isElytraFlying(): boolean
        getReachDistance(): number
        setEquipment(slot: EquipmentSlot, item: Internal.ItemStackJS): void
        getLegsArmorItem(): Internal.ItemStackJS
        isSleeping(): boolean
        swingArm(hand: Hand): void
        getPotionEffects(): Internal.EntityPotionEffectsJS
        getAttackingEntity(): Internal.LivingEntityJS
        rayTrace(): Internal.RayTraceResultJS
        isHoldingInAnyHand(ingredient: object): boolean
        setHeadArmorItem(item: Internal.ItemStackJS): void
        damageEquipment(slot: EquipmentSlot): void
        damageEquipment(slot: EquipmentSlot, amount: number): void
        damageEquipment(slot: EquipmentSlot, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void
        canEntityBeSeen(entity: Internal.LivingEntityJS): boolean
        setAbsorptionAmount(amount: number): void
        getHeadArmorItem(): Internal.ItemStackJS
        getLastAttackedEntityTime(): number
        setOffHandItem(item: Internal.ItemStackJS): void
        setHeldItem(hand: Hand, item: Internal.ItemStackJS): void
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        get revengeTimer(): number;
        get lastAttackedEntity(): Internal.LivingEntityJS;
        get absorptionAmount(): number;
        get maxHealth(): number;
        get feetArmorItem(): Internal.ItemStackJS;
        set mainHandItem(item: Internal.ItemStackJS);
        get revengeTarget(): Internal.LivingEntityJS;
        get offHandItem(): Internal.ItemStackJS;
        get idleTime(): number;
        get movementSpeed(): number;
        get chestArmorItem(): Internal.ItemStackJS;
        set chestArmorItem(item: Internal.ItemStackJS);
        set revengeTarget(target: Internal.LivingEntityJS);
        set movementSpeed(speed: number);
        set legsArmorItem(item: Internal.ItemStackJS);
        get mainHandItem(): Internal.ItemStackJS;
        get health(): number;
        set health(hp: number);
        set feetArmorItem(item: Internal.ItemStackJS);
        set maxHealth(hp: number);
        get lastDamageSource(): Internal.DamageSourceJS;
        get reachDistance(): number;
        get legsArmorItem(): Internal.ItemStackJS;
        get potionEffects(): Internal.EntityPotionEffectsJS;
        get attackingEntity(): Internal.LivingEntityJS;
        set headArmorItem(item: Internal.ItemStackJS);
        set absorptionAmount(amount: number);
        get headArmorItem(): Internal.ItemStackJS;
        get lastAttackedEntityTime(): number;
        set offHandItem(item: Internal.ItemStackJS);
    }
    interface TypeDescriptor$OfMethod <F, M> implements Internal.TypeDescriptor {
        parameterType(arg0: number): F
        parameterArray(): F[]
        dropParameterTypes(arg0: number, arg1: number): M
        parameterCount(): number
        changeReturnType(arg0: F): M
        descriptorString(): string
        parameterList(): Internal.List<F>
        insertParameterTypes(arg0: number, arg1: F[]): M
        returnType(): F
        changeParameterType(arg0: number, arg1: F): M
    }
    class Proxy {
        address(): Internal.SocketAddress
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        type(): Internal.Proxy$Type
        static readonly NO_PROXY : Internal.Proxy;
    }
    interface Container implements Internal.Clearable {
    }
    class CallbackInfo implements Internal.Cancellable {
        cancel(): void
        static getCallInfoClassName(arg0: org.objectweb.asm.Type): string
        isCancelled(): boolean
        isCancellable(): boolean
        getId(): string
        toString(): string
        get id(): string;
    }
    class AbstractList <E> extends Internal.AbstractCollection<E> implements Internal.List<E> {
        add(arg0: number, arg1: E): void
        add(arg0: E): boolean
        subList(arg0: number, arg1: number): Internal.List<E>
        set(arg0: number, arg1: E): E
        spliterator(): Internal.Spliterator<E>
        clear(): void
        sort(arg0: Internal.Comparator<E>): void
        replaceAll(arg0: Internal.UnaryOperator<E>): void
        remove(arg0: number): E
        lastIndexOf(arg0: object): number
        iterator(): Internal.Iterator<E>
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean
        hashCode(): number
        equals(arg0: object): boolean
        get(arg0: number): E
        listIterator(): Internal.ListIterator<E>
        listIterator(arg0: number): Internal.ListIterator<E>
        indexOf(arg0: object): number
    }
    class CrusherRecipeJS extends Internal.IERecipeJS {
        serialize(): void
        create(args: Internal.ListJS): void
        deserialize(): void
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<Internal.FluidStack>;
        originalRecipe : Internal.Recipe<object>;
        readonly inputFluids : Internal.List<Internal.FluidTagInput>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        id : ResourceLocation;
        serializeInputs : boolean;
    }
    interface Enumeration <E> {
        hasMoreElements(): boolean
        asIterator(): Internal.Iterator<E>
        nextElement(): E
    }
    interface ChronoLocalDateTime <D> implements Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.ChronoLocalDateTime<object>> {
        minus(arg0: Internal.TemporalAmount): Internal.Temporal
        minus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDateTime<D>
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDateTime<D>
        isEqual(arg0: Internal.ChronoLocalDateTime<object>): boolean
        toLocalTime(): Internal.LocalTime
        adjustInto(arg0: Internal.Temporal): Internal.Temporal
        range(arg0: Internal.TemporalField): Internal.ValueRange
        compareTo(arg0: object): number
        compareTo(arg0: Internal.ChronoLocalDateTime<object>): number
        hashCode(): number
        get(arg0: Internal.TemporalField): number
        static from(arg0: Internal.TemporalAccessor): Internal.ChronoLocalDateTime<object>
        getChronology(): Internal.Chronology
        query<R>(arg0: Internal.TemporalQuery<R>): R
        format(arg0: Internal.DateTimeFormatter): string
        isSupported(arg0: Internal.TemporalUnit): boolean
        isSupported(arg0: Internal.TemporalField): boolean
        atZone(arg0: Internal.ZoneId): Internal.ChronoZonedDateTime<D>
        toInstant(arg0: Internal.ZoneOffset): Internal.Instant
        isBefore(arg0: Internal.ChronoLocalDateTime<object>): boolean
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.ChronoLocalDateTime<D>
        plus(arg0: Internal.TemporalAmount): Internal.ChronoLocalDateTime<D>
        plus(arg0: Internal.TemporalAmount): Internal.Temporal
        getLong(arg0: Internal.TemporalField): number
        with(arg0: Internal.TemporalField, arg1: number): Internal.ChronoLocalDateTime<D>
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal
        with(arg0: Internal.TemporalAdjuster): Internal.ChronoLocalDateTime<D>
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal
        toLocalDate(): D
        toEpochSecond(arg0: Internal.ZoneOffset): number
        equals(arg0: object): boolean
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number
        static timeLineOrder(): Internal.Comparator<Internal.ChronoLocalDateTime<object>>
        toString(): string
        isAfter(arg0: Internal.ChronoLocalDateTime<object>): boolean
        get chronology(): Internal.Chronology;
    }
    interface IntSupplier {
        getAsInt(): number
        get asInt(): number;
    }
    interface BlockAndTintGetter implements Internal.BlockGetter {
    }
    class LootContext {
        getLootingModifier(): number
        setQueriedLootTableId(arg0: ResourceLocation): void
        getQueriedLootTableId(): ResourceLocation
        get lootingModifier(): number;
        set queriedLootTableId(arg0: ResourceLocation);
        get queriedLootTableId(): ResourceLocation;
    }
    interface Float2ByteFunction implements Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Byte2ShortFunction): Internal.Float2ShortFunction
        composeByte(arg0: Internal.Byte2FloatFunction): Internal.Byte2ByteFunction
        andThenInt(arg0: Internal.Byte2IntFunction): Internal.Float2IntFunction
        composeReference<T>(arg0: Internal.Reference2FloatFunction<T>): Internal.Reference2ByteFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Byte2DoubleFunction): Internal.Float2DoubleFunction
        andThenObject<T>(arg0: Internal.Byte2ObjectFunction<T>): Internal.Float2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Byte2LongFunction): Internal.Float2LongFunction
        composeLong(arg0: Internal.Long2FloatFunction): Internal.Long2ByteFunction
        andThenByte(arg0: Internal.Byte2ByteFunction): Internal.Float2ByteFunction
        andThenFloat(arg0: Internal.Byte2FloatFunction): Internal.Float2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2FloatFunction): Internal.Int2ByteFunction
        clear(): void
        composeFloat(arg0: Internal.Float2FloatFunction): Internal.Float2ByteFunction
        andThenChar(arg0: Internal.Byte2CharFunction): Internal.Float2CharFunction
        composeObject<T>(arg0: Internal.Object2FloatFunction<T>): Internal.Object2ByteFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2FloatFunction): Internal.Short2ByteFunction
        andThenReference<T>(arg0: Internal.Byte2ReferenceFunction<T>): Internal.Float2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2FloatFunction): Internal.Char2ByteFunction
        composeDouble(arg0: Internal.Double2FloatFunction): Internal.Double2ByteFunction
    }
    class CodingErrorAction {
        toString(): string
        static readonly REPORT : Internal.CodingErrorAction;
        static readonly IGNORE : Internal.CodingErrorAction;
        static readonly REPLACE : Internal.CodingErrorAction;
    }
    class ClientboundBlockEntityDataPacket implements Internal.Packet<Unknown> {
    }
    interface GuiEventListener {
    }
    class FileLock implements Internal.AutoCloseable {
        size(): number
        release(): void
        isValid(): boolean
        overlaps(arg0: number, arg1: number): boolean
        channel(): Internal.FileChannel
        toString(): string
        position(): number
        close(): void
        isShared(): boolean
        acquiredBy(): java_.nio.channels.Channel
    }
    interface K1 {
    }
    class RecordCodecBuilder$Instance <O> implements Internal.Applicative<Internal.RecordCodecBuilder$Mu<O>, Unknown<O>> {
        deprecated<A>(arg0: A, arg1: number): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A>
        point<A>(arg0: A, arg1: Internal.Lifecycle): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A>
        point<A>(arg0: A): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A>
        map<T, R>(arg0: (arg0: T) => R, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>): Internal.Products$P11<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>): Internal.Products$P10<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>): Internal.Products$P9<F, T1, T2, T3, T4, T5, T6, T7, T8, T9>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>, arg13: Internal.App<F, T14>, arg14: Internal.App<F, T15>, arg15: Internal.App<F, T16>): Internal.Products$P16<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>, arg13: Internal.App<F, T14>, arg14: Internal.App<F, T15>): Internal.Products$P15<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>, arg13: Internal.App<F, T14>): Internal.Products$P14<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>): Internal.Products$P13<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>): Internal.Products$P12<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
        group<T1, T2, T3>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>): Internal.Products$P3<F, T1, T2, T3>
        group<T1, T2>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>): Internal.Products$P2<F, T1, T2>
        group<T1>(arg0: Internal.App<F, T1>): Internal.Products$P1<F, T1>
        group<T1, T2, T3, T4, T5, T6, T7, T8>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        group<T1, T2, T3, T4, T5, T6, T7>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        group<T1, T2, T3, T4, T5, T6>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>
        group<T1, T2, T3, T4, T5>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>
        group<T1, T2, T3, T4>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>): Internal.Products$P4<F, T1, T2, T3, T4>
        apply2<A, B, R>(arg0: (arg0: A, arg1: B) => R, arg1: Internal.App<F, A>, arg2: Internal.App<F, B>): Internal.App<F, R>
        apply3<T1, T2, T3, R>(arg0: Internal.Function3<T1, T2, T3, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>): Internal.App<F, R>
        apply4<T1, T2, T3, T4, R>(arg0: Internal.Function4<T1, T2, T3, T4, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>): Internal.App<F, R>
        ap11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>(arg0: Internal.App<F, Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>): Internal.App<F, R>
        ap2<A, B, R>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, (arg0: A, arg1: B) => R>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, A>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, B>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>
        apply5<T1, T2, T3, T4, T5, R>(arg0: Internal.Function5<T1, T2, T3, T4, T5, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>): Internal.App<F, R>
        ap10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>(arg0: Internal.App<F, Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>): Internal.App<F, R>
        lift2<A, B, R>(arg0: Internal.App<F, (arg0: A, arg1: B) => R>): (arg0: Internal.App<F, A>, arg1: Internal.App<F, B>) => Internal.App<F, R>
        ap4<T1, T2, T3, T4, R>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function4<T1, T2, T3, T4, R>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>
        ap3<T1, T2, T3, R>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function3<T1, T2, T3, R>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>
        lift1<A, R>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, (arg0: A) => R>): (arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, A>) => Internal.App<Internal.RecordCodecBuilder$Mu<O>, R>
        ap6<T1, T2, T3, T4, T5, T6, R>(arg0: Internal.App<F, Internal.Function6<T1, T2, T3, T4, T5, T6, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>): Internal.App<F, R>
        ap5<T1, T2, T3, T4, T5, R>(arg0: Internal.App<F, Internal.Function5<T1, T2, T3, T4, T5, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>): Internal.App<F, R>
        ap8<T1, T2, T3, T4, T5, T6, T7, T8, R>(arg0: Internal.App<F, Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>): Internal.App<F, R>
        lift6<T1, T2, T3, T4, T5, T6, R>(arg0: Internal.App<F, Internal.Function6<T1, T2, T3, T4, T5, T6, R>>): Internal.Function6<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, R>>
        lift5<T1, T2, T3, T4, T5, R>(arg0: Internal.App<F, Internal.Function5<T1, T2, T3, T4, T5, R>>): Internal.Function5<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, R>>
        ap7<T1, T2, T3, T4, T5, T6, T7, R>(arg0: Internal.App<F, Internal.Function7<T1, T2, T3, T4, T5, T6, T7, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>): Internal.App<F, R>
        lift4<T1, T2, T3, T4, R>(arg0: Internal.App<F, Internal.Function4<T1, T2, T3, T4, R>>): Internal.Function4<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, R>>
        ap9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>(arg0: Internal.App<F, Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>): Internal.App<F, R>
        lift3<T1, T2, T3, R>(arg0: Internal.App<F, Internal.Function3<T1, T2, T3, R>>): Internal.Function3<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, R>>
        apply6<T1, T2, T3, T4, T5, T6, R>(arg0: Internal.Function6<T1, T2, T3, T4, T5, T6, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>): Internal.App<F, R>
        apply7<T1, T2, T3, T4, T5, T6, T7, R>(arg0: Internal.Function7<T1, T2, T3, T4, T5, T6, T7, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>): Internal.App<F, R>
        lift9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>(arg0: Internal.App<F, Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>): Internal.Function9<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, T7>, Internal.App<F, T8>, Internal.App<F, T9>, Internal.App<F, R>>
        apply8<T1, T2, T3, T4, T5, T6, T7, T8, R>(arg0: Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>): Internal.App<F, R>
        lift8<T1, T2, T3, T4, T5, T6, T7, T8, R>(arg0: Internal.App<F, Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>>): Internal.Function8<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, T7>, Internal.App<F, T8>, Internal.App<F, R>>
        apply9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>(arg0: Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>): Internal.App<F, R>
        lift7<T1, T2, T3, T4, T5, T6, T7, R>(arg0: Internal.App<F, Internal.Function7<T1, T2, T3, T4, T5, T6, T7, R>>): Internal.Function7<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, T7>, Internal.App<F, R>>
        ap<A, R>(arg0: Internal.App<F, (arg0: A) => R>, arg1: Internal.App<F, A>): Internal.App<F, R>
        ap<A, R>(arg0: (arg0: A) => R, arg1: Internal.App<F, A>): Internal.App<F, R>
        stable<A>(arg0: A): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A>
        ap16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>(arg0: Internal.App<F, Internal.Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>, arg12: Internal.App<F, T12>, arg13: Internal.App<F, T13>, arg14: Internal.App<F, T14>, arg15: Internal.App<F, T15>, arg16: Internal.App<F, T16>): Internal.App<F, R>
        ap13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>(arg0: Internal.App<F, Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>, arg12: Internal.App<F, T12>, arg13: Internal.App<F, T13>): Internal.App<F, R>
        ap12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>(arg0: Internal.App<F, Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>, arg12: Internal.App<F, T12>): Internal.App<F, R>
        ap15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>(arg0: Internal.App<F, Internal.Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>, arg12: Internal.App<F, T12>, arg13: Internal.App<F, T13>, arg14: Internal.App<F, T14>, arg15: Internal.App<F, T15>): Internal.App<F, R>
        ap14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>(arg0: Internal.App<F, Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>, arg12: Internal.App<F, T12>, arg13: Internal.App<F, T13>, arg14: Internal.App<F, T14>): Internal.App<F, R>
    }
    class LightLayer extends Internal.Enum<Internal.LightLayer> {
        static valueOf(arg0: string): Internal.LightLayer
        static values(): Internal.LightLayer[]
        static readonly SKY : Internal.LightLayer;
        static readonly BLOCK : Internal.LightLayer;
    }
    interface Int2DoubleFunction implements Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        applyAsDouble(arg0: number): number
        andThenShort(arg0: Internal.Double2ShortFunction): Internal.Int2ShortFunction
        composeByte(arg0: Internal.Byte2IntFunction): Internal.Byte2DoubleFunction
        andThenInt(arg0: Internal.Double2IntFunction): Internal.Int2IntFunction
        composeReference<T>(arg0: Internal.Reference2IntFunction<T>): Internal.Reference2DoubleFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Double2DoubleFunction): Internal.Int2DoubleFunction
        andThenObject<T>(arg0: Internal.Double2ObjectFunction<T>): Internal.Int2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Double2LongFunction): Internal.Int2LongFunction
        composeLong(arg0: Internal.Long2IntFunction): Internal.Long2DoubleFunction
        andThenByte(arg0: Internal.Double2ByteFunction): Internal.Int2ByteFunction
        andThenFloat(arg0: Internal.Double2FloatFunction): Internal.Int2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2IntFunction): Internal.Int2DoubleFunction
        clear(): void
        composeFloat(arg0: Internal.Float2IntFunction): Internal.Float2DoubleFunction
        andThenChar(arg0: Internal.Double2CharFunction): Internal.Int2CharFunction
        composeObject<T>(arg0: Internal.Object2IntFunction<T>): Internal.Object2DoubleFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2IntFunction): Internal.Short2DoubleFunction
        andThenReference<T>(arg0: Internal.Double2ReferenceFunction<T>): Internal.Int2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2IntFunction): Internal.Char2DoubleFunction
        composeDouble(arg0: Internal.Double2IntFunction): Internal.Double2DoubleFunction
    }
    class ItemRegistryEventJS extends Internal.StartupEventJS {
        create(name: string, callback: (arg0: Internal.ItemBuilder) => void): void
        createFood(builder: () => Internal.FoodBuilder): () => Internal.FoodBuilder
    }
    interface Object2ObjectFunction <K, V> implements Internal.Function<K, V> {
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Object2ShortFunction<V>): Internal.Object2ShortFunction<K>
        composeByte(arg0: Internal.Byte2ObjectFunction<K>): Internal.Byte2ObjectFunction<V>
        andThenInt(arg0: Internal.Object2IntFunction<V>): Internal.Object2IntFunction<K>
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: (arg0: T) => K): (arg0: T) => V
        put(arg0: K, arg1: V): V
        remove(arg0: object): V
        defaultReturnValue(): V
        defaultReturnValue(arg0: V): void
        andThenDouble(arg0: Internal.Object2DoubleFunction<V>): Internal.Object2DoubleFunction<K>
        andThenObject<T>(arg0: (arg0: V) => T): (arg0: K) => T
        get(arg0: object): V
        andThenLong(arg0: Internal.Object2LongFunction<V>): Internal.Object2LongFunction<K>
        composeLong(arg0: Internal.Long2ObjectFunction<K>): Internal.Long2ObjectFunction<V>
        andThenByte(arg0: Internal.Object2ByteFunction<V>): Internal.Object2ByteFunction<K>
        andThenFloat(arg0: Internal.Object2FloatFunction<V>): Internal.Object2FloatFunction<K>
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ObjectFunction<K>): Internal.Int2ObjectFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2ObjectFunction<K>): Internal.Float2ObjectFunction<V>
        andThenChar(arg0: Internal.Object2CharFunction<V>): Internal.Object2CharFunction<K>
        composeObject<T>(arg0: (arg0: T) => K): (arg0: T) => V
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ObjectFunction<K>): Internal.Short2ObjectFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): (arg0: K) => T
        composeChar(arg0: Internal.Char2ObjectFunction<K>): Internal.Char2ObjectFunction<V>
        composeDouble(arg0: Internal.Double2ObjectFunction<K>): Internal.Double2ObjectFunction<V>
    }
    interface Short2ShortFunction implements Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Short2ShortFunction): Internal.Short2ShortFunction
        composeByte(arg0: Internal.Byte2ShortFunction): Internal.Byte2ShortFunction
        andThenInt(arg0: Internal.Short2IntFunction): Internal.Short2IntFunction
        composeReference<T>(arg0: Internal.Reference2ShortFunction<T>): Internal.Reference2ShortFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Short2DoubleFunction): Internal.Short2DoubleFunction
        andThenObject<T>(arg0: Internal.Short2ObjectFunction<T>): Internal.Short2ObjectFunction<T>
        static identity(): Internal.Short2ShortFunction
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Short2LongFunction): Internal.Short2LongFunction
        composeLong(arg0: Internal.Long2ShortFunction): Internal.Long2ShortFunction
        andThenByte(arg0: Internal.Short2ByteFunction): Internal.Short2ByteFunction
        andThenFloat(arg0: Internal.Short2FloatFunction): Internal.Short2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ShortFunction): Internal.Int2ShortFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ShortFunction): Internal.Float2ShortFunction
        andThenChar(arg0: Internal.Short2CharFunction): Internal.Short2CharFunction
        composeObject<T>(arg0: Internal.Object2ShortFunction<T>): Internal.Object2ShortFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2ShortFunction): Internal.Short2ShortFunction
        andThenReference<T>(arg0: Internal.Short2ReferenceFunction<T>): Internal.Short2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ShortFunction): Internal.Char2ShortFunction
        composeDouble(arg0: Internal.Double2ShortFunction): Internal.Double2ShortFunction
    }
    class AbstractCollection <E> implements Internal.Collection<E> {
        add(arg0: E): boolean
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: T) => void): void
        containsAll(arg0: Internal.Collection<object>): boolean
        isEmpty(): boolean
        clear(): void
        remove(arg0: object): boolean
        removeIf(arg0: (arg0: E) => boolean): boolean
        removeAll(arg0: Internal.Collection<object>): boolean
        contains(arg0: object): boolean
        iterator(): Internal.Iterator<E>
        size(): number
        stream(): Internal.Stream<E>
        addAll(arg0: Internal.Collection<E>): boolean
        toArray(): object[]
        toArray<T>(arg0: T[]): T[]
        toArray<T>(arg0: Internal.IntFunction<T[]>): T[]
        parallelStream(): Internal.Stream<E>
        toString(): string
        retainAll(arg0: Internal.Collection<object>): boolean
    }
    interface IForgeRegistryEntry <V> {
        getRegistryType(): Internal.Class<V>
        getRegistryName(): ResourceLocation
        setRegistryName(arg0: ResourceLocation): V
        get registryType(): Internal.Class<V>;
        get registryName(): ResourceLocation;
        set registryName(arg0: ResourceLocation);
    }
    class EventsJS$ScriptEventHandler {
    }
    interface Int2IntMap$Entry implements Internal.Map$Entry<number, number> {
        getIntKey(): number
        getKey(): object
        getKey(): number
        getValue(): number
        getValue(): object
        hashCode(): number
        getIntValue(): number
        equals(arg0: object): boolean
        setValue(arg0: object): object
        setValue(arg0: number): number
        setValue(arg0: number): number
        get intKey(): number;
        get key(): object;
        get key(): number;
        get value(): number;
        get value(): object;
        get intValue(): number;
        set value(arg0: object);
        set value(arg0: number);
        set value(arg0: number);
    }
    class ServerEventJS extends Internal.EventJS {
        getServer(): Internal.ServerJS
        get server(): Internal.ServerJS;
    }
    class EntityModel <T> extends Internal.Model {
    }
    interface MapCodec$ResultFunction <A> {
        apply<T>(arg0: Internal.DynamicOps<T>, arg1: Internal.MapLike<T>, arg2: Internal.DataResult<A>): Internal.DataResult<A>
        coApply<T>(arg0: Internal.DynamicOps<T>, arg1: A, arg2: Internal.RecordBuilder<T>): Internal.RecordBuilder<T>
    }
    interface Member {
        getDeclaringClass(): Internal.Class<object>
        getName(): string
        isSynthetic(): boolean
        getModifiers(): number
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get declaringClass(): Internal.Class<object>;
        get name(): string;
        get modifiers(): number;
    }
    class Products$P4 <F, T1, T2, T3, T4> {
        t4(): Internal.App<F, T4>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.Function4<T1, T2, T3, T4, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, Internal.Function4<T1, T2, T3, T4, R>>): Internal.App<F, R>
        and<T5, T6, T7>(arg0: Internal.Products$P3<F, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        and<T5, T6, T7, T8>(arg0: Internal.Products$P4<F, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        and<T5, T6>(arg0: Internal.Products$P2<F, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>
        and<T5>(arg0: Internal.App<F, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>
        t1(): Internal.App<F, T1>
        t2(): Internal.App<F, T2>
        t3(): Internal.App<F, T3>
    }
    class MinMaxBounds$Doubles extends Internal.MinMaxBounds<number> {
    }
    class Vector3d {
    }
    class ChronoField extends Internal.Enum<Internal.ChronoField> implements Internal.TemporalField {
        resolve(arg0: Map<Internal.TemporalField, number>, arg1: Internal.TemporalAccessor, arg2: Internal.ResolverStyle): Internal.TemporalAccessor
        static valueOf(arg0: string): Internal.ChronoField
        static values(): Internal.ChronoField[]
        adjustInto<R>(arg0: R, arg1: number): R
        range(): Internal.ValueRange
        getRangeUnit(): Internal.TemporalUnit
        getBaseUnit(): Internal.TemporalUnit
        rangeRefinedBy(arg0: Internal.TemporalAccessor): Internal.ValueRange
        getDisplayName(arg0: Internal.Locale): string
        isTimeBased(): boolean
        checkValidIntValue(arg0: number): number
        checkValidValue(arg0: number): number
        toString(): string
        isDateBased(): boolean
        getFrom(arg0: Internal.TemporalAccessor): number
        isSupportedBy(arg0: Internal.TemporalAccessor): boolean
        static readonly CLOCK_HOUR_OF_AMPM : Internal.ChronoField;
        static readonly DAY_OF_YEAR : Internal.ChronoField;
        static readonly MICRO_OF_DAY : Internal.ChronoField;
        static readonly ALIGNED_DAY_OF_WEEK_IN_MONTH : Internal.ChronoField;
        static readonly DAY_OF_MONTH : Internal.ChronoField;
        static readonly SECOND_OF_MINUTE : Internal.ChronoField;
        static readonly PROLEPTIC_MONTH : Internal.ChronoField;
        static readonly MILLI_OF_SECOND : Internal.ChronoField;
        static readonly NANO_OF_DAY : Internal.ChronoField;
        static readonly CLOCK_HOUR_OF_DAY : Internal.ChronoField;
        static readonly MINUTE_OF_DAY : Internal.ChronoField;
        static readonly ALIGNED_WEEK_OF_MONTH : Internal.ChronoField;
        static readonly YEAR : Internal.ChronoField;
        static readonly HOUR_OF_DAY : Internal.ChronoField;
        static readonly MILLI_OF_DAY : Internal.ChronoField;
        static readonly ALIGNED_DAY_OF_WEEK_IN_YEAR : Internal.ChronoField;
        static readonly YEAR_OF_ERA : Internal.ChronoField;
        static readonly AMPM_OF_DAY : Internal.ChronoField;
        static readonly NANO_OF_SECOND : Internal.ChronoField;
        static readonly SECOND_OF_DAY : Internal.ChronoField;
        static readonly MICRO_OF_SECOND : Internal.ChronoField;
        static readonly MONTH_OF_YEAR : Internal.ChronoField;
        static readonly EPOCH_DAY : Internal.ChronoField;
        static readonly ERA : Internal.ChronoField;
        static readonly OFFSET_SECONDS : Internal.ChronoField;
        static readonly HOUR_OF_AMPM : Internal.ChronoField;
        static readonly MINUTE_OF_HOUR : Internal.ChronoField;
        static readonly INSTANT_SECONDS : Internal.ChronoField;
        static readonly ALIGNED_WEEK_OF_YEAR : Internal.ChronoField;
        static readonly DAY_OF_WEEK : Internal.ChronoField;
        get rangeUnit(): Internal.TemporalUnit;
        get baseUnit(): Internal.TemporalUnit;
    }
    class VariantBlockStateGenerator {
        toJson(): Internal.JsonObject
        variant(key: string, model: string): void
        variant(key: string, consumer: (arg0: Internal.VariantBlockStateGenerator$Variant) => void): void
    }
    interface Double2LongFunction implements Internal.Function<number, number>, Internal.DoubleToLongFunction {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Long2ShortFunction): Internal.Double2ShortFunction
        composeByte(arg0: Internal.Byte2DoubleFunction): Internal.Byte2LongFunction
        andThenInt(arg0: Internal.Long2IntFunction): Internal.Double2IntFunction
        composeReference<T>(arg0: Internal.Reference2DoubleFunction<T>): Internal.Reference2LongFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Long2DoubleFunction): Internal.Double2DoubleFunction
        andThenObject<T>(arg0: Internal.Long2ObjectFunction<T>): Internal.Double2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Long2LongFunction): Internal.Double2LongFunction
        composeLong(arg0: Internal.Long2DoubleFunction): Internal.Long2LongFunction
        andThenByte(arg0: Internal.Long2ByteFunction): Internal.Double2ByteFunction
        andThenFloat(arg0: Internal.Long2FloatFunction): Internal.Double2FloatFunction
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2DoubleFunction): Internal.Int2LongFunction
        clear(): void
        composeFloat(arg0: Internal.Float2DoubleFunction): Internal.Float2LongFunction
        andThenChar(arg0: Internal.Long2CharFunction): Internal.Double2CharFunction
        applyAsLong(arg0: number): number
        composeObject<T>(arg0: Internal.Object2DoubleFunction<T>): Internal.Object2LongFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        composeShort(arg0: Internal.Short2DoubleFunction): Internal.Short2LongFunction
        andThenReference<T>(arg0: Internal.Long2ReferenceFunction<T>): Internal.Double2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2DoubleFunction): Internal.Char2LongFunction
        composeDouble(arg0: Internal.Double2DoubleFunction): Internal.Double2LongFunction
    }
    interface TemporalAmount {
        subtractFrom(arg0: Internal.Temporal): Internal.Temporal
        get(arg0: Internal.TemporalUnit): number
        getUnits(): Internal.List<Internal.TemporalUnit>
        addTo(arg0: Internal.Temporal): Internal.Temporal
        get units(): Internal.List<Internal.TemporalUnit>;
    }
    class NonNullList <E> extends Internal.AbstractList<E> implements Internal.DefaultedListAccessor {
        add(arg0: number, arg1: E): void
        set(arg0: number, arg1: E): E
        size(): number
        get(arg0: number): E
        clear(): void
        getDelegate(): Internal.List<any>
        remove(arg0: number): E
        get delegate(): Internal.List<any>;
    }
    class LithiumStackList extends Internal.NonNullList<Internal.ItemStack> implements Internal.LithiumDefaultedList {
        add(slot: number, element: Internal.ItemStack): void
        add(arg0: number, arg1: object): void
        set(arg0: number, arg1: object): object
        set(index: number, element: Internal.ItemStack): Internal.ItemStack
        clear(): void
        clearSignalStrengthOverride(): void
        hasSignalStrengthOverride(): boolean
        beforeSlotCountChange(slot: number, newCount: number): void
        changedInteractionConditions(): void
        remove(arg0: number): object
        remove(index: number): Internal.ItemStack
        getOccupiedSlots(): number
        runComparatorUpdatePatternOnFailedExtract(masterStackList: Internal.LithiumStackList, inventory: Internal.Container): void
        setReducedSignalStrengthOverride(): void
        getModCount(): number
        setUnstableInteractionConditions(): void
        changedALot(): void
        getSignalStrength(inventory: Internal.Container): number
        getFullSlots(): number
        changed(): void
        get occupiedSlots(): number;
        get modCount(): number;
        get fullSlots(): number;
    }
    interface LevelHeightAccessor {
    }
    interface RenderTypeExtension {
        flywheel$getDrawBuffer(): Internal.DrawBuffer
        static getDrawBuffer(arg0: Internal.RenderType): Internal.DrawBuffer
    }
    class InputStream implements Internal.Closeable {
        read(arg0: number[], arg1: number, arg2: number): number
        read(arg0: number[]): number
        read(): number
        markSupported(): boolean
        available(): number
        readAllBytes(): number[]
        static nullInputStream(): Internal.InputStream
        reset(): void
        readNBytes(arg0: number): number[]
        readNBytes(arg0: number[], arg1: number, arg2: number): number
        skip(arg0: number): number
        transferTo(arg0: Internal.OutputStream): number
        close(): void
        skipNBytes(arg0: number): void
        mark(arg0: number): void
    }
    class TwoHandedAnimation {
        setTwoHanded(arg0: boolean): void
        isTwoHanded(): boolean
        set twoHanded(arg0: boolean);
    }
    interface Applicative <F, Mu> implements Internal.Functor<F, Mu> {
        point<A>(arg0: A): Internal.App<F, A>
        map<T, R>(arg0: (arg0: T) => R, arg1: Internal.App<F, T>): Internal.App<F, R>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>): Internal.Products$P11<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>): Internal.Products$P10<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>): Internal.Products$P9<F, T1, T2, T3, T4, T5, T6, T7, T8, T9>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>, arg13: Internal.App<F, T14>, arg14: Internal.App<F, T15>, arg15: Internal.App<F, T16>): Internal.Products$P16<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>, arg13: Internal.App<F, T14>, arg14: Internal.App<F, T15>): Internal.Products$P15<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>, arg13: Internal.App<F, T14>): Internal.Products$P14<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>, arg12: Internal.App<F, T13>): Internal.Products$P13<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
        group<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>, arg8: Internal.App<F, T9>, arg9: Internal.App<F, T10>, arg10: Internal.App<F, T11>, arg11: Internal.App<F, T12>): Internal.Products$P12<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
        group<T1, T2, T3>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>): Internal.Products$P3<F, T1, T2, T3>
        group<T1, T2>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>): Internal.Products$P2<F, T1, T2>
        group<T1>(arg0: Internal.App<F, T1>): Internal.Products$P1<F, T1>
        group<T1, T2, T3, T4, T5, T6, T7, T8>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>, arg7: Internal.App<F, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>
        group<T1, T2, T3, T4, T5, T6, T7>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>, arg6: Internal.App<F, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>
        group<T1, T2, T3, T4, T5, T6>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>, arg5: Internal.App<F, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>
        group<T1, T2, T3, T4, T5>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>, arg4: Internal.App<F, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>
        group<T1, T2, T3, T4>(arg0: Internal.App<F, T1>, arg1: Internal.App<F, T2>, arg2: Internal.App<F, T3>, arg3: Internal.App<F, T4>): Internal.Products$P4<F, T1, T2, T3, T4>
        apply2<A, B, R>(arg0: (arg0: A, arg1: B) => R, arg1: Internal.App<F, A>, arg2: Internal.App<F, B>): Internal.App<F, R>
        apply3<T1, T2, T3, R>(arg0: Internal.Function3<T1, T2, T3, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>): Internal.App<F, R>
        ap2<A, B, R>(arg0: Internal.App<F, (arg0: A, arg1: B) => R>, arg1: Internal.App<F, A>, arg2: Internal.App<F, B>): Internal.App<F, R>
        apply4<T1, T2, T3, T4, R>(arg0: Internal.Function4<T1, T2, T3, T4, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>): Internal.App<F, R>
        ap11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>(arg0: Internal.App<F, Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>): Internal.App<F, R>
        apply5<T1, T2, T3, T4, T5, R>(arg0: Internal.Function5<T1, T2, T3, T4, T5, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>): Internal.App<F, R>
        ap10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>(arg0: Internal.App<F, Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>): Internal.App<F, R>
        ap4<T1, T2, T3, T4, R>(arg0: Internal.App<F, Internal.Function4<T1, T2, T3, T4, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>): Internal.App<F, R>
        lift2<A, B, R>(arg0: Internal.App<F, (arg0: A, arg1: B) => R>): (arg0: Internal.App<F, A>, arg1: Internal.App<F, B>) => Internal.App<F, R>
        ap3<T1, T2, T3, R>(arg0: Internal.App<F, Internal.Function3<T1, T2, T3, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>): Internal.App<F, R>
        lift1<A, R>(arg0: Internal.App<F, (arg0: A) => R>): (arg0: Internal.App<F, A>) => Internal.App<F, R>
        ap6<T1, T2, T3, T4, T5, T6, R>(arg0: Internal.App<F, Internal.Function6<T1, T2, T3, T4, T5, T6, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>): Internal.App<F, R>
        ap5<T1, T2, T3, T4, T5, R>(arg0: Internal.App<F, Internal.Function5<T1, T2, T3, T4, T5, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>): Internal.App<F, R>
        ap8<T1, T2, T3, T4, T5, T6, T7, T8, R>(arg0: Internal.App<F, Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>): Internal.App<F, R>
        lift6<T1, T2, T3, T4, T5, T6, R>(arg0: Internal.App<F, Internal.Function6<T1, T2, T3, T4, T5, T6, R>>): Internal.Function6<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, R>>
        lift5<T1, T2, T3, T4, T5, R>(arg0: Internal.App<F, Internal.Function5<T1, T2, T3, T4, T5, R>>): Internal.Function5<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, R>>
        ap7<T1, T2, T3, T4, T5, T6, T7, R>(arg0: Internal.App<F, Internal.Function7<T1, T2, T3, T4, T5, T6, T7, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>): Internal.App<F, R>
        lift4<T1, T2, T3, T4, R>(arg0: Internal.App<F, Internal.Function4<T1, T2, T3, T4, R>>): Internal.Function4<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, R>>
        ap9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>(arg0: Internal.App<F, Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>): Internal.App<F, R>
        lift3<T1, T2, T3, R>(arg0: Internal.App<F, Internal.Function3<T1, T2, T3, R>>): Internal.Function3<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, R>>
        apply6<T1, T2, T3, T4, T5, T6, R>(arg0: Internal.Function6<T1, T2, T3, T4, T5, T6, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>): Internal.App<F, R>
        apply7<T1, T2, T3, T4, T5, T6, T7, R>(arg0: Internal.Function7<T1, T2, T3, T4, T5, T6, T7, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>): Internal.App<F, R>
        lift9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>(arg0: Internal.App<F, Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>): Internal.Function9<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, T7>, Internal.App<F, T8>, Internal.App<F, T9>, Internal.App<F, R>>
        apply8<T1, T2, T3, T4, T5, T6, T7, T8, R>(arg0: Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>): Internal.App<F, R>
        lift8<T1, T2, T3, T4, T5, T6, T7, T8, R>(arg0: Internal.App<F, Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>>): Internal.Function8<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, T7>, Internal.App<F, T8>, Internal.App<F, R>>
        apply9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>(arg0: Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>): Internal.App<F, R>
        lift7<T1, T2, T3, T4, T5, T6, T7, R>(arg0: Internal.App<F, Internal.Function7<T1, T2, T3, T4, T5, T6, T7, R>>): Internal.Function7<Internal.App<F, T1>, Internal.App<F, T2>, Internal.App<F, T3>, Internal.App<F, T4>, Internal.App<F, T5>, Internal.App<F, T6>, Internal.App<F, T7>, Internal.App<F, R>>
        ap<A, R>(arg0: Internal.App<F, (arg0: A) => R>, arg1: Internal.App<F, A>): Internal.App<F, R>
        ap<A, R>(arg0: (arg0: A) => R, arg1: Internal.App<F, A>): Internal.App<F, R>
        static unbox<F, Mu>(arg0: Internal.App<Mu, F>): Internal.Applicative<F, Mu>
        ap16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>(arg0: Internal.App<F, Internal.Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>, arg12: Internal.App<F, T12>, arg13: Internal.App<F, T13>, arg14: Internal.App<F, T14>, arg15: Internal.App<F, T15>, arg16: Internal.App<F, T16>): Internal.App<F, R>
        ap13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>(arg0: Internal.App<F, Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>, arg12: Internal.App<F, T12>, arg13: Internal.App<F, T13>): Internal.App<F, R>
        ap12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>(arg0: Internal.App<F, Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>, arg12: Internal.App<F, T12>): Internal.App<F, R>
        ap15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>(arg0: Internal.App<F, Internal.Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>, arg12: Internal.App<F, T12>, arg13: Internal.App<F, T13>, arg14: Internal.App<F, T14>, arg15: Internal.App<F, T15>): Internal.App<F, R>
        ap14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>(arg0: Internal.App<F, Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>, arg1: Internal.App<F, T1>, arg2: Internal.App<F, T2>, arg3: Internal.App<F, T3>, arg4: Internal.App<F, T4>, arg5: Internal.App<F, T5>, arg6: Internal.App<F, T6>, arg7: Internal.App<F, T7>, arg8: Internal.App<F, T8>, arg9: Internal.App<F, T9>, arg10: Internal.App<F, T10>, arg11: Internal.App<F, T11>, arg12: Internal.App<F, T12>, arg13: Internal.App<F, T13>, arg14: Internal.App<F, T14>): Internal.App<F, R>
    }
    class Products$P16 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> {
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>): Internal.App<F, R>
        apply<R>(arg0: Internal.Applicative<F, object>, arg1: Internal.App<F, Internal.Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>): Internal.App<F, R>
    }
    interface IForgeVertexConsumer {
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer): number
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void
        applyBakedNormals(arg0: Internal.Vector3f, arg1: Internal.ByteBuffer, arg2: Internal.Matrix3f): void
    }
    interface TypeAdapterFactory {
        create<T>(arg0: Internal.Gson, arg1: Internal.TypeToken<T>): Internal.TypeAdapter<T>
    }
    class ObjectiveCriteria {
    }
    interface Matrix3fExtended {
        getA20(): number
        rotate(arg0: Internal.Quaternion): void
        getA21(): number
        getA10(): number
        getA22(): number
        getA00(): number
        getA11(): number
        getA12(): number
        getA01(): number
        getA02(): number
        transformVecZ(dir: Internal.Vector3f): number
        transformVecZ(arg0: number, arg1: number, arg2: number): number
        transformVecY(dir: Internal.Vector3f): number
        transformVecY(arg0: number, arg1: number, arg2: number): number
        transformVecX(arg0: number, arg1: number, arg2: number): number
        transformVecX(dir: Internal.Vector3f): number
        computeNormal(arg0: Internal.Direction): number
        get a20(): number;
        get a21(): number;
        get a10(): number;
        get a22(): number;
        get a00(): number;
        get a11(): number;
        get a12(): number;
        get a01(): number;
        get a02(): number;
    }
    class EntityEventJS extends Internal.LevelEventJS {
        getLevel(): Internal.LevelJS
        getEntity(): Internal.EntityJS
        get level(): Internal.LevelJS;
        get entity(): Internal.EntityJS;
    }
    interface NearbyEntityListenerProvider {
        getListener(): Internal.NearbyEntityListenerMulti
        addListener(arg0: Internal.NearbyEntityListener): void
        get listener(): Internal.NearbyEntityListenerMulti;
    }
    interface ChangeListener <T> {
        onChanged(arg0: T): void
    }
    interface Multiset <E> implements Internal.Collection<E> {
        add(arg0: E, arg1: number): number
        add(arg0: E): boolean
        forEachEntry(arg0: Internal.ObjIntConsumer<E>): void
        entrySet(): Internal.Set<Internal.Multiset$Entry<E>>
        spliterator(): Internal.Spliterator<E>
        forEach(arg0: (arg0: E) => void): void
        containsAll(arg0: Internal.Collection<object>): boolean
        isEmpty(): boolean
        clear(): void
        count(arg0: object): number
        remove(arg0: object, arg1: number): number
        remove(arg0: object): boolean
        removeIf(arg0: (arg0: E) => boolean): boolean
        removeAll(arg0: Internal.Collection<object>): boolean
        contains(arg0: object): boolean
        iterator(): Internal.Iterator<E>
        size(): number
        addAll(arg0: Internal.Collection<E>): boolean
        stream(): Internal.Stream<E>
        elementSet(): Internal.Set<E>
        hashCode(): number
        equals(arg0: object): boolean
        toArray<T>(arg0: T[]): T[]
        toArray<T>(arg0: Internal.IntFunction<T[]>): T[]
        toArray(): object[]
        parallelStream(): Internal.Stream<E>
        toString(): string
        setCount(arg0: E, arg1: number, arg2: number): boolean
        setCount(arg0: E, arg1: number): number
        retainAll(arg0: Internal.Collection<object>): boolean
    }
    interface ProgressiveFuture <V> implements io.netty.util.concurrent.Future<V> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.ProgressiveFuture<V>
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        getNow(): V
        cause(): Internal.Throwable
        awaitUninterruptibly(): Internal.ProgressiveFuture<V>
        awaitUninterruptibly(): io.netty.util.concurrent.Future<V>
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.ProgressiveFuture<V>
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        isDone(): boolean
        sync(): Internal.ProgressiveFuture<V>
        sync(): io.netty.util.concurrent.Future<V>
        syncUninterruptibly(): Internal.ProgressiveFuture<V>
        syncUninterruptibly(): io.netty.util.concurrent.Future<V>
        get(arg0: number, arg1: Internal.TimeUnit): V
        get(): V
        isCancellable(): boolean
        await(): Internal.ProgressiveFuture<V>
        await(): io.netty.util.concurrent.Future<V>
        await(arg0: number): boolean
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): Internal.ProgressiveFuture<V>
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        isSuccess(): boolean
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): Internal.ProgressiveFuture<V>
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        get now(): V;
    }
    class EntityType <T> extends Internal.ForgeRegistryEntry<Internal.EntityType<object>> implements Internal.EntityTypeTest<Internal.Entity, T>, Internal.EntityTypeExtension {
        getTags(): Internal.Set<ResourceLocation>
        toString(): string
        customClientSpawn(arg0: Internal.PlayMessages$SpawnEntity, arg1: Internal.Level): T
        flywheel$setInstancingController(arg0: Internal.EntityInstancingController<any>): void
        flywheel$getInstancingController(): Internal.EntityInstancingController<any>
        readonly delegate : () => V;
        get tags(): Internal.Set<ResourceLocation>;
    }
    interface NavigatingEntity {
        updateNavigationRegistration(): void
        getRegisteredNavigation(): Internal.PathNavigation
        isRegisteredToWorld(): boolean
        setRegisteredToWorld(arg0: Internal.PathNavigation): void
        get registeredNavigation(): Internal.PathNavigation;
        set registeredToWorld(arg0: Internal.PathNavigation);
    }
    interface Tier {
        getTag(): Internal.Tag<Internal.Block>
        get tag(): Internal.Tag<Internal.Block>;
    }
    class WorldGenSettings {
    }
    interface LevelAccessor implements Internal.CommonLevelAccessor, Internal.LevelTimeAccess {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean
    }
    class NetworkDirection extends Internal.Enum<Internal.NetworkDirection> {
        getEvent(arg0: Internal.ICustomPacket<object>, arg1: () => Internal.NetworkEvent$Context): Internal.NetworkEvent
        getReceptionSide(): Internal.LogicalSide
        buildPacket<T>(arg0: Internal.Pair<Internal.FriendlyByteBuf, number>, arg1: ResourceLocation): Internal.ICustomPacket<T>
        static directionFor<T>(arg0: Internal.Class<T>): Internal.NetworkDirection
        static valueOf(arg0: string): Internal.NetworkDirection
        static values(): Internal.NetworkDirection[]
        reply(): Internal.NetworkDirection
        getOriginationSide(): Internal.LogicalSide
        static readonly LOGIN_TO_CLIENT : Internal.NetworkDirection;
        static readonly PLAY_TO_SERVER : Internal.NetworkDirection;
        static readonly LOGIN_TO_SERVER : Internal.NetworkDirection;
        static readonly PLAY_TO_CLIENT : Internal.NetworkDirection;
        get receptionSide(): Internal.LogicalSide;
        get originationSide(): Internal.LogicalSide;
    }
    class MethodHandles$Lookup$ClassOption extends Internal.Enum<Internal.MethodHandles$Lookup$ClassOption> {
        static valueOf(arg0: string): Internal.MethodHandles$Lookup$ClassOption
        static values(): Internal.MethodHandles$Lookup$ClassOption[]
        static readonly NESTMATE : Internal.MethodHandles$Lookup$ClassOption;
        static readonly STRONG : Internal.MethodHandles$Lookup$ClassOption;
    }
    class IngredientWithCustomPredicateJS implements Internal.IngredientJS {
        anyStackMatches(ingredient: Internal.IngredientJS): boolean
        getItemIds(): Internal.Set<string>
        testVanillaItem(i: Internal.Item): boolean
        test(stack: Internal.ItemStackJS): boolean
        getStacks(): Internal.Set<Internal.ItemStackJS>
        getVanillaItems(): Internal.Set<Internal.Item>
        isEmpty(): boolean
        asIngredientStack(): Internal.IngredientStackJS
        isInvalidRecipeIngredient(): boolean
        getVanillaPredicate(): (arg0: Internal.ItemStack) => boolean
        filter(filter: Internal.IngredientJS): Internal.IngredientJS
        createVanillaIngredient(): Internal.Ingredient
        not(): Internal.IngredientJS
        toJson(): Internal.JsonElement
        withCount(count: number): Internal.IngredientJS
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>
        getFirst(): Internal.ItemStackJS
        testVanilla(stack: Internal.ItemStack): boolean
        x(c: number): Internal.IngredientJS
        toString(): string
        copy(): Internal.IngredientJS
        copy(): Internal.Copyable
        getCount(): number
        readonly predicate : (arg0: Internal.ItemStack) => boolean;
        readonly ingredient : Internal.IngredientJS;
        readonly uuid : Internal.UUID;
        get itemIds(): Internal.Set<string>;
        get stacks(): Internal.Set<Internal.ItemStackJS>;
        get vanillaItems(): Internal.Set<Internal.Item>;
        get vanillaPredicate(): (arg0: Internal.ItemStack) => boolean;
        get first(): Internal.ItemStackJS;
        get count(): number;
    }
    interface GenericFutureListener <F> implements Internal.EventListener {
        operationComplete(arg0: F): void
    }
    class ResolvedModule {
        reference(): Internal.ModuleReference
        configuration(): Internal.Configuration
        hashCode(): number
        equals(arg0: object): boolean
        reads(): Internal.Set<Internal.ResolvedModule>
        name(): string
        toString(): string
    }
    interface Short2ByteFunction implements Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: object, arg1: number): number
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: number, arg1: number): number
        andThenShort(arg0: Internal.Byte2ShortFunction): Internal.Short2ShortFunction
        composeByte(arg0: Internal.Byte2ShortFunction): Internal.Byte2ByteFunction
        andThenInt(arg0: Internal.Byte2IntFunction): Internal.Short2IntFunction
        composeReference<T>(arg0: Internal.Reference2ShortFunction<T>): Internal.Reference2ByteFunction<T>
        andThen<T>(arg0: (arg0: number) => T): (arg0: number) => T
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        put(arg0: object, arg1: object): object
        put(arg0: number, arg1: number): number
        put(arg0: number, arg1: number): number
        remove(arg0: number): number
        remove(arg0: object): object
        remove(arg0: object): number
        defaultReturnValue(): number
        defaultReturnValue(arg0: number): void
        andThenDouble(arg0: Internal.Byte2DoubleFunction): Internal.Short2DoubleFunction
        andThenObject<T>(arg0: Internal.Byte2ObjectFunction<T>): Internal.Short2ObjectFunction<T>
        get(arg0: object): number
        get(arg0: object): object
        get(arg0: number): number
        andThenLong(arg0: Internal.Byte2LongFunction): Internal.Short2LongFunction
        composeLong(arg0: Internal.Long2ShortFunction): Internal.Long2ByteFunction
        andThenByte(arg0: Internal.Byte2ByteFunction): Internal.Short2ByteFunction
        andThenFloat(arg0: Internal.Byte2FloatFunction): Internal.Short2FloatFunction
        applyAsInt(arg0: number): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        containsKey(arg0: number): boolean
        composeInt(arg0: Internal.Int2ShortFunction): Internal.Int2ByteFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ShortFunction): Internal.Float2ByteFunction
        andThenChar(arg0: Internal.Byte2CharFunction): Internal.Short2CharFunction
        composeObject<T>(arg0: Internal.Object2ShortFunction<T>): Internal.Object2ByteFunction<T>
        size(): number
        compose<T>(arg0: (arg0: T) => number): (arg0: T) => number
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator
        composeShort(arg0: Internal.Short2ShortFunction): Internal.Short2ByteFunction
        andThenReference<T>(arg0: Internal.Byte2ReferenceFunction<T>): Internal.Short2ReferenceFunction<T>
        composeChar(arg0: Internal.Char2ShortFunction): Internal.Char2ByteFunction
        composeDouble(arg0: Internal.Double2ShortFunction): Internal.Double2ByteFunction
    }
    class UserPrincipalLookupService {
        lookupPrincipalByGroupName(arg0: string): Internal.GroupPrincipal
        lookupPrincipalByName(arg0: string): Internal.UserPrincipal
    }
    interface StringRepresentable {
    }
    class Constructor <T> extends Internal.Executable {
        getName(): string
        getParameterCount(): number
        setAccessible(arg0: boolean): void
        isVarArgs(): boolean
        isSynthetic(): boolean
        getParameterTypes(): Internal.Class<object>[]
        newInstance(arg0: object[]): T
        getGenericExceptionTypes(): Internal.Type[]
        getAnnotatedReceiverType(): Internal.AnnotatedType
        getDeclaredAnnotations(): Internal.Annotation[]
        getExceptionTypes(): Internal.Class<object>[]
        getDeclaringClass(): Internal.Class<T>
        getGenericParameterTypes(): Internal.Type[]
        getAnnotation<T>(arg0: Internal.Class<T>): T
        hashCode(): number
        toGenericString(): string
        equals(arg0: object): boolean
        toString(): string
        getTypeParameters(): Internal.TypeVariable<Internal.Constructor<T>>[]
        getModifiers(): number
        getAnnotatedReturnType(): Internal.AnnotatedType
        getParameterAnnotations(): Internal.Annotation[][]
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get name(): string;
        get parameterCount(): number;
        set accessible(arg0: boolean);
        get parameterTypes(): Internal.Class<object>[];
        get genericExceptionTypes(): Internal.Type[];
        get annotatedReceiverType(): Internal.AnnotatedType;
        get declaredAnnotations(): Internal.Annotation[];
        get exceptionTypes(): Internal.Class<object>[];
        get declaringClass(): Internal.Class<T>;
        get genericParameterTypes(): Internal.Type[];
        get typeParameters(): Internal.TypeVariable<Internal.Constructor<T>>[];
        get modifiers(): number;
        get annotatedReturnType(): Internal.AnnotatedType;
        get parameterAnnotations(): Internal.Annotation[][];
    }
    interface Compressable implements Internal.Keyable {
        keys<T>(arg0: Internal.DynamicOps<T>): Internal.Stream<T>
        compressor<T>(arg0: Internal.DynamicOps<T>): Internal.KeyCompressor<T>
    }
    interface App <F, A> {
    }
    interface Object2ReferenceFunction <K, V> implements Internal.Function<K, V> {
        getOrDefault(arg0: object, arg1: V): V
        andThenShort(arg0: Internal.Reference2ShortFunction<V>): Internal.Object2ShortFunction<K>
        composeByte(arg0: Internal.Byte2ObjectFunction<K>): Internal.Byte2ReferenceFunction<V>
        andThenInt(arg0: Internal.Reference2IntFunction<V>): Internal.Object2IntFunction<K>
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
        composeReference<T>(arg0: (arg0: T) => K): (arg0: T) => V
        put(arg0: K, arg1: V): V
        remove(arg0: object): V
        defaultReturnValue(): V
        defaultReturnValue(arg0: V): void
        andThenDouble(arg0: Internal.Reference2DoubleFunction<V>): Internal.Object2DoubleFunction<K>
        andThenObject<T>(arg0: (arg0: V) => T): (arg0: K) => T
        get(arg0: object): V
        andThenLong(arg0: Internal.Reference2LongFunction<V>): Internal.Object2LongFunction<K>
        composeLong(arg0: Internal.Long2ObjectFunction<K>): Internal.Long2ReferenceFunction<V>
        andThenByte(arg0: Internal.Reference2ByteFunction<V>): Internal.Object2ByteFunction<K>
        andThenFloat(arg0: Internal.Reference2FloatFunction<V>): Internal.Object2FloatFunction<K>
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ObjectFunction<K>): Internal.Int2ReferenceFunction<V>
        clear(): void
        composeFloat(arg0: Internal.Float2ObjectFunction<K>): Internal.Float2ReferenceFunction<V>
        andThenChar(arg0: Internal.Reference2CharFunction<V>): Internal.Object2CharFunction<K>
        composeObject<T>(arg0: (arg0: T) => K): (arg0: T) => V
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ObjectFunction<K>): Internal.Short2ReferenceFunction<V>
        andThenReference<T>(arg0: (arg0: V) => T): (arg0: K) => T
        composeChar(arg0: Internal.Char2ObjectFunction<K>): Internal.Char2ReferenceFunction<V>
        composeDouble(arg0: Internal.Double2ObjectFunction<K>): Internal.Double2ReferenceFunction<V>
    }
    interface MapDecoder <A> implements Internal.Keyable {
        flatMap<B>(arg0: (arg0: A) => Internal.DataResult<B>): Internal.MapDecoder<B>
        compressedDecode<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<A>
        keys<T>(arg0: Internal.DynamicOps<T>): Internal.Stream<T>
        decoder(): Internal.Decoder<A>
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapDecoder<A>
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: Internal.MapLike<T>): Internal.DataResult<A>
        map<B>(arg0: (arg0: A) => B): Internal.MapDecoder<B>
        compressor<T>(arg0: Internal.DynamicOps<T>): Internal.KeyCompressor<T>
        ap<E>(arg0: Internal.MapDecoder<(arg0: A) => E>): Internal.MapDecoder<E>
    }
    interface NonNullSupplier <T> {
        get(): T
    }
    class RayTraceResultJS {
        readonly fromEntity : Internal.EntityJS;
        readonly distance : number;
        hitX : number;
        hitY : number;
        hitZ : number;
        facing : Internal.Direction;
        block : Internal.BlockContainerJS;
        readonly type : string;
        entity : Internal.EntityJS;
    }
    interface WindowEventHandler {
    }
    class Field extends Internal.AccessibleObject implements Internal.Member {
        setByte(arg0: object, arg1: number): void
        getByte(arg0: object): number
        getName(): string
        isSynthetic(): boolean
        getDouble(arg0: object): number
        setShort(arg0: object, arg1: number): void
        getFloat(arg0: object): number
        getDeclaredAnnotations(): Internal.Annotation[]
        setDouble(arg0: object, arg1: number): void
        setChar(arg0: object, arg1: string): void
        getDeclaringClass(): Internal.Class<object>
        getAnnotationsByType<T>(arg0: Internal.Class<T>): T[]
        hashCode(): number
        toGenericString(): string
        get(arg0: object): object
        getBoolean(arg0: object): boolean
        getGenericType(): Internal.Type
        getModifiers(): number
        getAnnotatedType(): Internal.AnnotatedType
        setFloat(arg0: object, arg1: number): void
        set(arg0: object, arg1: object): void
        setAccessible(arg0: boolean): void
        getShort(arg0: object): number
        setInt(arg0: object, arg1: number): void
        getLong(arg0: object): number
        getInt(arg0: object): number
        getChar(arg0: object): string
        setLong(arg0: object, arg1: number): void
        getType(): Internal.Class<object>
        getAnnotation<T>(arg0: Internal.Class<T>): T
        equals(arg0: object): boolean
        toString(): string
        isEnumConstant(): boolean
        setBoolean(arg0: object, arg1: boolean): void
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get name(): string;
        get declaredAnnotations(): Internal.Annotation[];
        get declaringClass(): Internal.Class<object>;
        get genericType(): Internal.Type;
        get modifiers(): number;
        get annotatedType(): Internal.AnnotatedType;
        set accessible(arg0: boolean);
        get type(): Internal.Class<object>;
    }
    class Monster extends Internal.PathfinderMob implements Internal.Enemy {
        backpackedMoved : boolean;
    }
    interface MaterialGroup {
        material<D>(arg0: Internal.StructType<D>): com.jozufozu.flywheel.api.Material<D>
    }
    class MoverType extends Internal.Enum<Internal.MoverType> {
        static valueOf(arg0: string): Internal.MoverType
        static values(): Internal.MoverType[]
        static readonly PLAYER : Internal.MoverType;
        static readonly PISTON : Internal.MoverType;
        static readonly SHULKER_BOX : Internal.MoverType;
        static readonly SELF : Internal.MoverType;
        static readonly SHULKER : Internal.MoverType;
    }
    interface ClassDesc implements Internal.ConstantDesc, Internal.TypeDescriptor$OfField<Internal.ClassDesc> {
        componentType(): Internal.TypeDescriptor$OfField<any>
        componentType(): Internal.ClassDesc
        arrayType(): Internal.TypeDescriptor$OfField<any>
        arrayType(): Internal.ClassDesc
        arrayType(arg0: number): Internal.ClassDesc
        displayName(): string
        static of(arg0: string): Internal.ClassDesc
        static of(arg0: string, arg1: string): Internal.ClassDesc
        equals(arg0: object): boolean
        descriptorString(): string
        static ofDescriptor(arg0: string): Internal.ClassDesc
        isArray(): boolean
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): object
        packageName(): string
        isClassOrInterface(): boolean
        nested(arg0: string): Internal.ClassDesc
        nested(arg0: string, arg1: string[]): Internal.ClassDesc
        isPrimitive(): boolean
    }
    class BiomeDictionary$Type {
        static getAll(): Internal.Collection<Internal.BiomeDictionary$Type>
        getName(): string
        static getType(arg0: string, arg1: Internal.BiomeDictionary$Type[]): Internal.BiomeDictionary$Type
        toString(): string
        static fromVanilla(arg0: Internal.Biome$BiomeCategory): Internal.BiomeDictionary$Type
        static hasType(arg0: string): boolean
        static readonly SNOWY : Internal.BiomeDictionary$Type;
        static readonly BEACH : Internal.BiomeDictionary$Type;
        static readonly UNDERGROUND : Internal.BiomeDictionary$Type;
        static readonly SAVANNA : Internal.BiomeDictionary$Type;
        static readonly MESA : Internal.BiomeDictionary$Type;
        static readonly RARE : Internal.BiomeDictionary$Type;
        static readonly SPOOKY : Internal.BiomeDictionary$Type;
        static readonly WET : Internal.BiomeDictionary$Type;
        static readonly SPARSE : Internal.BiomeDictionary$Type;
        static readonly MOUNTAIN : Internal.BiomeDictionary$Type;
        static readonly DRY : Internal.BiomeDictionary$Type;
        static readonly RIVER : Internal.BiomeDictionary$Type;
        static readonly MAGICAL : Internal.BiomeDictionary$Type;
        static readonly NETHER : Internal.BiomeDictionary$Type;
        static readonly WATER : Internal.BiomeDictionary$Type;
        static readonly DENSE : Internal.BiomeDictionary$Type;
        static readonly JUNGLE : Internal.BiomeDictionary$Type;
        static readonly SANDY : Internal.BiomeDictionary$Type;
        static readonly OCEAN : Internal.BiomeDictionary$Type;
        static readonly HILLS : Internal.BiomeDictionary$Type;
        static readonly HOT : Internal.BiomeDictionary$Type;
        static readonly FOREST : Internal.BiomeDictionary$Type;
        static readonly MUSHROOM : Internal.BiomeDictionary$Type;
        static readonly OVERWORLD : Internal.BiomeDictionary$Type;
        static readonly PLATEAU : Internal.BiomeDictionary$Type;
        static readonly PLAINS : Internal.BiomeDictionary$Type;
        static readonly SWAMP : Internal.BiomeDictionary$Type;
        static readonly PEAK : Internal.BiomeDictionary$Type;
        static readonly END : Internal.BiomeDictionary$Type;
        static readonly COLD : Internal.BiomeDictionary$Type;
        static readonly DEAD : Internal.BiomeDictionary$Type;
        static readonly MODIFIED : Internal.BiomeDictionary$Type;
        static readonly VOID : Internal.BiomeDictionary$Type;
        static readonly LUSH : Internal.BiomeDictionary$Type;
        static readonly CONIFEROUS : Internal.BiomeDictionary$Type;
        static readonly SLOPE : Internal.BiomeDictionary$Type;
        static readonly WASTELAND : Internal.BiomeDictionary$Type;
        get all(): Internal.Collection<Internal.BiomeDictionary$Type>;
        get name(): string;
    }
    class Entity extends Internal.CapabilityProvider<Internal.Entity> implements Internal.Nameable, Internal.EntityAccess, Internal.CommandSource, Internal.IForgeEntity, Internal.IMovedAccess, blusunrize.immersiveengineering.mixin.accessors.EntityAccess, Internal.EntityKJS, Internal.NearbyEntityListenerProvider, Internal.EntityAccessor, Internal.BlockCachingEntity {
        shouldRiderSit(): boolean
        backpackedMoved(): boolean
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>
        captureDrops(): Internal.Collection<Internal.ItemEntity>
        handler$zzm000$moveStep(arg0: Internal.MoverType, arg1: Vec3, arg2: Internal.CallbackInfo): void
        canBeRiddenInWater(arg0: Internal.Entity): boolean
        getPersistentData(): Internal.CompoundTag
        getRemainingFireTicks(): number
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void
        handler$zzm000$tickHead(arg0: Internal.CallbackInfo): void
        getCachedFeetBlockState(): Internal.BlockState
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity
        getEntityChangeListener(): Internal.EntityInLevelCallback
        serializeNBT(): Internal.CompoundTag
        serializeNBT(): net.minecraft.nbt.Tag
        hashCode(): number
        revive(): void
        isAddedToWorld(): boolean
        getParts(): Internal.PartEntity<object>[]
        addListener(listener: Internal.NearbyEntityListener): void
        getPersistentDataKJS(): Internal.CompoundTag
        canUpdate(arg0: boolean): void
        canUpdate(): boolean
        onRemovedFromWorld(): void
        isMultipartEntity(): boolean
        deserializeNBT(arg0: Internal.CompoundTag): void
        deserializeNBT(arg0: net.minecraft.nbt.Tag): void
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number
        asKJS(): object
        lithiumOnBlockCacheDeleted(): void
        canRiderInteract(): boolean
        onAddedToWorld(): void
        equals(arg0: object): boolean
        handler$zlp000$tryShortcutFluidPushing(tag: Internal.Tag<any>, speed: number, cir: Internal.CallbackInfoReturnable<any>, box: Internal.AABB, x1: number, x2: number, y1: number, y2: number, z1: number, z2: number, zero: number): void
        toString(): string
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean
        setRemainingFireTicks(arg0: number): void
        getListener(): Internal.NearbyEntityListenerMulti
        getClassification(arg0: boolean): Internal.MobCategory
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listening: boolean): void
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get cachedFeetBlockState(): Internal.BlockState;
        get entityChangeListener(): Internal.EntityInLevelCallback;
        get parts(): Internal.PartEntity<object>[];
        get persistentDataKJS(): Internal.CompoundTag;
        set remainingFireTicks(arg0: number);
        get listener(): Internal.NearbyEntityListenerMulti;
    }
    class DateTimeFormatter {
        withLocale(arg0: Internal.Locale): Internal.DateTimeFormatter
        parseBest(arg0: Internal.CharSequence, arg1: Internal.TemporalQuery<object>[]): Internal.TemporalAccessor
        static ofLocalizedDateTime(arg0: Internal.FormatStyle): Internal.DateTimeFormatter
        static ofLocalizedDateTime(arg0: Internal.FormatStyle, arg1: Internal.FormatStyle): Internal.DateTimeFormatter
        getResolverFields(): Internal.Set<Internal.TemporalField>
        static ofPattern(arg0: string): Internal.DateTimeFormatter
        static ofPattern(arg0: string, arg1: Internal.Locale): Internal.DateTimeFormatter
        static ofLocalizedDate(arg0: Internal.FormatStyle): Internal.DateTimeFormatter
        formatTo(arg0: Internal.TemporalAccessor, arg1: Internal.Appendable): void
        static parsedLeapSecond(): Internal.TemporalQuery<boolean>
        getChronology(): Internal.Chronology
        withChronology(arg0: Internal.Chronology): Internal.DateTimeFormatter
        withDecimalStyle(arg0: Internal.DecimalStyle): Internal.DateTimeFormatter
        withZone(arg0: Internal.ZoneId): Internal.DateTimeFormatter
        localizedBy(arg0: Internal.Locale): Internal.DateTimeFormatter
        static parsedExcessDays(): Internal.TemporalQuery<Internal.Period>
        withResolverStyle(arg0: Internal.ResolverStyle): Internal.DateTimeFormatter
        getResolverStyle(): Internal.ResolverStyle
        format(arg0: Internal.TemporalAccessor): string
        getZone(): Internal.ZoneId
        parse(arg0: Internal.CharSequence, arg1: Internal.ParsePosition): Internal.TemporalAccessor
        parse(arg0: Internal.CharSequence): Internal.TemporalAccessor
        parse<T>(arg0: Internal.CharSequence, arg1: Internal.TemporalQuery<T>): T
        getDecimalStyle(): Internal.DecimalStyle
        toFormat(arg0: Internal.TemporalQuery<object>): Internal.Format
        toFormat(): Internal.Format
        static ofLocalizedTime(arg0: Internal.FormatStyle): Internal.DateTimeFormatter
        toString(): string
        withResolverFields(arg0: Internal.TemporalField[]): Internal.DateTimeFormatter
        withResolverFields(arg0: Internal.Set<Internal.TemporalField>): Internal.DateTimeFormatter
        getLocale(): Internal.Locale
        parseUnresolved(arg0: Internal.CharSequence, arg1: Internal.ParsePosition): Internal.TemporalAccessor
        static readonly ISO_OFFSET_TIME : Internal.DateTimeFormatter;
        static readonly ISO_LOCAL_DATE_TIME : Internal.DateTimeFormatter;
        static readonly RFC_1123_DATE_TIME : Internal.DateTimeFormatter;
        static readonly ISO_INSTANT : Internal.DateTimeFormatter;
        static readonly ISO_ZONED_DATE_TIME : Internal.DateTimeFormatter;
        static readonly ISO_OFFSET_DATE_TIME : Internal.DateTimeFormatter;
        static readonly ISO_DATE_TIME : Internal.DateTimeFormatter;
        static readonly ISO_DATE : Internal.DateTimeFormatter;
        static readonly ISO_TIME : Internal.DateTimeFormatter;
        static readonly ISO_LOCAL_TIME : Internal.DateTimeFormatter;
        static readonly ISO_OFFSET_DATE : Internal.DateTimeFormatter;
        static readonly ISO_ORDINAL_DATE : Internal.DateTimeFormatter;
        static readonly ISO_LOCAL_DATE : Internal.DateTimeFormatter;
        static readonly BASIC_ISO_DATE : Internal.DateTimeFormatter;
        static readonly ISO_WEEK_DATE : Internal.DateTimeFormatter;
        get resolverFields(): Internal.Set<Internal.TemporalField>;
        get chronology(): Internal.Chronology;
        get resolverStyle(): Internal.ResolverStyle;
        get zone(): Internal.ZoneId;
        get decimalStyle(): Internal.DecimalStyle;
        get locale(): Internal.Locale;
    }
    interface Object2CharFunction <K> implements Internal.Function<K, string>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: object, arg1: string): string
        getOrDefault(arg0: object, arg1: object): object
        getOrDefault(arg0: object, arg1: string): string
        andThenShort(arg0: Internal.Char2ShortFunction): Internal.Object2ShortFunction<K>
        removeChar(arg0: object): string
        composeByte(arg0: Internal.Byte2ObjectFunction<K>): Internal.Byte2CharFunction
        andThenInt(arg0: Internal.Char2IntFunction): Internal.Object2IntFunction<K>
        composeReference<T>(arg0: (arg0: T) => K): Internal.Reference2CharFunction<T>
        andThen<T>(arg0: (arg0: string) => T): (arg0: K) => T
        put(arg0: K, arg1: string): string
        put(arg0: K, arg1: string): string
        put(arg0: object, arg1: object): object
        remove(arg0: object): object
        remove(arg0: object): string
        defaultReturnValue(arg0: string): void
        defaultReturnValue(): string
        andThenDouble(arg0: Internal.Char2DoubleFunction): Internal.Object2DoubleFunction<K>
        andThenObject<T>(arg0: Internal.Char2ObjectFunction<T>): (arg0: K) => T
        get(arg0: object): string
        get(arg0: object): object
        andThenLong(arg0: Internal.Char2LongFunction): Internal.Object2LongFunction<K>
        composeLong(arg0: Internal.Long2ObjectFunction<K>): Internal.Long2CharFunction
        andThenByte(arg0: Internal.Char2ByteFunction): Internal.Object2ByteFunction<K>
        andThenFloat(arg0: Internal.Char2FloatFunction): Internal.Object2FloatFunction<K>
        applyAsInt(arg0: K): number
        apply(arg0: K): V
        containsKey(arg0: object): boolean
        composeInt(arg0: Internal.Int2ObjectFunction<K>): Internal.Int2CharFunction
        clear(): void
        composeFloat(arg0: Internal.Float2ObjectFunction<K>): Internal.Float2CharFunction
        andThenChar(arg0: Internal.Char2CharFunction): Internal.Object2CharFunction<K>
        getChar(arg0: object): string
        composeObject<T>(arg0: (arg0: T) => K): Internal.Object2CharFunction<T>
        size(): number
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        composeShort(arg0: Internal.Short2ObjectFunction<K>): Internal.Short2CharFunction
        andThenReference<T>(arg0: Internal.Char2ReferenceFunction<T>): (arg0: K) => T
        composeChar(arg0: Internal.Char2ObjectFunction<K>): Internal.Char2CharFunction
        composeDouble(arg0: Internal.Double2ObjectFunction<K>): Internal.Double2CharFunction
    }
    interface UnaryOperator <T> implements java_.util.function_.Function<T, T> {
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        apply(arg0: T): R
        static identity<T>(): Internal.UnaryOperator<T>
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
    }
    class PortalInfo {
    }
    class FileSystemProvider {
        getFileStore(arg0: Internal.Path): Internal.FileStore
        isSameFile(arg0: Internal.Path, arg1: Internal.Path): boolean
        newByteChannel(arg0: Internal.Path, arg1: Internal.Set<Internal.OpenOption>, arg2: Internal.FileAttribute<object>[]): Internal.SeekableByteChannel
        getFileAttributeView<V>(arg0: Internal.Path, arg1: Internal.Class<V>, arg2: Internal.LinkOption[]): V
        newAsynchronousFileChannel(arg0: Internal.Path, arg1: Internal.Set<Internal.OpenOption>, arg2: Internal.ExecutorService, arg3: Internal.FileAttribute<object>[]): Internal.AsynchronousFileChannel
        createSymbolicLink(arg0: Internal.Path, arg1: Internal.Path, arg2: Internal.FileAttribute<object>[]): void
        static installedProviders(): Internal.List<Internal.FileSystemProvider>
        delete(arg0: Internal.Path): void
        createLink(arg0: Internal.Path, arg1: Internal.Path): void
        setAttribute(arg0: Internal.Path, arg1: string, arg2: object, arg3: Internal.LinkOption[]): void
        newFileChannel(arg0: Internal.Path, arg1: Internal.Set<Internal.OpenOption>, arg2: Internal.FileAttribute<object>[]): Internal.FileChannel
        newInputStream(arg0: Internal.Path, arg1: Internal.OpenOption[]): Internal.InputStream
        readAttributes<A>(arg0: Internal.Path, arg1: Internal.Class<A>, arg2: Internal.LinkOption[]): A
        readAttributes(arg0: Internal.Path, arg1: string, arg2: Internal.LinkOption[]): Map<string, object>
        newOutputStream(arg0: Internal.Path, arg1: Internal.OpenOption[]): Internal.OutputStream
        getPath(arg0: Internal.URI): Internal.Path
        createDirectory(arg0: Internal.Path, arg1: Internal.FileAttribute<object>[]): void
        copy(arg0: Internal.Path, arg1: Internal.Path, arg2: Internal.CopyOption[]): void
        move(arg0: Internal.Path, arg1: Internal.Path, arg2: Internal.CopyOption[]): void
        getScheme(): string
        newFileSystem(arg0: Internal.URI, arg1: Map<string, object>): Internal.FileSystem
        newFileSystem(arg0: Internal.Path, arg1: Map<string, object>): Internal.FileSystem
        deleteIfExists(arg0: Internal.Path): boolean
        newDirectoryStream(arg0: Internal.Path, arg1: Internal.DirectoryStream$Filter<Internal.Path>): Internal.DirectoryStream<Internal.Path>
        getFileSystem(arg0: Internal.URI): Internal.FileSystem
        checkAccess(arg0: Internal.Path, arg1: Internal.AccessMode[]): void
        readSymbolicLink(arg0: Internal.Path): Internal.Path
        isHidden(arg0: Internal.Path): boolean
        get scheme(): string;
    }
    class AbstractByteBuf extends Internal.ByteBuf {
        asReadOnly(): Internal.ByteBuf
        markReaderIndex(): Internal.ByteBuf
        getByte(arg0: number): number
        writeZero(arg0: number): Internal.ByteBuf
        resetReaderIndex(): Internal.ByteBuf
        writeFloat(arg0: number): Internal.ByteBuf
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf
        readRetainedSlice(arg0: number): Internal.ByteBuf
        slice(): Internal.ByteBuf
        slice(arg0: number, arg1: number): Internal.ByteBuf
        getMediumLE(arg0: number): number
        readUnsignedIntLE(): number
        readInt(): number
        order(arg0: Internal.ByteOrder): Internal.ByteBuf
        writeMedium(arg0: number): Internal.ByteBuf
        resetWriterIndex(): Internal.ByteBuf
        writableBytes(): number
        getUnsignedShort(arg0: number): number
        maxCapacity(): number
        bytesBefore(arg0: number, arg1: number): number
        bytesBefore(arg0: number, arg1: number, arg2: number): number
        bytesBefore(arg0: number): number
        setInt(arg0: number, arg1: number): Internal.ByteBuf
        getInt(arg0: number): number
        markWriterIndex(): Internal.ByteBuf
        isReadable(arg0: number): boolean
        isReadable(): boolean
        writeBoolean(arg0: boolean): Internal.ByteBuf
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf
        writeLongLE(arg0: number): Internal.ByteBuf
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf
        isWritable(arg0: number): boolean
        isWritable(): boolean
        readChar(): string
        readCharSequence(arg0: number, arg1: Internal.Charset): Internal.CharSequence
        isReadOnly(): boolean
        readUnsignedShortLE(): number
        readDouble(): number
        readFloat(): number
        getLongLE(arg0: number): number
        getBoolean(arg0: number): boolean
        copy(): Internal.ByteBuf
        readShortLE(): number
        readUnsignedMedium(): number
        ensureWritable(arg0: number): Internal.ByteBuf
        ensureWritable(arg0: number, arg1: boolean): number
        writeInt(arg0: number): Internal.ByteBuf
        readableBytes(): number
        readSlice(arg0: number): Internal.ByteBuf
        getIntLE(arg0: number): number
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        forEachByteDesc(arg0: Internal.ByteProcessor): number
        nioBuffers(): Internal.ByteBuffer[]
        skipBytes(arg0: number): Internal.ByteBuf
        getLong(arg0: number): number
        readLong(): number
        readShort(): number
        equals(arg0: object): boolean
        setZero(arg0: number, arg1: number): Internal.ByteBuf
        getUnsignedMedium(arg0: number): number
        readBytes(arg0: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        readBytes(arg0: Internal.GatheringByteChannel, arg1: number): number
        readBytes(arg0: number[]): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        readBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.ByteBuf
        readBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        readBoolean(): boolean
        toString(): string
        toString(arg0: Internal.Charset): string
        toString(arg0: number, arg1: number, arg2: Internal.Charset): string
        retainedSlice(): Internal.ByteBuf
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf
        readMediumLE(): number
        setMedium(arg0: number, arg1: number): Internal.ByteBuf
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf
        readerIndex(arg0: number): Internal.ByteBuf
        readerIndex(): number
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset): Internal.CharSequence
        setShort(arg0: number, arg1: number): Internal.ByteBuf
        compareTo(arg0: Internal.ByteBuf): number
        compareTo(arg0: object): number
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        setDouble(arg0: number, arg1: number): Internal.ByteBuf
        setChar(arg0: number, arg1: number): Internal.ByteBuf
        getUnsignedIntLE(arg0: number): number
        getUnsignedInt(arg0: number): number
        indexOf(arg0: number, arg1: number, arg2: number): number
        writeByte(arg0: number): Internal.ByteBuf
        nioBuffer(): Internal.ByteBuffer
        discardSomeReadBytes(): Internal.ByteBuf
        duplicate(): Internal.ByteBuf
        writerIndex(arg0: number): Internal.ByteBuf
        writerIndex(): number
        writeCharSequence(arg0: Internal.CharSequence, arg1: Internal.Charset): number
        readUnsignedInt(): number
        getUnsignedShortLE(arg0: number): number
        retainedDuplicate(): Internal.ByteBuf
        getChar(arg0: number): string
        setLong(arg0: number, arg1: number): Internal.ByteBuf
        readMedium(): number
        writeBytes(arg0: Internal.ScatteringByteChannel, arg1: number): number
        writeBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf
        writeBytes(arg0: Internal.InputStream, arg1: number): number
        writeBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: number[]): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf
        forEachByte(arg0: Internal.ByteProcessor): number
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number
        setIndex(arg0: number, arg1: number): Internal.ByteBuf
        writeShort(arg0: number): Internal.ByteBuf
        getShortLE(arg0: number): number
        getMedium(arg0: number): number
        readUnsignedShort(): number
        setByte(arg0: number, arg1: number): Internal.ByteBuf
        writeShortLE(arg0: number): Internal.ByteBuf
        maxWritableBytes(): number
        getDouble(arg0: number): number
        getFloat(arg0: number): number
        writeLong(arg0: number): Internal.ByteBuf
        writeIntLE(arg0: number): Internal.ByteBuf
        setCharSequence(arg0: number, arg1: Internal.CharSequence, arg2: Internal.Charset): number
        hashCode(): number
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf
        readIntLE(): number
        readUnsignedByte(): number
        readUnsignedMediumLE(): number
        readLongLE(): number
        writeDouble(arg0: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf
        setFloat(arg0: number, arg1: number): Internal.ByteBuf
        getShort(arg0: number): number
        writeMediumLE(arg0: number): Internal.ByteBuf
        clear(): Internal.ByteBuf
        getUnsignedByte(arg0: number): number
        discardReadBytes(): Internal.ByteBuf
        writeChar(arg0: number): Internal.ByteBuf
        getUnsignedMediumLE(arg0: number): number
        readByte(): number
    }
    interface FileFilter {
        accept(arg0: Internal.File): boolean
    }
    interface Marker implements Internal.Serializable {
        getParents(): Internal.Marker[]
        setParents(markers: Internal.Marker[]): Internal.Marker
        getName(): string
        hasParents(): boolean
        hashCode(): number
        equals(obj: object): boolean
        isInstanceOf(name: string): boolean
        isInstanceOf(m: Internal.Marker): boolean
        addParents(markers: Internal.Marker[]): Internal.Marker
        remove(marker: Internal.Marker): boolean
        get parents(): Internal.Marker[];
        set parents(markers: Internal.Marker[]);
        get name(): string;
    }
    interface Codec <A> implements Internal.Encoder<A>, Internal.Decoder<A> {
        encode<T>(arg0: A, arg1: Internal.DynamicOps<T>, arg2: T): Internal.DataResult<T>
        flatComapMap<S>(arg0: (arg0: A) => S, arg1: (arg0: S) => Internal.DataResult<A>): Internal.Codec<S>
        dispatch<E>(arg0: (arg0: E) => A, arg1: (arg0: A) => Internal.Codec<E>): Internal.Codec<E>
        dispatch<E>(arg0: string, arg1: (arg0: E) => A, arg2: (arg0: A) => Internal.Codec<E>): Internal.Codec<E>
        deprecated(arg0: number): Internal.Codec<A>
        simple(): Internal.Decoder$Simple<A>
        dispatchMap<E>(arg0: (arg0: E) => A, arg1: (arg0: A) => Internal.Codec<E>): Internal.MapCodec<E>
        dispatchMap<E>(arg0: string, arg1: (arg0: E) => A, arg2: (arg0: A) => Internal.Codec<E>): Internal.MapCodec<E>
        static mapPair<F, S>(arg0: Internal.MapCodec<F>, arg1: Internal.MapCodec<S>): Internal.MapCodec<com.mojang.datafixers.util.Pair<F, S>>
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
        decode<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<com.mojang.datafixers.util.Pair<A, T>>
        comapFlatMap<S>(arg0: (arg0: A) => Internal.DataResult<S>, arg1: (arg0: S) => A): Internal.Codec<S>
        static checkRange<N>(arg0: N, arg1: N): (arg0: N) => Internal.DataResult<N>
        promotePartial(arg0: Internal.Consumer<any>): Internal.Decoder<any>
        promotePartial(arg0: (arg0: string) => void): Internal.Codec<A>
        static either<F, S>(arg0: Internal.Codec<F>, arg1: Internal.Codec<S>): Internal.Codec<Internal.Either<F, S>>
        flatXmap<S>(arg0: (arg0: A) => Internal.DataResult<S>, arg1: (arg0: S) => Internal.DataResult<A>): Internal.Codec<S>
        comap<B>(arg0: (arg0: B) => A): Internal.Encoder<B>
        static of<A>(arg0: Internal.MapEncoder<A>, arg1: Internal.MapDecoder<A>, arg2: () => string): Internal.MapCodec<A>
        static of<A>(arg0: Internal.MapEncoder<A>, arg1: Internal.MapDecoder<A>): Internal.MapCodec<A>
        static of<A>(arg0: Internal.Encoder<A>, arg1: Internal.Decoder<A>, arg2: string): Internal.Codec<A>
        static of<A>(arg0: Internal.Encoder<A>, arg1: Internal.Decoder<A>): Internal.Codec<A>
        fieldOf(arg0: string): Internal.MapEncoder<any>
        fieldOf(arg0: string): Internal.MapDecoder<any>
        fieldOf(arg0: string): Internal.MapCodec<A>
        xmap<S>(arg0: (arg0: A) => S, arg1: (arg0: S) => A): Internal.Codec<S>
        listOf(): Internal.Codec<Internal.List<A>>
        map<B>(arg0: (arg0: A) => B): Internal.Decoder<B>
        encodeStart<T>(arg0: Internal.DynamicOps<T>, arg1: A): Internal.DataResult<T>
        optionalFieldOf(arg0: string, arg1: Internal.Lifecycle, arg2: A, arg3: Internal.Lifecycle): Internal.MapCodec<A>
        optionalFieldOf(arg0: string, arg1: A): Internal.MapCodec<A>
        optionalFieldOf(arg0: string): Internal.MapCodec<Internal.Optional<A>>
        optionalFieldOf(arg0: string, arg1: A, arg2: Internal.Lifecycle): Internal.MapCodec<A>
        static unboundedMap<K, V>(arg0: Internal.Codec<K>, arg1: Internal.Codec<V>): Internal.UnboundedMapCodec<K, V>
        flatComap<B>(arg0: (arg0: B) => Internal.DataResult<A>): Internal.Encoder<B>
        static compoundList<K, V>(arg0: Internal.Codec<K>, arg1: Internal.Codec<V>): Internal.Codec<Internal.List<com.mojang.datafixers.util.Pair<K, V>>>
        static intRange(arg0: number, arg1: number): Internal.Codec<number>
        static floatRange(arg0: number, arg1: number): Internal.Codec<number>
        partialDispatch<E>(arg0: string, arg1: (arg0: E) => Internal.DataResult<A>, arg2: (arg0: A) => Internal.DataResult<Internal.Codec<E>>): Internal.Codec<E>
        static simpleMap<K, V>(arg0: Internal.Codec<K>, arg1: Internal.Codec<V>, arg2: Internal.Keyable): Internal.SimpleMapCodec<K, V>
        static mapEither<F, S>(arg0: Internal.MapCodec<F>, arg1: Internal.MapCodec<S>): Internal.MapCodec<Internal.Either<F, S>>
        terminal(): Internal.Decoder$Terminal<A>
        parse<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<A>
        parse<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<A>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Encoder<any>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Decoder<any>
        withLifecycle(arg0: Internal.Lifecycle): Internal.Codec<A>
        static list<E>(arg0: Internal.Codec<E>): Internal.Codec<Internal.List<E>>
        orElse(arg0: A): Internal.Codec<A>
        orElse(arg0: (arg0: string) => void, arg1: A): Internal.Codec<A>
        orElse(arg0: Internal.UnaryOperator<string>, arg1: A): Internal.Codec<A>
        static pair<F, S>(arg0: Internal.Codec<F>, arg1: Internal.Codec<S>): Internal.Codec<com.mojang.datafixers.util.Pair<F, S>>
        flatMap<B>(arg0: (arg0: A) => Internal.DataResult<B>): Internal.Decoder<B>
        static unit<A>(arg0: () => A): Internal.Codec<A>
        static unit<A>(arg0: A): Internal.Codec<A>
        boxed(): Internal.Decoder$Boxed<A>
        static optionalField<F>(arg0: string, arg1: Internal.Codec<F>): Internal.MapCodec<Internal.Optional<F>>
        dispatchStable<E>(arg0: (arg0: E) => A, arg1: (arg0: A) => Internal.Codec<E>): Internal.Codec<E>
        orElseGet(arg0: (arg0: string) => void, arg1: () => A): Internal.Codec<A>
        orElseGet(arg0: () => A): Internal.Codec<A>
        orElseGet(arg0: Internal.UnaryOperator<string>, arg1: () => A): Internal.Codec<A>
        stable(): Internal.Codec<A>
        mapResult(arg0: Internal.Codec$ResultFunction<A>): Internal.Codec<A>
        static doubleRange(arg0: number, arg1: number): Internal.Codec<number>
        static readonly FLOAT : Internal.PrimitiveCodec<number>;
        static readonly INT : Internal.PrimitiveCodec<number>;
        static readonly SHORT : Internal.PrimitiveCodec<number>;
        static readonly PASSTHROUGH : Internal.Codec<Internal.Dynamic<object>>;
        static readonly BOOL : Internal.PrimitiveCodec<boolean>;
        static readonly BYTE_BUFFER : Internal.PrimitiveCodec<Internal.ByteBuffer>;
        static readonly INT_STREAM : Internal.PrimitiveCodec<Internal.IntStream>;
        static readonly BYTE : Internal.PrimitiveCodec<number>;
        static readonly LONG_STREAM : Internal.PrimitiveCodec<Internal.LongStream>;
        static readonly STRING : Internal.PrimitiveCodec<string>;
        static readonly DOUBLE : Internal.PrimitiveCodec<number>;
        static readonly EMPTY : Internal.MapCodec<Internal.Unit>;
        static readonly LONG : Internal.PrimitiveCodec<number>;
    }
    class ForgeModelBakery extends Internal.ModelBakery {
        isLoading(): boolean
        static addSpecialModel(arg0: ResourceLocation): void
        static defaultTextureGetter(): (arg0: Internal.Material) => Internal.TextureAtlasSprite
        static instance(): Internal.ForgeModelBakery
        static getInventoryVariant(arg0: string): Internal.ModelResourceLocation
        getModelOrLogError(arg0: ResourceLocation, arg1: string): Internal.UnbakedModel
        getSpecialModels(): Internal.Set<ResourceLocation>
        onPostBakeEvent(arg0: Map<ResourceLocation, Internal.BakedModel>): void
        static defaultModelGetter(): (arg0: ResourceLocation) => Internal.UnbakedModel
        getModelOrMissing(arg0: ResourceLocation): Internal.UnbakedModel
        get specialModels(): Internal.Set<ResourceLocation>;
    }
    class Stat <T> extends Internal.ObjectiveCriteria {
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
    }
    class PainterObject implements Internal.SpecialEquality {
        hashCode(): number
        equals(o: object): boolean
        update(tag: Internal.CompoundTag): void
        toString(): string
        id(i: string): Internal.PainterObject
        specialEquals(o: object, shallow: boolean): boolean
        parent : Internal.PainterObjectStorage;
        visible : boolean;
    }
    class LevelChunkTicks <T> implements Internal.SerializableTickContainer<T>, Internal.TickContainerAccess<T> {
    }
    class ProtoChunkTicks <T> implements Internal.SerializableTickContainer<T>, Internal.TickContainerAccess<T> {
    }
    interface ItemColor {
    }
    interface ChannelConfig {
        setMessageSizeEstimator(arg0: Internal.MessageSizeEstimator): Internal.ChannelConfig
        setWriteBufferLowWaterMark(arg0: number): Internal.ChannelConfig
        getWriteBufferLowWaterMark(): number
        getMessageSizeEstimator(): Internal.MessageSizeEstimator
        setRecvByteBufAllocator(arg0: Internal.RecvByteBufAllocator): Internal.ChannelConfig
        getOption<T>(arg0: Internal.ChannelOption<T>): T
        isAutoClose(): boolean
        getRecvByteBufAllocator<T>(): T
        setAllocator(arg0: Internal.ByteBufAllocator): Internal.ChannelConfig
        getAllocator(): Internal.ByteBufAllocator
        isAutoRead(): boolean
        setOptions(arg0: Map<Internal.ChannelOption<object>, object>): boolean
        setConnectTimeoutMillis(arg0: number): Internal.ChannelConfig
        setWriteBufferWaterMark(arg0: Internal.WriteBufferWaterMark): Internal.ChannelConfig
        setOption<T>(arg0: Internal.ChannelOption<T>, arg1: T): boolean
        setWriteSpinCount(arg0: number): Internal.ChannelConfig
        getConnectTimeoutMillis(): number
        setWriteBufferHighWaterMark(arg0: number): Internal.ChannelConfig
        getMaxMessagesPerRead(): number
        getWriteBufferHighWaterMark(): number
        setAutoRead(arg0: boolean): Internal.ChannelConfig
        getWriteSpinCount(): number
        setMaxMessagesPerRead(arg0: number): Internal.ChannelConfig
        getOptions(): Map<Internal.ChannelOption<object>, object>
        getWriteBufferWaterMark(): Internal.WriteBufferWaterMark
        setAutoClose(arg0: boolean): Internal.ChannelConfig
        set messageSizeEstimator(arg0: Internal.MessageSizeEstimator);
        set writeBufferLowWaterMark(arg0: number);
        get writeBufferLowWaterMark(): number;
        get messageSizeEstimator(): Internal.MessageSizeEstimator;
        set recvByteBufAllocator(arg0: Internal.RecvByteBufAllocator);
        get recvByteBufAllocator(): T;
        set allocator(arg0: Internal.ByteBufAllocator);
        get allocator(): Internal.ByteBufAllocator;
        set options(arg0: Map<Internal.ChannelOption<object>, object>);
        set connectTimeoutMillis(arg0: number);
        set writeBufferWaterMark(arg0: Internal.WriteBufferWaterMark);
        set writeSpinCount(arg0: number);
        get connectTimeoutMillis(): number;
        set writeBufferHighWaterMark(arg0: number);
        get maxMessagesPerRead(): number;
        get writeBufferHighWaterMark(): number;
        set autoRead(arg0: boolean);
        get writeSpinCount(): number;
        set maxMessagesPerRead(arg0: number);
        get options(): Map<Internal.ChannelOption<object>, object>;
        get writeBufferWaterMark(): Internal.WriteBufferWaterMark;
        set autoClose(arg0: boolean);
    }
    interface Principal {
        getName(): string
        hashCode(): number
        equals(arg0: object): boolean
        toString(): string
        implies(arg0: Internal.Subject): boolean
        get name(): string;
    }
}
namespace io.netty.util {
    interface Attribute <T> {
        set(arg0: T): void
        compareAndSet(arg0: T, arg1: T): boolean
        setIfAbsent(arg0: T): T
        get(): T
        getAndSet(arg0: T): T
        getAndRemove(): T
        key(): Internal.AttributeKey<T>
        remove(): void
        set ifAbsent(arg0: T);
        get andRemove(): T;
    }
}
namespace dev.architectury.fluid {
    class FluidStack {
        getRawFluidSupplier(): () => Internal.Fluid
        getRawFluid(): Internal.Fluid
        getName(): Internal.Component
        getOrCreateChildTag(childName: string): Internal.CompoundTag
        static empty(): dev.architectury.fluid.FluidStack
        getChildTag(childName: string): Internal.CompoundTag
        hashCode(): number
        static create(fluid: Internal.Fluid, amount: number, tag: Internal.CompoundTag): dev.architectury.fluid.FluidStack
        static create(fluid: Internal.Fluid, amount: number): dev.architectury.fluid.FluidStack
        static create(stack: dev.architectury.fluid.FluidStack, amount: number): dev.architectury.fluid.FluidStack
        static create(fluid: () => Internal.Fluid, amount: number, tag: Internal.CompoundTag): dev.architectury.fluid.FluidStack
        static create(fluid: () => Internal.Fluid, amount: number): dev.architectury.fluid.FluidStack
        setTag(tag: Internal.CompoundTag): void
        copy(): dev.architectury.fluid.FluidStack
        setAmount(amount: number): void
        write(buf: Internal.FriendlyByteBuf): void
        write(tag: Internal.CompoundTag): Internal.CompoundTag
        getAmount(): number
        removeChildTag(childName: string): void
        grow(amount: number): void
        static read(tag: Internal.CompoundTag): dev.architectury.fluid.FluidStack
        static read(buf: Internal.FriendlyByteBuf): dev.architectury.fluid.FluidStack
        hasTag(): boolean
        shrink(amount: number): void
        getTranslationKey(): string
        isEmpty(): boolean
        getTag(): Internal.CompoundTag
        isFluidStackEqual(other: dev.architectury.fluid.FluidStack): boolean
        static bucketAmount(): number
        getOrCreateTag(): Internal.CompoundTag
        equals(o: object): boolean
        getFluid(): Internal.Fluid
        get rawFluidSupplier(): () => Internal.Fluid;
        get rawFluid(): Internal.Fluid;
        get name(): Internal.Component;
        set tag(tag: Internal.CompoundTag);
        set amount(amount: number);
        get amount(): number;
        get translationKey(): string;
        get tag(): Internal.CompoundTag;
        get orCreateTag(): Internal.CompoundTag;
        get fluid(): Internal.Fluid;
    }
}
namespace it.unimi.dsi.fastutil.ints {
    interface IntPredicate implements Internal.Predicate<number>, Internal.IntPredicate {
        or(arg0: (arg0: number) => boolean): (arg0: number) => boolean
        or(arg0: Internal.IntPredicate): it.unimi.dsi.fastutil.ints.IntPredicate
        or(arg0: Internal.IntPredicate): Internal.IntPredicate
        or(arg0: it.unimi.dsi.fastutil.ints.IntPredicate): it.unimi.dsi.fastutil.ints.IntPredicate
        test(arg0: number): boolean
        test(arg0: object): boolean
        test(arg0: number): boolean
        and(arg0: Internal.IntPredicate): Internal.IntPredicate
        and(arg0: Internal.IntPredicate): it.unimi.dsi.fastutil.ints.IntPredicate
        and(arg0: it.unimi.dsi.fastutil.ints.IntPredicate): it.unimi.dsi.fastutil.ints.IntPredicate
        and(arg0: (arg0: number) => boolean): (arg0: number) => boolean
        negate(): Internal.IntPredicate
        negate(): Internal.Predicate<any>
        negate(): it.unimi.dsi.fastutil.ints.IntPredicate
    }
}
namespace org.objectweb.asm {
    class Type {
        getDescriptor(): string
        static getDescriptor(arg0: Internal.Class<object>): string
        getElementType(): org.objectweb.asm.Type
        static getArgumentTypes(arg0: string): org.objectweb.asm.Type[]
        static getArgumentTypes(arg0: Internal.Method): org.objectweb.asm.Type[]
        getArgumentTypes(): org.objectweb.asm.Type[]
        static getArgumentsAndReturnSizes(arg0: string): number
        getArgumentsAndReturnSizes(): number
        getDimensions(): number
        getSort(): number
        getSize(): number
        static getMethodDescriptor(arg0: org.objectweb.asm.Type, arg1: org.objectweb.asm.Type[]): string
        static getMethodDescriptor(arg0: Internal.Method): string
        getReturnType(): org.objectweb.asm.Type
        static getReturnType(arg0: string): org.objectweb.asm.Type
        static getReturnType(arg0: Internal.Method): org.objectweb.asm.Type
        getInternalName(): string
        static getInternalName(arg0: Internal.Class<object>): string
        static getType(arg0: Internal.Class<object>): org.objectweb.asm.Type
        static getType(arg0: string): org.objectweb.asm.Type
        static getType(arg0: Internal.Method): org.objectweb.asm.Type
        static getType(arg0: Internal.Constructor<object>): org.objectweb.asm.Type
        hashCode(): number
        equals(arg0: object): boolean
        static getObjectType(arg0: string): org.objectweb.asm.Type
        static getConstructorDescriptor(arg0: Internal.Constructor<object>): string
        static getMethodType(arg0: org.objectweb.asm.Type, arg1: org.objectweb.asm.Type[]): org.objectweb.asm.Type
        static getMethodType(arg0: string): org.objectweb.asm.Type
        toString(): string
        getClassName(): string
        getOpcode(arg0: number): number
        static readonly CHAR_TYPE : org.objectweb.asm.Type;
        static readonly FLOAT : 6;
        static readonly DOUBLE_TYPE : org.objectweb.asm.Type;
        static readonly ARRAY : 9;
        static readonly LONG_TYPE : org.objectweb.asm.Type;
        static readonly BYTE_TYPE : org.objectweb.asm.Type;
        static readonly CHAR : 2;
        static readonly VOID_TYPE : org.objectweb.asm.Type;
        static readonly OBJECT : 10;
        static readonly BOOLEAN_TYPE : org.objectweb.asm.Type;
        static readonly FLOAT_TYPE : org.objectweb.asm.Type;
        static readonly BOOLEAN : 1;
        static readonly INT : 5;
        static readonly SHORT : 4;
        static readonly BYTE : 3;
        static readonly METHOD : 11;
        static readonly SHORT_TYPE : org.objectweb.asm.Type;
        static readonly DOUBLE : 8;
        static readonly VOID : 0;
        static readonly LONG : 7;
        static readonly INT_TYPE : org.objectweb.asm.Type;
        get descriptor(): string;
        get elementType(): org.objectweb.asm.Type;
        get argumentTypes(): org.objectweb.asm.Type[];
        get argumentsAndReturnSizes(): number;
        get dimensions(): number;
        get sort(): number;
        get size(): number;
        get returnType(): org.objectweb.asm.Type;
        get internalName(): string;
        get className(): string;
    }
}
namespace blusunrize.immersiveengineering.mixin.accessors {
    interface EntityAccess {
        getRemainingFireTicks(): number
        setRemainingFireTicks(arg0: number): void
        get remainingFireTicks(): number;
        set remainingFireTicks(arg0: number);
    }
}
namespace me.jellysquid.mods.lithium.mixin.chunk.entity_class_groups {
    interface ServerEntityManagerAccessor <T> {
        getCache(): Internal.EntitySectionStorage<T>
        get cache(): Internal.EntitySectionStorage<T>;
    }
}
namespace com.jozufozu.flywheel.api.vertex {
    interface VertexType {
        getLayout(): Internal.BufferLayout
        createWriter(arg0: Internal.ByteBuffer): Internal.VertexWriter
        getStride(): number
        byteOffset(arg0: number): number
        createReader(arg0: Internal.ByteBuffer, arg1: number): Internal.VertexList
        getShaderHeader(): string
        get layout(): Internal.BufferLayout;
        get stride(): number;
        get shaderHeader(): string;
    }
}
namespace java_.util.function_ {
    interface Function <T, R> {
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R
        apply(arg0: T): R
        static identity<T>(): (arg0: T) => T
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V
    }
    interface IntBinaryOperator {
        applyAsInt(arg0: number, arg1: number): number
    }
    interface Supplier <T> {
        get(): T
    }
    interface IntConsumer {
        andThen(arg0: java_.util.function_.IntConsumer): java_.util.function_.IntConsumer
        accept(arg0: number): void
    }
}
namespace com.jozufozu.flywheel.core.model {
    interface Model {
        size(): number
        getReader(): Internal.VertexList
        getType(): com.jozufozu.flywheel.api.vertex.VertexType
        writeInto(arg0: Internal.ByteBuffer): void
        name(): string
        vertexCount(): number
        createEBO(): Internal.ElementBuffer
        empty(): boolean
        get reader(): Internal.VertexList;
        get type(): com.jozufozu.flywheel.api.vertex.VertexType;
    }
}
namespace org.apache.logging.log4j {
    class Level implements Internal.Comparable<org.apache.logging.log4j.Level>, Internal.Serializable {
        isLessSpecificThan(level: org.apache.logging.log4j.Level): boolean
        isMoreSpecificThan(level: org.apache.logging.log4j.Level): boolean
        static forName(name: string, intValue: number): org.apache.logging.log4j.Level
        static valueOf<T>(enumType: Internal.Class<T>, name: string): T
        static valueOf(name: string): org.apache.logging.log4j.Level
        static values(): org.apache.logging.log4j.Level[]
        isInRange(minLevel: org.apache.logging.log4j.Level, maxLevel: org.apache.logging.log4j.Level): boolean
        compareTo(other: object): number
        compareTo(other: org.apache.logging.log4j.Level): number
        intLevel(): number
        static getLevel(name: string): org.apache.logging.log4j.Level
        getDeclaringClass(): Internal.Class<org.apache.logging.log4j.Level>
        static toLevel(name: string, defaultLevel: org.apache.logging.log4j.Level): org.apache.logging.log4j.Level
        static toLevel(sArg: string): org.apache.logging.log4j.Level
        getStandardLevel(): Internal.StandardLevel
        hashCode(): number
        equals(other: object): boolean
        clone(): object
        clone(): org.apache.logging.log4j.Level
        name(): string
        toString(): string
        static readonly TRACE : org.apache.logging.log4j.Level;
        static readonly ALL : org.apache.logging.log4j.Level;
        static readonly CATEGORY : "Level";
        static readonly ERROR : org.apache.logging.log4j.Level;
        static readonly INFO : org.apache.logging.log4j.Level;
        static readonly FATAL : org.apache.logging.log4j.Level;
        static readonly DEBUG : org.apache.logging.log4j.Level;
        static readonly OFF : org.apache.logging.log4j.Level;
        static readonly WARN : org.apache.logging.log4j.Level;
        get declaringClass(): Internal.Class<org.apache.logging.log4j.Level>;
        get standardLevel(): Internal.StandardLevel;
    }
}
namespace io.netty.util.concurrent {
    interface ScheduledFuture <V> implements io.netty.util.concurrent.Future<V>, Internal.ScheduledFuture<V> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        getDelay(arg0: Internal.TimeUnit): number
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        getNow(): V
        cause(): Internal.Throwable
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        awaitUninterruptibly(): io.netty.util.concurrent.Future<V>
        compareTo(arg0: T): number
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        isDone(): boolean
        sync(): io.netty.util.concurrent.Future<V>
        syncUninterruptibly(): io.netty.util.concurrent.Future<V>
        get(arg0: number, arg1: Internal.TimeUnit): V
        get(): V
        isCancellable(): boolean
        await(arg0: number): boolean
        await(): io.netty.util.concurrent.Future<V>
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        isSuccess(): boolean
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        get now(): V;
    }
    interface Future <V> implements Internal.Future<V> {
        cancel(arg0: boolean): boolean
        isCancelled(): boolean
        removeListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        getNow(): V
        cause(): Internal.Throwable
        awaitUninterruptibly(arg0: number): boolean
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean
        awaitUninterruptibly(): io.netty.util.concurrent.Future<V>
        removeListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        isDone(): boolean
        sync(): io.netty.util.concurrent.Future<V>
        syncUninterruptibly(): io.netty.util.concurrent.Future<V>
        get(arg0: number, arg1: Internal.TimeUnit): V
        get(): V
        isCancellable(): boolean
        await(arg0: number): boolean
        await(): io.netty.util.concurrent.Future<V>
        await(arg0: number, arg1: Internal.TimeUnit): boolean
        addListeners(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>[]): io.netty.util.concurrent.Future<V>
        isSuccess(): boolean
        addListener(arg0: Internal.GenericFutureListener<io.netty.util.concurrent.Future<V>>): io.netty.util.concurrent.Future<V>
        get now(): V;
    }
}
namespace com.jozufozu.flywheel.api {
    interface Material <D> {
        getModel(arg0: Internal.PartialModel, arg1: Internal.BlockState, arg2: Internal.Direction): Internal.Instancer<D>
        getModel(arg0: Internal.PartialModel, arg1: Internal.BlockState, arg2: Internal.Direction, arg3: () => Internal.PoseStack): Internal.Instancer<D>
        getModel(arg0: Internal.BlockState): Internal.Instancer<D>
        getModel(arg0: Internal.PartialModel): Internal.Instancer<D>
        getModel(arg0: Internal.PartialModel, arg1: Internal.BlockState): Internal.Instancer<D>
        model(arg0: object, arg1: () => com.jozufozu.flywheel.core.model.Model): Internal.Instancer<D>
    }
}
namespace dev.latvian.mods.rhino.util.unit {
    class Unit {
        sub(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        mod(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        mul(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        log(): dev.latvian.mods.rhino.util.unit.Unit
        log1p(): dev.latvian.mods.rhino.util.unit.Unit
        log10(): dev.latvian.mods.rhino.util.unit.Unit
        cos(): dev.latvian.mods.rhino.util.unit.Unit
        deg(): dev.latvian.mods.rhino.util.unit.Unit
        lt(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        atan(): dev.latvian.mods.rhino.util.unit.Unit
        getAsInt(): number
        div(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        neg(): dev.latvian.mods.rhino.util.unit.Unit
        not(): dev.latvian.mods.rhino.util.unit.Unit
        shiftLeft(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        min(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        rad(): dev.latvian.mods.rhino.util.unit.Unit
        sqrt(): dev.latvian.mods.rhino.util.unit.Unit
        and(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        get(): number
        gte(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        pow(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        sin(): dev.latvian.mods.rhino.util.unit.Unit
        xor(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        neq(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        lte(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        floor(): dev.latvian.mods.rhino.util.unit.Unit
        isFixed(): boolean
        sq(): dev.latvian.mods.rhino.util.unit.Unit
        atan2(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        tan(): dev.latvian.mods.rhino.util.unit.Unit
        add(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        or(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        max(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        toBool(): dev.latvian.mods.rhino.util.unit.Unit
        ceil(): dev.latvian.mods.rhino.util.unit.Unit
        eq(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        gt(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        shiftRight(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit
        abs(): dev.latvian.mods.rhino.util.unit.Unit
        getAsBoolean(): boolean
        toString(): string
        append(arg0: Internal.StringBuilder): void
        get asInt(): number;
        get asBoolean(): boolean;
    }
}
namespace java_.util.concurrent {
    interface Callable <V> {
        call(): V
    }
}
namespace net.minecraft.nbt {
    interface Tag {
        toString(): string
    }
}
namespace org.apache.logging.log4j.message {
    interface Message implements Internal.Serializable {
        getParameters(): object[]
        getFormattedMessage(): string
        getFormat(): string
        getThrowable(): Internal.Throwable
        get parameters(): object[];
        get formattedMessage(): string;
        get format(): string;
        get throwable(): Internal.Throwable;
    }
}
namespace net.minecraft.world.level.material {
    class Material {
    }
}
namespace dev.latvian.mods.rhino {
    interface Function implements Internal.Scriptable, Internal.Callable {
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: object) => void): boolean
        hasInstance(arg0: Internal.Scriptable): boolean
        setParentScope(arg0: Internal.Scriptable): void
        getIds(): object[]
        construct(arg0: Internal.Context, arg1: Internal.Scriptable, arg2: object[]): Internal.Scriptable
        getAllIds(): object[]
        delete(arg0: string): void
        delete(arg0: number): void
        put(arg0: number, arg1: Internal.Scriptable, arg2: object): void
        put(arg0: string, arg1: Internal.Scriptable, arg2: object): void
        getDefaultValue(arg0: Internal.Class<object>): object
        setPrototype(arg0: Internal.Scriptable): void
        getPrototype(): Internal.Scriptable
        call(arg0: Internal.Context, arg1: Internal.Scriptable, arg2: Internal.Scriptable, arg3: object[]): object
        get(arg0: number, arg1: Internal.Scriptable): object
        get(arg0: string, arg1: Internal.Scriptable): object
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: object) => void): boolean
        has(arg0: number, arg1: Internal.Scriptable): boolean
        has(arg0: string, arg1: Internal.Scriptable): boolean
        getClassName(): string
        getParentScope(): Internal.Scriptable
        static readonly NOT_FOUND : object;
        set parentScope(arg0: Internal.Scriptable);
        get ids(): object[];
        get allIds(): object[];
        set prototype(arg0: Internal.Scriptable);
        get prototype(): Internal.Scriptable;
        get className(): string;
        get parentScope(): Internal.Scriptable;
    }
}
namespace net.minecraft.client.renderer.culling {
    class Frustum implements Internal.FrustumAdapter {
        handler$zol000$init(modelViewMatrix: Internal.Matrix4f, projectionMatrix: Internal.Matrix4f, ci: Internal.CallbackInfo): void
        sodium$createFrustum(): Internal.Frustum
    }
}
namespace java_.nio.channels {
    interface Channel implements Internal.Closeable {
        isOpen(): boolean
        close(): void
    }
}
namespace com.mojang.datafixers.util {
    class Pair <F, S> implements Internal.App<Internal.Pair$Mu<S>, F> {
        mapFirst<F2>(arg0: (arg0: F) => F2): com.mojang.datafixers.util.Pair<F2, S>
        swap(): com.mojang.datafixers.util.Pair<S, F>
        static unbox<F, S>(arg0: Internal.App<Internal.Pair$Mu<S>, F>): com.mojang.datafixers.util.Pair<F, S>
        getFirst(): F
        hashCode(): number
        static toMap<F, S>(): Internal.Collector<com.mojang.datafixers.util.Pair<F, S>, object, Map<F, S>>
        static of<F, S>(arg0: F, arg1: S): com.mojang.datafixers.util.Pair<F, S>
        equals(arg0: object): boolean
        getSecond(): S
        toString(): string
        mapSecond<S2>(arg0: (arg0: S) => S2): com.mojang.datafixers.util.Pair<F, S2>
        get first(): F;
        get second(): S;
    }
}
namespace Document {
    class CreateRecipes {
        /**
        * Creates a recipe for Crushing Wheels.
        *
        * Specifying chances on outputs will make them output with chance.
        */
        crushing(outputs: Internal.ItemStackJS[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Millstone.
        *
        * Specifying chances on outputs will make them output with chance.
        */
        milling(outputs: Internal.ItemStackJS[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Compacting.
        */
        compacting(output: Type.ItemStackOrFluid, inputs: Type.IngredientOrFluid[]): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Mixing.
        */
        mixing(output: Type.ItemStackOrFluid, inputs: Type.IngredientOrFluid[]): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Pressing.
        *
        * Pressing uses Depot or Belt as container, and can only have 1 item slot as input.
        *
        * Pressing is available as an Assembly step.
        */
        pressing(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Deploying.
        *
        * Deploying is available as an Assembly step.
        */
        deploying(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Cutting.
        *
        * Cutting is available as an Assembly step.
        */
        cutting(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Filling.
        *
        * Filling is available as an Assembly step.
        */
        filling(output: Internal.ItemStackJS, input: Type.IngredientOrFluid[]): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Sequenced Assembly.
        *
        * The sequnce must use recipes which is available for Assembly.
        */
        sequenced_assembly(output: Internal.ItemStackJS[], input: Internal.IngredientJS, sequence: Internal.ProcessingRecipeJS[]): Internal.SequencedAssemblyRecipeJS;
        /**
        * Creates a recipe for Splashing.
        */
        splashing(output: Internal.ItemStackJS[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Haunting.
        */
        haunting(output: Internal.ItemStackJS[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Sandpaper Polishing.
        */
        sandpaper_polishing(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Mechanical Crafting.
        */
        mechanical_crafting(output: Internal.ItemStackJS, pattern: string[], items: Map<string, Internal.IngredientJS>): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Emptying.
        */
        emptying(output: Type.ItemStackOrFluid[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
    }
    class RecipeHolder {
        /**
        * All recipes from Create.
        */
        readonly create: Document.CreateRecipes;
        /**
        * All recipes from Minecraft.
        */
        readonly minecraft: Document.MinecraftRecipes;
    }
    class MinecraftRecipes {
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Furnaces.
        */
        smelting(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Smokers.
        */
        smoking(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Blast Furnaces.
        */
        blasting(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a shaped crafting recipe.
        */
        crafting_shaped(output: Internal.ItemStackJS, pattern: string[], items: Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        /**
        * Adds a shapeless crafting recipe.
        */
        crafting_shapeless(output: Internal.ItemStackJS, inputs: Internal.IngredientJS[]): Internal.ShapelessRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Camefire.
        */
        camefire_cooking(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a stonecutting recipe.
        */
        stonecutting(output: Internal.ItemStackJS, inputs: Internal.IngredientJS): Internal.StonecuttingRecipeJS;
        /**
        * Adds a smithing recipe.
        */
        smithing(output: Internal.ItemStackJS, base: Internal.IngredientJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
    }
}
namespace Type {
    type ItemStackOrFluid = Internal.ItemStackJS | Internal.FluidStackJS;
    type IngredientOrFluid = Internal.IngredientJS | Internal.FluidStackJS;
}
