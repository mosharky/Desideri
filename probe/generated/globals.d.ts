declare class JavaMath {
    getClass(): Internal.Class<any>;
    static multiplyFull(arg0: number, arg1: number): number;
    static copySign(arg0: number, arg1: number): number;
    static copySign(arg0: number, arg1: number): number;
    static log1p(arg0: number): number;
    static expm1(arg0: number): number;
    static cos(arg0: number): number;
    static rint(arg0: number): number;
    static atan(arg0: number): number;
    static nextUp(arg0: number): number;
    static nextUp(arg0: number): number;
    static sqrt(arg0: number): number;
    static decrementExact(arg0: number): number;
    static decrementExact(arg0: number): number;
    static absExact(arg0: number): number;
    static absExact(arg0: number): number;
    static exp(arg0: number): number;
    static atan2(arg0: number, arg1: number): number;
    static signum(arg0: number): number;
    static signum(arg0: number): number;
    static tan(arg0: number): number;
    static sinh(arg0: number): number;
    static toDegrees(arg0: number): number;
    static acos(arg0: number): number;
    static ceil(arg0: number): number;
    static getExponent(arg0: number): number;
    static getExponent(arg0: number): number;
    static addExact(arg0: number, arg1: number): number;
    static addExact(arg0: number, arg1: number): number;
    static multiplyHigh(arg0: number, arg1: number): number;
    static ulp(arg0: number): number;
    static ulp(arg0: number): number;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static scalb(arg0: number, arg1: number): number;
    static scalb(arg0: number, arg1: number): number;
    static floorMod(arg0: number, arg1: number): number;
    static floorMod(arg0: number, arg1: number): number;
    static floorMod(arg0: number, arg1: number): number;
    static log(arg0: number): number;
    static log10(arg0: number): number;
    notifyAll(): void;
    static nextAfter(arg0: number, arg1: number): number;
    static nextAfter(arg0: number, arg1: number): number;
    static multiplyExact(arg0: number, arg1: number): number;
    static multiplyExact(arg0: number, arg1: number): number;
    static multiplyExact(arg0: number, arg1: number): number;
    notify(): void;
    static cbrt(arg0: number): number;
    static random(): number;
    static tanh(arg0: number): number;
    static min(arg0: number, arg1: number): number;
    static min(arg0: number, arg1: number): number;
    static min(arg0: number, arg1: number): number;
    static min(arg0: number, arg1: number): number;
    static negateExact(arg0: number): number;
    static negateExact(arg0: number): number;
    hashCode(): number;
    static hypot(arg0: number, arg1: number): number;
    static pow(arg0: number, arg1: number): number;
    static sin(arg0: number): number;
    static floor(arg0: number): number;
    static subtractExact(arg0: number, arg1: number): number;
    static subtractExact(arg0: number, arg1: number): number;
    static max(arg0: number, arg1: number): number;
    static max(arg0: number, arg1: number): number;
    static max(arg0: number, arg1: number): number;
    static max(arg0: number, arg1: number): number;
    static toIntExact(arg0: number): number;
    static nextDown(arg0: number): number;
    static nextDown(arg0: number): number;
    static toRadians(arg0: number): number;
    static cosh(arg0: number): number;
    static IEEEremainder(arg0: number, arg1: number): number;
    static abs(arg0: number): number;
    static abs(arg0: number): number;
    static abs(arg0: number): number;
    static abs(arg0: number): number;
    static round(arg0: number): number;
    static round(arg0: number): number;
    static floorDiv(arg0: number, arg1: number): number;
    static floorDiv(arg0: number, arg1: number): number;
    static floorDiv(arg0: number, arg1: number): number;
    static incrementExact(arg0: number): number;
    static incrementExact(arg0: number): number;
    equals(arg0: any): boolean;
    toString(): string;
    static asin(arg0: number): number;
    static fma(arg0: number, arg1: number, arg2: number): number;
    static fma(arg0: number, arg1: number, arg2: number): number;
    static readonly E : 2.718281828459045;
    static readonly PI : 3.141592653589793;
    get class(): Internal.Class<any>;
}
declare interface NBT {
    longArrayTag(v: number[]): Internal.Tag;
    byteArrayTag(v: number[]): Internal.Tag;
    b(v: number): Internal.Tag;
    fromTag(t: Internal.Tag): any;
    listTag(): Internal.Tag;
    listTag(list: Internal.List<any>): Internal.Tag;
    d(v: number): Internal.Tag;
    f(v: number): Internal.Tag;
    compoundTag(map: Internal.Map<string, any>): Internal.Tag;
    compoundTag(): Internal.Tag;
    toTag(v: any): Internal.Tag;
    i(v: number): Internal.Tag;
    shortTag(v: number): Internal.Tag;
    l(v: number): Internal.Tag;
    floatTag(v: number): Internal.Tag;
    s(v: number): Internal.Tag;
    la(v: number[]): Internal.Tag;
    longTag(v: number): Internal.Tag;
    intArrayTag(v: number[]): Internal.Tag;
    ia(v: number[]): Internal.Tag;
    intTag(v: number): Internal.Tag;
    doubleTag(v: number): Internal.Tag;
    byteTag(v: number): Internal.Tag;
    stringTag(v: string): Internal.Tag;
    ba(v: number[]): Internal.Tag;
}
declare const NBT: NBT;
declare class Platform {
    static isDevelopmentEnvironment(): boolean;
    getClass(): Internal.Class<any>;
    static isClientEnvironment(): boolean;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static getName(): string;
    static getInfo(modID: string): Internal.PlatformWrapper$ModInfo;
    static getMods(): Internal.Map<string, Internal.PlatformWrapper$ModInfo>;
    notifyAll(): void;
    static isForge(): boolean;
    static isLoaded(modId: string): boolean;
    notify(): void;
    static isFabric(): boolean;
    hashCode(): number;
    static getList(): Internal.Set<string>;
    equals(arg0: any): boolean;
    static getModVersion(): string;
    toString(): string;
    static getMcVersion(): string;
    get mods(): Internal.Map<string, Internal.PlatformWrapper$ModInfo>;
    get modVersion(): string;
    get developmentEnvironment(): boolean;
    get forge(): boolean;
    get fabric(): boolean;
    get mcVersion(): string;
    get clientEnvironment(): boolean;
    get name(): string;
    get list(): Internal.Set<string>;
    get class(): Internal.Class<any>;
    constructor();
}
declare class ResourceLocation implements Internal.Comparable<ResourceLocation>, Internal.ResourceLocationAccess, Internal.SpecialEquality {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    notifyAll(): void;
    setPath(arg0: string): void;
    compareTo(arg0: any): number;
    compareTo(arg0: ResourceLocation): number;
    notify(): void;
    getNamespace(): string;
    hashCode(): number;
    compareNamespaced(arg0: ResourceLocation): number;
    equals(arg0: any): boolean;
    getPath(): string;
    toString(): string;
    setNamespace(arg0: string): void;
    specialEquals(o: any, shallow: boolean): boolean;
    get path(): string;
    get namespace(): string;
    get class(): Internal.Class<any>;
    set path(arg0: string);
    set namespace(arg0: string);
    constructor(arg0: string, arg1: string);
    constructor(arg0: string);
}
declare class Fluid {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    notifyAll(): void;
    static water(): Internal.FluidStackJS;
    static water(amount: number): Internal.FluidStackJS;
    notify(): void;
    static lava(amount: number): Internal.FluidStackJS;
    static lava(): Internal.FluidStackJS;
    static getType(id: ResourceLocation): Internal.Fluid;
    hashCode(): number;
    equals(arg0: any): boolean;
    static getEmpty(): Internal.FluidStackJS;
    static of(o: Internal.FluidStackJS): Internal.FluidStackJS;
    static of(o: Internal.FluidStackJS, amount: number, nbt: Internal.CompoundTag): Internal.FluidStackJS;
    static of(o: Internal.FluidStackJS, nbt: Internal.CompoundTag): Internal.FluidStackJS;
    static of(o: Internal.FluidStackJS, amount: number): Internal.FluidStackJS;
    static exists(id: ResourceLocation): boolean;
    toString(): string;
    static getTypes(): Internal.List<string>;
    static readonly LAVA_ID : ResourceLocation;
    static readonly WATER_ID : ResourceLocation;
    get types(): Internal.List<string>;
    get class(): Internal.Class<any>;
    get empty(): Internal.FluidStackJS;
    constructor();
}
declare interface UUID {
    digits(sb: Internal.StringBuilder, val: number, digits: number): void;
    toString(id: Internal.UUID): string;
    fromString(o: any): Internal.UUID;
}
declare const UUID: UUID;
declare interface BlockStatePredicate {
    test(arg0: Internal.BlockState): boolean;
    getBlockStates(): Internal.Collection<Internal.BlockState>;
    of(o: any): BlockStatePredicate;
    getBlocks(): Internal.Collection<Internal.Block>;
    fromString(s: string): BlockStatePredicate;
    check(targetStates: Internal.List<Internal.OreConfiguration$TargetBlockState>): boolean;
    getBlockIds(): Internal.Set<ResourceLocation>;
    asRuleTest(): Internal.RuleTest;
    ruleTestOf(o: any): Internal.RuleTest;
    readonly AIR_ID : ResourceLocation;
}
declare const BlockStatePredicate: BlockStatePredicate;
declare class Hand extends Internal.Enum<any> {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static valueOf(arg0: string): Hand;
    static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
    notifyAll(): void;
    static values(): Hand[];
    compareTo(arg0: any): number;
    compareTo(arg0: Hand): number;
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Hand>>;
    notify(): void;
    getDeclaringClass(): Internal.Class<Hand>;
    hashCode(): number;
    equals(arg0: any): boolean;
    name(): string;
    toString(): string;
    ordinal(): number;
    static readonly MAIN_HAND : Hand;
    static readonly OFF_HAND : Hand;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<Hand>;
}
declare interface Color {
    rgba(r: number, g: number, b: number, a: number): Internal.Color;
    of(o: any): Internal.Color;
    createMapped(o: any, names: string[]): Internal.Color;
    readonly BLUE_DYE : Internal.Color;
    readonly GOLD : Internal.Color;
    readonly GRAY : Internal.Color;
    readonly MAGENTA_DYE : Internal.Color;
    readonly BLUE : Internal.Color;
    readonly DARK_AQUA : Internal.Color;
    readonly TEXT : Internal.Map<string, Internal.ChatFormatting>;
    readonly DYE : Internal.Map<string, Internal.DyeColor>;
    readonly WHITE_DYE : Internal.Color;
    readonly DARK_RED : Internal.Color;
    readonly LIGHT_PURPLE : Internal.Color;
    readonly BROWN_DYE : Internal.Color;
    readonly BLACK : Internal.Color;
    readonly GRAY_DYE : Internal.Color;
    readonly NONE : Internal.Color;
    readonly LIGHT_BLUE_DYE : Internal.Color;
    readonly AQUA : Internal.Color;
    readonly WHITE : Internal.Color;
    readonly LIGHT_GRAY_DYE : Internal.Color;
    readonly BLACK_DYE : Internal.Color;
    readonly RED_DYE : Internal.Color;
    readonly PURPLE_DYE : Internal.Color;
    readonly GREEN_DYE : Internal.Color;
    readonly PINK_DYE : Internal.Color;
    readonly DARK_BLUE : Internal.Color;
    readonly GREEN : Internal.Color;
    readonly CYAN_DYE : Internal.Color;
    readonly RED : Internal.Color;
    readonly DARK_PURPLE : Internal.Color;
    readonly ORANGE_DYE : Internal.Color;
    readonly YELLOW_DYE : Internal.Color;
    readonly DARK_GREEN : Internal.Color;
    readonly YELLOW : Internal.Color;
    readonly LIME_DYE : Internal.Color;
    readonly DARK_GRAY : Internal.Color;
    readonly MAP : Internal.Map<string, Internal.Color>;
}
declare const Color: Color;
declare class Rarity {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    hashCode(): number;
    notifyAll(): void;
    equals(arg0: any): boolean;
    toString(): string;
    notify(): void;
    static readonly RARE : Rarity;
    static readonly EPIC : Rarity;
    static readonly UNCOMMON : Rarity;
    static readonly COMMON : Rarity;
    readonly rarity : Internal.Rarity;
    get class(): Internal.Class<any>;
}
declare interface NBTIO {
    read(path: Internal.Path): Internal.CompoundTag;
    write(path: Internal.Path, nbt: Internal.CompoundTag): void;
}
declare const NBTIO: NBTIO;
declare class Ingredient {
    getClass(): Internal.Class<any>;
    static customNBT(in_: Internal.IngredientJS, predicate: (arg0: Internal.CompoundTag) => boolean): Internal.IngredientJS;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static getAll(): Internal.IngredientJS;
    static isIngredient(o: any): boolean;
    notifyAll(): void;
    static custom(in_: Internal.IngredientJS, predicate: (arg0: Internal.ItemStackJS) => boolean): Internal.IngredientJS;
    static custom(predicate: (arg0: Internal.ItemStackJS) => boolean): Internal.IngredientJS;
    static getNone(): Internal.IngredientJS;
    notify(): void;
    static matchAny(objects: any): Internal.IngredientJS;
    hashCode(): number;
    equals(arg0: any): boolean;
    static of(object: any, count: number): Internal.IngredientJS;
    static of(object: any): Internal.IngredientJS;
    toString(): string;
    static registerCustomIngredientAction(id: string, callback: Internal.CustomIngredientActionCallback): void;
    get all(): Internal.IngredientJS;
    get none(): Internal.IngredientJS;
    get class(): Internal.Class<any>;
    constructor();
}
declare class EquipmentSlot extends Internal.Enum<any> {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static valueOf(arg0: string): EquipmentSlot;
    static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
    notifyAll(): void;
    static values(): EquipmentSlot[];
    compareTo(arg0: any): number;
    compareTo(arg0: EquipmentSlot): number;
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<EquipmentSlot>>;
    notify(): void;
    getDeclaringClass(): Internal.Class<EquipmentSlot>;
    hashCode(): number;
    equals(arg0: any): boolean;
    name(): string;
    toString(): string;
    ordinal(): number;
    static readonly CHEST : EquipmentSlot;
    static readonly HEAD : EquipmentSlot;
    static readonly OFFHAND : EquipmentSlot;
    static readonly MAINHAND : EquipmentSlot;
    static readonly LEGS : EquipmentSlot;
    static readonly FEET : EquipmentSlot;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<EquipmentSlot>;
}
declare interface Facing {
    readonly ALL : Internal.Map<string, Internal.Direction>;
    readonly DOWN : Internal.Direction;
    readonly south : Internal.Direction;
    readonly north : Internal.Direction;
    readonly WEST : Internal.Direction;
    readonly down : Internal.Direction;
    readonly east : Internal.Direction;
    readonly NORTH : Internal.Direction;
    readonly west : Internal.Direction;
    readonly up : Internal.Direction;
    readonly UP : Internal.Direction;
    readonly SOUTH : Internal.Direction;
    readonly EAST : Internal.Direction;
}
declare const Facing: Facing;
declare class Text {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static string(text: any): Internal.Text;
    notifyAll(): void;
    static yellow(text: any): Internal.Text;
    static darkBlue(text: any): Internal.Text;
    notify(): void;
    static translate(key: string, objects: any[]): Internal.Text;
    static translate(key: string): Internal.Text;
    static gold(text: any): Internal.Text;
    static red(text: any): Internal.Text;
    static aqua(text: any): Internal.Text;
    static gray(text: any): Internal.Text;
    static white(text: any): Internal.Text;
    hashCode(): number;
    static darkRed(text: any): Internal.Text;
    static of(object: any): Internal.Text;
    static darkPurple(text: any): Internal.Text;
    static join(separator: Internal.Text, texts: Internal.Iterable<Internal.Text>): Internal.Text;
    static green(text: any): Internal.Text;
    static darkGreen(text: any): Internal.Text;
    static lightPurple(text: any): Internal.Text;
    static black(text: any): Internal.Text;
    static darkAqua(text: any): Internal.Text;
    static blue(text: any): Internal.Text;
    equals(arg0: any): boolean;
    static keybind(keybind: string): Internal.Text;
    static darkGray(text: any): Internal.Text;
    toString(): string;
    get class(): Internal.Class<any>;
    constructor();
}
declare class Block {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static getBlock(id: ResourceLocation): Internal.Block;
    notifyAll(): void;
    static custom(predicate: Internal.BlockPredicate): Internal.BlockPredicate;
    static getTypeList(): Internal.List<string>;
    notify(): void;
    static getMaterial(): Internal.Map<string, Internal.MaterialJS>;
    static getTaggedIds(tag: ResourceLocation): Internal.List<string>;
    hashCode(): number;
    equals(arg0: any): boolean;
    toString(): string;
    static getFacing(): Internal.Map<string, Internal.Direction>;
    static id(id: ResourceLocation, properties: Internal.Map<string, any>): Internal.BlockIDPredicate;
    static id(id: ResourceLocation): Internal.BlockIDPredicate;
    static entity(id: ResourceLocation): Internal.BlockEntityPredicate;
    get typeList(): Internal.List<string>;
    get material(): Internal.Map<string, Internal.MaterialJS>;
    get facing(): Internal.Map<string, Internal.Direction>;
    get class(): Internal.Class<any>;
    constructor();
}
declare class Vec3 implements Internal.Position {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    hashCode(): number;
    notifyAll(): void;
    equals(arg0: any): boolean;
    toString(): string;
    notify(): void;
    readonly x : number;
    readonly y : number;
    readonly z : number;
    get class(): Internal.Class<any>;
    constructor(arg0: number, arg1: number, arg2: number);
    constructor(arg0: Internal.Vector3f);
}
declare class DecorationGenerationStep extends Internal.Enum<any> {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static valueOf(arg0: string): DecorationGenerationStep;
    static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
    notifyAll(): void;
    static values(): DecorationGenerationStep[];
    compareTo(arg0: any): number;
    compareTo(arg0: DecorationGenerationStep): number;
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<DecorationGenerationStep>>;
    notify(): void;
    getDeclaringClass(): Internal.Class<DecorationGenerationStep>;
    hashCode(): number;
    equals(arg0: any): boolean;
    name(): string;
    toString(): string;
    ordinal(): number;
    static readonly RAW_GENERATION : DecorationGenerationStep;
    static readonly UNDERGROUND_STRUCTURES : DecorationGenerationStep;
    static readonly LOCAL_MODIFICATIONS : DecorationGenerationStep;
    static readonly TOP_LAYER_MODIFICATION : DecorationGenerationStep;
    static readonly UNDERGROUND_DECORATION : DecorationGenerationStep;
    static readonly LAKES : DecorationGenerationStep;
    static readonly SURFACE_STRUCTURES : DecorationGenerationStep;
    static readonly STRONGHOLDS : DecorationGenerationStep;
    static readonly FLUID_SPRINGS : DecorationGenerationStep;
    static readonly VEGETAL_DECORATION : DecorationGenerationStep;
    static readonly UNDERGROUND_ORES : DecorationGenerationStep;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<DecorationGenerationStep>;
}
declare class BlockPos extends Vec3i {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    getX(): number;
    getY(): number;
    getZ(): number;
    hashCode(): number;
    notifyAll(): void;
    equals(arg0: any): boolean;
    toString(): string;
    compareTo(arg0: any): number;
    compareTo(arg0: Vec3i): number;
    notify(): void;
    get x(): number;
    get y(): number;
    get z(): number;
    get class(): Internal.Class<any>;
    constructor(arg0: Vec3i);
    constructor(arg0: Internal.Position);
    constructor(arg0: Vec3);
    constructor(arg0: number, arg1: number, arg2: number);
    constructor(arg0: number, arg1: number, arg2: number);
}
declare class BiomeDictionary {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static printTags(biome: ResourceLocation): void;
    static getBiomeType(o: any): Internal.BiomeDictionary$Type;
    static printBiomes(type: Internal.BiomeDictionary$Type): void;
    hashCode(): number;
    static addTypes(biomes: ResourceLocation[], tags: Internal.BiomeDictionary$Type[]): void;
    notifyAll(): void;
    equals(arg0: any): boolean;
    toString(): string;
    notify(): void;
    get class(): Internal.Class<any>;
    constructor();
}
declare class LootType extends Internal.Enum<any> {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static valueOf(arg0: string): LootType;
    static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
    notifyAll(): void;
    static values(): LootType[];
    compareTo(arg0: any): number;
    compareTo(arg0: LootType): number;
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<LootType>>;
    notify(): void;
    getDeclaringClass(): Internal.Class<LootType>;
    hashCode(): number;
    equals(arg0: any): boolean;
    name(): string;
    toString(): string;
    ordinal(): number;
    static readonly CHEST : LootType;
    static readonly ADVANCEMENT_ENTITY : LootType;
    static readonly GIFT : LootType;
    static readonly ENTITY : LootType;
    static readonly FISHING : LootType;
    static readonly PIGLIN_BARTER : LootType;
    static readonly BLOCK : LootType;
    static readonly UNKNOWN : LootType;
    static readonly ADVANCEMENT_REWARD : LootType;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<LootType>;
}
declare class CarvingGenerationStep extends Internal.Enum<any> implements Internal.StringRepresentable {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static valueOf(arg0: string): CarvingGenerationStep;
    static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
    notifyAll(): void;
    static values(): CarvingGenerationStep[];
    compareTo(arg0: any): number;
    compareTo(arg0: CarvingGenerationStep): number;
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<CarvingGenerationStep>>;
    notify(): void;
    getDeclaringClass(): Internal.Class<CarvingGenerationStep>;
    hashCode(): number;
    equals(arg0: any): boolean;
    name(): string;
    toString(): string;
    ordinal(): number;
    static readonly LIQUID : CarvingGenerationStep;
    static readonly AIR : CarvingGenerationStep;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<CarvingGenerationStep>;
}
declare interface Utils {
    getSystemTime(): number;
    listOrSelf(o: any): Internal.ListJS;
    getStat(id: ResourceLocation): Internal.Stat<ResourceLocation>;
    parseDouble(object: any, def: number): number;
    emptyList<T>(): Internal.List<T>;
    getRandom(): Internal.Random;
    randomOf(random: Internal.Random, objects: Internal.Collection<any>): any;
    emptyMap<K, V>(): Internal.Map<K, V>;
    copy(o: any): any;
    id(namespace: string, path: string): ResourceLocation;
    id(id: ResourceLocation): ResourceLocation;
    listOf(o: any): Internal.ListJS;
    rollChestLoot(id: ResourceLocation, entity: Internal.EntityJS): Internal.ListJS;
    rollChestLoot(id: ResourceLocation): Internal.ListJS;
    getServer(): Internal.ServerJS;
    newCountingMap(): Internal.CountingMap;
    createConsole(name: string): Internal.ConsoleJS;
    newMap(): Internal.MapJS;
    newList(): Internal.ListJS;
    getClientLevel(): Internal.LevelJS;
    parseInt(object: any, def: number): number;
    getLevel(level: net.minecraft.world.level.Level): Internal.LevelJS;
    isWrapped(o: any): boolean;
    regex(s: any): Internal.Pattern;
    regex(pattern: string, flags: number): Internal.Pattern;
    newRandom(seed: number): Internal.Random;
    queueIO(runnable: Internal.Runnable): void;
    toTitleCase(s: string): string;
    mapOf(o: any): Internal.MapJS;
    getSound(id: ResourceLocation): Internal.SoundEvent;
}
declare const Utils: Utils;
declare class JsonIO {
    static writeJsonHash(stream: Internal.DataOutputStream, element: Internal.JsonElement): void;
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static toPrimitive(element: Internal.JsonElement): any;
    static read(path: Internal.Path): Internal.MapJS;
    notifyAll(): void;
    static getJsonHashBytes(json: Internal.JsonElement): number[];
    static parse(string: string): any;
    static primitiveOf(o: any): Internal.JsonPrimitive;
    notify(): void;
    hashCode(): number;
    equals(arg0: any): boolean;
    static of(o: any): Internal.JsonElement;
    static toArray(element: Internal.JsonElement): Internal.JsonArray;
    static toPrettyString(json: Internal.JsonElement): string;
    static parseRaw(string: string): Internal.JsonElement;
    static toString(json: Internal.JsonElement): string;
    toString(): string;
    static toObject(json: Internal.JsonElement): any;
    static copy(element: Internal.JsonElement): Internal.JsonElement;
    static write(path: Internal.Path, json: Internal.JsonElement): void;
    static readonly GSON : Internal.Gson;
    get class(): Internal.Class<any>;
    constructor();
}
declare class Vec3i implements Internal.Comparable<Vec3i> {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    getX(): number;
    getY(): number;
    getZ(): number;
    hashCode(): number;
    notifyAll(): void;
    equals(arg0: any): boolean;
    toString(): string;
    compareTo(arg0: any): number;
    compareTo(arg0: Vec3i): number;
    notify(): void;
    get x(): number;
    get y(): number;
    get z(): number;
    get class(): Internal.Class<any>;
    constructor(arg0: number, arg1: number, arg2: number);
    constructor(arg0: number, arg1: number, arg2: number);
}
declare class Item {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    notifyAll(): void;
    static getTypeList(): Internal.ListJS;
    static findGroup(id: string): Internal.CreativeModeTab;
    static getItem(id: ResourceLocation): Internal.Item;
    static fireworks(properties: Internal.Map<string, any>): Internal.FireworksJS;
    notify(): void;
    static clearListCache(): void;
    hashCode(): number;
    static getList(): Internal.ListJS;
    equals(arg0: any): boolean;
    static getEmpty(): Internal.ItemStackJS;
    static of(in_: Internal.ItemStackJS, count: number, nbt: Internal.CompoundTag): Internal.ItemStackJS;
    static of(in_: Internal.ItemStackJS, tag: Internal.CompoundTag): Internal.ItemStackJS;
    static of(in_: Internal.ItemStackJS, count: number): Internal.ItemStackJS;
    static of(in_: Internal.ItemStackJS): Internal.ItemStackJS;
    static isItem(o: any): boolean;
    static exists(id: ResourceLocation): boolean;
    toString(): string;
    static withChance(in_: Internal.ItemStackJS, c: number): Internal.ItemStackJS;
    static withNBT(in_: Internal.ItemStackJS, nbt: Internal.CompoundTag): Internal.ItemStackJS;
    get typeList(): Internal.ListJS;
    get list(): Internal.ListJS;
    get class(): Internal.Class<any>;
    get empty(): Internal.ItemStackJS;
    constructor();
}
declare interface AABB {
    ofBlock(pos: BlockPos): Internal.AABB;
    ofSize(x: number, y: number, z: number): Internal.AABB;
    ofSize(vec3: Vec3, x: number, y: number, z: number): Internal.AABB;
    of(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.AABB;
    wrap(o: any): Internal.AABB;
    ofBlocks(pos1: BlockPos, pos2: BlockPos): Internal.AABB;
    readonly CUBE : Internal.AABB;
    readonly EMPTY : Internal.AABB;
}
declare const AABB: AABB;
declare namespace net.blay09.mods.netherportalfix.mixin {
    interface LivingEntityAccessor {
        getLastPos(): BlockPos;
    }
}
declare namespace net.minecraft.client.model {
    abstract class Model {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace Internal {
    interface IntBinaryOperator {
        applyAsInt(arg0: number, arg1: number): number;
    }
    class TextureAtlasSprite implements Internal.AutoCloseable, Internal.SpriteExtended {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPixelRGBA(arg0: number, arg1: number, arg2: number): number;
        setActive(active: boolean): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        isActive(): boolean;
        close(): void;
        notify(): void;
        get active(): boolean;
        get class(): Internal.Class<any>;
        set active(active: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EntityTypeExtension <T> {
        flywheel$setInstancingController(arg0: Internal.EntityInstancingController<T>): void;
        flywheel$getInstancingController(): Internal.EntityInstancingController<T>;
    }
    interface EntityTrackerSection {
        updateMovementTimestamps(arg0: number, arg1: number): void;
        getMovementTimestampArray(): number[];
        removeListener(arg0: Internal.EntitySectionStorage<any>, arg1: Internal.SectionedEntityMovementTracker<any, any>): void;
        removeListener(arg0: Internal.EntitySectionStorage<any>, arg1: Internal.NearbyEntityListener): void;
        addListener(arg0: Internal.NearbyEntityListener): void;
        addListener(arg0: Internal.SectionedEntityMovementTracker<any, any>): void;
    }
    class Products$P14 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Short2FloatFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class ModuleDescriptor$Exports$Modifier extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ModuleDescriptor$Exports$Modifier;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ModuleDescriptor$Exports$Modifier[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ModuleDescriptor$Exports$Modifier): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ModuleDescriptor$Exports$Modifier>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ModuleDescriptor$Exports$Modifier>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Exports$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Exports$Modifier;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ModuleDescriptor$Exports$Modifier>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClientLevel extends net.minecraft.world.level.Level implements Internal.ClientLevelExtension, Internal.WorldEntityByChunkAccess, Internal.ClientWorldAccessor, Internal.BiomeSeedProvider, Internal.ExtendedWorld {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        getChunkAtImmediately(arg0: number, arg1: number): Internal.LevelChunk;
        notifyAll(): void;
        getLoadedExistingBlockEntity(pos: BlockPos): Internal.BlockEntity;
        addFreshBlockEntities(arg0: Internal.Collection<Internal.BlockEntity>): void;
        getEntityManager(): Internal.TransientEntitySectionManager<any>;
        notify(): void;
        getEntitiesInChunk(chunkX: number, chunkZ: number): Internal.Collection<any>;
        markAndNotifyBlock(arg0: BlockPos, arg1: Internal.LevelChunk, arg2: Internal.BlockState, arg3: Internal.BlockState, arg4: number, arg5: number): void;
        invalidateCaps(): void;
        getLunarContext(): Internal.LunarContext;
        hashCode(): number;
        increaseMaxEntityRadius(arg0: number): number;
        redirect$zod000$redirectTick(blockEntity: Internal.TickingBlockEntity): void;
        close(): void;
        flywheel$getAllLoadedEntities(): Internal.Iterable<any>;
        handler$zbl000$onOnChunkLoaded(arg0: Internal.ChunkPos, arg1: Internal.CallbackInfo): void;
        handler$zbl000$onClearColorCaches(arg0: Internal.CallbackInfo): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<net.minecraft.world.level.Level>): boolean;
        getMaxEntityRadius(): number;
        asKJS(): any;
        reviveCaps(): void;
        getAnyChunkImmediately(arg0: number, arg1: number): Internal.ChunkAccess;
        equals(arg0: any): boolean;
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean;
        toString(): string;
        getRandomPosInChunk(x: number, y: number, z: number, mask: number, out: Internal.BlockPos$MutableBlockPos): void;
        handler$caf000$onDisconnect(arg0: Internal.CallbackInfo): void;
        setLunarContext(arg0: Internal.LunarContext): Internal.LunarContext;
        getBiomeSeed(): number;
        restoringBlockSnapshots : boolean;
        capturedBlockSnapshots : Internal.ArrayList<Internal.BlockSnapshot>;
        captureBlockSnapshots : boolean;
        get lunarContext(): Internal.LunarContext;
        get entityManager(): Internal.TransientEntitySectionManager<any>;
        get maxEntityRadius(): number;
        get biomeSeed(): number;
        get class(): Internal.Class<any>;
        set lunarContext(arg0: Internal.LunarContext);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ImmutableCollection$Builder <E> {
        add(arg0: E): Internal.ImmutableCollection$Builder<E>;
        add(arg0: E[]): Internal.ImmutableCollection$Builder<E>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.ImmutableCollection<E>;
        addAll(arg0: Internal.Iterator<E>): Internal.ImmutableCollection$Builder<E>;
        addAll(arg0: Internal.Iterable<E>): Internal.ImmutableCollection$Builder<E>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DirectMethodHandleDesc$Kind extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: number, arg1: boolean): Internal.DirectMethodHandleDesc$Kind;
        static valueOf(arg0: string): Internal.DirectMethodHandleDesc$Kind;
        static valueOf(arg0: number): Internal.DirectMethodHandleDesc$Kind;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.DirectMethodHandleDesc$Kind[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.DirectMethodHandleDesc$Kind): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.DirectMethodHandleDesc$Kind>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.DirectMethodHandleDesc$Kind>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly INTERFACE_SPECIAL : Internal.DirectMethodHandleDesc$Kind;
        readonly refKind : number;
        static readonly SETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly SPECIAL : Internal.DirectMethodHandleDesc$Kind;
        static readonly STATIC : Internal.DirectMethodHandleDesc$Kind;
        static readonly GETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly STATIC_GETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly INTERFACE_VIRTUAL : Internal.DirectMethodHandleDesc$Kind;
        static readonly STATIC_SETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly CONSTRUCTOR : Internal.DirectMethodHandleDesc$Kind;
        readonly isInterface : boolean;
        static readonly INTERFACE_STATIC : Internal.DirectMethodHandleDesc$Kind;
        static readonly VIRTUAL : Internal.DirectMethodHandleDesc$Kind;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.DirectMethodHandleDesc$Kind>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Byte2DoubleFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class ProtoChunk extends Internal.ChunkAccess implements Internal.ExtendedChunk {
        getClass(): Internal.Class<any>;
        getWorldForge(): Internal.LevelAccessor;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getBlockNibbles(): any[];
        setBlockEmptinessMap(arg0: boolean[]): void;
        notify(): void;
        setSkyNibbles(arg0: any[]): void;
        hashCode(): number;
        getSkyEmptinessMap(): boolean[];
        equals(arg0: any): boolean;
        getSkyNibbles(): any[];
        toString(): string;
        localvar$bna000$modifyHeightmapType(arg0: Internal.Heightmap$Types): Internal.Heightmap$Types;
        setSkyEmptinessMap(arg0: boolean[]): void;
        getBlockEmptinessMap(): boolean[];
        handler$bmm000$onConstruct(arg0: Internal.ChunkPos, arg1: Internal.UpgradeData, arg2: any[], arg3: Internal.ProtoChunkTicks<any>, arg4: Internal.ProtoChunkTicks<any>, arg5: Internal.LevelHeightAccessor, arg6: Internal.Registry<any>, arg7: Internal.BlendingData, arg8: Internal.CallbackInfo): void;
        setBlockNibbles(arg0: any[]): void;
        get skyNibbles(): any[];
        get skyEmptinessMap(): boolean[];
        get blockEmptinessMap(): boolean[];
        get worldForge(): Internal.LevelAccessor;
        get class(): Internal.Class<any>;
        get blockNibbles(): any[];
        set skyNibbles(arg0: any[]);
        set skyEmptinessMap(arg0: boolean[]);
        set blockEmptinessMap(arg0: boolean[]);
        set blockNibbles(arg0: any[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class LunarEventClient <T> implements Internal.SkyRenderable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMoonSize(): number;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getMoonTextureLocation(): ResourceLocation;
        getSoundTrack(): Internal.SoundEvent;
        toString(): string;
        getColorSettings(): Internal.ColorSettings;
        renderSky(arg0: Internal.PoseStack, arg1: number): void;
        notify(): void;
        get moonSize(): number;
        get moonTextureLocation(): ResourceLocation;
        get soundTrack(): Internal.SoundEvent;
        get colorSettings(): Internal.ColorSettings;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Function13 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, (arg0: T13) => R>;
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function4<T10, T11, T12, T13, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function6<T8, T9, T10, T11, T12, T13, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function5<T9, T10, T11, T12, T13, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function8<T6, T7, T8, T9, T10, T11, T12, T13, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function7<T7, T8, T9, T10, T11, T12, T13, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function10<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function3<T11, T12, T13, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function9<T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>;
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, (arg0: T12, arg1: T13) => R>;
        curry2(): (arg0: T1, arg1: T2) => Internal.Function11<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>;
        curry(): (arg0: T1) => Internal.Function12<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>;
    }
    class MobSpawnSettings$MobSpawnCost {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Object2IntFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_;
        put(arg0: K, arg1: number): number;
        put(arg0: K, arg1: number): number;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): any;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        get(arg0: any): number;
        get(arg0: any): any;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: K): number;
        removeInt(arg0: any): number;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        getInt(arg0: any): number;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface IntStream$Builder extends java_.util.function_.IntConsumer {
        add(arg0: number): Internal.IntStream$Builder;
        build(): Internal.IntStream;
        andThen(arg0: java_.util.function_.IntConsumer): java_.util.function_.IntConsumer;
        accept(arg0: number): void;
    }
    interface Long2IntFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.LongToIntFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    abstract class ItemType {
        getClass(): Internal.Class<any>;
        applyDefaults(builder: Internal.ItemBuilder): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        createItem(arg0: Internal.ItemBuilder): Internal.Item;
        generateData(builder: Internal.ItemBuilder, generator: Internal.DataJsonGenerator): void;
        toString(): string;
        generateAssets(builder: Internal.ItemBuilder, generator: Internal.AssetJsonGenerator): void;
        notify(): void;
        readonly name : string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Endimation {
        getClass(): Internal.Class<any>;
        getEffects(): any[];
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPartKeyframes(): (arg0: string) => Internal.Endimation$PartKeyframes;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getBlendWeight(): number;
        static builder(): Internal.Endimation$Builder;
        getLength(): number;
        toString(): string;
        notify(): void;
        static readonly BLANK : Internal.Endimation;
        static readonly CODEC : Internal.Codec<Internal.Endimation>;
        get effects(): any[];
        get blendWeight(): number;
        get length(): number;
        get partKeyframes(): (arg0: string) => Internal.Endimation$PartKeyframes;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Exception extends Internal.Throwable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        printStackTrace(): void;
        printStackTrace(arg0: Internal.PrintStream): void;
        printStackTrace(arg0: Internal.PrintWriter): void;
        getLocalizedMessage(): string;
        notifyAll(): void;
        initCause(arg0: Internal.Throwable): Internal.Throwable;
        getMessage(): string;
        getCause(): Internal.Throwable;
        notify(): void;
        addSuppressed(arg0: Internal.Throwable): void;
        setStackTrace(arg0: Internal.StackTraceElement[]): void;
        getStackTrace(): Internal.StackTraceElement[];
        hashCode(): number;
        equals(arg0: any): boolean;
        getSuppressed(): Internal.Throwable[];
        toString(): string;
        fillInStackTrace(): Internal.Throwable;
        get localizedMessage(): string;
        get cause(): Internal.Throwable;
        get stackTrace(): Internal.StackTraceElement[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        set stackTrace(arg0: Internal.StackTraceElement[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TypeDescriptor$OfField <F> extends Internal.TypeDescriptor {
        componentType(): F;
        arrayType(): F;
        descriptorString(): string;
        isArray(): boolean;
        isPrimitive(): boolean;
    }
    class LevelChunk extends Internal.ChunkAccess implements Internal.ICapabilityProviderImpl<Internal.LevelChunk>, corgitaco.enhancedcelestials.mixin.access.ChunkAccess, Internal.LevelHeightAccessor, Internal.ExtendedChunk {
        getClass(): Internal.Class<any>;
        getWorldForge(): Internal.LevelAccessor;
        getWorldForge(): net.minecraft.world.level.Level;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        notifyAll(): void;
        setBlockEmptinessMap(arg0: boolean[]): void;
        notify(): void;
        readCapsFromNBT(arg0: Internal.CompoundTag): void;
        handler$bml000$onConstruct(arg0: net.minecraft.world.level.Level, arg1: Internal.ChunkPos, arg2: Internal.UpgradeData, arg3: Internal.LevelChunkTicks<any>, arg4: Internal.LevelChunkTicks<any>, arg5: number, arg6: any[], arg7: Internal.LevelChunk$PostLoadProcessor, arg8: Internal.BlendingData, arg9: Internal.CallbackInfo): void;
        invalidateCaps(): void;
        hashCode(): number;
        getSkyEmptinessMap(): boolean[];
        setSkyEmptinessMap(arg0: boolean[]): void;
        getBlockEmptinessMap(): boolean[];
        handler$bml000$onTransitionToFull(arg0: Internal.ServerLevel, arg1: Internal.ProtoChunk, arg2: Internal.LevelChunk$PostLoadProcessor, arg3: Internal.CallbackInfo): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.LevelChunk>): boolean;
        getBlockNibbles(): any[];
        writeCapsToNBT(): Internal.CompoundTag;
        reviveCaps(): void;
        setSkyNibbles(arg0: any[]): void;
        getLevel(): net.minecraft.world.level.Level;
        equals(arg0: any): boolean;
        getSkyNibbles(): any[];
        toString(): string;
        localvar$bna000$modifyHeightmapType(arg0: Internal.Heightmap$Types): Internal.Heightmap$Types;
        setBlockNibbles(arg0: any[]): void;
        get skyNibbles(): any[];
        get level(): net.minecraft.world.level.Level;
        get skyEmptinessMap(): boolean[];
        get blockEmptinessMap(): boolean[];
        get worldForge(): net.minecraft.world.level.Level;
        get class(): Internal.Class<any>;
        get blockNibbles(): any[];
        set skyNibbles(arg0: any[]);
        set skyEmptinessMap(arg0: boolean[]);
        set blockEmptinessMap(arg0: boolean[]);
        set blockNibbles(arg0: any[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface NarratableEntry extends Internal.NarrationSupplier {
    }
    class Products$P1 <F, T1> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: (arg0: T1) => R): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, (arg0: T1) => R>): Internal.App<F, R>;
        hashCode(): number;
        and<T2, T3, T4, T5, T6, T7>(arg0: Internal.Products$P6<F, T2, T3, T4, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        and<T2, T3, T4, T5, T6, T7, T8>(arg0: Internal.Products$P7<F, T2, T3, T4, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        and<T2, T3, T4, T5>(arg0: Internal.Products$P4<F, T2, T3, T4, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>;
        and<T2, T3>(arg0: Internal.Products$P2<F, T2, T3>): Internal.Products$P3<F, T1, T2, T3>;
        and<T2, T3, T4>(arg0: Internal.Products$P3<F, T2, T3, T4>): Internal.Products$P4<F, T1, T2, T3, T4>;
        and<T2>(arg0: Internal.App<F, T2>): Internal.Products$P2<F, T1, T2>;
        and<T2, T3, T4, T5, T6>(arg0: Internal.Products$P5<F, T2, T3, T4, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class CompressorHolder implements Internal.Compressable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        keys<T_>(arg0: Internal.DynamicOps<T_>): Internal.Stream<T_>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        compressor<T_>(arg0: Internal.DynamicOps<T_>): Internal.KeyCompressor<T_>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Color extends Internal.SpecialEquality {
        getRgbKJS(): number;
        createTextColorKJS(): Internal.TextColor;
        getHexKJS(): string;
        getArgbKJS(): number;
        getFireworkColorKJS(): number;
        getSerializeKJS(): string;
        specialEquals(o: any, shallow: boolean): boolean;
    }
    interface GeneratedClassLoader {
        defineClass(arg0: string, arg1: number[]): Internal.Class<any>;
        linkClass(arg0: Internal.Class<any>): void;
    }
    class AABB {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Char2ByteFunction extends it.unimi.dsi.fastutil.Function<string, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: string, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: string) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: string, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: string, arg1: number): number;
        remove(arg0: string): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: string): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: string): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface IForgeFluidState {
        getExplosionResistance(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): number;
        isEntityInside(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity, arg3: number, arg4: Internal.SetTag<Internal.Fluid>, arg5: boolean): boolean;
    }
    interface PrivilegedExceptionAction <T> {
        run(): T;
    }
    abstract class AbstractObjectCollection <K> extends Internal.AbstractCollection<any> implements Internal.ObjectCollection<K> {
        add(arg0: K): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        spliterator(): Internal.ObjectSpliterator<K>;
        spliterator(): Internal.Spliterator<any>;
        forEach(arg0: (arg0: K) => void): void;
        notifyAll(): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        notify(): void;
        remove(arg0: any): boolean;
        removeIf(arg0: (arg0: K) => boolean): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.ObjectIterator<K>;
        iterator(): Internal.Iterator<any>;
        size(): number;
        stream(): Internal.Stream<K>;
        addAll(arg0: Internal.Collection<K>): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<K>;
        toString(): string;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ModelQuadView {
        getNormal(arg0: number): number;
        getTexV(arg0: number): number;
        getLight(arg0: number): number;
        getTexU(arg0: number): number;
        getX(arg0: number): number;
        getColorIndex(): number;
        getY(arg0: number): number;
        getZ(arg0: number): number;
        getColor(arg0: number): number;
        getFlags(): number;
        getSprite(): Internal.TextureAtlasSprite;
    }
    interface SerializableTickContainer <T> {
    }
    class BlockItem extends Internal.Item implements Internal.IPlaceableItem {
        getClass(): Internal.Class<any>;
        canElytraFly(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean;
        setBurnTime(i: number): void;
        getTags(): Internal.Set<ResourceLocation>;
        setDamage(arg0: Internal.ItemStack, arg1: number): void;
        canPerformAction(arg0: Internal.ItemStack, arg1: Internal.ToolAction): boolean;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean;
        getItemEnchantability(arg0: Internal.ItemStack): number;
        damageItem<T_>(arg0: Internal.ItemStack, arg1: number, arg2: T_, arg3: (arg0: T_) => void): number;
        setFireResistantKJS(arg0: boolean): void;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: boolean): boolean;
        setCategory(arg0: Internal.CreativeModeTab): void;
        getXpRepairRatio(arg0: Internal.ItemStack): number;
        readShareTag(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): void;
        onEntityItemUpdate(arg0: Internal.ItemStack, arg1: Internal.ItemEntity): boolean;
        getDamage(arg0: Internal.ItemStack): number;
        setFoodPropertiesKJS(arg0: Internal.FoodProperties): void;
        isBookEnchantable(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean;
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.LivingEntity, arg3: Internal.LivingEntity): boolean;
        getCategory(): Internal.CreativeModeTab;
        onUsingTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        createEntity(arg0: net.minecraft.world.level.Level, arg1: Internal.Entity, arg2: Internal.ItemStack): Internal.Entity;
        callAllowdedIn(arg0: Internal.CreativeModeTab): boolean;
        getSweepHitBox(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): Internal.AABB;
        handler$baf000$overrideStackedOnOther(arg0: Internal.ItemStack, arg1: Internal.Slot, arg2: Internal.ClickAction, arg3: Internal.Player, arg4: Internal.CallbackInfoReturnable<any>): void;
        isRepairable(arg0: Internal.ItemStack): boolean;
        removeFromBlockToItemMap(arg0: Internal.Map<Internal.Block, Internal.Item>, arg1: Internal.Item): void;
        getShareTag(arg0: Internal.ItemStack): Internal.CompoundTag;
        getBurnTime(arg0: Internal.ItemStack, arg1: Internal.RecipeType<any>): number;
        onDroppedByPlayer(arg0: Internal.ItemStack, arg1: Internal.Player): boolean;
        isDamageable(arg0: Internal.ItemStack): boolean;
        onEntitySwing(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean;
        getRegistryType(): Internal.Class<Internal.Item>;
        setItemBuilderKJS(b: Internal.ItemBuilder): void;
        elytraFlightTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean;
        getItemBuilderKJS(): Internal.ItemBuilder;
        getBlockItemOverride(): Internal.BlockItem;
        setMaxStackSizeKJS(arg0: number): void;
        getAttributeModifiers(arg0: EquipmentSlot, arg1: Internal.ItemStack): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        onLeftClickEntity(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): boolean;
        canEquip(arg0: Internal.ItemStack, arg1: EquipmentSlot, arg2: Internal.Entity): boolean;
        notifyAll(): void;
        getId(): string;
        notify(): void;
        onBlockStartBreak(arg0: Internal.ItemStack, arg1: BlockPos, arg2: Internal.Player): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Mob): void;
        canContinueUsing(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean;
        getEntityLifespan(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level): number;
        getRenderPropertiesInternal(): any;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack): number;
        getArmorTexture(arg0: Internal.ItemStack, arg1: Internal.Entity, arg2: EquipmentSlot, arg3: string): string;
        hashCode(): number;
        hasCustomEntity(arg0: Internal.ItemStack): boolean;
        setCraftingRemainderKJS(arg0: Internal.Item): void;
        setMaxDamageKJS(arg0: number): void;
        getHighlightTip(arg0: Internal.ItemStack, arg1: Internal.Component): Internal.Component;
        initializeClient(arg0: (arg0: Internal.IItemRenderProperties) => void): void;
        getMaxDamage(arg0: Internal.ItemStack): number;
        getCreatorModId(arg0: Internal.ItemStack): string;
        setRarityKJS(arg0: Internal.Rarity): void;
        isDamaged(arg0: Internal.ItemStack): boolean;
        onArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Player): void;
        addPlaceable(arg0: Internal.Block): void;
        hasContainerItem(arg0: Internal.ItemStack): boolean;
        doesSneakBypassUse(arg0: Internal.ItemStack, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Player): boolean;
        onItemUseFirst(arg0: Internal.ItemStack, arg1: Internal.UseOnContext): Internal.InteractionResult;
        getContainerItem(arg0: Internal.ItemStack): Internal.ItemStack;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: string, arg1: string): Internal.Item;
        setRegistryName(arg0: ResourceLocation): any;
        setRegistryName(arg0: ResourceLocation): Internal.Item;
        setRegistryName(arg0: string): Internal.Item;
        onDestroyed(arg0: Internal.ItemEntity, arg1: Internal.DamageSource): void;
        isCorrectToolForDrops(arg0: Internal.ItemStack, arg1: Internal.BlockState): boolean;
        getEquipmentSlot(arg0: Internal.ItemStack): EquipmentSlot;
        handler$zjo000$getUseDuration(arg0: Internal.ItemStack, arg1: Internal.CallbackInfoReturnable<any>): void;
        initCapabilities(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): Internal.ICapabilityProvider;
        getItemStackLimit(arg0: Internal.ItemStack): number;
        equals(arg0: any): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean;
        handler$baf000$overrideOtherStackedOnMe(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.Slot, arg3: Internal.ClickAction, arg4: Internal.Player, arg5: Internal.SlotAccess, arg6: Internal.CallbackInfoReturnable<any>): void;
        toString(): string;
        isEnderMask(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.EnderMan): boolean;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean;
        readonly delegate : () => Internal.Item;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get category(): Internal.CreativeModeTab;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        get blockItemOverride(): Internal.BlockItem;
        set rarityKJS(arg0: Internal.Rarity);
        set maxStackSizeKJS(arg0: number);
        set itemBuilderKJS(b: Internal.ItemBuilder);
        set foodPropertiesKJS(arg0: Internal.FoodProperties);
        set burnTime(i: number);
        set fireResistantKJS(arg0: boolean);
        set registryName(arg0: ResourceLocation);
        set category(arg0: Internal.CreativeModeTab);
        set craftingRemainderKJS(arg0: Internal.Item);
        set maxDamageKJS(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MaterialJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getMinecraftMaterial(): net.minecraft.world.level.material.Material;
        toString(): string;
        getId(): string;
        notify(): void;
        getSound(): Internal.SoundType;
        get minecraftMaterial(): net.minecraft.world.level.material.Material;
        get sound(): Internal.SoundType;
        get id(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FluidInvokerMixin {
        callAnimateTick(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.FluidState, arg3: Internal.Random): void;
    }
    class ServerPlayerJS extends Internal.PlayerJS<any> {
        getXpLevel(): number;
        getLastAttackedEntity(): Internal.LivingEntityJS;
        setY(y: number): void;
        setX(x: number): void;
        isOnScoreboardTeam(teamID: string): boolean;
        isLiving(): boolean;
        isSprinting(): boolean;
        getItem(): Internal.ItemStackJS;
        paint(renderer: Internal.CompoundTag): void;
        getOffHandItem(): Internal.ItemStackJS;
        setGlowing(glowing: boolean): void;
        setZ(z: number): void;
        setXpLevel(l: number): void;
        getHasCustomName(): boolean;
        ban(banner: string, reason: string, expiresInMillis: number): void;
        runCommandSilent(command: string): number;
        setSelectedSlot(index: number): void;
        getDistanceSq(x: number, y: number, z: number): number;
        getDistanceSq(pos: BlockPos): number;
        isBoss(): boolean;
        isGlowing(): boolean;
        getHorizontalFacing(): Internal.Direction;
        setLegsArmorItem(item: Internal.ItemStackJS): void;
        isAdvancementDone(id: ResourceLocation): boolean;
        setMotion(x: number, y: number, z: number): void;
        getProfile(): Internal.GameProfile;
        setRotation(yaw: number, pitch: number): void;
        setGameMode(mode: string): void;
        isMiningBlock(): boolean;
        setAbsorptionAmount(amount: number): void;
        isOnSameTeam(e: Internal.EntityJS): boolean;
        isAnimal(): boolean;
        getType(): string;
        setCustomNameAlwaysVisible(b: boolean): void;
        addMotion(x: number, y: number, z: number): void;
        isFake(): boolean;
        setCreativeMode(mode: boolean): void;
        getFallDistance(): number;
        damageHeldItem(hand: Hand, amount: number): void;
        damageHeldItem(hand: Hand, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void;
        damageHeldItem(): void;
        setOnFire(seconds: number): void;
        attack(hp: number): void;
        attack(source: string, hp: number): void;
        isUndead(): boolean;
        getInventory(): Internal.InventoryJS;
        getDistance(x: number, y: number, z: number): number;
        getDistance(pos: BlockPos): number;
        getReachDistance(): number;
        getCustomName(): Internal.Text;
        getStepHeight(): number;
        getRidingEntity(): Internal.EntityJS;
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void;
        kick(): void;
        kick(reason: Internal.Component): void;
        getLastAttackedEntityTime(): number;
        isMonster(): boolean;
        addItemCooldown(item: Internal.Item, ticks: number): void;
        setPitch(pitch: number): void;
        isOnGround(): boolean;
        getFacing(): Internal.Direction;
        toString(): string;
        isSilent(): boolean;
        setXp(xp: number): void;
        getMaxAirSupply(): number;
        getName(): Internal.Text;
        getFeetArmorItem(): Internal.ItemStackJS;
        getHasClientMod(): boolean;
        setStepHeight(stepHeight: number): void;
        isWaterCreature(): boolean;
        setPosition(x: number, y: number, z: number): void;
        setPosition(block: Internal.BlockContainerJS): void;
        closeInventory(): void;
        extinguish(): void;
        setInvulnerable(invulnerable: boolean): void;
        isOp(): boolean;
        setMovementSpeed(speed: number): void;
        isChild(): boolean;
        setEquipment(slot: EquipmentSlot, item: Internal.ItemStackJS): void;
        giveInHand(item: Internal.ItemStackJS): void;
        getLegsArmorItem(): Internal.ItemStackJS;
        isCreativeMode(): boolean;
        getFullNBT(): Internal.CompoundTag;
        getNoClip(): boolean;
        setYaw(yaw: number): void;
        getYaw(): number;
        setNoGravity(noGravity: boolean): void;
        setHeldItem(hand: Hand, item: Internal.ItemStackJS): void;
        getRevengeTimer(): number;
        notifyAll(): void;
        unlockAdvancement(id: ResourceLocation): void;
        getId(): Internal.UUID;
        addXPLevels(l: number): void;
        getOpenInventory(): Internal.AbstractContainerMenu;
        hashCode(): number;
        getChestArmorItem(): Internal.ItemStackJS;
        isFrame(): boolean;
        startRiding(e: Internal.EntityJS, force: boolean): boolean;
        runCommand(command: string): number;
        setChestArmorItem(item: Internal.ItemStackJS): void;
        getCustomNameAlwaysVisible(): boolean;
        addXP(xp: number): void;
        getMainHandItem(): Internal.ItemStackJS;
        setHealth(hp: number): void;
        getBlock(): Internal.BlockContainerJS;
        isElytraFlying(): boolean;
        isInWater(): boolean;
        dismountRidingEntity(): void;
        isSleeping(): boolean;
        swingArm(hand: Hand): void;
        getPotionEffects(): Internal.EntityPotionEffectsJS;
        isInvulnerable(): boolean;
        revokeAdvancement(id: ResourceLocation): void;
        setHeadArmorItem(item: Internal.ItemStackJS): void;
        isPeacefulCreature(): boolean;
        getMouseItem(): Internal.ItemStackJS;
        getMotionZ(): number;
        getMotionX(): number;
        getMotionY(): number;
        sendData(channel: string, data: Internal.CompoundTag): void;
        getRevengeTarget(): Internal.LivingEntityJS;
        getTags(): Internal.Set<string>;
        setInvisible(invisible: boolean): void;
        getIdleTime(): number;
        getMovementSpeed(): number;
        addFood(f: number, m: number): void;
        getHealth(): number;
        getServer(): Internal.ServerJS;
        setFeetArmorItem(item: Internal.ItemStackJS): void;
        give(item: Internal.ItemStackJS): void;
        setMaxHealth(hp: number): void;
        setSpawnLocation(c: Internal.BlockContainerJS): void;
        isSpectator(): boolean;
        getDisplayName(): Internal.Text;
        getXp(): number;
        addExhaustion(exhaustion: number): void;
        setOffHandItem(item: Internal.ItemStackJS): void;
        getFoodLevel(): number;
        isInvisible(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMaxHealth(): number;
        isUnderWater(): boolean;
        getHeldItem(hand: Hand): Internal.ItemStackJS;
        getEyeHeight(): number;
        getEquipment(slot: EquipmentSlot): Internal.ItemStackJS;
        notify(): void;
        setAirSupply(air: number): void;
        removePassengers(): void;
        isOnLadder(): boolean;
        playSound(id: Internal.SoundEvent): void;
        playSound(id: Internal.SoundEvent, volume: number, pitch: number): void;
        boostElytraFlight(): void;
        getData(): Internal.AttachedData;
        getLastDamageSource(): Internal.DamageSourceJS;
        setStatusMessage(message: Internal.Component): void;
        isSwimming(): boolean;
        mergeFullNBT(tag: Internal.CompoundTag): Internal.EntityJS;
        kill(): void;
        getLevel(): Internal.LevelJS;
        getPitch(): number;
        getPassengers(): Internal.EntityArrayList;
        equals(arg0: any): boolean;
        isPassenger(e: Internal.EntityJS): boolean;
        getClass(): Internal.Class<any>;
        getNbt(): Internal.CompoundTag;
        getRecursivePassengers(): Internal.EntityArrayList;
        setFallDistance(fallDistance: number): void;
        sendInventoryUpdate(): void;
        setCustomName(name: Internal.Component): void;
        setMainHandItem(item: Internal.ItemStackJS): void;
        tell(message: Internal.Component): void;
        getTeamId(): string;
        setNoClip(noClip: boolean): void;
        setRevengeTarget(target: Internal.LivingEntityJS): void;
        getAirSupply(): number;
        setFullNBT(nbt: Internal.CompoundTag): void;
        getAttackingEntity(): Internal.LivingEntityJS;
        isHoldingInAnyHand(ingredient: any): boolean;
        damageEquipment(slot: EquipmentSlot, amount: number): void;
        damageEquipment(slot: EquipmentSlot): void;
        damageEquipment(slot: EquipmentSlot, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void;
        isAlive(): boolean;
        getHeadArmorItem(): Internal.ItemStackJS;
        setMouseItem(item: Internal.ItemStackJS): void;
        isPlayer(): boolean;
        getStats(): Internal.PlayerStatsJS;
        getAbsorptionAmount(): number;
        isCrouching(): boolean;
        getSpawnLocation(): Internal.BlockContainerJS;
        getTicksExisted(): number;
        getStages(): Internal.Stages;
        setSilent(isSilent: boolean): void;
        heal(hp: number): void;
        setMotionZ(z: number): void;
        setMotionY(y: number): void;
        setMotionX(x: number): void;
        isAmbientCreature(): boolean;
        rayTrace(): Internal.RayTraceResultJS;
        rayTrace(distance: number): Internal.RayTraceResultJS;
        getSelectedSlot(): number;
        canEntityBeSeen(entity: Internal.LivingEntityJS): boolean;
        getX(): number;
        getY(): number;
        spawn(): void;
        getZ(): number;
        setFoodLevel(foodLevel: number): void;
        getNoGravity(): boolean;
        readonly server : Internal.ServerJS;
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftPlayer : Internal.ServerPlayer;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        get xpLevel(): number;
        get invisible(): boolean;
        get creativeMode(): boolean;
        get customNameAlwaysVisible(): boolean;
        get type(): string;
        get movementSpeed(): number;
        get stats(): Internal.PlayerStatsJS;
        get revengeTarget(): Internal.LivingEntityJS;
        get hasCustomName(): boolean;
        get block(): Internal.BlockContainerJS;
        get maxHealth(): number;
        get id(): Internal.UUID;
        get pitch(): number;
        get item(): Internal.ItemStackJS;
        get passengers(): Internal.EntityArrayList;
        get profile(): Internal.GameProfile;
        get onLadder(): boolean;
        get offHandItem(): Internal.ItemStackJS;
        get customName(): Internal.Text;
        get lastAttackedEntityTime(): number;
        get tags(): Internal.Set<string>;
        get crouching(): boolean;
        get animal(): boolean;
        get lastDamageSource(): Internal.DamageSourceJS;
        get stepHeight(): number;
        get noClip(): boolean;
        get nbt(): Internal.CompoundTag;
        get boss(): boolean;
        get alive(): boolean;
        get revengeTimer(): number;
        get displayName(): Internal.Text;
        get mainHandItem(): Internal.ItemStackJS;
        get facing(): Internal.Direction;
        get ambientCreature(): boolean;
        get swimming(): boolean;
        get selectedSlot(): number;
        get eyeHeight(): number;
        get underWater(): boolean;
        get openInventory(): Internal.AbstractContainerMenu;
        get motionZ(): number;
        get silent(): boolean;
        get motionY(): number;
        get motionX(): number;
        get health(): number;
        get chestArmorItem(): Internal.ItemStackJS;
        get yaw(): number;
        get monster(): boolean;
        get glowing(): boolean;
        get onGround(): boolean;
        get spectator(): boolean;
        get x(): number;
        get hasClientMod(): boolean;
        get y(): number;
        get fake(): boolean;
        get z(): number;
        get foodLevel(): number;
        get data(): Internal.AttachedData;
        get idleTime(): number;
        get legsArmorItem(): Internal.ItemStackJS;
        get maxAirSupply(): number;
        get undead(): boolean;
        get lastAttackedEntity(): Internal.LivingEntityJS;
        get potionEffects(): Internal.EntityPotionEffectsJS;
        get spawnLocation(): Internal.BlockContainerJS;
        get level(): Internal.LevelJS;
        get feetArmorItem(): Internal.ItemStackJS;
        get horizontalFacing(): Internal.Direction;
        get sprinting(): boolean;
        get mouseItem(): Internal.ItemStackJS;
        get noGravity(): boolean;
        get fullNBT(): Internal.CompoundTag;
        get name(): Internal.Text;
        get peacefulCreature(): boolean;
        get child(): boolean;
        get frame(): boolean;
        get ticksExisted(): number;
        get fallDistance(): number;
        get elytraFlying(): boolean;
        get inventory(): Internal.InventoryJS;
        get sleeping(): boolean;
        get airSupply(): number;
        get waterCreature(): boolean;
        get invulnerable(): boolean;
        get miningBlock(): boolean;
        get headArmorItem(): Internal.ItemStackJS;
        get class(): Internal.Class<any>;
        get reachDistance(): number;
        get player(): boolean;
        get op(): boolean;
        get absorptionAmount(): number;
        get living(): boolean;
        get ridingEntity(): Internal.EntityJS;
        get inWater(): boolean;
        get recursivePassengers(): Internal.EntityArrayList;
        get attackingEntity(): Internal.LivingEntityJS;
        get teamId(): string;
        get xp(): number;
        get stages(): Internal.Stages;
        set noClip(noClip: boolean);
        set xpLevel(l: number);
        set fallDistance(fallDistance: number);
        set mainHandItem(item: Internal.ItemStackJS);
        set invisible(invisible: boolean);
        set creativeMode(mode: boolean);
        set customNameAlwaysVisible(b: boolean);
        set movementSpeed(speed: number);
        set airSupply(air: number);
        set invulnerable(invulnerable: boolean);
        set legsArmorItem(item: Internal.ItemStackJS);
        set selectedSlot(index: number);
        set revengeTarget(target: Internal.LivingEntityJS);
        set maxHealth(hp: number);
        set headArmorItem(item: Internal.ItemStackJS);
        set pitch(pitch: number);
        set motionZ(z: number);
        set spawnLocation(c: Internal.BlockContainerJS);
        set absorptionAmount(amount: number);
        set silent(isSilent: boolean);
        set motionY(y: number);
        set motionX(x: number);
        set feetArmorItem(item: Internal.ItemStackJS);
        set health(hp: number);
        set offHandItem(item: Internal.ItemStackJS);
        set chestArmorItem(item: Internal.ItemStackJS);
        set onFire(seconds: number);
        set statusMessage(message: Internal.Component);
        set yaw(yaw: number);
        set glowing(glowing: boolean);
        set mouseItem(item: Internal.ItemStackJS);
        set noGravity(noGravity: boolean);
        set fullNBT(nbt: Internal.CompoundTag);
        set xp(xp: number);
        set x(x: number);
        set y(y: number);
        set z(z: number);
        set foodLevel(foodLevel: number);
        set position(block: Internal.BlockContainerJS);
        set gameMode(mode: string);
        set stepHeight(stepHeight: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FunctionContainer {
        lootingEnchant(count: Internal.NumberProvider, limit: number): Internal.FunctionContainer;
        enchantWithLevels(levels: Internal.NumberProvider, treasure: boolean): Internal.FunctionContainer;
        damage(damage: Internal.NumberProvider): Internal.FunctionContainer;
        nbt(tag: Internal.CompoundTag): Internal.FunctionContainer;
        lootTable(table: ResourceLocation, seed: number): Internal.FunctionContainer;
        copyName(source: Internal.CopyNameFunction$NameSource): Internal.FunctionContainer;
        addFunction(arg0: Internal.JsonObject): Internal.FunctionContainer;
        count(count: Internal.NumberProvider): Internal.FunctionContainer;
        name(name: Internal.Text, entity: Internal.LootContext$EntityTarget): Internal.FunctionContainer;
        name(name: Internal.Text): Internal.FunctionContainer;
        furnaceSmelt(): Internal.FunctionContainer;
        addConditionalFunction(func: (arg0: Internal.ConditionalFunction) => void): Internal.FunctionContainer;
        enchantRandomly(enchantments: ResourceLocation[]): Internal.FunctionContainer;
    }
    abstract class OutputStream implements Internal.Closeable, Internal.Flushable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        flush(): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        static nullOutputStream(): Internal.OutputStream;
        close(): void;
        write(arg0: number[]): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        write(arg0: number): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ServerWorldAccessor {
        getEntityManager(): Internal.PersistentEntitySectionManager<Internal.Entity>;
    }
    class ModuleLayer {
        getClass(): Internal.Class<any>;
        static defineModulesWithManyLoaders(arg0: Internal.Configuration, arg1: Internal.List<Internal.ModuleLayer>, arg2: Internal.ClassLoader): Internal.ModuleLayer$Controller;
        defineModulesWithManyLoaders(arg0: Internal.Configuration, arg1: Internal.ClassLoader): Internal.ModuleLayer;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        configuration(): Internal.Configuration;
        notifyAll(): void;
        static defineModulesWithOneLoader(arg0: Internal.Configuration, arg1: Internal.List<Internal.ModuleLayer>, arg2: Internal.ClassLoader): Internal.ModuleLayer$Controller;
        defineModulesWithOneLoader(arg0: Internal.Configuration, arg1: Internal.ClassLoader): Internal.ModuleLayer;
        notify(): void;
        modules(): Internal.Set<Internal.Module>;
        defineModules(arg0: Internal.Configuration, arg1: (arg0: string) => Internal.ClassLoader): Internal.ModuleLayer;
        static defineModules(arg0: Internal.Configuration, arg1: Internal.List<Internal.ModuleLayer>, arg2: (arg0: string) => Internal.ClassLoader): Internal.ModuleLayer$Controller;
        static empty(): Internal.ModuleLayer;
        findModule(arg0: string): Internal.Optional<Internal.Module>;
        findLoader(arg0: string): Internal.ClassLoader;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        static boot(): Internal.ModuleLayer;
        parents(): Internal.List<Internal.ModuleLayer>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ScriptSource {
        createStream(arg0: Internal.ScriptFileInfo): Internal.InputStream;
    }
    abstract class MinecraftServer extends Internal.ReentrantBlockableEventLoop<any> implements Internal.CommandSource, Internal.AutoCloseable, Internal.MinecraftServerAccessor, Internal.MinecraftServerKJS, Internal.MinecraftServerAccessorMixin {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getServerResourcesKJS(): Internal.ServerResources;
        forgeGetWorldMap(): Internal.Map<Internal.ResourceKey<net.minecraft.world.level.Level>, Internal.ServerLevel>;
        notifyAll(): void;
        getTickables(): Internal.List<any>;
        getTickTime(arg0: Internal.ResourceKey<net.minecraft.world.level.Level>): number[];
        execute(arg0: Internal.Runnable): void;
        asKJS(): any;
        notify(): void;
        handler$zbj000$reloadResources(arg0: Internal.Collection<any>, arg1: Internal.CallbackInfoReturnable<any>): void;
        getResources(): Internal.ServerResources;
        hashCode(): number;
        equals(arg0: any): boolean;
        markWorldsDirty(): void;
        getServerResources(): Internal.ServerResources;
        toString(): string;
        close(): void;
        get serverResources(): Internal.ServerResources;
        get resources(): Internal.ServerResources;
        get serverResourcesKJS(): Internal.ServerResources;
        get class(): Internal.Class<any>;
        get tickables(): Internal.List<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ChunkRandomSource {
        getRandomPosInChunk(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.BlockPos$MutableBlockPos): void;
    }
    interface Collector <T, A, R> {
        characteristics(): Internal.Set<Internal.Collector$Characteristics>;
        supplier(): () => A;
        finisher(): (arg0: A) => R;
        accumulator(): (arg0: A, arg1: T) => void;
        combiner(): (arg0: any, arg1: any) => any;
    }
    interface FeatureAccess {
    }
    interface ChannelHandlerContext extends Internal.AttributeMap, Internal.ChannelInboundInvoker, Internal.ChannelOutboundInvoker {
        disconnect(): Internal.ChannelFuture;
        disconnect(arg0: Internal.ChannelPromise): Internal.ChannelFuture;
        handler(): Internal.ChannelHandler;
        newProgressivePromise(): Internal.ChannelProgressivePromise;
        fireChannelWritabilityChanged(): Internal.ChannelHandlerContext;
        fireChannelWritabilityChanged(): Internal.ChannelInboundInvoker;
        channel(): io.netty.channel.Channel;
        fireExceptionCaught(arg0: Internal.Throwable): Internal.ChannelHandlerContext;
        fireExceptionCaught(arg0: Internal.Throwable): Internal.ChannelInboundInvoker;
        fireChannelActive(): Internal.ChannelHandlerContext;
        fireChannelActive(): Internal.ChannelInboundInvoker;
        writeAndFlush(arg0: any): Internal.ChannelFuture;
        writeAndFlush(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        isRemoved(): boolean;
        flush(): Internal.ChannelHandlerContext;
        flush(): Internal.ChannelOutboundInvoker;
        executor(): Internal.EventExecutor;
        attr<T_>(arg0: Internal.AttributeKey<T_>): io.netty.util.Attribute<T_>;
        close(arg0: Internal.ChannelPromise): Internal.ChannelFuture;
        close(): Internal.ChannelFuture;
        write(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        write(arg0: any): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress, arg2: Internal.ChannelPromise): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        newPromise(): Internal.ChannelPromise;
        fireChannelInactive(): Internal.ChannelHandlerContext;
        fireChannelInactive(): Internal.ChannelInboundInvoker;
        read(): Internal.ChannelHandlerContext;
        read(): Internal.ChannelOutboundInvoker;
        fireChannelReadComplete(): Internal.ChannelHandlerContext;
        fireChannelReadComplete(): Internal.ChannelInboundInvoker;
        deregister(): Internal.ChannelFuture;
        deregister(arg0: Internal.ChannelPromise): Internal.ChannelFuture;
        newFailedFuture(arg0: Internal.Throwable): Internal.ChannelFuture;
        hasAttr<T_>(arg0: Internal.AttributeKey<T_>): boolean;
        fireChannelRegistered(): Internal.ChannelHandlerContext;
        fireChannelRegistered(): Internal.ChannelInboundInvoker;
        pipeline(): Internal.ChannelPipeline;
        fireChannelRead(arg0: any): Internal.ChannelHandlerContext;
        fireChannelRead(arg0: any): Internal.ChannelInboundInvoker;
        newSucceededFuture(): Internal.ChannelFuture;
        voidPromise(): Internal.ChannelPromise;
        name(): string;
        fireUserEventTriggered(arg0: any): Internal.ChannelHandlerContext;
        fireUserEventTriggered(arg0: any): Internal.ChannelInboundInvoker;
        alloc(): Internal.ByteBufAllocator;
        fireChannelUnregistered(): Internal.ChannelHandlerContext;
        fireChannelUnregistered(): Internal.ChannelInboundInvoker;
    }
    interface WeightedEntry {
    }
    class HashMap <K, V> extends Internal.AbstractMap<any, any> implements Internal.Map<K, V>, Internal.Cloneable, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: V): V;
        notifyAll(): void;
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V;
        values(): Internal.Collection<V>;
        replace(arg0: K, arg1: V): V;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replaceAll(arg0: (arg0: K, arg1: V) => V): void;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        remove(arg0: any, arg1: any): boolean;
        remove(arg0: any): V;
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        hashCode(): number;
        putAll(arg0: Internal.Map<K, V>): void;
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V;
        get(arg0: any): V;
        keySet(): Internal.Set<K>;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        containsKey(arg0: any): boolean;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        isEmpty(): boolean;
        clear(): void;
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        size(): number;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        putIfAbsent(arg0: K, arg1: V): V;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeCommandSourceStack {
        getAdvancement(arg0: ResourceLocation): Internal.Advancement;
        getRecipeManager(): Internal.RecipeManager;
        getUnsidedLevel(): net.minecraft.world.level.Level;
        getScoreboard(): Internal.Scoreboard;
    }
    interface Consumer <T> {
        andThen(arg0: (arg0: T) => void): (arg0: T) => void;
        accept(arg0: T): void;
    }
    interface VertexList {
        getLight(arg0: number): number;
        getG(arg0: number): number;
        isEmpty(): boolean;
        getR(arg0: number): number;
        getVertexCount(): number;
        getU(arg0: number): number;
        getV(arg0: number): number;
        getX(arg0: number): number;
        getY(arg0: number): number;
        getZ(arg0: number): number;
        getNZ(arg0: number): number;
        getNY(arg0: number): number;
        getNX(arg0: number): number;
        getA(arg0: number): number;
        getB(arg0: number): number;
    }
    class Thread$State extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Thread$State;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Thread$State[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Thread$State): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Thread$State>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Thread$State>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly NEW : Internal.Thread$State;
        static readonly TERMINATED : Internal.Thread$State;
        static readonly RUNNABLE : Internal.Thread$State;
        static readonly BLOCKED : Internal.Thread$State;
        static readonly WAITING : Internal.Thread$State;
        static readonly TIMED_WAITING : Internal.Thread$State;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Thread$State>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Float2FloatFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface ITeleporter {
        getPortalInfo(arg0: Internal.Entity, arg1: Internal.ServerLevel, arg2: (arg0: Internal.ServerLevel) => Internal.PortalInfo): Internal.PortalInfo;
        isVanilla(): boolean;
        playTeleportSound(arg0: Internal.ServerPlayer, arg1: Internal.ServerLevel, arg2: Internal.ServerLevel): boolean;
        placeEntity(arg0: Internal.Entity, arg1: Internal.ServerLevel, arg2: Internal.ServerLevel, arg3: number, arg4: (arg0: boolean) => Internal.Entity): Internal.Entity;
    }
    interface Byte2IntFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class ModuleDescriptor$Requires implements Internal.Comparable<Internal.ModuleDescriptor$Requires> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        compiledVersion(): Internal.Optional<Internal.ModuleDescriptor$Version>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        rawCompiledVersion(): Internal.Optional<string>;
        name(): string;
        toString(): string;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ModuleDescriptor$Requires): number;
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Requires$Modifier>;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface NearbyEntityListenerProvider {
        getListener(): Internal.NearbyEntityListenerMulti;
        addListener(arg0: Internal.NearbyEntityListener): void;
    }
    interface BlockKJS {
        getBlockStatesKJS(): Internal.List<Internal.BlockState>;
        setSoundTypeKJS(arg0: Internal.SoundType): void;
        getBlockBuilderKJS(): Internal.BlockBuilder;
        setExplosionResistanceKJS(arg0: number): void;
        setJumpFactorKJS(arg0: number): void;
        setSpeedFactorKJS(arg0: number): void;
        setBlockBuilderKJS(arg0: Internal.BlockBuilder): void;
        setFrictionKJS(arg0: number): void;
        setIsRandomlyTickingKJS(arg0: boolean): void;
        setHasCollisionKJS(arg0: boolean): void;
        setMaterialKJS(arg0: net.minecraft.world.level.material.Material): void;
    }
    interface Reference2IntFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_;
        put(arg0: K, arg1: number): number;
        put(arg0: K, arg1: number): number;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): any;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        get(arg0: any): number;
        get(arg0: any): any;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: K): number;
        removeInt(arg0: any): number;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        getInt(arg0: any): number;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    abstract class PlayerDataJS <E, P> implements Internal.WithAttachedData {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): P;
        getName(): string;
        notifyAll(): void;
        getProfile(): Internal.GameProfile;
        getId(): Internal.UUID;
        getOverworld(): Internal.LevelJS;
        notify(): void;
        getMinecraftPlayer(): E;
        hashCode(): number;
        equals(arg0: any): boolean;
        hasClientMod(): boolean;
        toString(): string;
        getData(): Internal.AttachedData;
        get data(): Internal.AttachedData;
        get minecraftPlayer(): E;
        get profile(): Internal.GameProfile;
        get name(): string;
        get id(): Internal.UUID;
        get overworld(): Internal.LevelJS;
        get class(): Internal.Class<any>;
        get player(): P;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Locale$FilteringMode extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Locale$FilteringMode;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Locale$FilteringMode[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Locale$FilteringMode): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Locale$FilteringMode>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Locale$FilteringMode>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly IGNORE_EXTENDED_RANGES : Internal.Locale$FilteringMode;
        static readonly MAP_EXTENDED_RANGES : Internal.Locale$FilteringMode;
        static readonly AUTOSELECT_FILTERING : Internal.Locale$FilteringMode;
        static readonly REJECT_EXTENDED_RANGES : Internal.Locale$FilteringMode;
        static readonly EXTENDED_FILTERING : Internal.Locale$FilteringMode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Locale$FilteringMode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Position {
    }
    abstract class SimpleJsonResourceReloadListener extends Internal.SimplePreparableReloadListener<any> implements Internal.JsonReloadListenerAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        getGson(): Internal.Gson;
        get gson(): Internal.Gson;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class NetworkEvent$Context {
        getClass(): Internal.Class<any>;
        getNetworkManager(): Internal.Connection;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getDirection(): Internal.NetworkDirection;
        enqueueWork(arg0: Internal.Runnable): Internal.CompletableFuture<void>;
        notifyAll(): void;
        notify(): void;
        getPacketHandled(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        setPacketHandled(arg0: boolean): void;
        getSender(): Internal.ServerPlayer;
        attr<T>(arg0: Internal.AttributeKey<T>): io.netty.util.Attribute<T>;
        getPacketDispatcher(): Internal.NetworkEvent$PacketDispatcher;
        get networkManager(): Internal.Connection;
        get packetHandled(): boolean;
        get sender(): Internal.ServerPlayer;
        get class(): Internal.Class<any>;
        get direction(): Internal.NetworkDirection;
        get packetDispatcher(): Internal.NetworkEvent$PacketDispatcher;
        set packetHandled(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class UnmodifiableListIterator <E> extends Internal.UnmodifiableIterator<any> implements Internal.ListIterator<E> {
        next(): E;
        add(arg0: E): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        set(arg0: E): void;
        previous(): E;
        notifyAll(): void;
        hasNext(): boolean;
        nextIndex(): number;
        notify(): void;
        remove(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        hasPrevious(): boolean;
        toString(): string;
        forEachRemaining(arg0: (arg0: E) => void): void;
        previousIndex(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Projectile extends Internal.Entity {
        getClass(): Internal.Class<any>;
        backpackedMoved(): boolean;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>;
        handler$zje000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void;
        onEndimationEnd(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        canBeRiddenInWater(arg0: Internal.Entity): boolean;
        handler$zzo000$tickHead(arg0: Internal.CallbackInfo): void;
        isEndimationPlaying(arg0: Internal.PlayableEndimation): boolean;
        isActive(): boolean;
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity;
        getCachedFeetBlockState(): Internal.BlockState;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        handler$bfj000$tryShortcutFluidPushing(tag: net.minecraft.tags.Tag<any>, speed: number, cir: Internal.CallbackInfoReturnable<any>, box: Internal.AABB, x1: number, x2: number, y1: number, y2: number, z1: number, z2: number, zero: number): void;
        getPos(): Internal.Position;
        revive(): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(arg0: boolean): void;
        canUpdate(): boolean;
        getEndimatedState(): Internal.Endimatable$EndimatedState;
        resetEndimation(): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean;
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number;
        reviveCaps(): void;
        lithiumOnBlockCacheDeleted(): void;
        canRiderInteract(): boolean;
        getEntries(arg0: boolean): Internal.Set<any>;
        getEffectHandler(): Internal.EndimationEffectHandler;
        onAddedToWorld(): void;
        setAnimationTick(arg0: number): void;
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean;
        getListener(): Internal.NearbyEntityListenerMulti;
        getClassification(arg0: boolean): Internal.MobCategory;
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listening: boolean): void;
        isNoEndimationPlaying(): boolean;
        onEndimationStart(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        shouldRiderSit(): boolean;
        getIsInsidePortal(): boolean;
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$zje000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        handler$zcg000$read(arg0: Internal.CompoundTag, arg1: Internal.CallbackInfo): void;
        getRemainingFireTicks(): number;
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void;
        notify(): void;
        getDataMap(): Internal.Map<any, any>;
        handler$zzo000$moveStep(arg0: Internal.MoverType, arg1: Vec3, arg2: Internal.CallbackInfo): void;
        getEntityChangeListener(): Internal.EntityInLevelCallback;
        endimateTick(): void;
        setDataMap(arg0: Internal.Map<any, any>): void;
        isDirty(): boolean;
        hashCode(): number;
        isAddedToWorld(): boolean;
        getParts(): any[];
        addListener(listener: Internal.NearbyEntityListener): void;
        onRemovedFromWorld(): void;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        clean(): void;
        asKJS(): any;
        getPlayingEndimation(): Internal.PlayableEndimation;
        getDirtyEntries(): Internal.Set<any>;
        getValue(arg0: Internal.TrackedData<any>): any;
        setPlayingEndimation(arg0: Internal.PlayableEndimation): void;
        setValue(arg0: Internal.TrackedData<any>, arg1: any): void;
        equals(arg0: any): boolean;
        getAnimationTick(): number;
        toString(): string;
        setRemainingFireTicks(arg0: number): void;
        handler$zgd001$tick(arg0: Internal.CallbackInfo): void;
        get dirty(): boolean;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get entityChangeListener(): Internal.EntityInLevelCallback;
        get listener(): Internal.NearbyEntityListenerMulti;
        get multipartEntity(): boolean;
        get active(): boolean;
        get addedToWorld(): boolean;
        get playingEndimation(): Internal.PlayableEndimation;
        get effectHandler(): Internal.EndimationEffectHandler;
        get cachedFeetBlockState(): Internal.BlockState;
        get dirtyEntries(): Internal.Set<any>;
        get animationTick(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get pos(): Internal.Position;
        get dataMap(): Internal.Map<any, any>;
        get noEndimationPlaying(): boolean;
        get parts(): any[];
        get endimatedState(): Internal.Endimatable$EndimatedState;
        get class(): Internal.Class<any>;
        set animationTick(arg0: number);
        set remainingFireTicks(arg0: number);
        set dataMap(arg0: Internal.Map<any, any>);
        set playingEndimation(arg0: Internal.PlayableEndimation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Enum <E> implements Internal.Constable, Internal.Comparable<E>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        getDeclaringClass(): Internal.Class<E>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        compareTo(arg0: any): number;
        compareTo(arg0: E): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<E>>;
        notify(): void;
        ordinal(): number;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<E>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Destroyable {
        isDestroyed(): boolean;
        destroy(): void;
    }
    class RandomTickCallbackJS {
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        getLevel(): Internal.LevelJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        random : Internal.Random;
        block : Internal.BlockContainerJS;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Temporal extends Internal.TemporalAccessor {
        getLong(arg0: Internal.TemporalField): number;
        minus(arg0: Internal.TemporalAmount): Internal.Temporal;
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal;
        with(arg0: Internal.TemporalField, arg1: number): Internal.Temporal;
        with(arg0: Internal.TemporalAdjuster): Internal.Temporal;
        query<R_>(arg0: Internal.TemporalQuery<R_>): R_;
        get(arg0: Internal.TemporalField): number;
        range(arg0: Internal.TemporalField): Internal.ValueRange;
        until(arg0: Internal.Temporal, arg1: Internal.TemporalUnit): number;
        isSupported(arg0: Internal.TemporalUnit): boolean;
        isSupported(arg0: Internal.TemporalField): boolean;
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Temporal;
        plus(arg0: Internal.TemporalAmount): Internal.Temporal;
    }
    class LightLayer extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.LightLayer;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.LightLayer[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.LightLayer): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.LightLayer>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.LightLayer>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SKY : Internal.LightLayer;
        static readonly BLOCK : Internal.LightLayer;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.LightLayer>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TemporalQuery <R> {
        queryFrom(arg0: Internal.TemporalAccessor): R;
    }
    class MoverType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.MoverType;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.MoverType[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.MoverType): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.MoverType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.MoverType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly PLAYER : Internal.MoverType;
        static readonly PISTON : Internal.MoverType;
        static readonly SHULKER_BOX : Internal.MoverType;
        static readonly SELF : Internal.MoverType;
        static readonly SHULKER : Internal.MoverType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.MoverType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractList <E> extends Internal.AbstractCollection<any> implements Internal.List<E> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        replaceAll(arg0: (arg0: any) => any): void;
        notify(): void;
        remove(arg0: number): E;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.Iterator<E>;
        stream(): Internal.Stream<E>;
        hashCode(): number;
        get(arg0: number): E;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: E): void;
        add(arg0: E): boolean;
        subList(arg0: number, arg1: number): Internal.List<E>;
        set(arg0: number, arg1: E): E;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: (arg0: E) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator<E>): void;
        removeIf(arg0: (arg0: E) => boolean): boolean;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean;
        addAll(arg0: Internal.Collection<E>): boolean;
        equals(arg0: any): boolean;
        listIterator(): Internal.ListIterator<E>;
        listIterator(arg0: number): Internal.ListIterator<E>;
        toString(): string;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class WorldBorder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ICapabilityProviderImpl <B> extends Internal.ICapabilityProvider {
        invalidateCaps(): void;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        areCapsCompatible(arg0: Internal.CapabilityProvider<B>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        reviveCaps(): void;
    }
    interface RecipeManagerAccessor {
        getRecipeMap<C, T>(arg0: Internal.RecipeType<T>): Internal.Map<ResourceLocation, Internal.Recipe<C>>;
    }
    interface ItemKJS {
        setFoodPropertiesKJS(arg0: Internal.FoodProperties): void;
        setFireResistantKJS(arg0: boolean): void;
        setCraftingRemainderKJS(arg0: Internal.Item): void;
        setItemBuilderKJS(arg0: Internal.ItemBuilder): void;
        setMaxDamageKJS(arg0: number): void;
        setBurnTimeKJS(arg0: number): void;
        setRarityKJS(arg0: Internal.Rarity): void;
        getItemBuilderKJS(): Internal.ItemBuilder;
        setMaxStackSizeKJS(arg0: number): void;
    }
    abstract class Text implements Internal.Iterable<Internal.Text>, Internal.Comparable<Internal.Text>, Internal.JsonSerializable, Internal.WrappedJS {
        getClass(): Internal.Class<any>;
        rawCopy(): Internal.Text;
        hasStyle(): boolean;
        compareTo(other: Internal.Text): number;
        compareTo(arg0: any): number;
        italic(): Internal.Text;
        italic(value: boolean): Internal.Text;
        static componentOf(o: any): Internal.Component;
        red(): Internal.Text;
        aqua(): Internal.Text;
        iterator(): Internal.Iterator<Internal.Text>;
        white(): Internal.Text;
        noColor(): Internal.Text;
        darkPurple(): Internal.Text;
        static join(separator: Internal.Text, texts: Internal.Iterable<Internal.Text>): Internal.Text;
        obfuscated(value: boolean): Internal.Text;
        obfuscated(): Internal.Text;
        write(buffer: Internal.FriendlyByteBuf): void;
        static read(buffer: Internal.FriendlyByteBuf): Internal.Text;
        spliterator(): Internal.Spliterator<Internal.Text>;
        getSiblings(): Internal.List<Internal.Text>;
        bold(value: boolean): Internal.Text;
        bold(): Internal.Text;
        click(value: string): Internal.Text;
        toJson(): Internal.JsonElement;
        darkGray(): Internal.Text;
        insertion(value: string): Internal.Text;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        color(c: Internal.Color): Internal.Text;
        notifyAll(): void;
        yellow(): Internal.Text;
        darkBlue(): Internal.Text;
        notify(): void;
        gold(): Internal.Text;
        hover(text: any): Internal.Text;
        gray(): Internal.Text;
        darkRed(): Internal.Text;
        hashCode(): number;
        static of(o: any): Internal.Text;
        strikethrough(): Internal.Text;
        strikethrough(value: boolean): Internal.Text;
        copy(): Internal.Text;
        rawComponent(): Internal.MutableComponent;
        createStyleJson(): Internal.JsonObject;
        hasSiblings(): boolean;
        green(): Internal.Text;
        darkGreen(): Internal.Text;
        forEach(arg0: (arg0: Internal.Text) => void): void;
        lightPurple(): Internal.Text;
        black(): Internal.Text;
        getString(): string;
        getStyleAndSiblingJson(): Internal.JsonObject;
        darkAqua(): Internal.Text;
        component(): Internal.Component;
        blue(): Internal.Text;
        underlined(): Internal.Text;
        underlined(value: boolean): Internal.Text;
        equals(obj: any): boolean;
        toString(): string;
        createStyle(): Internal.Style;
        append(sibling: any): Internal.Text;
        font(value: string): Internal.Text;
        get siblings(): Internal.List<Internal.Text>;
        get string(): string;
        get styleAndSiblingJson(): Internal.JsonObject;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BigDecimal extends Internal.Number implements Internal.Comparable<Internal.BigDecimal> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        longValueExact(): number;
        movePointLeft(arg0: number): Internal.BigDecimal;
        notifyAll(): void;
        precision(): number;
        byteValueExact(): number;
        toBigInteger(): Internal.BigInteger;
        scale(): number;
        toPlainString(): string;
        compareTo(arg0: Internal.BigDecimal): number;
        compareTo(arg0: any): number;
        shortValueExact(): number;
        notify(): void;
        longValue(): number;
        min(arg0: Internal.BigDecimal): Internal.BigDecimal;
        unscaledValue(): Internal.BigInteger;
        sqrt(arg0: Internal.MathContext): Internal.BigDecimal;
        scaleByPowerOfTen(arg0: number): Internal.BigDecimal;
        hashCode(): number;
        pow(arg0: number, arg1: Internal.MathContext): Internal.BigDecimal;
        pow(arg0: number): Internal.BigDecimal;
        shortValue(): number;
        divide(arg0: Internal.BigDecimal): Internal.BigDecimal;
        divide(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal;
        divide(arg0: Internal.BigDecimal, arg1: number): Internal.BigDecimal;
        divide(arg0: Internal.BigDecimal, arg1: Internal.RoundingMode): Internal.BigDecimal;
        divide(arg0: Internal.BigDecimal, arg1: number, arg2: number): Internal.BigDecimal;
        divide(arg0: Internal.BigDecimal, arg1: number, arg2: Internal.RoundingMode): Internal.BigDecimal;
        multiply(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal;
        multiply(arg0: Internal.BigDecimal): Internal.BigDecimal;
        signum(): number;
        add(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal;
        add(arg0: Internal.BigDecimal): Internal.BigDecimal;
        toBigIntegerExact(): Internal.BigInteger;
        toEngineeringString(): string;
        max(arg0: Internal.BigDecimal): Internal.BigDecimal;
        setScale(arg0: number): Internal.BigDecimal;
        setScale(arg0: number, arg1: Internal.RoundingMode): Internal.BigDecimal;
        setScale(arg0: number, arg1: number): Internal.BigDecimal;
        static valueOf(arg0: number): Internal.BigDecimal;
        static valueOf(arg0: number): Internal.BigDecimal;
        static valueOf(arg0: number, arg1: number): Internal.BigDecimal;
        intValue(): number;
        subtract(arg0: Internal.BigDecimal): Internal.BigDecimal;
        subtract(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal;
        floatValue(): number;
        doubleValue(): number;
        divideToIntegralValue(arg0: Internal.BigDecimal): Internal.BigDecimal;
        divideToIntegralValue(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal;
        plus(arg0: Internal.MathContext): Internal.BigDecimal;
        plus(): Internal.BigDecimal;
        abs(): Internal.BigDecimal;
        abs(arg0: Internal.MathContext): Internal.BigDecimal;
        round(arg0: Internal.MathContext): Internal.BigDecimal;
        divideAndRemainder(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal[];
        divideAndRemainder(arg0: Internal.BigDecimal): Internal.BigDecimal[];
        negate(arg0: Internal.MathContext): Internal.BigDecimal;
        negate(): Internal.BigDecimal;
        movePointRight(arg0: number): Internal.BigDecimal;
        equals(arg0: any): boolean;
        ulp(): Internal.BigDecimal;
        toString(): string;
        stripTrailingZeros(): Internal.BigDecimal;
        remainder(arg0: Internal.BigDecimal, arg1: Internal.MathContext): Internal.BigDecimal;
        remainder(arg0: Internal.BigDecimal): Internal.BigDecimal;
        intValueExact(): number;
        byteValue(): number;
        static readonly ZERO : Internal.BigDecimal;
        static readonly ROUND_DOWN : 1;
        static readonly ROUND_UNNECESSARY : 7;
        static readonly ROUND_CEILING : 2;
        static readonly ROUND_HALF_DOWN : 5;
        static readonly ROUND_HALF_UP : 4;
        static readonly ONE : Internal.BigDecimal;
        static readonly ROUND_UP : 0;
        static readonly ROUND_FLOOR : 3;
        static readonly ROUND_HALF_EVEN : 6;
        static readonly TEN : Internal.BigDecimal;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PainterObjectStorage {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getObject(key: string): Internal.PainterObject;
        notifyAll(): void;
        clear(): void;
        handle(root: Internal.CompoundTag): void;
        notify(): void;
        remove(id: string): void;
        createScreenObjects(): any[];
        createWorldObjects(): any[];
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getObjects(): Internal.Collection<Internal.PainterObject>;
        get objects(): Internal.Collection<Internal.PainterObject>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Explosion implements Internal.ExplosionAccess {
        redirect$bic000$skipNewHashSet(): Internal.HashSet<any>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static callAddBlockDrops_$md$dd73f7$0(arg0: Internal.ObjectArrayList<any>, arg1: Internal.ItemStack, arg2: BlockPos): void;
        getPosition(): Vec3;
        hashCode(): number;
        getExploder(): Internal.Entity;
        notifyAll(): void;
        equals(arg0: any): boolean;
        redirect$bic000$collectBlocks(affectedBlocks: Internal.List<any>, collection: Internal.Collection<any>): boolean;
        constant$bic000$skipLoop(prevValue: number): number;
        toString(): string;
        notify(): void;
        get exploder(): Internal.Entity;
        get position(): Vec3;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ServerScriptManager {
        getClass(): Internal.Class<any>;
        init(serverResources: Internal.ServerResources): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        reloadScriptManager(resourceManager: Internal.ResourceManager): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        resourcePackList(list0: Internal.List<Internal.PackResources>): Internal.List<Internal.PackResources>;
        notify(): void;
        readonly scriptManager : Internal.ScriptManager;
        static instance : Internal.ServerScriptManager;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractObjectList <K> extends Internal.AbstractObjectCollection<any> implements Internal.ObjectList<K>, Internal.Stack<K> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.List<K>): number;
        replaceAll(arg0: (arg0: any) => any): void;
        notify(): void;
        remove(arg0: number): K;
        remove(arg0: any): boolean;
        pop(): K;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.Iterator<any>;
        iterator(): Internal.ObjectListIterator<K>;
        iterator(): Internal.ObjectIterator<any>;
        top(): K;
        stream(): Internal.Stream<K>;
        addElements(arg0: number, arg1: K[]): void;
        addElements(arg0: number, arg1: K[], arg2: number, arg3: number): void;
        hashCode(): number;
        get(arg0: number): K;
        toArray<T_>(arg0: T_[]): T_[];
        toArray(): any[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<K>;
        indexOf(arg0: any): number;
        add(arg0: K): boolean;
        add(arg0: number, arg1: K): void;
        subList(arg0: number, arg1: number): Internal.List<any>;
        subList(arg0: number, arg1: number): Internal.ObjectList<K>;
        set(arg0: number, arg1: K): K;
        spliterator(): Internal.Spliterator<any>;
        spliterator(): Internal.ObjectSpliterator<K>;
        forEach(arg0: (arg0: K) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        setElements(arg0: number, arg1: K[], arg2: number, arg3: number): void;
        setElements(arg0: K[]): void;
        setElements(arg0: number, arg1: K[]): void;
        sort(arg0: Internal.Comparator<K>): void;
        removeElements(arg0: number, arg1: number): void;
        push(arg0: K): void;
        removeIf(arg0: (arg0: K) => boolean): boolean;
        peek(arg0: number): K;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        size(arg0: number): void;
        size(): number;
        addAll(arg0: number, arg1: Internal.Collection<K>): boolean;
        addAll(arg0: Internal.Collection<K>): boolean;
        addAll(arg0: Internal.ObjectList<K>): boolean;
        addAll(arg0: number, arg1: Internal.ObjectList<K>): boolean;
        getElements(arg0: number, arg1: any[], arg2: number, arg3: number): void;
        equals(arg0: any): boolean;
        listIterator(arg0: number): Internal.ListIterator<any>;
        listIterator(arg0: number): Internal.ObjectListIterator<K>;
        listIterator(): Internal.ObjectListIterator<K>;
        listIterator(): Internal.ListIterator<any>;
        toString(): string;
        unstableSort(arg0: Internal.Comparator<K>): void;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        set elements(arg0: K[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BlockPathingBehavior {
        getPathNodeType(arg0: Internal.BlockState): Internal.BlockPathTypes;
        getPathNodeTypeAsNeighbor(arg0: Internal.BlockState): Internal.BlockPathTypes;
    }
    class MenuType <T> extends Internal.ForgeRegistryEntry<any> implements Internal.IForgeMenuType<T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.MenuType<any>>;
        getRegistryName(): ResourceLocation;
        create(arg0: number, arg1: Internal.Inventory, arg2: Internal.FriendlyByteBuf): T;
        create(arg0: number, arg1: Internal.Inventory, arg2: Internal.FriendlyByteBuf): any;
        toString(): string;
        setRegistryName(arg0: string, arg1: string): Internal.MenuType<any>;
        setRegistryName(arg0: ResourceLocation): any;
        setRegistryName(arg0: ResourceLocation): Internal.MenuType<any>;
        setRegistryName(arg0: string): Internal.MenuType<any>;
        notify(): void;
        readonly delegate : () => Internal.MenuType<any>;
        get registryType(): Internal.Class<Internal.MenuType<any>>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PathMatcher {
        matches(arg0: Internal.Path): boolean;
    }
    class PlayableEndimation extends Internal.Record {
        duration(): number;
        loopType(): Internal.PlayableEndimation$LoopType;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        asEndimation(): Internal.Endimation;
        location(): ResourceLocation;
        toString(): string;
        notify(): void;
        static readonly BLANK : Internal.PlayableEndimation;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Permission implements Internal.Guard, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        checkGuard(arg0: any): void;
        newPermissionCollection(): Internal.PermissionCollection;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getActions(): string;
        toString(): string;
        implies(arg0: Internal.Permission): boolean;
        notify(): void;
        get name(): string;
        get class(): Internal.Class<any>;
        get actions(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Configuration {
        findModule(arg0: string): Internal.Optional<Internal.ResolvedModule>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        resolve(arg0: Internal.ModuleFinder, arg1: Internal.ModuleFinder, arg2: Internal.Collection<string>): Internal.Configuration;
        static resolve(arg0: Internal.ModuleFinder, arg1: Internal.List<Internal.Configuration>, arg2: Internal.ModuleFinder, arg3: Internal.Collection<string>): Internal.Configuration;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        static resolveAndBind(arg0: Internal.ModuleFinder, arg1: Internal.List<Internal.Configuration>, arg2: Internal.ModuleFinder, arg3: Internal.Collection<string>): Internal.Configuration;
        resolveAndBind(arg0: Internal.ModuleFinder, arg1: Internal.ModuleFinder, arg2: Internal.Collection<string>): Internal.Configuration;
        notify(): void;
        modules(): Internal.Set<Internal.ResolvedModule>;
        parents(): Internal.List<Internal.Configuration>;
        static empty(): Internal.Configuration;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class FloatBuffer extends Internal.Buffer implements Internal.Comparable<Internal.FloatBuffer> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        compact(): Internal.FloatBuffer;
        notifyAll(): void;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.FloatBuffer): number;
        notify(): void;
        asReadOnlyBuffer(): Internal.FloatBuffer;
        put(arg0: number[]): Internal.FloatBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.FloatBuffer;
        put(arg0: number, arg1: number[]): Internal.FloatBuffer;
        put(arg0: number[], arg1: number, arg2: number): Internal.FloatBuffer;
        put(arg0: number, arg1: Internal.FloatBuffer, arg2: number, arg3: number): Internal.FloatBuffer;
        put(arg0: Internal.FloatBuffer): Internal.FloatBuffer;
        put(arg0: number, arg1: number): Internal.FloatBuffer;
        put(arg0: number): Internal.FloatBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        slice(): Internal.Buffer;
        slice(): Internal.FloatBuffer;
        slice(arg0: number, arg1: number): Internal.Buffer;
        slice(arg0: number, arg1: number): Internal.FloatBuffer;
        array(): number[];
        array(): any;
        hashCode(): number;
        get(): number;
        get(arg0: number, arg1: number[]): Internal.FloatBuffer;
        get(arg0: number): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.FloatBuffer;
        get(arg0: number[], arg1: number, arg2: number): Internal.FloatBuffer;
        get(arg0: number[]): Internal.FloatBuffer;
        limit(arg0: number): Internal.FloatBuffer;
        limit(arg0: number): Internal.Buffer;
        limit(): number;
        arrayOffset(): number;
        flip(): Internal.Buffer;
        flip(): Internal.FloatBuffer;
        order(): Internal.ByteOrder;
        hasArray(): boolean;
        hasRemaining(): boolean;
        clear(): Internal.Buffer;
        clear(): Internal.FloatBuffer;
        duplicate(): Internal.FloatBuffer;
        duplicate(): Internal.Buffer;
        remaining(): number;
        static allocate(arg0: number): Internal.FloatBuffer;
        rewind(): Internal.Buffer;
        rewind(): Internal.FloatBuffer;
        mismatch(arg0: Internal.FloatBuffer): number;
        equals(arg0: any): boolean;
        reset(): Internal.Buffer;
        reset(): Internal.FloatBuffer;
        toString(): string;
        position(arg0: number): Internal.FloatBuffer;
        position(arg0: number): Internal.Buffer;
        position(): number;
        isDirect(): boolean;
        static wrap(arg0: number[]): Internal.FloatBuffer;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.FloatBuffer;
        mark(): Internal.Buffer;
        mark(): Internal.FloatBuffer;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class BlockableEventLoop <R> implements Internal.ProfilerMeasured, Internal.ProcessorHandle<R>, Internal.Executor {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        execute(arg0: Internal.Runnable): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TypeDescriptor$OfMethod <F, M> extends Internal.TypeDescriptor {
        parameterType(arg0: number): F;
        parameterArray(): F[];
        dropParameterTypes(arg0: number, arg1: number): M;
        parameterCount(): number;
        changeReturnType(arg0: F): M;
        descriptorString(): string;
        parameterList(): Internal.List<F>;
        insertParameterTypes(arg0: number, arg1: F[]): M;
        returnType(): F;
        changeParameterType(arg0: number, arg1: F): M;
    }
    class LootBuilder implements Internal.FunctionContainer, Internal.ConditionContainer {
        enchantWithLevels(levels: Internal.NumberProvider, treasure: boolean): Internal.FunctionContainer;
        damage(damage: Internal.NumberProvider): Internal.FunctionContainer;
        nbt(tag: Internal.CompoundTag): Internal.FunctionContainer;
        getClass(): Internal.Class<any>;
        clearFunctions(): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        survivesExplosion(): Internal.ConditionContainer;
        notifyAll(): void;
        addConditionalFunction(func: (arg0: Internal.ConditionalFunction) => void): Internal.FunctionContainer;
        addCondition(arg0: Internal.JsonObject): Internal.ConditionContainer;
        addCondition(o: Internal.JsonObject): Internal.LootBuilder;
        notify(): void;
        lootTable(table: ResourceLocation, seed: number): Internal.FunctionContainer;
        addPool(p: (arg0: Internal.LootBuilderPool) => void): void;
        hashCode(): number;
        killedByPlayer(): Internal.ConditionContainer;
        randomChance(chance: number): Internal.ConditionContainer;
        addFunction(o: Internal.JsonObject): Internal.LootBuilder;
        addFunction(arg0: Internal.JsonObject): Internal.FunctionContainer;
        count(count: Internal.NumberProvider): Internal.FunctionContainer;
        lootingEnchant(count: Internal.NumberProvider, limit: number): Internal.FunctionContainer;
        toJson(): Internal.JsonObject;
        entityScores(entity: Internal.LootContext$EntityTarget, scores: Internal.Map<string, any>): Internal.ConditionContainer;
        copyName(source: Internal.CopyNameFunction$NameSource): Internal.FunctionContainer;
        clearPools(): void;
        equals(arg0: any): boolean;
        name(name: Internal.Text, entity: Internal.LootContext$EntityTarget): Internal.FunctionContainer;
        name(name: Internal.Text): Internal.FunctionContainer;
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer;
        furnaceSmelt(): Internal.FunctionContainer;
        toString(): string;
        enchantRandomly(enchantments: ResourceLocation[]): Internal.FunctionContainer;
        entityProperties(entity: Internal.LootContext$EntityTarget, properties: Internal.JsonObject): Internal.ConditionContainer;
        clearConditions(): void;
        functions : Internal.JsonArray;
        pools : Internal.JsonArray;
        type : string;
        conditions : Internal.JsonArray;
        customId : ResourceLocation;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClocheRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        energy(e: number): Internal.IERecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        render(o: any): Internal.ClocheRecipeJS;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        time(t: number): Internal.IERecipeJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        renderReference : Internal.ClocheRenderFunction$ClocheRenderReference;
        readonly outputFluids : Internal.List<net.minecraftforge.fluids.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Decoder$Boxed <A> {
        decoder(): Internal.Decoder<A>;
        decode<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<Internal.Pair<A, T>>;
    }
    interface ImmutableBox {
        hasPowerOf2Sides(): boolean;
        intersect(arg0: Internal.ImmutableBox): Internal.GridAlignedBB;
        intersects(arg0: Internal.ImmutableBox): boolean;
        intersects(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        getMaxX(): number;
        forEachContained(arg0: Internal.CoordinateConsumer): void;
        getMaxY(): number;
        union(arg0: Internal.ImmutableBox): Internal.ImmutableBox;
        getMaxZ(): number;
        empty(): boolean;
        volume(): number;
        sizeX(): number;
        contains(arg0: Internal.ImmutableBox): boolean;
        contains(arg0: number, arg1: number, arg2: number): boolean;
        isContainedBy(arg0: Internal.GridAlignedBB): boolean;
        toAABB(): Internal.AABB;
        copy(): Internal.GridAlignedBB;
        getMinZ(): number;
        getMinX(): number;
        sizeY(): number;
        getMinY(): number;
        sameAs(arg0: Internal.ImmutableBox): boolean;
        sameAs(arg0: Internal.AABB): boolean;
        sizeZ(): number;
    }
    interface Object2LongFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToLongFunction<K> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_;
        put(arg0: K, arg1: number): number;
        put(arg0: K, arg1: number): number;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): any;
        remove(arg0: any): number;
        defaultReturnValue(arg0: number): void;
        defaultReturnValue(): number;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        removeLong(arg0: any): number;
        get(arg0: any): number;
        get(arg0: any): any;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        getLong(arg0: any): number;
        applyAsLong(arg0: K): number;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface ContextAction <T> {
        run(arg0: Internal.Context): T;
    }
    interface Copyable {
        copy(): Internal.Copyable;
    }
    interface Object2ObjectMap <K, V> extends Internal.Object2ObjectFunction<K, V>, Internal.Map<K, V> {
        computeObjectIfAbsentPartial(arg0: K, arg1: (arg0: K) => V): V;
        object2ObjectEntrySet(): Internal.ObjectSet<Internal.Object2ObjectMap$Entry<K, V>>;
        getOrDefault(arg0: any, arg1: V): V;
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V;
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V;
        values(): Internal.ObjectCollection<V>;
        values(): Internal.Collection<any>;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replace(arg0: K, arg1: V): V;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        replaceAll(arg0: (arg0: K, arg1: V) => V): void;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        containsValue(arg0: any): boolean;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: K) => V_;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: any, arg1: any): boolean;
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        hashCode(): number;
        putAll(arg0: Internal.Map<K, V>): void;
        get(arg0: any): V;
        get(arg0: any): V;
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        keySet(): Internal.Set<any>;
        keySet(): Internal.ObjectSet<K>;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: K): V;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<K, V>>;
        entrySet(): Internal.Set<any>;
        containsKey(arg0: any): boolean;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        isEmpty(): boolean;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => V;
        equals(arg0: any): boolean;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        putIfAbsent(arg0: K, arg1: V): V;
    }
    abstract class InputStream implements Internal.Closeable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        read(arg0: number[], arg1: number, arg2: number): number;
        read(arg0: number[]): number;
        read(): number;
        markSupported(): boolean;
        notifyAll(): void;
        available(): number;
        static nullInputStream(): Internal.InputStream;
        skip(arg0: number): number;
        transferTo(arg0: Internal.OutputStream): number;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        readAllBytes(): number[];
        reset(): void;
        readNBytes(arg0: number): number[];
        readNBytes(arg0: number[], arg1: number, arg2: number): number;
        toString(): string;
        close(): void;
        skipNBytes(arg0: number): void;
        mark(arg0: number): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class UseOnContext {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Long2DoubleFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.LongToDoubleFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface ScreenAccessor {
        balm_getChildren(): Internal.List<Internal.GuiEventListener>;
        balm_getRenderables(): Internal.List<Internal.Widget>;
        balm_getNarratables(): Internal.List<Internal.NarratableEntry>;
    }
    interface ExternalArrayData {
        setArrayElement(arg0: number, arg1: any): void;
        getArrayLength(): number;
        getArrayElement(arg0: number): any;
    }
    interface MaterialManager {
        defaultCutout(): Internal.MaterialGroup;
        solid(arg0: Internal.RenderType): Internal.MaterialGroup;
        defaultSolid(): Internal.MaterialGroup;
        defaultTransparent(): Internal.MaterialGroup;
        cutout(arg0: Internal.RenderType): Internal.MaterialGroup;
        state(arg0: Internal.RenderLayer, arg1: Internal.RenderType): Internal.MaterialGroup;
        transparent(arg0: Internal.RenderType): Internal.MaterialGroup;
        getOriginCoordinate(): Vec3i;
    }
    interface ScatteringByteChannel extends Internal.ReadableByteChannel {
        isOpen(): boolean;
        read(arg0: Internal.ByteBuffer[], arg1: number, arg2: number): number;
        read(arg0: Internal.ByteBuffer[]): number;
        read(arg0: Internal.ByteBuffer): number;
        close(): void;
    }
    class PartialModel {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLocation(): ResourceLocation;
        static onModelRegistry(arg0: Internal.ModelRegistryEvent): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        get(): Internal.BakedModel;
        toString(): string;
        static onModelBake(arg0: Internal.ModelBakeEvent): void;
        notify(): void;
        get location(): ResourceLocation;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DirectoryStream <T> extends Internal.Closeable, Internal.Iterable<T> {
        iterator(): Internal.Iterator<T>;
        spliterator(): Internal.Spliterator<T>;
        forEach(arg0: (arg0: T) => void): void;
        close(): void;
    }
    class Gson {
        getAdapter<T>(arg0: Internal.TypeToken<T>): Internal.TypeAdapter<T>;
        getAdapter<T>(arg0: Internal.Class<T>): Internal.TypeAdapter<T>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        excluder(): Internal.Excluder;
        notifyAll(): void;
        newBuilder(): Internal.GsonBuilder;
        notify(): void;
        newJsonReader(arg0: Internal.Reader): Internal.JsonReader;
        serializeNulls(): boolean;
        fieldNamingStrategy(): Internal.FieldNamingStrategy;
        toJson(arg0: any, arg1: java_.lang.reflect.Type, arg2: Internal.Appendable): void;
        toJson(arg0: Internal.JsonElement, arg1: Internal.JsonWriter): void;
        toJson(arg0: any, arg1: java_.lang.reflect.Type): string;
        toJson(arg0: any, arg1: java_.lang.reflect.Type, arg2: Internal.JsonWriter): void;
        toJson(arg0: Internal.JsonElement): string;
        toJson(arg0: Internal.JsonElement, arg1: Internal.Appendable): void;
        toJson(arg0: any, arg1: Internal.Appendable): void;
        toJson(arg0: any): string;
        newJsonWriter(arg0: Internal.Writer): Internal.JsonWriter;
        hashCode(): number;
        equals(arg0: any): boolean;
        toJsonTree(arg0: any): Internal.JsonElement;
        toJsonTree(arg0: any, arg1: java_.lang.reflect.Type): Internal.JsonElement;
        fromJson<T>(arg0: string, arg1: Internal.Class<T>): T;
        fromJson<T>(arg0: Internal.JsonReader, arg1: java_.lang.reflect.Type): T;
        fromJson<T>(arg0: Internal.JsonElement, arg1: Internal.Class<T>): T;
        fromJson<T>(arg0: Internal.JsonElement, arg1: java_.lang.reflect.Type): T;
        fromJson<T>(arg0: Internal.Reader, arg1: java_.lang.reflect.Type): T;
        fromJson<T>(arg0: Internal.Reader, arg1: Internal.Class<T>): T;
        fromJson<T>(arg0: string, arg1: java_.lang.reflect.Type): T;
        toString(): string;
        getDelegateAdapter<T>(arg0: Internal.TypeAdapterFactory, arg1: Internal.TypeToken<T>): Internal.TypeAdapter<T>;
        htmlSafe(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Int2LongFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsLong(arg0: number): number;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface Codec$ResultFunction <A> {
        apply<T>(arg0: Internal.DynamicOps<T>, arg1: T, arg2: Internal.DataResult<Internal.Pair<A, T>>): Internal.DataResult<Internal.Pair<A, T>>;
        coApply<T>(arg0: Internal.DynamicOps<T>, arg1: A, arg2: Internal.DataResult<T>): Internal.DataResult<T>;
    }
    class ImmutableMap$Builder <K, V> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        buildOrThrow(): Internal.ImmutableMap<K, V>;
        build(): Internal.ImmutableMap<K, V>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        putAll(arg0: Internal.Iterable<Internal.Map$Entry<K, V>>): Internal.ImmutableMap$Builder<K, V>;
        putAll(arg0: Internal.Map<K, V>): Internal.ImmutableMap$Builder<K, V>;
        toString(): string;
        orderEntriesByValue(arg0: Internal.Comparator<V>): Internal.ImmutableMap$Builder<K, V>;
        notify(): void;
        put(arg0: K, arg1: V): Internal.ImmutableMap$Builder<K, V>;
        put(arg0: Internal.Map$Entry<K, V>): Internal.ImmutableMap$Builder<K, V>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LongStream$Builder extends Internal.LongConsumer {
        add(arg0: number): Internal.LongStream$Builder;
        build(): Internal.LongStream;
        andThen(arg0: Internal.LongConsumer): Internal.LongConsumer;
        accept(arg0: number): void;
    }
    interface ScheduledFuture <V> extends Internal.Future<V>, java_.util.concurrent.ScheduledFuture<V> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        getDelay(arg0: Internal.TimeUnit): number;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>;
        getNow(): V;
        cause(): Internal.Throwable;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean;
        awaitUninterruptibly(): Internal.Future<V>;
        awaitUninterruptibly(arg0: number): boolean;
        compareTo(arg0: Internal.Delayed): number;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>;
        isDone(): boolean;
        sync(): Internal.Future<V>;
        syncUninterruptibly(): Internal.Future<V>;
        get(arg0: number, arg1: Internal.TimeUnit): V;
        get(): V;
        isCancellable(): boolean;
        await(arg0: number, arg1: Internal.TimeUnit): boolean;
        await(): Internal.Future<V>;
        await(arg0: number): boolean;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>;
        isSuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>;
    }
    interface Container extends Internal.Clearable {
    }
    interface TemporalAdjuster {
        adjustInto(arg0: Internal.Temporal): Internal.Temporal;
    }
    abstract class AbstractContainerEventHandler extends Internal.GuiComponent implements Internal.ContainerEventHandler {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ImmutableMultiset <E> extends Internal.ImmutableMultisetGwtSerializationDependencies<any> implements Internal.Multiset<E> {
        getClass(): Internal.Class<any>;
        forEachEntry(arg0: Internal.ObjIntConsumer<E>): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        notify(): void;
        asList(): Internal.ImmutableList<E>;
        remove(arg0: any, arg1: number): number;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.UnmodifiableIterator<E>;
        iterator(): Internal.Iterator<any>;
        stream(): Internal.Stream<E>;
        elementSet(): Internal.ImmutableSet<E>;
        elementSet(): Internal.Set<any>;
        hashCode(): number;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_): Internal.ImmutableMultiset<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_): Internal.ImmutableMultiset<E_>;
        static of<E_>(): Internal.ImmutableMultiset<E_>;
        static of<E_>(arg0: E_, arg1: E_): Internal.ImmutableMultiset<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_[]): Internal.ImmutableMultiset<E_>;
        static of<E_>(arg0: E_): Internal.ImmutableMultiset<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_): Internal.ImmutableMultiset<E_>;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        static builder<E_>(): Internal.ImmutableMultiset$Builder<E_>;
        parallelStream(): Internal.Stream<E>;
        setCount(arg0: E, arg1: number, arg2: number): boolean;
        setCount(arg0: E, arg1: number): number;
        add(arg0: E, arg1: number): number;
        add(arg0: E): boolean;
        static toImmutableMultiset<E_>(): Internal.Collector<E_, any, Internal.ImmutableMultiset<E_>>;
        static toImmutableMultiset<T_, E_>(arg0: (arg0: T_) => E_, arg1: Internal.ToIntFunction<T_>): Internal.Collector<T_, any, Internal.ImmutableMultiset<E_>>;
        spliterator(): Internal.Spliterator<E>;
        entrySet(): Internal.ImmutableSet<Internal.Multiset$Entry<E>>;
        entrySet(): Internal.Set<any>;
        forEach(arg0: (arg0: E) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        count(arg0: any): number;
        isEmpty(): boolean;
        clear(): void;
        static copyOf<E_>(arg0: Internal.Iterator<E_>): Internal.ImmutableMultiset<E_>;
        static copyOf<E_>(arg0: E_[]): Internal.ImmutableMultiset<E_>;
        static copyOf<E_>(arg0: Internal.Iterable<E_>): Internal.ImmutableMultiset<E_>;
        removeIf(arg0: (arg0: E) => boolean): boolean;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.Collection<E>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ContentHandlerFactory {
        createContentHandler(arg0: string): Internal.ContentHandler;
    }
    interface MaterialGroup {
        material<D>(arg0: Internal.StructType<D>): Internal.Material<D>;
    }
    interface LongToIntFunction {
        applyAsInt(arg0: number): number;
    }
    class ProtoChunkTicks <T> implements Internal.SerializableTickContainer<T>, Internal.TickContainerAccess<T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IScheduledEventCallback {
        onCallback(arg0: Internal.ScheduledEvent): void;
    }
    interface IntConsumer extends Internal.Consumer<number>, java_.util.function_.IntConsumer {
        andThen(arg0: java_.util.function_.IntConsumer): java_.util.function_.IntConsumer;
        andThen(arg0: java_.util.function_.IntConsumer): (arg0: any) => void;
        andThen(arg0: (arg0: number) => void): (arg0: number) => void;
        andThen(arg0: (arg0: any) => void): (arg0: any) => void;
        accept(arg0: any): void;
        accept(arg0: number): void;
        accept(arg0: number): void;
    }
    interface DirectoryStream$Filter <T> {
        accept(arg0: T): boolean;
    }
    class ScriptFileInfo {
        getPackMode(): string;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getProperty(s: string, def: string): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getPriority(): number;
        toString(): string;
        preload(source: Internal.ScriptSource): Internal.Throwable;
        isIgnored(): boolean;
        notify(): void;
        readonly file : string;
        readonly location : string;
        readonly id : ResourceLocation;
        readonly pack : Internal.ScriptPackInfo;
        get ignored(): boolean;
        get packMode(): string;
        get priority(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class MinMaxBounds <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractInterruptibleChannel implements Internal.Channel, Internal.InterruptibleChannel {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isOpen(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get class(): Internal.Class<any>;
        get open(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Locale$LanguageRange {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getWeight(): number;
        getRange(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static mapEquivalents(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Map<string, Internal.List<string>>): Internal.List<Internal.Locale$LanguageRange>;
        toString(): string;
        static parse(arg0: string): Internal.List<Internal.Locale$LanguageRange>;
        static parse(arg0: string, arg1: Internal.Map<string, Internal.List<string>>): Internal.List<Internal.Locale$LanguageRange>;
        notify(): void;
        static readonly MAX_WEIGHT : 1.0;
        static readonly MIN_WEIGHT : 0.0;
        get weight(): number;
        get range(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractInt2IntFunction implements Internal.Int2IntFunction, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        notifyAll(): void;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        notify(): void;
        defaultReturnValue(arg0: number): void;
        defaultReturnValue(): number;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        hashCode(): number;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        toString(): string;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Char2ShortFunction extends it.unimi.dsi.fastutil.Function<string, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: string, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: string) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: string, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: string, arg1: number): number;
        remove(arg0: string): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: string): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: string): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface BufferVertexType <T> extends Internal.VertexType<T> {
        getBufferVertexFormat(): Internal.BufferVertexFormat;
        createFallbackWriter(arg0: Internal.VertexConsumer): T;
        asBlittable(): Internal.BlittableVertexType<T>;
    }
    interface ScheduledExecutorService extends Internal.ExecutorService {
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<V_>;
        submit(arg0: Internal.Runnable): java_.util.concurrent.Future<any>;
        submit<T_>(arg0: Internal.Runnable, arg1: T_): java_.util.concurrent.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): java_.util.concurrent.Future<T_>;
        isTerminated(): boolean;
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<java_.util.concurrent.Future<T_>>;
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): Internal.List<java_.util.concurrent.Future<T_>>;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean;
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): T_;
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): T_;
        shutdownNow(): Internal.List<Internal.Runnable>;
        execute(arg0: Internal.Runnable): void;
        shutdown(): void;
        isShutdown(): boolean;
    }
    abstract class PainterObject implements Internal.SpecialEquality {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(o: any): boolean;
        update(tag: Internal.CompoundTag): void;
        toString(): string;
        id(i: string): Internal.PainterObject;
        notify(): void;
        specialEquals(o: any, shallow: boolean): boolean;
        parent : Internal.PainterObjectStorage;
        visible : boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PortalInfo {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeLevel extends Internal.ICapabilityProvider {
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        increaseMaxEntityRadius(arg0: number): number;
        getMaxEntityRadius(): number;
    }
    interface TStack <Self> {
        pushPose(): Self;
        popPose(): Self;
    }
    class Int2IntOpenHashMap extends Internal.AbstractInt2IntMap implements Internal.Serializable, Internal.Cloneable, Internal.Hash {
        getClass(): Internal.Class<any>;
        getOrDefault(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        replace(arg0: number, arg1: number, arg2: number): boolean;
        replace(arg0: number, arg1: number): number;
        replace(arg0: number, arg1: number, arg2: number): boolean;
        replace(arg0: number, arg1: number): number;
        replace(arg0: any, arg1: any): any;
        replace(arg0: any, arg1: any, arg2: any): boolean;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        containsValue(arg0: number): boolean;
        containsValue(arg0: any): boolean;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        mergeInt(arg0: number, arg1: number, arg2: (arg0: any, arg1: any) => any): number;
        mergeInt(arg0: number, arg1: number, arg2: Internal.IntBinaryOperator): number;
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number;
        compute(arg0: any, arg1: (arg0: any, arg1: any) => any): any;
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number;
        defaultReturnValue(arg0: number): void;
        defaultReturnValue(): number;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        trim(): boolean;
        trim(arg0: number): boolean;
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number;
        merge(arg0: any, arg1: any, arg2: (arg0: any, arg1: any) => any): any;
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, number>>;
        entrySet(): Internal.Set<any>;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        computeIfAbsent(arg0: number, arg1: Internal.IntUnaryOperator): number;
        computeIfAbsent(arg0: number, arg1: (arg0: any) => any): number;
        computeIfAbsent(arg0: any, arg1: (arg0: any) => any): any;
        computeIfAbsent(arg0: number, arg1: (arg0: number) => number): number;
        values(): Internal.Collection<any>;
        values(): Internal.IntCollection;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        computeIfAbsentPartial(arg0: number, arg1: (arg0: any) => any): number;
        replaceAll(arg0: (arg0: number, arg1: number) => number): void;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        notify(): void;
        remove(arg0: number, arg1: number): boolean;
        remove(arg0: number): number;
        remove(arg0: any): any;
        remove(arg0: any): number;
        remove(arg0: any, arg1: any): boolean;
        int2IntEntrySet(): Internal.Int2IntMap$FastEntrySet;
        int2IntEntrySet(): Internal.ObjectSet<any>;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        hashCode(): number;
        putAll(arg0: Internal.Map<number, number>): void;
        get(arg0: number): number;
        get(arg0: any): any;
        get(arg0: any): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        keySet(): Internal.Set<any>;
        keySet(): Internal.IntSet;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        computeIfAbsentNullable(arg0: number, arg1: Internal.IntFunction<number>): number;
        forEach(arg0: (arg0: number, arg1: number) => void): void;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        isEmpty(): boolean;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number;
        computeIfPresent(arg0: any, arg1: (arg0: any, arg1: any) => any): any;
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        clone(): (arg0: any) => any;
        clone(): any;
        addTo(arg0: number, arg1: number): number;
        toString(): string;
        putIfAbsent(arg0: number, arg1: number): number;
        putIfAbsent(arg0: any, arg1: any): any;
        putIfAbsent(arg0: number, arg1: number): number;
        static readonly DEFAULT_GROWTH_FACTOR : 16;
        static readonly FAST_LOAD_FACTOR : 0.5;
        static readonly DEFAULT_INITIAL_SIZE : 16;
        static readonly DEFAULT_LOAD_FACTOR : 0.75;
        static readonly OCCUPIED : -1;
        static readonly VERY_FAST_LOAD_FACTOR : 0.25;
        static readonly FREE : 0;
        static readonly PRIMES : number[];
        static readonly REMOVED : 1;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockState extends Internal.BlockBehaviour$BlockStateBase implements Internal.IForgeBlockState {
        getNeighborTable(): Internal.Table<any, any, any>;
        rotate(arg0: Internal.LevelAccessor, arg1: BlockPos, arg2: Internal.Rotation): Internal.BlockState;
        getClass(): Internal.Class<any>;
        getStateAtViewpoint(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Vec3): Internal.BlockState;
        onBlockExploded(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Explosion): void;
        getBedDirection(arg0: Internal.LevelReader, arg1: BlockPos): Internal.Direction;
        getOpacityIfCached(): number;
        isBed(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.LivingEntity): boolean;
        canHarvestBlock(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Player): boolean;
        setRequiresToolKJS(arg0: boolean): void;
        setMaterialKJS(arg0: net.minecraft.world.level.material.Material): void;
        replacePropertyMap(newMap: Internal.ImmutableMap<any, any>): void;
        isLadder(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.LivingEntity): boolean;
        handler$zkf000$onBlockCollision(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Entity, arg3: Internal.CallbackInfo): void;
        shouldDisplayFluidOverlay(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidState): boolean;
        canStickTo(arg0: Internal.BlockState): boolean;
        onNeighborChange(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): void;
        getWeakChanges(arg0: Internal.LevelReader, arg1: BlockPos): boolean;
        isBurning(arg0: Internal.BlockGetter, arg1: BlockPos): boolean;
        canEntityDestroy(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Entity): boolean;
        getFriction(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity): number;
        setDestroySpeedKJS(arg0: number): void;
        isValidSpawn(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.SpawnPlacements$Type, arg3: Internal.EntityType<any>): boolean;
        getNeighborPathNodeType(): Internal.BlockPathTypes;
        isPortalFrame(arg0: Internal.BlockGetter, arg1: BlockPos): boolean;
        getExplosionResistance(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): number;
        setLightEmissionKJS(arg0: number): void;
        getPathNodeType(): Internal.BlockPathTypes;
        canSustainPlant(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction, arg3: Internal.IPlantable): boolean;
        isScaffolding(arg0: Internal.LivingEntity): boolean;
        setNeighborTable(table: Internal.Table<any, any, any>): void;
        setStateMap(newValue: Internal.FastMap<any>): void;
        canDropFromExplosion(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): boolean;
        canRedstoneConnectTo(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): boolean;
        isStickyBlock(): boolean;
        isFertile(arg0: Internal.BlockGetter, arg1: BlockPos): boolean;
        isSlimeBlock(): boolean;
        getFireSpreadSpeed(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): number;
        getToolModifiedState(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Player, arg3: Internal.ItemStack, arg4: Internal.ToolAction): Internal.BlockState;
        getBeaconColorMultiplier(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): number[];
        handler$zhp000$cacheStateHead(ci: Internal.CallbackInfo): void;
        getStateIndex(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$zhp000$cacheStateTail(ci: Internal.CallbackInfo): void;
        getExpDrop(arg0: Internal.LevelReader, arg1: BlockPos, arg2: number, arg3: number): number;
        isConduitFrame(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): boolean;
        notifyAll(): void;
        getLightEmission(arg0: Internal.BlockGetter, arg1: BlockPos): number;
        onDestroyedByPlayer(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Player, arg3: boolean, arg4: Internal.FluidState): boolean;
        shouldCheckWeakPower(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Direction): boolean;
        collisionExtendsVertically(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Entity): boolean;
        notify(): void;
        addLandingEffects(arg0: Internal.ServerLevel, arg1: BlockPos, arg2: Internal.BlockState, arg3: Internal.LivingEntity, arg4: number): boolean;
        getSoundType(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity): Internal.SoundType;
        hashCode(): number;
        addRunningEffects(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Entity): boolean;
        setStateIndex(newValue: number): void;
        getCloneItemStack(arg0: Internal.HitResult, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Player): Internal.ItemStack;
        getVanillaPropertyMap(): Internal.ImmutableMap<any, any>;
        handler$bmk000$initLightAccessState(arg0: Internal.CallbackInfo): void;
        isFlammable(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): boolean;
        getBlockPathType(arg0: Internal.BlockGetter, arg1: BlockPos): Internal.BlockPathTypes;
        getBlockPathType(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Mob): Internal.BlockPathTypes;
        redirect$zhl000$getNeighborFromFastMap(ignore: Internal.Table<any, any, any>, rowKey: any, columnKey: any): any;
        onCaughtFire(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Direction, arg3: Internal.LivingEntity): void;
        getEnchantPowerBonus(arg0: Internal.LevelReader, arg1: BlockPos): number;
        setBedOccupied(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.LivingEntity, arg3: boolean): void;
        isFireSource(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Direction): boolean;
        getStateMap(): Internal.FastMap<any>;
        isConditionallyFullOpaque(): boolean;
        getRespawnPosition(arg0: Internal.EntityType<any>, arg1: Internal.LevelReader, arg2: BlockPos, arg3: number, arg4: Internal.LivingEntity): Internal.Optional<Vec3>;
        equals(arg0: any): boolean;
        getAllFlags(): number;
        toString(): string;
        getFlammability(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): number;
        get conditionallyFullOpaque(): boolean;
        get opacityIfCached(): number;
        get stickyBlock(): boolean;
        get stateIndex(): number;
        get slimeBlock(): boolean;
        get neighborTable(): Internal.Table<any, any, any>;
        get stateMap(): Internal.FastMap<any>;
        get neighborPathNodeType(): Internal.BlockPathTypes;
        get class(): Internal.Class<any>;
        get allFlags(): number;
        get pathNodeType(): Internal.BlockPathTypes;
        get vanillaPropertyMap(): Internal.ImmutableMap<any, any>;
        set materialKJS(arg0: net.minecraft.world.level.material.Material);
        set requiresToolKJS(arg0: boolean);
        set stateIndex(newValue: number);
        set stateMap(newValue: Internal.FastMap<any>);
        set neighborTable(table: Internal.Table<any, any, any>);
        set destroySpeedKJS(arg0: number);
        set lightEmissionKJS(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Int2ObjectFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: number, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        put(arg0: number, arg1: V): V;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: V): V;
        remove(arg0: number): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): V;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface NumberProvider extends Internal.LootContextUser {
    }
    interface LivingEntityAccessor {
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void;
    }
    abstract class AbstractMap <K, V> implements Internal.Map<K, V> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: V): V;
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V;
        notifyAll(): void;
        values(): Internal.Collection<V>;
        replace(arg0: K, arg1: V): V;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replaceAll(arg0: (arg0: K, arg1: V) => V): void;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: any, arg1: any): boolean;
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        hashCode(): number;
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V;
        putAll(arg0: Internal.Map<K, V>): void;
        get(arg0: any): V;
        keySet(): Internal.Set<K>;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        containsKey(arg0: any): boolean;
        isEmpty(): boolean;
        clear(): void;
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        size(): number;
        equals(arg0: any): boolean;
        toString(): string;
        putIfAbsent(arg0: K, arg1: V): V;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class MapCodec <A> extends Internal.CompressorHolder implements Internal.MapDecoder<A>, Internal.MapEncoder<A> {
        encode<T_>(arg0: A, arg1: Internal.DynamicOps<T_>, arg2: Internal.RecordBuilder<T_>): Internal.RecordBuilder<T_>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setPartial(arg0: () => A): Internal.MapCodec<A>;
        keys<T_>(arg0: Internal.DynamicOps<T_>): Internal.Stream<T_>;
        notifyAll(): void;
        deprecated(arg0: number): Internal.MapCodec<A>;
        decode<T_>(arg0: Internal.DynamicOps<T_>, arg1: Internal.MapLike<T_>): Internal.DataResult<A>;
        notify(): void;
        hashCode(): number;
        flatXmap<S_>(arg0: (arg0: A) => Internal.DataResult<S_>, arg1: (arg0: S_) => Internal.DataResult<A>): Internal.MapCodec<S_>;
        comap<B_>(arg0: (arg0: B_) => A): Internal.MapEncoder<B_>;
        static of<A_>(arg0: Internal.MapEncoder<A_>, arg1: Internal.MapDecoder<A_>, arg2: () => string): Internal.MapCodec<A_>;
        static of<A_>(arg0: Internal.MapEncoder<A_>, arg1: Internal.MapDecoder<A_>): Internal.MapCodec<A_>;
        fieldOf(arg0: string): Internal.MapCodec<A>;
        xmap<S_>(arg0: (arg0: A) => S_, arg1: (arg0: S_) => A): Internal.MapCodec<S_>;
        map<B_>(arg0: (arg0: A) => B_): Internal.MapDecoder<B_>;
        dependent<E_>(arg0: Internal.MapCodec<E_>, arg1: (arg0: A) => Internal.Pair<E_, Internal.MapCodec<E_>>, arg2: (arg0: A, arg1: E_) => A): Internal.MapCodec<A>;
        flatComap<B_>(arg0: (arg0: B_) => Internal.DataResult<A>): Internal.MapEncoder<B_>;
        compressedDecode<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<A>;
        compressedBuilder<T_>(arg0: Internal.DynamicOps<T_>): Internal.RecordBuilder<T_>;
        decoder(): Internal.Decoder<A>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapDecoder<any>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapEncoder<any>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapCodec<A>;
        encoder(): Internal.Encoder<A>;
        orElse(arg0: A): Internal.MapCodec<A>;
        orElse(arg0: (arg0: string) => void, arg1: A): Internal.MapCodec<A>;
        orElse(arg0: (arg0: any) => any, arg1: A): Internal.MapCodec<A>;
        forGetter<O_>(arg0: (arg0: O_) => A): Internal.RecordCodecBuilder<O_, A>;
        ap<E_>(arg0: Internal.MapDecoder<(arg0: A) => E_>): Internal.MapDecoder<E_>;
        flatMap<B_>(arg0: (arg0: A) => Internal.DataResult<B_>): Internal.MapDecoder<B_>;
        codec(): Internal.Codec<A>;
        static unit<A_>(arg0: () => A_): Internal.MapCodec<A_>;
        static unit<A_>(arg0: A_): Internal.MapCodec<A_>;
        orElseGet(arg0: (arg0: any) => any, arg1: () => A): Internal.MapCodec<A>;
        orElseGet(arg0: (arg0: string) => void, arg1: () => A): Internal.MapCodec<A>;
        orElseGet(arg0: () => A): Internal.MapCodec<A>;
        stable(): Internal.MapCodec<A>;
        equals(arg0: any): boolean;
        mapResult(arg0: Internal.MapCodec$ResultFunction<A>): Internal.MapCodec<A>;
        toString(): string;
        compressor<T_>(arg0: Internal.DynamicOps<T_>): Internal.KeyCompressor<T_>;
        get class(): Internal.Class<any>;
        set partial(arg0: () => A);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Promise <V> extends Internal.Future<V> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Promise<V>;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>;
        getNow(): V;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): Internal.Promise<V>;
        awaitUninterruptibly(): Internal.Future<V>;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Promise<V>;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>;
        tryFailure(arg0: Internal.Throwable): boolean;
        isDone(): boolean;
        sync(): Internal.Promise<V>;
        sync(): Internal.Future<V>;
        setSuccess(arg0: V): Internal.Promise<V>;
        setFailure(arg0: Internal.Throwable): Internal.Promise<V>;
        trySuccess(arg0: V): boolean;
        syncUninterruptibly(): Internal.Promise<V>;
        syncUninterruptibly(): Internal.Future<V>;
        get(arg0: number, arg1: Internal.TimeUnit): V;
        get(): V;
        isCancellable(): boolean;
        await(): Internal.Promise<V>;
        await(): Internal.Future<V>;
        await(arg0: number, arg1: Internal.TimeUnit): boolean;
        await(arg0: number): boolean;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Promise<V>;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>;
        isSuccess(): boolean;
        setUncancellable(): boolean;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Promise<V>;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>;
    }
    abstract class EffectRenderingInventoryScreen <T> extends Internal.AbstractContainerScreen<any> {
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.ItemStack): void;
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.Font): void;
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.Font, arg5: Internal.ItemStack): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getHoveredSlot(): Internal.Slot;
        notifyAll(): void;
        getYSize(): number;
        getIsQuickCrafting(): boolean;
        getLeftPos(): number;
        notify(): void;
        getImageHeight(): number;
        balm_getNarratables(): Internal.List<any>;
        static renderSlotHighlight(arg0: Internal.PoseStack, arg1: number, arg2: number, arg3: number, arg4: number): void;
        invokeFindSlot(arg0: number, arg1: number): Internal.Slot;
        hashCode(): number;
        setIsQuickCrafting(arg0: boolean): void;
        getQuickCraftingButton(): number;
        getSlotColor(arg0: number): number;
        localvar$bjb000$modifyBl(bl: boolean): boolean;
        callIsHovering(arg0: Internal.Slot, arg1: number, arg2: number): boolean;
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.ItemStack): void;
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.Font): void;
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedCharSequence>, arg2: number, arg3: number, arg4: Internal.Font): void;
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.Font, arg6: Internal.ItemStack): void;
        handler$zjd000$renderSlot(arg0: Internal.PoseStack, arg1: Internal.Slot, arg2: Internal.CallbackInfo): void;
        setSkipNextRelease(arg0: boolean): void;
        callRenderSlot(arg0: Internal.PoseStack, arg1: Internal.Slot): void;
        getRenderables(): Internal.List<any>;
        getImageWidth(): number;
        invokeSlotClicked(arg0: Internal.Slot, arg1: number, arg2: number, arg3: Internal.ClickType): void;
        localvar$bjb000$modifyK(k: number): number;
        getMinecraft(): Internal.Minecraft;
        getTopPos(): number;
        getGuiTop(): number;
        getGuiLeft(): number;
        balm_getChildren(): Internal.List<any>;
        balm_getRenderables(): Internal.List<any>;
        equals(arg0: any): boolean;
        getSlotUnderMouse(): Internal.Slot;
        toString(): string;
        getXSize(): number;
        tooltipStack : Internal.ItemStack;
        get leftPos(): number;
        get imageWidth(): number;
        get minecraft(): Internal.Minecraft;
        get quickCraftingButton(): number;
        get isQuickCrafting(): boolean;
        get ySize(): number;
        get imageHeight(): number;
        get renderables(): Internal.List<any>;
        get hoveredSlot(): Internal.Slot;
        get slotUnderMouse(): Internal.Slot;
        get guiLeft(): number;
        get xSize(): number;
        get class(): Internal.Class<any>;
        get topPos(): number;
        get guiTop(): number;
        set isQuickCrafting(arg0: boolean);
        set skipNextRelease(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeItemStack extends Internal.ICapabilitySerializable<Internal.CompoundTag> {
        canElytraFly(arg0: Internal.LivingEntity): boolean;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        canEquip(arg0: EquipmentSlot, arg1: Internal.Entity): boolean;
        canPerformAction(arg0: Internal.ToolAction): boolean;
        onBlockStartBreak(arg0: BlockPos, arg1: Internal.Player): boolean;
        onHorseArmorTick(arg0: net.minecraft.world.level.Level, arg1: Internal.Mob): void;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack): boolean;
        getItemEnchantability(): number;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        getEntityLifespan(arg0: net.minecraft.world.level.Level): number;
        getXpRepairRatio(): number;
        getHighlightTip(arg0: Internal.Component): Internal.Component;
        readShareTag(arg0: Internal.CompoundTag): void;
        onEntityItemUpdate(arg0: Internal.ItemEntity): boolean;
        onArmorTick(arg0: net.minecraft.world.level.Level, arg1: Internal.Player): void;
        isBookEnchantable(arg0: Internal.ItemStack): boolean;
        hasContainerItem(): boolean;
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: Internal.LivingEntity): boolean;
        doesSneakBypassUse(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Player): boolean;
        onItemUseFirst(arg0: Internal.UseOnContext): Internal.InteractionResult;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        getContainerItem(): Internal.ItemStack;
        onUsingTick(arg0: Internal.LivingEntity, arg1: number): void;
        isPiglinCurrency(): boolean;
        getSweepHitBox(arg0: Internal.Player, arg1: Internal.Entity): Internal.AABB;
        onDestroyed(arg0: Internal.ItemEntity, arg1: Internal.DamageSource): void;
        isRepairable(): boolean;
        getEquipmentSlot(): EquipmentSlot;
        getShareTag(): Internal.CompoundTag;
        getBurnTime(arg0: Internal.RecipeType<any>): number;
        onDroppedByPlayer(arg0: Internal.Player): boolean;
        onEntitySwing(arg0: Internal.LivingEntity): boolean;
        equals(arg0: Internal.ItemStack, arg1: boolean): boolean;
        makesPiglinsNeutral(arg0: Internal.LivingEntity): boolean;
        elytraFlightTick(arg0: Internal.LivingEntity, arg1: number): boolean;
        isEnderMask(arg0: Internal.Player, arg1: Internal.EnderMan): boolean;
        areShareTagsEqual(arg0: Internal.ItemStack): boolean;
        canApplyAtEnchantingTable(arg0: Internal.Enchantment): boolean;
    }
    interface LightProvider {
        getLight(arg0: Internal.LightLayer, arg1: number, arg2: number, arg3: number): number;
        getPackedLight(arg0: number, arg1: number, arg2: number): number;
    }
    interface MapLike <T> {
        entries(): Internal.Stream<Internal.Pair<T, T>>;
        get(arg0: T): T;
        get(arg0: string): T;
    }
    class FluidAttributes {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOverlayTexture(): ResourceLocation;
        isLighterThanAir(): boolean;
        notifyAll(): void;
        getRarity(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): Internal.Rarity;
        getRarity(): Internal.Rarity;
        getRarity(arg0: net.minecraftforge.fluids.FluidStack): Internal.Rarity;
        isGaseous(arg0: net.minecraftforge.fluids.FluidStack): boolean;
        isGaseous(): boolean;
        isGaseous(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): boolean;
        getEmptySound(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): Internal.SoundEvent;
        getEmptySound(arg0: net.minecraftforge.fluids.FluidStack): Internal.SoundEvent;
        getEmptySound(): Internal.SoundEvent;
        notify(): void;
        getBucket(arg0: net.minecraftforge.fluids.FluidStack): Internal.ItemStack;
        getFlowingTexture(arg0: net.minecraftforge.fluids.FluidStack): ResourceLocation;
        getFlowingTexture(): ResourceLocation;
        getFlowingTexture(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): ResourceLocation;
        hashCode(): number;
        static builder(arg0: ResourceLocation, arg1: ResourceLocation): Internal.FluidAttributes$Builder;
        getStillTexture(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): ResourceLocation;
        getStillTexture(arg0: net.minecraftforge.fluids.FluidStack): ResourceLocation;
        getStillTexture(): ResourceLocation;
        getBlock(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidState): Internal.BlockState;
        getTranslationKey(arg0: net.minecraftforge.fluids.FluidStack): string;
        getTranslationKey(): string;
        getStateForPlacement(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: net.minecraftforge.fluids.FluidStack): Internal.FluidState;
        getColor(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): number;
        getColor(): number;
        getColor(arg0: net.minecraftforge.fluids.FluidStack): number;
        getFillSound(): Internal.SoundEvent;
        getFillSound(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): Internal.SoundEvent;
        getFillSound(arg0: net.minecraftforge.fluids.FluidStack): Internal.SoundEvent;
        getDensity(arg0: net.minecraftforge.fluids.FluidStack): number;
        getDensity(): number;
        getDensity(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): number;
        getLuminosity(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): number;
        getLuminosity(arg0: net.minecraftforge.fluids.FluidStack): number;
        getLuminosity(): number;
        doesVaporize(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: net.minecraftforge.fluids.FluidStack): boolean;
        getViscosity(arg0: net.minecraftforge.fluids.FluidStack): number;
        getViscosity(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): number;
        getViscosity(): number;
        canBePlacedInWorld(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidState): boolean;
        canBePlacedInWorld(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: net.minecraftforge.fluids.FluidStack): boolean;
        getDisplayName(arg0: net.minecraftforge.fluids.FluidStack): Internal.Component;
        equals(arg0: any): boolean;
        getTextures(): Internal.Stream<ResourceLocation>;
        toString(): string;
        vaporize(arg0: Internal.Player, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: net.minecraftforge.fluids.FluidStack): void;
        getTemperature(arg0: net.minecraftforge.fluids.FluidStack): number;
        getTemperature(arg0: Internal.BlockAndTintGetter, arg1: BlockPos): number;
        getTemperature(): number;
        static readonly BUCKET_VOLUME : 1000;
        get overlayTexture(): ResourceLocation;
        get translationKey(): string;
        get color(): number;
        get density(): number;
        get textures(): Internal.Stream<ResourceLocation>;
        get lighterThanAir(): boolean;
        get gaseous(): boolean;
        get emptySound(): Internal.SoundEvent;
        get stillTexture(): ResourceLocation;
        get viscosity(): number;
        get flowingTexture(): ResourceLocation;
        get temperature(): number;
        get luminosity(): number;
        get class(): Internal.Class<any>;
        get fillSound(): Internal.SoundEvent;
        get rarity(): Internal.Rarity;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TypeToken <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRawType(): Internal.Class<T>;
        getType(): java_.lang.reflect.Type;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static get(arg0: java_.lang.reflect.Type): Internal.TypeToken<any>;
        static get<T>(arg0: Internal.Class<T>): Internal.TypeToken<T>;
        static getArray(arg0: java_.lang.reflect.Type): Internal.TypeToken<any>;
        toString(): string;
        isAssignableFrom(arg0: Internal.TypeToken<any>): boolean;
        isAssignableFrom(arg0: java_.lang.reflect.Type): boolean;
        isAssignableFrom(arg0: Internal.Class<any>): boolean;
        notify(): void;
        static getParameterized(arg0: java_.lang.reflect.Type, arg1: java_.lang.reflect.Type[]): Internal.TypeToken<any>;
        get rawType(): Internal.Class<T>;
        get type(): java_.lang.reflect.Type;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface OffsetVoxelShapeCache {
        getOffsetSimplifiedShape(arg0: number, arg1: Internal.Direction): Internal.VoxelShape;
        setShape(arg0: number, arg1: Internal.Direction, arg2: Internal.VoxelShape): void;
    }
    abstract class AbstractReferenceCountedByteBuf extends Internal.AbstractByteBuf {
        asReadOnly(): Internal.ByteBuf;
        markReaderIndex(): Internal.ByteBuf;
        getByte(arg0: number): number;
        release(): boolean;
        release(arg0: number): boolean;
        readDoubleLE(): number;
        writeZero(arg0: number): Internal.ByteBuf;
        resetReaderIndex(): Internal.ByteBuf;
        writeFloat(arg0: number): Internal.ByteBuf;
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf;
        readRetainedSlice(arg0: number): Internal.ByteBuf;
        slice(): Internal.ByteBuf;
        slice(arg0: number, arg1: number): Internal.ByteBuf;
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf;
        getMediumLE(arg0: number): number;
        readUnsignedIntLE(): number;
        writeFloatLE(arg0: number): Internal.ByteBuf;
        readInt(): number;
        order(arg0: Internal.ByteOrder): Internal.ByteBuf;
        order(): Internal.ByteOrder;
        writeMedium(arg0: number): Internal.ByteBuf;
        resetWriterIndex(): Internal.ByteBuf;
        writableBytes(): number;
        maxCapacity(): number;
        getUnsignedShort(arg0: number): number;
        nioBufferCount(): number;
        bytesBefore(arg0: number): number;
        bytesBefore(arg0: number, arg1: number): number;
        bytesBefore(arg0: number, arg1: number, arg2: number): number;
        setInt(arg0: number, arg1: number): Internal.ByteBuf;
        getInt(arg0: number): number;
        markWriterIndex(): Internal.ByteBuf;
        isReadable(arg0: number): boolean;
        isReadable(): boolean;
        writeBoolean(arg0: boolean): Internal.ByteBuf;
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        writeLongLE(arg0: number): Internal.ByteBuf;
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf;
        retain(arg0: number): Internal.ByteBuf;
        retain(arg0: number): Internal.ReferenceCounted;
        retain(): Internal.ByteBuf;
        retain(): Internal.ReferenceCounted;
        isWritable(arg0: number): boolean;
        isWritable(): boolean;
        notify(): void;
        readChar(): string;
        hasMemoryAddress(): boolean;
        capacity(): number;
        capacity(arg0: number): Internal.ByteBuf;
        readCharSequence(arg0: number, arg1: Internal.Charset): Internal.CharSequence;
        isReadOnly(): boolean;
        readUnsignedShortLE(): number;
        readDouble(): number;
        readFloat(): number;
        getLongLE(arg0: number): number;
        getBoolean(arg0: number): boolean;
        copy(): Internal.ByteBuf;
        copy(arg0: number, arg1: number): Internal.ByteBuf;
        readShortLE(): number;
        readUnsignedMedium(): number;
        ensureWritable(arg0: number, arg1: boolean): number;
        ensureWritable(arg0: number): Internal.ByteBuf;
        writeInt(arg0: number): Internal.ByteBuf;
        readFloatLE(): number;
        getDoubleLE(arg0: number): number;
        hasArray(): boolean;
        memoryAddress(): number;
        maxFastWritableBytes(): number;
        readableBytes(): number;
        readSlice(arg0: number): Internal.ByteBuf;
        getIntLE(arg0: number): number;
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number;
        forEachByteDesc(arg0: Internal.ByteProcessor): number;
        nioBuffers(): Internal.ByteBuffer[];
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        skipBytes(arg0: number): Internal.ByteBuf;
        getLong(arg0: number): number;
        readLong(): number;
        readShort(): number;
        equals(arg0: any): boolean;
        getUnsignedMedium(arg0: number): number;
        setZero(arg0: number, arg1: number): Internal.ByteBuf;
        readBytes(arg0: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: Internal.GatheringByteChannel, arg1: number): number;
        readBytes(arg0: number[]): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf;
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf;
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number;
        readBoolean(): boolean;
        toString(): string;
        toString(arg0: Internal.Charset): string;
        toString(arg0: number, arg1: number, arg2: Internal.Charset): string;
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf;
        retainedSlice(): Internal.ByteBuf;
        readMediumLE(): number;
        isDirect(): boolean;
        setMedium(arg0: number, arg1: number): Internal.ByteBuf;
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf;
        getClass(): Internal.Class<any>;
        getFloatLE(arg0: number): number;
        readerIndex(arg0: number): Internal.ByteBuf;
        readerIndex(): number;
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset): Internal.CharSequence;
        setShort(arg0: number, arg1: number): Internal.ByteBuf;
        compareTo(arg0: Internal.ByteBuf): number;
        compareTo(arg0: any): number;
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number;
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel, arg2: number): number;
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf;
        unwrap(): Internal.ByteBuf;
        setDouble(arg0: number, arg1: number): Internal.ByteBuf;
        setChar(arg0: number, arg1: number): Internal.ByteBuf;
        refCnt(): number;
        getUnsignedIntLE(arg0: number): number;
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf;
        getUnsignedInt(arg0: number): number;
        indexOf(arg0: number, arg1: number, arg2: number): number;
        writeByte(arg0: number): Internal.ByteBuf;
        nioBuffer(): Internal.ByteBuffer;
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        discardSomeReadBytes(): Internal.ByteBuf;
        touch(arg0: any): Internal.ReferenceCounted;
        touch(arg0: any): Internal.ByteBuf;
        touch(): Internal.ReferenceCounted;
        touch(): Internal.ByteBuf;
        duplicate(): Internal.ByteBuf;
        writerIndex(): number;
        writerIndex(arg0: number): Internal.ByteBuf;
        getUnsignedShortLE(arg0: number): number;
        writeCharSequence(arg0: Internal.CharSequence, arg1: Internal.Charset): number;
        readUnsignedInt(): number;
        retainedDuplicate(): Internal.ByteBuf;
        getChar(arg0: number): string;
        setLong(arg0: number, arg1: number): Internal.ByteBuf;
        readMedium(): number;
        writeBytes(arg0: Internal.ScatteringByteChannel, arg1: number): number;
        writeBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf;
        writeBytes(arg0: Internal.InputStream, arg1: number): number;
        writeBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number;
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: number[]): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf;
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number;
        forEachByte(arg0: Internal.ByteProcessor): number;
        setIndex(arg0: number, arg1: number): Internal.ByteBuf;
        writeShort(arg0: number): Internal.ByteBuf;
        alloc(): Internal.ByteBufAllocator;
        getShortLE(arg0: number): number;
        getMedium(arg0: number): number;
        readUnsignedShort(): number;
        setByte(arg0: number, arg1: number): Internal.ByteBuf;
        maxWritableBytes(): number;
        writeShortLE(arg0: number): Internal.ByteBuf;
        notifyAll(): void;
        getDouble(arg0: number): number;
        getFloat(arg0: number): number;
        writeLong(arg0: number): Internal.ByteBuf;
        writeIntLE(arg0: number): Internal.ByteBuf;
        array(): number[];
        setCharSequence(arg0: number, arg1: Internal.CharSequence, arg2: Internal.Charset): number;
        hashCode(): number;
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        arrayOffset(): number;
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf;
        readIntLE(): number;
        readUnsignedByte(): number;
        readLongLE(): number;
        readUnsignedMediumLE(): number;
        writeDouble(arg0: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel, arg2: number): number;
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.InputStream, arg2: number): number;
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number;
        setFloat(arg0: number, arg1: number): Internal.ByteBuf;
        getShort(arg0: number): number;
        writeMediumLE(arg0: number): Internal.ByteBuf;
        clear(): Internal.ByteBuf;
        getUnsignedByte(arg0: number): number;
        discardReadBytes(): Internal.ByteBuf;
        writeChar(arg0: number): Internal.ByteBuf;
        writeDoubleLE(arg0: number): Internal.ByteBuf;
        isContiguous(): boolean;
        getUnsignedMediumLE(arg0: number): number;
        readByte(): number;
        get readable(): boolean;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get contiguous(): boolean;
        get writable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ChannelOutboundInvoker {
        disconnect(): Internal.ChannelFuture;
        disconnect(arg0: Internal.ChannelPromise): Internal.ChannelFuture;
        newProgressivePromise(): Internal.ChannelProgressivePromise;
        read(): Internal.ChannelOutboundInvoker;
        deregister(): Internal.ChannelFuture;
        deregister(arg0: Internal.ChannelPromise): Internal.ChannelFuture;
        newFailedFuture(arg0: Internal.Throwable): Internal.ChannelFuture;
        writeAndFlush(arg0: any): Internal.ChannelFuture;
        writeAndFlush(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        newSucceededFuture(): Internal.ChannelFuture;
        voidPromise(): Internal.ChannelPromise;
        flush(): Internal.ChannelOutboundInvoker;
        close(arg0: Internal.ChannelPromise): Internal.ChannelFuture;
        close(): Internal.ChannelFuture;
        write(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        write(arg0: any): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress, arg2: Internal.ChannelPromise): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        newPromise(): Internal.ChannelPromise;
    }
    class PersistentEntitySectionManager <T> implements Internal.AutoCloseable, me.jellysquid.mods.lithium.mixin.ai.nearby_entity_tracking.ServerEntityManagerAccessor<any>, Internal.ServerEntityManagerAccessor<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getCache(): Internal.EntitySectionStorage<any>;
        addNewEntityWithoutEvent(arg0: T): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get cache(): Internal.EntitySectionStorage<any>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Message extends Internal.Serializable {
        getParameters(): any[];
        getFormattedMessage(): string;
        getFormat(): string;
        getThrowable(): Internal.Throwable;
    }
    class DrawBuffer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hasVertices(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        reset(): void;
        toString(): string;
        inject(arg0: Internal.BufferBuilderExtension): void;
        begin(arg0: number): Internal.DirectVertexConsumer;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BiConsumer <T, U> {
        andThen(arg0: (arg0: T, arg1: U) => void): (arg0: T, arg1: U) => void;
        accept(arg0: T, arg1: U): void;
    }
    interface BlockAndTintGetter extends Internal.BlockGetter {
    }
    class ObjectArrayList <K> extends Internal.AbstractObjectList<any> implements Internal.RandomAccess, Internal.Cloneable, Internal.Serializable {
        getClass(): Internal.Class<any>;
        static toList<K_>(): Internal.Collector<K_, any, Internal.ObjectArrayList<K_>>;
        compareTo(arg0: Internal.List<K>): number;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ObjectArrayList<K>): number;
        iterator(): Internal.Iterator<any>;
        iterator(): Internal.ObjectListIterator<K>;
        iterator(): Internal.ObjectIterator<any>;
        removeAll(arg0: Internal.Collection<any>): boolean;
        trim(arg0: number): void;
        trim(): void;
        toArray<K_>(arg0: K_[]): K_[];
        toArray(): any[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<K>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: K): void;
        add(arg0: K): boolean;
        spliterator(): Internal.ObjectSpliterator<K>;
        spliterator(): Internal.Spliterator<any>;
        sort(arg0: Internal.Comparator<K>): void;
        push(arg0: K): void;
        removeIf(arg0: (arg0: K) => boolean): boolean;
        contains(arg0: any): boolean;
        size(arg0: number): void;
        size(): number;
        getElements(arg0: number, arg1: any[], arg2: number, arg3: number): void;
        listIterator(arg0: number): Internal.ListIterator<any>;
        listIterator(arg0: number): Internal.ObjectListIterator<K>;
        listIterator(): Internal.ObjectListIterator<K>;
        listIterator(): Internal.ListIterator<any>;
        ensureCapacity(arg0: number): void;
        unstableSort(arg0: Internal.Comparator<K>): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        replaceAll(arg0: (arg0: any) => any): void;
        notify(): void;
        remove(arg0: any): boolean;
        remove(arg0: number): K;
        pop(): K;
        top(): K;
        stream(): Internal.Stream<K>;
        hashCode(): number;
        addElements(arg0: number, arg1: K[], arg2: number, arg3: number): void;
        addElements(arg0: number, arg1: K[]): void;
        static of<K_>(arg0: K_[]): Internal.ObjectArrayList<K_>;
        static of<K_>(): Internal.ObjectArrayList<K_>;
        get(arg0: number): K;
        static toListWithExpectedSize<K_>(arg0: number): Internal.Collector<K_, any, Internal.ObjectArrayList<K_>>;
        subList(arg0: number, arg1: number): Internal.List<any>;
        subList(arg0: number, arg1: number): Internal.ObjectList<K>;
        set(arg0: number, arg1: K): K;
        forEach(arg0: (arg0: K) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        setElements(arg0: number, arg1: K[], arg2: number, arg3: number): void;
        setElements(arg0: K[]): void;
        setElements(arg0: number, arg1: K[]): void;
        removeElements(arg0: number, arg1: number): void;
        peek(arg0: number): K;
        lastIndexOf(arg0: any): number;
        addAll(arg0: number, arg1: Internal.ObjectList<K>): boolean;
        addAll(arg0: number, arg1: Internal.Collection<K>): boolean;
        addAll(arg0: Internal.Collection<K>): boolean;
        addAll(arg0: Internal.ObjectList<K>): boolean;
        elements(): K[];
        equals(arg0: Internal.ObjectArrayList<K>): boolean;
        equals(arg0: any): boolean;
        clone(): any;
        clone(): Internal.ObjectArrayList<K>;
        toString(): string;
        static wrap<K_>(arg0: K_[]): Internal.ObjectArrayList<K_>;
        static wrap<K_>(arg0: K_[], arg1: number): Internal.ObjectArrayList<K_>;
        retainAll(arg0: Internal.Collection<any>): boolean;
        static readonly DEFAULT_INITIAL_CAPACITY : 10;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClickAction extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ClickAction;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ClickAction[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ClickAction): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ClickAction>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ClickAction>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SECONDARY : Internal.ClickAction;
        static readonly PRIMARY : Internal.ClickAction;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ClickAction>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ItemInvokerMixin {
        callAllowdedIn(arg0: Internal.CreativeModeTab): boolean;
    }
    interface ConditionsContainer <B> {
        killerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B;
        survivesExplosion(): B;
        addCondition(arg0: Internal.LootItemCondition$Builder): B;
        addCondition(arg0: (arg0: any) => boolean): B;
        customDistanceToPlayer(arg0: (arg0: Internal.DistancePredicateBuilder) => void): B;
        matchFluid(arg0: string): B;
        not(arg0: (arg0: Internal.NotConditionBuilder) => void): B;
        directKillerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B;
        matchEquip(arg0: EquipmentSlot, arg1: Internal.IngredientJS): B;
        and(arg0: (arg0: Internal.AndConditionBuilder) => void): B;
        matchLoot(arg0: Internal.IngredientJS): B;
        matchLoot(arg0: Internal.IngredientJS, arg1: boolean): B;
        anyBiome(arg0: string[]): B;
        distanceToKiller(arg0: Internal.MinMaxBounds$Doubles): B;
        entityPredicate(arg0: (arg0: Internal.EntityJS) => boolean): B;
        matchEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B;
        anyDimension(arg0: ResourceLocation[]): B;
        killedByPlayer(): B;
        or(arg0: (arg0: Internal.OrConditionBuilder) => void): B;
        randomChance(arg0: number): B;
        timeCheck(arg0: number, arg1: number, arg2: number): B;
        timeCheck(arg0: number, arg1: number): B;
        matchOffHand(arg0: Internal.IngredientJS): B;
        playerPredicate(arg0: (arg0: Internal.PlayerJS<any>) => boolean): B;
        weatherCheck(arg0: Internal.Map<string, boolean>): B;
        matchDirectKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B;
        matchBlockState(arg0: Internal.Block, arg1: Internal.Map<string, string>): B;
        matchMainHand(arg0: Internal.IngredientJS): B;
        matchPlayer(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B;
        lightLevel(arg0: number, arg1: number): B;
        biome(arg0: string[]): B;
        customCondition(arg0: Internal.JsonObject): B;
        matchKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): B;
        randomChanceWithLooting(arg0: number, arg1: number): B;
        hasAnyStage(arg0: string[]): B;
        randomChanceWithEnchantment(arg0: Internal.Enchantment, arg1: number[]): B;
        matchDamageSource(arg0: (arg0: Internal.DamageSourcePredicateBuilderJS) => void): B;
        anyStructure(arg0: ResourceLocation[], arg1: boolean): B;
    }
    class File implements Internal.Serializable, Internal.Comparable<Internal.File> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getUsableSpace(): number;
        static listRoots(): Internal.File[];
        renameTo(arg0: Internal.File): boolean;
        getName(): string;
        setExecutable(arg0: boolean, arg1: boolean): boolean;
        setExecutable(arg0: boolean): boolean;
        canRead(): boolean;
        notifyAll(): void;
        getCanonicalFile(): Internal.File;
        compareTo(arg0: Internal.File): number;
        compareTo(arg0: any): number;
        delete(): boolean;
        notify(): void;
        setReadable(arg0: boolean): boolean;
        setReadable(arg0: boolean, arg1: boolean): boolean;
        getTotalSpace(): number;
        hashCode(): number;
        getParentFile(): Internal.File;
        getPath(): string;
        getAbsoluteFile(): Internal.File;
        listFiles(arg0: Internal.FilenameFilter): Internal.File[];
        listFiles(arg0: Internal.FileFilter): Internal.File[];
        listFiles(): Internal.File[];
        mkdir(): boolean;
        deleteOnExit(): void;
        canExecute(): boolean;
        getCanonicalPath(): string;
        toURL(): Internal.URL;
        getParent(): string;
        setWritable(arg0: boolean): boolean;
        setWritable(arg0: boolean, arg1: boolean): boolean;
        isFile(): boolean;
        getAbsolutePath(): string;
        toURI(): Internal.URI;
        getFreeSpace(): number;
        length(): number;
        canWrite(): boolean;
        static createTempFile(arg0: string, arg1: string, arg2: Internal.File): Internal.File;
        static createTempFile(arg0: string, arg1: string): Internal.File;
        list(): string[];
        list(arg0: Internal.FilenameFilter): string[];
        isHidden(): boolean;
        toPath(): Internal.Path;
        mkdirs(): boolean;
        equals(arg0: any): boolean;
        exists(): boolean;
        isAbsolute(): boolean;
        toString(): string;
        lastModified(): number;
        createNewFile(): boolean;
        setLastModified(arg0: number): boolean;
        isDirectory(): boolean;
        setReadOnly(): boolean;
        static readonly pathSeparator : ";";
        static readonly pathSeparatorChar : ";";
        static readonly separatorChar : "\\";
        static readonly separator : "\\";
        get parent(): string;
        get parentFile(): Internal.File;
        get hidden(): boolean;
        get freeSpace(): number;
        get usableSpace(): number;
        get totalSpace(): number;
        get canonicalFile(): Internal.File;
        get directory(): boolean;
        get path(): string;
        get absoluteFile(): Internal.File;
        get file(): boolean;
        get absolute(): boolean;
        get name(): string;
        get canonicalPath(): string;
        get absolutePath(): string;
        get class(): Internal.Class<any>;
        set readable(arg0: boolean);
        set executable(arg0: boolean);
        set writable(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ItemTooltipEventJS extends Internal.EventJS {
        cancel(): void;
        add(item: any, text: any): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        isAlt(): boolean;
        notifyAll(): void;
        addAdvancedToAll(handler: Internal.ItemTooltipEventJS$StaticTooltipHandlerFromJS): void;
        notify(): void;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        isCtrl(): boolean;
        hashCode(): number;
        isShift(): boolean;
        addAdvanced(item: any, handler: Internal.ItemTooltipEventJS$StaticTooltipHandlerFromJS): void;
        equals(arg0: any): boolean;
        toString(): string;
        addToAll(text: any): void;
        canCancel(): boolean;
        get ctrl(): boolean;
        get shift(): boolean;
        get alt(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FireworksJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static of(o: any): Internal.FireworksJS;
        toString(): string;
        createFireworkRocket(w: net.minecraft.world.level.Level, x: number, y: number, z: number): Internal.FireworkRocketEntity;
        notify(): void;
        flight : number;
        lifetime : number;
        readonly explosions : Internal.List<Internal.FireworksJS$Explosion>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class HashSet <E> extends Internal.AbstractSet<any> implements Internal.Set<E>, Internal.Cloneable, Internal.Serializable {
        add(arg0: E): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: (arg0: E) => void): void;
        notifyAll(): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        notify(): void;
        remove(arg0: any): boolean;
        removeIf(arg0: (arg0: E) => boolean): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.Iterator<E>;
        size(): number;
        stream(): Internal.Stream<E>;
        addAll(arg0: Internal.Collection<E>): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray(): any[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        clone(): any;
        parallelStream(): Internal.Stream<E>;
        toString(): string;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AsKJS {
        asKJS(): any;
    }
    class CodingErrorAction {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        static readonly REPORT : Internal.CodingErrorAction;
        static readonly IGNORE : Internal.CodingErrorAction;
        static readonly REPLACE : Internal.CodingErrorAction;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Kind1 <F, Mu> extends Internal.App<Mu, F> {
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>): Internal.Products$P11<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>): Internal.Products$P10<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>): Internal.Products$P9<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>, arg14: Internal.App<Mu, T15_>, arg15: Internal.App<Mu, T16_>): Internal.Products$P16<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>, arg14: Internal.App<Mu, T15_>): Internal.Products$P15<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>): Internal.Products$P14<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>): Internal.Products$P13<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>): Internal.Products$P12<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>;
        group<T1_, T2_, T3_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>): Internal.Products$P3<Mu, T1_, T2_, T3_>;
        group<T1_, T2_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>): Internal.Products$P2<Mu, T1_, T2_>;
        group<T1_>(arg0: Internal.App<Mu, T1_>): Internal.Products$P1<Mu, T1_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>): Internal.Products$P8<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>): Internal.Products$P7<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>): Internal.Products$P6<Mu, T1_, T2_, T3_, T4_, T5_, T6_>;
        group<T1_, T2_, T3_, T4_, T5_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>): Internal.Products$P5<Mu, T1_, T2_, T3_, T4_, T5_>;
        group<T1_, T2_, T3_, T4_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>): Internal.Products$P4<Mu, T1_, T2_, T3_, T4_>;
    }
    class NativeJavaObject implements Internal.Scriptable, Internal.SymbolScriptable, Internal.Wrapper, Internal.Serializable {
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hasInstance(value: Internal.Scriptable): boolean;
        setParentScope(m: Internal.Scriptable): void;
        static canConvert(cx: Internal.Context, fromObj: any, to: Internal.Class<any>): boolean;
        notifyAll(): void;
        getIds(): any[];
        addCustomProperty(name: string, getter: Internal.CustomProperty): void;
        getAllIds(): any[];
        delete(index: number): void;
        delete(key: Internal.Symbol): void;
        delete(name: string): void;
        notify(): void;
        put(index: number, start: Internal.Scriptable, value: any): void;
        put(name: string, start: Internal.Scriptable, value: any): void;
        put(symbol: Internal.Symbol, start: Internal.Scriptable, value: any): void;
        unwrap(): any;
        getDefaultValue(hint: Internal.Class<any>): any;
        setPrototype(m: Internal.Scriptable): void;
        getPrototype(): Internal.Scriptable;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(key: Internal.Symbol, start: Internal.Scriptable): any;
        get(index: number, start: Internal.Scriptable): any;
        get(name: string, start: Internal.Scriptable): any;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        has(name: string, start: Internal.Scriptable): boolean;
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean;
        has(index: number, start: Internal.Scriptable): boolean;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        static readonly NOT_FOUND : any;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get className(): string;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get prototype(): Internal.Scriptable;
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PrimitiveIterator$OfDouble extends Internal.PrimitiveIterator<number, Internal.DoubleConsumer> {
        next(): any;
        next(): number;
        hasNext(): boolean;
        forEachRemaining(arg0: any): void;
        forEachRemaining(arg0: Internal.DoubleConsumer): void;
        forEachRemaining(arg0: (arg0: number) => void): void;
        remove(): void;
        nextDouble(): number;
    }
    abstract class AbstractSet <E> extends Internal.AbstractCollection<any> implements Internal.Set<E> {
        add(arg0: E): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: (arg0: E) => void): void;
        notifyAll(): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        notify(): void;
        remove(arg0: any): boolean;
        removeIf(arg0: (arg0: E) => boolean): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.Iterator<E>;
        removeAll(arg0: Internal.Collection<any>): boolean;
        size(): number;
        stream(): Internal.Stream<E>;
        addAll(arg0: Internal.Collection<E>): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        toString(): string;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjectCollection <K> extends Internal.Collection<K>, Internal.ObjectIterable<K> {
        add(arg0: K): boolean;
        spliterator(): Internal.ObjectSpliterator<K>;
        spliterator(): Internal.Spliterator<any>;
        forEach(arg0: (arg0: K) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        remove(arg0: any): boolean;
        removeIf(arg0: (arg0: K) => boolean): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.Iterator<any>;
        iterator(): Internal.ObjectIterator<K>;
        size(): number;
        addAll(arg0: Internal.Collection<K>): boolean;
        stream(): Internal.Stream<K>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<K>;
        retainAll(arg0: Internal.Collection<any>): boolean;
    }
    interface LevelWriter {
    }
    interface EventLoop extends Internal.OrderedEventExecutor, Internal.EventLoopGroup {
        next(): Internal.EventExecutor;
        next(): Internal.EventLoop;
        terminationFuture(): Internal.Future<any>;
        parent(): Internal.EventLoopGroup;
        parent(): Internal.EventExecutorGroup;
        newProgressivePromise<V_>(): Internal.ProgressivePromise<V_>;
        shutdownGracefully(): Internal.Future<any>;
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit): Internal.Future<any>;
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): Internal.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): java_.util.concurrent.Future<T_>;
        submit(arg0: Internal.Runnable): Internal.Future<any>;
        submit(arg0: Internal.Runnable): java_.util.concurrent.Future<any>;
        submit<T_>(arg0: Internal.Runnable, arg1: T_): Internal.Future<T_>;
        submit<T_>(arg0: Internal.Runnable, arg1: T_): java_.util.concurrent.Future<T_>;
        isTerminated(): boolean;
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>;
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        inEventLoop(arg0: Internal.Thread): boolean;
        inEventLoop(): boolean;
        iterator(): Internal.Iterator<Internal.EventExecutor>;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean;
        shutdownNow(): Internal.List<Internal.Runnable>;
        newPromise<V_>(): Internal.Promise<V_>;
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>;
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        forEach(arg0: (arg0: Internal.EventExecutor) => void): void;
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<java_.util.concurrent.Future<T_>>;
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): Internal.List<java_.util.concurrent.Future<T_>>;
        newFailedFuture<V_>(arg0: Internal.Throwable): Internal.Future<V_>;
        execute(arg0: Internal.Runnable): void;
        isShuttingDown(): boolean;
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<any>;
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V_>;
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<V_>;
        newSucceededFuture<V_>(arg0: V_): Internal.Future<V_>;
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): T_;
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): T_;
        shutdown(): void;
        register(arg0: io.netty.channel.Channel, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        register(arg0: Internal.ChannelPromise): Internal.ChannelFuture;
        register(arg0: io.netty.channel.Channel): Internal.ChannelFuture;
        isShutdown(): boolean;
    }
    interface RecvByteBufAllocator$Handle {
        continueReading(): boolean;
        incMessagesRead(arg0: number): void;
        allocate(arg0: Internal.ByteBufAllocator): Internal.ByteBuf;
        guess(): number;
        reset(arg0: Internal.ChannelConfig): void;
        attemptedBytesRead(arg0: number): void;
        attemptedBytesRead(): number;
        readComplete(): void;
        lastBytesRead(): number;
        lastBytesRead(arg0: number): void;
    }
    interface VertexType <T> {
        createFallbackWriter(arg0: Internal.VertexConsumer): T;
        asBlittable(): Internal.BlittableVertexType<T>;
    }
    abstract class StateHolder <O, S> implements Internal.FastMapStateHolder<any> {
        getNeighborTable(): Internal.Table<any, any, any>;
        getStateIndex(): number;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        redirect$zhl000$getNeighborFromFastMap(ignore: Internal.Table<any, any, any>, rowKey: any, columnKey: any): any;
        setNeighborTable(table: Internal.Table<any, any, any>): void;
        notifyAll(): void;
        setStateMap(newValue: Internal.FastMap<any>): void;
        getStateMap(): Internal.FastMap<any>;
        notify(): void;
        replacePropertyMap(newMap: Internal.ImmutableMap<any, any>): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        setStateIndex(newValue: number): void;
        toString(): string;
        getVanillaPropertyMap(): Internal.ImmutableMap<any, any>;
        get stateIndex(): number;
        get neighborTable(): Internal.Table<any, any, any>;
        get stateMap(): Internal.FastMap<any>;
        get class(): Internal.Class<any>;
        get vanillaPropertyMap(): Internal.ImmutableMap<any, any>;
        set stateIndex(newValue: number);
        set stateMap(newValue: Internal.FastMap<any>);
        set neighborTable(table: Internal.Table<any, any, any>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface GenericFutureListener <F> extends Internal.EventListener {
        operationComplete(arg0: F): void;
    }
    interface Functor <F, Mu> extends Internal.Kind1<F, Mu> {
        map<T_, R_>(arg0: (arg0: T_) => R_, arg1: Internal.App<Mu, T_>): Internal.App<Mu, R_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>): Internal.Products$P11<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>): Internal.Products$P10<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>): Internal.Products$P9<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>, arg14: Internal.App<Mu, T15_>, arg15: Internal.App<Mu, T16_>): Internal.Products$P16<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>, arg14: Internal.App<Mu, T15_>): Internal.Products$P15<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>): Internal.Products$P14<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>): Internal.Products$P13<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>): Internal.Products$P12<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>;
        group<T1_, T2_, T3_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>): Internal.Products$P3<Mu, T1_, T2_, T3_>;
        group<T1_, T2_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>): Internal.Products$P2<Mu, T1_, T2_>;
        group<T1_>(arg0: Internal.App<Mu, T1_>): Internal.Products$P1<Mu, T1_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>): Internal.Products$P8<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>): Internal.Products$P7<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>): Internal.Products$P6<Mu, T1_, T2_, T3_, T4_, T5_, T6_>;
        group<T1_, T2_, T3_, T4_, T5_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>): Internal.Products$P5<Mu, T1_, T2_, T3_, T4_, T5_>;
        group<T1_, T2_, T3_, T4_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>): Internal.Products$P4<Mu, T1_, T2_, T3_, T4_>;
    }
    interface IVertexConsumer {
        setQuadOrientation(arg0: Internal.Direction): void;
        setTexture(arg0: Internal.TextureAtlasSprite): void;
        setApplyDiffuseLighting(arg0: boolean): void;
        setQuadTint(arg0: number): void;
        getVertexFormat(): Internal.VertexFormat;
        put(arg0: number, arg1: number[]): void;
    }
    class EndimationEffectHandler {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        reset(): void;
        update(arg0: Internal.Endimation, arg1: number): void;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class WrapFactory {
        getClass(): Internal.Class<any>;
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, javaObject: any, staticType: Internal.Class<any>): Internal.Scriptable;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        wrapJavaClass(cx: Internal.Context, scope: Internal.Scriptable, javaClass: Internal.Class<any>): Internal.Scriptable;
        setJavaPrimitiveWrap(value: boolean): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        isJavaPrimitiveWrap(): boolean;
        toString(): string;
        wrapNewObject(cx: Internal.Context, scope: Internal.Scriptable, obj: any): Internal.Scriptable;
        wrap(cx: Internal.Context, scope: Internal.Scriptable, obj: any, staticType: Internal.Class<any>): any;
        notify(): void;
        get javaPrimitiveWrap(): boolean;
        get class(): Internal.Class<any>;
        set javaPrimitiveWrap(value: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Enumeration <E> {
        hasMoreElements(): boolean;
        asIterator(): Internal.Iterator<E>;
        nextElement(): E;
    }
    interface SecretKey extends Internal.Key, Internal.Destroyable {
        getEncoded(): number[];
        isDestroyed(): boolean;
        getAlgorithm(): string;
        destroy(): void;
        getFormat(): string;
    }
    class Item$Properties {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        setNoRepair(): Internal.Item$Properties;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ServerEntityManagerAccessor <T> {
        getCache(): Internal.EntitySectionStorage<T>;
    }
    interface Future <V> extends java_.util.concurrent.Future<V> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>;
        getNow(): V;
        cause(): Internal.Throwable;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean;
        awaitUninterruptibly(): Internal.Future<V>;
        awaitUninterruptibly(arg0: number): boolean;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>;
        isDone(): boolean;
        sync(): Internal.Future<V>;
        syncUninterruptibly(): Internal.Future<V>;
        get(arg0: number, arg1: Internal.TimeUnit): V;
        get(): V;
        isCancellable(): boolean;
        await(arg0: number, arg1: Internal.TimeUnit): boolean;
        await(): Internal.Future<V>;
        await(arg0: number): boolean;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>;
        isSuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>;
    }
    interface ContextFactory$Listener {
        contextReleased(arg0: Internal.Context): void;
        contextCreated(arg0: Internal.Context): void;
    }
    interface Delayed extends Internal.Comparable<Internal.Delayed> {
        getDelay(arg0: Internal.TimeUnit): number;
        compareTo(arg0: Internal.Delayed): number;
    }
    class Products$P13 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ArmedModel {
    }
    class LunarTextComponents$Notification {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getNotificationType(): Internal.LunarTextComponents$NotificationType;
        notify(): void;
        getCustomTranslationTextComponent(): Internal.CustomTranslationTextComponent;
        static readonly CODEC : Internal.Codec<Internal.LunarTextComponents$Notification>;
        static readonly DEFAULT : Internal.LunarTextComponents$Notification;
        get notificationType(): Internal.LunarTextComponents$NotificationType;
        get class(): Internal.Class<any>;
        get customTranslationTextComponent(): Internal.CustomTranslationTextComponent;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Watchable {
        register(arg0: Internal.WatchService, arg1: Internal.WatchEvent$Kind<any>[], arg2: any[]): Internal.WatchKey;
        register(arg0: Internal.WatchService, arg1: Internal.WatchEvent$Kind<any>[]): Internal.WatchKey;
    }
    interface Short2ObjectFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: number, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        put(arg0: number, arg1: V): V;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: V): V;
        remove(arg0: number): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): V;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface ProcessorHandle <Msg> extends Internal.AutoCloseable {
        close(): void;
    }
    class URI implements Internal.Comparable<Internal.URI>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        toASCIIString(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        resolve(arg0: string): Internal.URI;
        resolve(arg0: Internal.URI): Internal.URI;
        isOpaque(): boolean;
        notifyAll(): void;
        compareTo(arg0: Internal.URI): number;
        compareTo(arg0: any): number;
        notify(): void;
        getRawAuthority(): string;
        hashCode(): number;
        normalize(): Internal.URI;
        getPath(): string;
        static create(arg0: string): Internal.URI;
        relativize(arg0: Internal.URI): Internal.URI;
        getQuery(): string;
        getHost(): string;
        toURL(): Internal.URL;
        getScheme(): string;
        getAuthority(): string;
        getRawFragment(): string;
        getRawUserInfo(): string;
        parseServerAuthority(): Internal.URI;
        getRawSchemeSpecificPart(): string;
        getRawQuery(): string;
        getPort(): number;
        equals(arg0: any): boolean;
        isAbsolute(): boolean;
        toString(): string;
        getFragment(): string;
        getRawPath(): string;
        getUserInfo(): string;
        getSchemeSpecificPart(): string;
        get rawFragment(): string;
        get userInfo(): string;
        get opaque(): boolean;
        get scheme(): string;
        get query(): string;
        get schemeSpecificPart(): string;
        get rawUserInfo(): string;
        get path(): string;
        get fragment(): string;
        get rawPath(): string;
        get rawSchemeSpecificPart(): string;
        get port(): number;
        get rawAuthority(): string;
        get absolute(): boolean;
        get authority(): string;
        get host(): string;
        get class(): Internal.Class<any>;
        get rawQuery(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MapEncoder <A> extends Internal.Keyable {
        encode<T_>(arg0: A, arg1: Internal.DynamicOps<T_>, arg2: Internal.RecordBuilder<T_>): Internal.RecordBuilder<T_>;
        flatComap<B_>(arg0: (arg0: B_) => Internal.DataResult<A>): Internal.MapEncoder<B_>;
        compressedBuilder<T_>(arg0: Internal.DynamicOps<T_>): Internal.RecordBuilder<T_>;
        keys<T_>(arg0: Internal.DynamicOps<T_>): Internal.Stream<T_>;
        comap<B_>(arg0: (arg0: B_) => A): Internal.MapEncoder<B_>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapEncoder<A>;
        encoder(): Internal.Encoder<A>;
        compressor<T_>(arg0: Internal.DynamicOps<T_>): Internal.KeyCompressor<T_>;
    }
    interface Char2FloatFunction extends it.unimi.dsi.fastutil.Function<string, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: string, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: string) => T_;
        put(arg0: string, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: string, arg1: number): number;
        remove(arg0: string): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: string): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: string): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface BakedQuadAccess {
        setVertices(arg0: number[]): void;
    }
    abstract class IngredientAction extends Internal.IngredientActionFilter {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        checkFilter(index: number, stack: Internal.ItemStack): boolean;
        static getRemaining(container: Internal.CraftingContainer, index: number, ingredientActions: Internal.List<Internal.IngredientAction>): Internal.ItemStack;
        notifyAll(): void;
        static parseList(json: Internal.JsonElement): Internal.List<Internal.IngredientAction>;
        static filterOf(o: any): Internal.IngredientActionFilter;
        notify(): void;
        copyFrom(filter: Internal.IngredientActionFilter): void;
        static readList(buf: Internal.FriendlyByteBuf): Internal.List<Internal.IngredientAction>;
        toJson(json: Internal.JsonObject): void;
        toJson(): Internal.JsonObject;
        transform(arg0: Internal.ItemStack, arg1: number, arg2: Internal.CraftingContainer): Internal.ItemStack;
        static writeList(buf: Internal.FriendlyByteBuf, list: Internal.List<Internal.IngredientAction>): void;
        getType(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        static readonly FACTORY_MAP : Internal.Map<string, (arg0: Internal.JsonObject) => Internal.IngredientAction>;
        filterIndex : number;
        filterIngredient : Internal.IngredientJS;
        get type(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MinecraftServerKJS extends Internal.AsKJS {
        getServerResourcesKJS(): Internal.ServerResources;
        asKJS(): any;
    }
    abstract class LivingEntityEventJS extends Internal.EntityEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.LevelJS;
        post(id: string, sub: string): boolean;
        post(id: string): boolean;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class StandardLevel extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(name: string): Internal.StandardLevel;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.StandardLevel[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.StandardLevel): number;
        intLevel(): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.StandardLevel>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.StandardLevel>;
        hashCode(): number;
        static getStandardLevel(intLevel: number): Internal.StandardLevel;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly TRACE : Internal.StandardLevel;
        static readonly ALL : Internal.StandardLevel;
        static readonly ERROR : Internal.StandardLevel;
        static readonly INFO : Internal.StandardLevel;
        static readonly FATAL : Internal.StandardLevel;
        static readonly DEBUG : Internal.StandardLevel;
        static readonly OFF : Internal.StandardLevel;
        static readonly WARN : Internal.StandardLevel;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.StandardLevel>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Material <D> {
        getModel(arg0: Internal.PartialModel, arg1: Internal.BlockState, arg2: Internal.Direction): Internal.Instancer<D>;
        getModel(arg0: Internal.PartialModel, arg1: Internal.BlockState, arg2: Internal.Direction, arg3: () => Internal.PoseStack): Internal.Instancer<D>;
        getModel(arg0: Internal.BlockState): Internal.Instancer<D>;
        getModel(arg0: Internal.PartialModel): Internal.Instancer<D>;
        getModel(arg0: Internal.PartialModel, arg1: Internal.BlockState): Internal.Instancer<D>;
        model(arg0: any, arg1: () => Internal.Model): Internal.Instancer<D>;
    }
    class Pair$Mu <S> implements Internal.K1 {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Reference2ByteFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        getByte(arg0: any): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_;
        put(arg0: K, arg1: number): number;
        put(arg0: K, arg1: number): number;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): any;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        get(arg0: any): number;
        get(arg0: any): any;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        removeByte(arg0: any): number;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: K): number;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class IngredientActionFilter {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        checkFilter(index: number, stack: Internal.ItemStack): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        static filterOf(o: any): Internal.IngredientActionFilter;
        notify(): void;
        copyFrom(filter: Internal.IngredientActionFilter): void;
        filterIndex : number;
        filterIngredient : Internal.IngredientJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DoubleStream$DoubleMapMultiConsumer {
        accept(arg0: number, arg1: Internal.DoubleConsumer): void;
    }
    interface SpriteExtended {
        setActive(arg0: boolean): void;
        isActive(): boolean;
    }
    class TwoHandedAnimation {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setTwoHanded(arg0: boolean): void;
        hashCode(): number;
        isTwoHanded(): boolean;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get twoHanded(): boolean;
        get class(): Internal.Class<any>;
        set twoHanded(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface SkyRenderable {
        renderSky(arg0: Internal.PoseStack, arg1: number): void;
    }
    class IngredientStackJS implements Internal.IngredientJS {
        anyStackMatches(ingredient: Internal.IngredientJS): boolean;
        getItemIds(): Internal.Set<string>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getStacks(): Internal.Set<Internal.ItemStackJS>;
        getVanillaItems(): Internal.Set<Internal.Item>;
        notifyAll(): void;
        isInvalidRecipeIngredient(): boolean;
        notify(): void;
        not(): Internal.IngredientJS;
        hashCode(): number;
        getFirst(): Internal.ItemStackJS;
        static stackOf(in_: Internal.IngredientJS): Internal.IngredientStackJS;
        copy(): Internal.Copyable;
        copy(): Internal.IngredientJS;
        getCount(): number;
        testVanillaItem(item: Internal.Item): boolean;
        test(stack: Internal.ItemStackJS): boolean;
        isEmpty(): boolean;
        asIngredientStack(): Internal.IngredientStackJS;
        getVanillaPredicate(): (arg0: Internal.ItemStack) => boolean;
        filter(filter: Internal.IngredientJS): Internal.IngredientJS;
        createVanillaIngredient(): (arg0: any) => boolean;
        toJson(): Internal.JsonElement;
        withCount(count: number): Internal.IngredientJS;
        getIngredient(): Internal.IngredientJS;
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>;
        equals(arg0: any): boolean;
        testVanilla(stack: Internal.ItemStack): boolean;
        x(c: number): Internal.IngredientJS;
        toString(): string;
        ingredientKey : string;
        ingredient : Internal.IngredientJS;
        countKey : string;
        get invalidRecipeIngredient(): boolean;
        get stacks(): Internal.Set<Internal.ItemStackJS>;
        get itemIds(): Internal.Set<string>;
        get count(): number;
        get class(): Internal.Class<any>;
        get vanillaItems(): Internal.Set<Internal.Item>;
        get first(): Internal.ItemStackJS;
        get empty(): boolean;
        get vanillaPredicate(): (arg0: Internal.ItemStack) => boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Spliterator$OfDouble extends Internal.Spliterator$OfPrimitive<number, Internal.DoubleConsumer, Internal.Spliterator$OfDouble> {
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>;
        trySplit(): Internal.Spliterator<any>;
        trySplit(): Internal.Spliterator$OfDouble;
        characteristics(): number;
        tryAdvance(arg0: Internal.DoubleConsumer): boolean;
        tryAdvance(arg0: (arg0: number) => void): boolean;
        tryAdvance(arg0: any): boolean;
        getComparator(): Internal.Comparator<number>;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: any): void;
        forEachRemaining(arg0: Internal.DoubleConsumer): void;
        forEachRemaining(arg0: (arg0: number) => void): void;
    }
    interface Marker extends Internal.Serializable {
        getParents(): Internal.Marker[];
        setParents(markers: Internal.Marker[]): Internal.Marker;
        getName(): string;
        hasParents(): boolean;
        hashCode(): number;
        equals(obj: any): boolean;
        isInstanceOf(name: string): boolean;
        isInstanceOf(m: Internal.Marker): boolean;
        addParents(markers: Internal.Marker[]): Internal.Marker;
        remove(marker: Internal.Marker): boolean;
    }
    interface DoubleFunction <R> {
        apply(arg0: number): R;
    }
    interface Double2ReferenceFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: number, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        put(arg0: number, arg1: V): V;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: V): V;
        remove(arg0: number): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): V;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class ClientPlayerDataJS extends Internal.PlayerDataJS<any, any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.ClientPlayerJS;
        getPlayer(): Internal.PlayerJS<any>;
        getName(): string;
        notifyAll(): void;
        getProfile(): Internal.GameProfile;
        getId(): Internal.UUID;
        getOverworld(): Internal.LevelJS;
        notify(): void;
        getLevel(): Internal.ClientLevelJS;
        getMinecraftPlayer(): Internal.Player;
        hashCode(): number;
        equals(arg0: any): boolean;
        hasClientMod(): boolean;
        toString(): string;
        getData(): Internal.AttachedData;
        get data(): Internal.AttachedData;
        get level(): Internal.ClientLevelJS;
        get minecraftPlayer(): Internal.Player;
        get profile(): Internal.GameProfile;
        get name(): string;
        get id(): Internal.UUID;
        get overworld(): Internal.LevelJS;
        get class(): Internal.Class<any>;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class RenderStateShard implements Internal.RenderTypeAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get name(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Short2CharFunction extends it.unimi.dsi.fastutil.Function<number, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: number, arg1: string): string;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: number, arg1: string): string;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: string): string;
        remove(arg0: number): string;
        remove(arg0: any): string;
        remove(arg0: any): any;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): string;
        get(arg0: any): any;
        get(arg0: number): string;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): string;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => string;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class DistancePredicateBuilder {
        getClass(): Internal.Class<any>;
        horizontal(arg0: Internal.MinMaxBounds$Doubles): Internal.DistancePredicateBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.DistancePredicate;
        hashCode(): number;
        absolute(arg0: Internal.MinMaxBounds$Doubles): Internal.DistancePredicateBuilder;
        notifyAll(): void;
        equals(arg0: any): boolean;
        x(arg0: Internal.MinMaxBounds$Doubles): Internal.DistancePredicateBuilder;
        y(arg0: Internal.MinMaxBounds$Doubles): Internal.DistancePredicateBuilder;
        toString(): string;
        z(arg0: Internal.MinMaxBounds$Doubles): Internal.DistancePredicateBuilder;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class MethodHandle implements Internal.Constable {
        asCollector(arg0: Internal.Class<any>, arg1: number): Internal.MethodHandle;
        asCollector(arg0: number, arg1: Internal.Class<any>, arg2: number): Internal.MethodHandle;
        asSpreader(arg0: number, arg1: Internal.Class<any>, arg2: number): Internal.MethodHandle;
        asSpreader(arg0: Internal.Class<any>, arg1: number): Internal.MethodHandle;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        withVarargs(arg0: boolean): Internal.MethodHandle;
        invokeExact(arg0: any[]): any;
        notifyAll(): void;
        invoke(arg0: any[]): any;
        type(): Internal.MethodType;
        describeConstable(): Internal.Optional<Internal.MethodHandleDesc>;
        notify(): void;
        bindTo(arg0: any): Internal.MethodHandle;
        asVarargsCollector(arg0: Internal.Class<any>): Internal.MethodHandle;
        asType(arg0: Internal.MethodType): Internal.MethodHandle;
        invokeWithArguments(arg0: any[]): any;
        invokeWithArguments(arg0: Internal.List<any>): any;
        hashCode(): number;
        equals(arg0: any): boolean;
        isVarargsCollector(): boolean;
        asFixedArity(): Internal.MethodHandle;
        toString(): string;
        get varargsCollector(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface GuiEventListener {
    }
    class OrCondition implements Internal.IExtendedLootCondition {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: (arg0: Internal.LootContext) => boolean): (arg0: Internal.LootContext) => boolean;
        test(arg0: Internal.LootContext): boolean;
        test(arg0: any): boolean;
        and(arg0: (arg0: Internal.LootContext) => boolean): (arg0: Internal.LootContext) => boolean;
        negate(): (arg0: Internal.LootContext) => boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class IdFunctionObject extends Internal.BaseFunction {
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        setParentScope(m: Internal.Scriptable): void;
        static redefineProperty(obj: Internal.Scriptable, name: string, isConst: boolean): void;
        putConst(name: string, start: Internal.Scriptable, value: any): void;
        static getTypedProperty<T_>(s: Internal.Scriptable, index: number, type: Internal.Class<T_>): T_;
        static getTypedProperty<T_>(s: Internal.Scriptable, name: string, type: Internal.Class<T_>): T_;
        getIds(): any[];
        static getArrayPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        construct(cx: Internal.Context, scope: Internal.Scriptable, args: any[]): Internal.Scriptable;
        getAllIds(): any[];
        put(key: Internal.Symbol, start: Internal.Scriptable, value: any): void;
        put(name: string, start: Internal.Scriptable, value: any): void;
        put(index: number, start: Internal.Scriptable, value: any): void;
        getArity(): number;
        getDefaultValue(typeHint: Internal.Class<any>): any;
        static getDefaultValue(object: Internal.Scriptable, typeHint: Internal.Class<any>): any;
        defineOwnProperties(cx: Internal.Context, props: Internal.ScriptableObject): void;
        defineProperty(propertyName: string, clazz: Internal.Class<any>, attributes: number): void;
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method, setter: Internal.Method, attributes: number): void;
        defineProperty(propertyName: string, value: any, attributes: number): void;
        defineProperty(key: Internal.Symbol, value: any, attributes: number): void;
        static defineProperty(destination: Internal.Scriptable, propertyName: string, value: any, attributes: number): void;
        hasPrototypeMap(): boolean;
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable, isSetter: boolean): void;
        avoidObjectDetection(): boolean;
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean;
        has(name: string, start: Internal.Scriptable): boolean;
        has(index: number, start: Internal.Scriptable): boolean;
        getFunctionName(): string;
        getExternalArrayLength(): any;
        getAttributes(name: string): number;
        getAttributes(key: Internal.Symbol): number;
        getAttributes(index: number): number;
        setImmunePrototypeProperty(value: any): void;
        hasInstance(instance: Internal.Scriptable): boolean;
        hasTag(tag: any): boolean;
        getAssociatedValue(key: any): any;
        execIdCall(f: Internal.IdFunctionObject, cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any;
        static getPropertyIds(obj: Internal.Scriptable): any[];
        static hasProperty(obj: Internal.Scriptable, index: number): boolean;
        static hasProperty(obj: Internal.Scriptable, name: string): boolean;
        static hasProperty(obj: Internal.Scriptable, key: Internal.Symbol): boolean;
        getExternalArrayData(): Internal.ExternalArrayData;
        size(): number;
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol, functionName: string, arity: number): Internal.IdFunctionObject;
        defineOwnProperty(cx: Internal.Context, key: any, desc: Internal.ScriptableObject): void;
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void;
        initPrototypeValue(id: number, key: Internal.Symbol, value: any, attributes: number): void;
        static getFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        preventExtensions(): void;
        setExternalArrayData(array: Internal.ExternalArrayData): void;
        static callMethod(obj: Internal.Scriptable, methodName: string, args: any[]): any;
        static callMethod(cx: Internal.Context, obj: Internal.Scriptable, methodName: string, args: any[]): any;
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        getTypeOf(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        addAsProperty(target: Internal.Scriptable): void;
        static getTopScopeValue(scope: Internal.Scriptable, key: any): any;
        initPrototypeConstructor(f: Internal.IdFunctionObject): void;
        notifyAll(): void;
        methodId(): number;
        sealObject(): void;
        setAttributes(name: string, attributes: number): void;
        setAttributes(index: number, attributes: number): void;
        setAttributes(key: Internal.Symbol, attributes: number): void;
        static putProperty(obj: Internal.Scriptable, index: number, value: any): void;
        static putProperty(obj: Internal.Scriptable, key: Internal.Symbol, value: any): void;
        static putProperty(obj: Internal.Scriptable, name: string, value: any): void;
        delete(key: Internal.Symbol): void;
        delete(name: string): void;
        delete(index: number): void;
        notify(): void;
        associateValue(key: any, value: any): any;
        static deleteProperty(obj: Internal.Scriptable, name: string): boolean;
        static deleteProperty(obj: Internal.Scriptable, index: number): boolean;
        unknown(): Internal.RuntimeException;
        getPrototype(): Internal.Scriptable;
        static getObjectPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        isExtensible(): boolean;
        markAsConstructor(prototypeProperty: Internal.Scriptable): void;
        exportAsScopeProperty(): void;
        hashCode(): number;
        isConst(name: string): boolean;
        get(name: string, start: Internal.Scriptable): any;
        get(key: Internal.Symbol, start: Internal.Scriptable): any;
        get(index: number, start: Internal.Scriptable): any;
        get(key: any): any;
        static putConstProperty(obj: Internal.Scriptable, name: string, value: any): void;
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any;
        static getTopLevelScope(obj: Internal.Scriptable): Internal.Scriptable;
        static getProperty(obj: Internal.Scriptable, name: string): any;
        static getProperty(obj: Internal.Scriptable, key: Internal.Symbol): any;
        static getProperty(obj: Internal.Scriptable, index: number): any;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean): void;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>): void;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean, mapInheritance: boolean): string;
        initFunction(name: string, scope: Internal.Scriptable): void;
        activatePrototypeMap(maxPrototypeId: number): void;
        isEmpty(): boolean;
        defineFunctionProperties(names: string[], clazz: Internal.Class<any>, attributes: number): void;
        getTag(): any;
        static getClassPrototype(scope: Internal.Scriptable, className: string): Internal.Scriptable;
        createObject(cx: Internal.Context, scope: Internal.Scriptable): Internal.Scriptable;
        setPrototype(m: Internal.Scriptable): void;
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable, sealed: boolean): Internal.IdFunctionObject;
        call(cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any;
        defineConst(name: string, start: Internal.Scriptable): void;
        equals(arg0: any): boolean;
        static defineConstProperty(destination: Internal.Scriptable, propertyName: string): void;
        getLength(): number;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get functionName(): string;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get length(): number;
        get className(): string;
        get prototype(): Internal.Scriptable;
        get empty(): boolean;
        get arity(): number;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get externalArrayLength(): any;
        get tag(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get extensible(): boolean;
        get typeOf(): string;
        set immunePrototypeProperty(value: any);
        set externalArrayData(array: Internal.ExternalArrayData);
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MapDecoder <A> extends Internal.Keyable {
        flatMap<B_>(arg0: (arg0: A) => Internal.DataResult<B_>): Internal.MapDecoder<B_>;
        compressedDecode<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<A>;
        keys<T_>(arg0: Internal.DynamicOps<T_>): Internal.Stream<T_>;
        decoder(): Internal.Decoder<A>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapDecoder<A>;
        decode<T_>(arg0: Internal.DynamicOps<T_>, arg1: Internal.MapLike<T_>): Internal.DataResult<A>;
        map<B_>(arg0: (arg0: A) => B_): Internal.MapDecoder<B_>;
        compressor<T_>(arg0: Internal.DynamicOps<T_>): Internal.KeyCompressor<T_>;
        ap<E_>(arg0: Internal.MapDecoder<(arg0: A) => E_>): Internal.MapDecoder<E_>;
    }
    class Style implements Internal.StyleAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        setObfuscated(arg0: boolean): Internal.Style;
        toString(): string;
        static create_$md$dd73f7$0(arg0: Internal.TextColor, arg1: boolean, arg2: boolean, arg3: boolean, arg4: boolean, arg5: boolean, arg6: Internal.ClickEvent, arg7: Internal.HoverEvent, arg8: string, arg9: ResourceLocation): Internal.Style;
        notify(): void;
        setUnderlined(arg0: boolean): Internal.Style;
        setStrikethrough(arg0: boolean): Internal.Style;
        get class(): Internal.Class<any>;
        set underlined(arg0: boolean);
        set strikethrough(arg0: boolean);
        set obfuscated(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BlockPredicate {
        check(arg0: Internal.BlockContainerJS): boolean;
    }
    interface Channel$Unsafe {
        disconnect(arg0: Internal.ChannelPromise): void;
        deregister(arg0: Internal.ChannelPromise): void;
        recvBufAllocHandle(): Internal.RecvByteBufAllocator$Handle;
        closeForcibly(): void;
        beginRead(): void;
        bind(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): void;
        voidPromise(): Internal.ChannelPromise;
        flush(): void;
        localAddress(): Internal.SocketAddress;
        outboundBuffer(): Internal.ChannelOutboundBuffer;
        close(arg0: Internal.ChannelPromise): void;
        write(arg0: any, arg1: Internal.ChannelPromise): void;
        remoteAddress(): Internal.SocketAddress;
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress, arg2: Internal.ChannelPromise): void;
        register(arg0: Internal.EventLoop, arg1: Internal.ChannelPromise): void;
    }
    class WriteBufferWaterMark {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        high(): number;
        low(): number;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        static readonly DEFAULT : Internal.WriteBufferWaterMark;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ConstantDesc {
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): any;
    }
    abstract class Enchantment extends Internal.ForgeRegistryEntry<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: string, arg1: string): Internal.Enchantment;
        setRegistryName(arg0: ResourceLocation): any;
        setRegistryName(arg0: ResourceLocation): Internal.Enchantment;
        setRegistryName(arg0: string): Internal.Enchantment;
        getTags(): Internal.Set<ResourceLocation>;
        isAllowedOnBooks(): boolean;
        is(arg0: net.minecraft.tags.Tag<Internal.Enchantment>): boolean;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.Enchantment>;
        toString(): string;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack): boolean;
        readonly delegate : () => Internal.Enchantment;
        get registryType(): Internal.Class<Internal.Enchantment>;
        get allowedOnBooks(): boolean;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ICitadelDataEntity {
        setCitadelEntityData(arg0: Internal.CompoundTag): void;
        getCitadelEntityData(): Internal.CompoundTag;
    }
    class VertexFormatElement {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getElementCount(): number;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get elementCount(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class NetworkEvent extends Internal.Event {
        setCanceled(arg0: boolean): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLoginIndex(): number;
        isCanceled(): boolean;
        setResult(arg0: Internal.Event$Result): void;
        notifyAll(): void;
        hasResult(): boolean;
        notify(): void;
        getPayload(): Internal.FriendlyByteBuf;
        getListenerList(): Internal.ListenerList;
        hashCode(): number;
        getSource(): () => Internal.NetworkEvent$Context;
        equals(arg0: any): boolean;
        getResult(): Internal.Event$Result;
        toString(): string;
        isCancelable(): boolean;
        getPhase(): Internal.EventPriority;
        setPhase(arg0: Internal.EventPriority): void;
        get result(): Internal.Event$Result;
        get phase(): Internal.EventPriority;
        get canceled(): boolean;
        get cancelable(): boolean;
        get loginIndex(): number;
        get payload(): Internal.FriendlyByteBuf;
        get listenerList(): Internal.ListenerList;
        get source(): () => Internal.NetworkEvent$Context;
        get class(): Internal.Class<any>;
        set phase(arg0: Internal.EventPriority);
        set result(arg0: Internal.Event$Result);
        set canceled(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DoublePredicate {
        or(arg0: Internal.DoublePredicate): Internal.DoublePredicate;
        test(arg0: number): boolean;
        and(arg0: Internal.DoublePredicate): Internal.DoublePredicate;
        negate(): Internal.DoublePredicate;
    }
    abstract class FieldNamingPolicy extends Internal.Enum<any> implements Internal.FieldNamingStrategy {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.FieldNamingPolicy;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.FieldNamingPolicy[];
        translateName(arg0: Internal.Field): string;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.FieldNamingPolicy): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.FieldNamingPolicy>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.FieldNamingPolicy>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly IDENTITY : Internal.FieldNamingPolicy;
        static readonly UPPER_CAMEL_CASE_WITH_SPACES : Internal.FieldNamingPolicy;
        static readonly UPPER_CAMEL_CASE : Internal.FieldNamingPolicy;
        static readonly LOWER_CASE_WITH_DOTS : Internal.FieldNamingPolicy;
        static readonly LOWER_CASE_WITH_UNDERSCORES : Internal.FieldNamingPolicy;
        static readonly LOWER_CASE_WITH_DASHES : Internal.FieldNamingPolicy;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.FieldNamingPolicy>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ServerJS implements Internal.MessageSender, Internal.WithAttachedData {
        getAdvancement(id: ResourceLocation): Internal.AdvancementJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(name: string): Internal.ServerPlayerJS;
        getPlayer(uuid: Internal.UUID): Internal.ServerPlayerJS;
        getPlayer(minecraftPlayer: Internal.Player): Internal.ServerPlayerJS;
        getName(): Internal.Text;
        updateWorldList(): void;
        release(): void;
        notifyAll(): void;
        tell(message: Internal.Component): void;
        getAllLevels(): Internal.List<Internal.ServerLevelJS>;
        getHardcore(): boolean;
        getMotd(): string;
        getOverworld(): Internal.ServerLevelJS;
        notify(): void;
        runCommandSilent(command: string): number;
        scheduleInTicks(ticks: number, data: any, event: Internal.IScheduledEventCallback): Internal.ScheduledEvent;
        scheduleInTicks(ticks: number, event: Internal.IScheduledEventCallback): Internal.ScheduledEvent;
        isRunning(): boolean;
        hashCode(): number;
        setMotd(text: Internal.Component): void;
        runCommand(command: string): number;
        isSinglePlayer(): boolean;
        getPlayers(): Internal.EntityArrayList;
        getData(): Internal.AttachedData;
        setStatusMessage(message: Internal.Component): void;
        sendDataToAll(channel: string, data: Internal.CompoundTag): void;
        isDedicated(): boolean;
        schedule(timer: number, event: Internal.IScheduledEventCallback): Internal.ScheduledEvent;
        schedule(timer: number, data: any, event: Internal.IScheduledEventCallback): Internal.ScheduledEvent;
        getLevel(minecraftLevel: net.minecraft.world.level.Level): Internal.LevelJS;
        getLevel(dimension: string): Internal.LevelJS;
        getMinecraftServer(): Internal.MinecraftServer;
        stop(): void;
        getDisplayName(): Internal.Text;
        equals(arg0: any): boolean;
        getEntities(): Internal.EntityArrayList;
        getEntities(filter: string): Internal.EntityArrayList;
        toString(): string;
        readonly playerMap : Internal.Map<Internal.UUID, Internal.ServerPlayerDataJS>;
        readonly serverScriptManager : Internal.ServerScriptManager;
        static instance : Internal.ServerJS;
        readonly allLevels : Internal.List<Internal.ServerLevelJS>;
        readonly persistentData : Internal.CompoundTag;
        readonly fakePlayerMap : Internal.Map<Internal.UUID, Internal.FakeServerPlayerDataJS>;
        readonly scheduledEvents : Internal.List<Internal.ScheduledEvent>;
        readonly levelMap : Internal.Map<string, Internal.ServerLevelJS>;
        overworld : Internal.ServerLevelJS;
        readonly scheduledTickEvents : Internal.List<Internal.ScheduledEvent>;
        get running(): boolean;
        get singlePlayer(): boolean;
        get motd(): string;
        get dedicated(): boolean;
        get data(): Internal.AttachedData;
        get hardcore(): boolean;
        get entities(): Internal.EntityArrayList;
        get players(): Internal.EntityArrayList;
        get displayName(): Internal.Text;
        get name(): Internal.Text;
        get minecraftServer(): Internal.MinecraftServer;
        get class(): Internal.Class<any>;
        set statusMessage(message: Internal.Component);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Byte2ByteFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface ClientLevelExtension {
        flywheel$getAllLoadedEntities(): Internal.Iterable<Internal.Entity>;
    }
    interface IAntiqueTextProvider {
        setAntiqueInk(arg0: boolean): void;
        hasAntiqueInk(): boolean;
    }
    interface NearbyEntityListener {
        getEntityClass(): Internal.Class<Internal.Entity>;
        getChunkRange(): Internal.Range6Int;
        onSectionLeftRange<T>(entityTrackingSection: any, collection: Internal.ClassInstanceMultiMap<T>): void;
        onEntityLeftRange(arg0: Internal.Entity): void;
        onSectionEnteredRange<T>(entityTrackingSection: any, collection: Internal.ClassInstanceMultiMap<T>): void;
        forEachChunkInRangeChange(entityCache: Internal.EntitySectionStorage<Internal.EntityAccess>, prevCenterPos: Internal.SectionPos, newCenterPos: Internal.SectionPos): void;
        onEntityEnteredRange(arg0: Internal.Entity): void;
    }
    class BufferLayout {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getStride(): number;
        hashCode(): number;
        getLayoutItems(): Internal.List<Internal.LayoutItem>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static builder(): Internal.BufferLayout$Builder;
        toString(): string;
        getAttributeCount(): number;
        notify(): void;
        get layoutItems(): Internal.List<Internal.LayoutItem>;
        get attributeCount(): number;
        get stride(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    class RecipeEventJS extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        forEachRecipe(filter: (arg0: any) => boolean, consumer: (arg0: Internal.RecipeJS) => void): void;
        countRecipes(filter: (arg0: any) => boolean): number;
        notify(): void;
        remove(filter: (arg0: any) => boolean): number;
        replaceOutput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): number;
        replaceOutput(ingredient: Internal.IngredientJS, with_: Internal.ItemStackJS): number;
        replaceOutput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: Internal.ItemStackJS): number;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        hashCode(): number;
        printAllTypes(): void;
        customFilter(filter: (arg0: any) => boolean): (arg0: any) => boolean;
        isCancelled(): boolean;
        printTypes(): void;
        getRecipeFunction(id: string): Internal.RecipeFunction;
        custom(o: any): Internal.RecipeJS;
        forEachRecipeAsync(filter: (arg0: any) => boolean, consumer: (arg0: Internal.RecipeJS) => void): void;
        printExamples(type: string): void;
        addRecipe(r: Internal.RecipeJS, type: Internal.RecipeTypeJS, args1: Internal.ListJS): Internal.RecipeJS;
        stage(filter: (arg0: any) => boolean, stage: string): void;
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: Internal.IngredientJS): number;
        replaceInput(filter: (arg0: any) => boolean, ingredient: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): number;
        replaceInput(ingredient: Internal.IngredientJS, with_: Internal.IngredientJS): number;
        equals(arg0: any): boolean;
        toString(): string;
        /**
        * Holds all the recipes collected from documents.
        */
        getRecipes(): Document.RecipeHolder;
        canCancel(): boolean;
        setItemErrors(b: boolean): void;
        static instance : Internal.RecipeEventJS;
        static readonly FORGE_CONDITIONAL : "forge:conditional";
        static customIngredientMap : Internal.Map<Internal.UUID, Internal.IngredientWithCustomPredicateJS>;
        /**
        * Holds all the recipes collected from documents.
        */
        get recipes(): Document.RecipeHolder;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        set itemErrors(b: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Furnaces.
        */
        smelting(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Smokers.
        */
        smoking(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Blast Furnaces.
        */
        blasting(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a shaped crafting recipe.
        */
        shaped(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        /**
        * Adds a shapeless crafting recipe.
        */
        shapeless(output: Internal.ItemStackJS, inputs: Internal.IngredientJS[]): Internal.ShapelessRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Camefire.
        */
        campfireCooking(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a stonecutting recipe.
        */
        stonecutting(output: Internal.ItemStackJS, inputs: Internal.IngredientJS): Internal.StonecuttingRecipeJS;
        /**
        * Adds a smithing recipe.
        */
        smithing(output: Internal.ItemStackJS, base: Internal.IngredientJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
    }
    class ImmutableSet$Builder <E> extends Internal.ImmutableCollection$Builder<any> {
        add(arg0: E): Internal.ImmutableSet$Builder<E>;
        add(arg0: any): Internal.ImmutableCollection$Builder<any>;
        add(arg0: E[]): Internal.ImmutableSet$Builder<E>;
        add(arg0: any[]): Internal.ImmutableCollection$Builder<any>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.ImmutableCollection<any>;
        build(): Internal.ImmutableSet<E>;
        addAll(arg0: Internal.Iterator<any>): Internal.ImmutableCollection$Builder<any>;
        addAll(arg0: Internal.Iterator<E>): Internal.ImmutableSet$Builder<E>;
        addAll(arg0: Internal.Iterable<any>): Internal.ImmutableCollection$Builder<any>;
        addAll(arg0: Internal.Iterable<E>): Internal.ImmutableSet$Builder<E>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MixerRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        energy(e: number): Internal.IERecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        time(t: number): Internal.IERecipeJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<net.minecraftforge.fluids.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DirectMethodHandleDesc extends Internal.MethodHandleDesc {
        owner(): Internal.ClassDesc;
        invocationType(): Internal.MethodTypeDesc;
        kind(): Internal.DirectMethodHandleDesc$Kind;
        equals(arg0: any): boolean;
        refKind(): number;
        isOwnerInterface(): boolean;
        lookupDescriptor(): string;
        methodName(): string;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): any;
        asType(arg0: Internal.MethodTypeDesc): Internal.MethodHandleDesc;
    }
    class ShapedRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        noShrink(): Internal.ShapedRecipeJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        noMirror(): Internal.ShapedRecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        parseResultItem(o: any): Internal.ItemStackJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FilterOutputStream extends Internal.OutputStream {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        flush(): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        static nullOutputStream(): Internal.OutputStream;
        close(): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        write(arg0: number[]): void;
        write(arg0: number): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BlockStateKJS {
        setDestroySpeedKJS(arg0: number): void;
        setLightEmissionKJS(arg0: number): void;
        setRequiresToolKJS(arg0: boolean): void;
        setMaterialKJS(arg0: net.minecraft.world.level.material.Material): void;
    }
    interface LevelHeightAccessor {
    }
    interface EventExecutor extends Internal.EventExecutorGroup {
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>;
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        next(): Internal.EventExecutor;
        terminationFuture(): Internal.Future<any>;
        parent(): Internal.EventExecutorGroup;
        newProgressivePromise<V_>(): Internal.ProgressivePromise<V_>;
        shutdownGracefully(): Internal.Future<any>;
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit): Internal.Future<any>;
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): Internal.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): java_.util.concurrent.Future<T_>;
        submit(arg0: Internal.Runnable): Internal.Future<any>;
        submit(arg0: Internal.Runnable): java_.util.concurrent.Future<any>;
        submit<T_>(arg0: Internal.Runnable, arg1: T_): Internal.Future<T_>;
        submit<T_>(arg0: Internal.Runnable, arg1: T_): java_.util.concurrent.Future<T_>;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        isTerminated(): boolean;
        forEach(arg0: (arg0: Internal.EventExecutor) => void): void;
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>;
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<java_.util.concurrent.Future<T_>>;
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): Internal.List<java_.util.concurrent.Future<T_>>;
        newFailedFuture<V_>(arg0: Internal.Throwable): Internal.Future<V_>;
        execute(arg0: Internal.Runnable): void;
        inEventLoop(arg0: Internal.Thread): boolean;
        inEventLoop(): boolean;
        isShuttingDown(): boolean;
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<any>;
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V_>;
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<V_>;
        iterator(): Internal.Iterator<Internal.EventExecutor>;
        newSucceededFuture<V_>(arg0: V_): Internal.Future<V_>;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean;
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): T_;
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): T_;
        shutdownNow(): Internal.List<Internal.Runnable>;
        shutdown(): void;
        isShutdown(): boolean;
        newPromise<V_>(): Internal.Promise<V_>;
    }
    class Subject implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        static getSubject(arg0: Internal.AccessControlContext): Internal.Subject;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPrivateCredentials<T_>(arg0: Internal.Class<T_>): Internal.Set<T_>;
        getPrivateCredentials(): Internal.Set<any>;
        notifyAll(): void;
        getPrincipals(): Internal.Set<Internal.Principal>;
        getPrincipals<T_>(arg0: Internal.Class<T_>): Internal.Set<T_>;
        notify(): void;
        getPublicCredentials(): Internal.Set<any>;
        getPublicCredentials<T_>(arg0: Internal.Class<T_>): Internal.Set<T_>;
        static doAsPrivileged<T_>(arg0: Internal.Subject, arg1: Internal.PrivilegedAction<T_>, arg2: Internal.AccessControlContext): T_;
        static doAsPrivileged<T_>(arg0: Internal.Subject, arg1: Internal.PrivilegedExceptionAction<T_>, arg2: Internal.AccessControlContext): T_;
        static doAs<T_>(arg0: Internal.Subject, arg1: Internal.PrivilegedAction<T_>): T_;
        static doAs<T_>(arg0: Internal.Subject, arg1: Internal.PrivilegedExceptionAction<T_>): T_;
        isReadOnly(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        setReadOnly(): void;
        get privateCredentials(): Internal.Set<any>;
        get principals(): Internal.Set<Internal.Principal>;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get publicCredentials(): Internal.Set<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BufferLayout$Builder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.BufferLayout;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        addItems(arg0: Internal.LayoutItem[]): Internal.BufferLayout$Builder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ModuleReader extends Internal.Closeable {
        read(arg0: string): Internal.Optional<Internal.ByteBuffer>;
        release(arg0: Internal.ByteBuffer): void;
        find(arg0: string): Internal.Optional<Internal.URI>;
        list(): Internal.Stream<string>;
        close(): void;
        open(arg0: string): Internal.Optional<Internal.InputStream>;
    }
    class EntityLootEventJS extends Internal.LootEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        modifyEntity(type: Internal.EntityType<any>, b: (arg0: Internal.LootBuilder) => void): void;
        notifyAll(): void;
        addJson(id: ResourceLocation, json: Internal.JsonObject): void;
        notify(): void;
        modify(id: ResourceLocation, b: (arg0: Internal.LootBuilder) => void): void;
        addEntity(type: Internal.EntityType<any>, b: (arg0: Internal.LootBuilder) => void): void;
        removeAll(): void;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        getType(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getDirectory(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get type(): string;
        get class(): Internal.Class<any>;
        get directory(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Symbol {
    }
    class GameRulesJS {
        getClass(): Internal.Class<any>;
        getInt(rule: string): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        set(rule: string, value: any): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getBoolean(rule: string): boolean;
        getString(rule: string): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface RandomGenerator {
        nextFloat(): number;
        nextFloat(arg0: number): number;
        nextFloat(arg0: number, arg1: number): number;
        isDeprecated(): boolean;
        nextInt(): number;
        nextInt(arg0: number): number;
        nextInt(arg0: number, arg1: number): number;
        nextLong(arg0: number, arg1: number): number;
        nextLong(arg0: number): number;
        nextLong(): number;
        nextGaussian(arg0: number, arg1: number): number;
        nextGaussian(): number;
        nextDouble(arg0: number): number;
        nextDouble(arg0: number, arg1: number): number;
        nextDouble(): number;
        nextBytes(arg0: number[]): void;
        longs(arg0: number): Internal.LongStream;
        longs(arg0: number, arg1: number): Internal.LongStream;
        longs(): Internal.LongStream;
        longs(arg0: number, arg1: number, arg2: number): Internal.LongStream;
        nextExponential(): number;
        ints(): Internal.IntStream;
        ints(arg0: number): Internal.IntStream;
        ints(arg0: number, arg1: number, arg2: number): Internal.IntStream;
        ints(arg0: number, arg1: number): Internal.IntStream;
        doubles(): Internal.DoubleStream;
        doubles(arg0: number): Internal.DoubleStream;
        doubles(arg0: number, arg1: number, arg2: number): Internal.DoubleStream;
        doubles(arg0: number, arg1: number): Internal.DoubleStream;
        nextBoolean(): boolean;
    }
    interface WritableByteChannel extends Internal.Channel {
        isOpen(): boolean;
        close(): void;
        write(arg0: Internal.ByteBuffer): number;
    }
    interface InterruptibleChannel extends Internal.Channel {
        isOpen(): boolean;
        close(): void;
    }
    interface BlockStateFlagHolder {
        getAllFlags(): number;
    }
    class FluidState extends Internal.StateHolder<any, any> implements Internal.IForgeFluidState {
        getNeighborTable(): Internal.Table<any, any, any>;
        getStateIndex(): number;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getExplosionResistance(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): number;
        redirect$zhl000$getNeighborFromFastMap(ignore: Internal.Table<any, any, any>, rowKey: any, columnKey: any): any;
        setNeighborTable(table: Internal.Table<any, any, any>): void;
        notifyAll(): void;
        setStateMap(newValue: Internal.FastMap<any>): void;
        isEntityInside(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity, arg3: number, arg4: Internal.SetTag<Internal.Fluid>, arg5: boolean): boolean;
        getStateMap(): Internal.FastMap<any>;
        notify(): void;
        replacePropertyMap(newMap: Internal.ImmutableMap<any, any>): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        setStateIndex(newValue: number): void;
        toString(): string;
        getVanillaPropertyMap(): Internal.ImmutableMap<any, any>;
        get stateIndex(): number;
        get neighborTable(): Internal.Table<any, any, any>;
        get stateMap(): Internal.FastMap<any>;
        get class(): Internal.Class<any>;
        get vanillaPropertyMap(): Internal.ImmutableMap<any, any>;
        set stateIndex(newValue: number);
        set stateMap(newValue: Internal.FastMap<any>);
        set neighborTable(table: Internal.Table<any, any, any>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Char2IntFunction extends it.unimi.dsi.fastutil.Function<string, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: string, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: string) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: string, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: string, arg1: number): number;
        remove(arg0: string): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: string): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: string): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class Products$P4 <F, T1, T2, T3, T4> {
        t4(): Internal.App<F, T4>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function4<T1, T2, T3, T4, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function4<T1, T2, T3, T4, R>>): Internal.App<F, R>;
        hashCode(): number;
        and<T5, T6, T7>(arg0: Internal.Products$P3<F, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        and<T5, T6, T7, T8>(arg0: Internal.Products$P4<F, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        and<T5, T6>(arg0: Internal.Products$P2<F, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        and<T5>(arg0: Internal.App<F, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        notify(): void;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MethodHandleInfo {
        getReferenceKind(): number;
        getDeclaringClass(): Internal.Class<any>;
        getName(): string;
        isVarArgs(): boolean;
        getMethodType(): Internal.MethodType;
        reflectAs<T>(arg0: Internal.Class<T>, arg1: Internal.MethodHandles$Lookup): T;
        getModifiers(): number;
    }
    abstract class Particle {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        shouldCull(): boolean;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Long2FloatFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.LongToDoubleFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface DoubleToLongFunction {
        applyAsLong(arg0: number): number;
    }
    class Products$P6 <F, T1, T2, T3, T4, T5, T6> {
        t4(): Internal.App<F, T4>;
        getClass(): Internal.Class<any>;
        t5(): Internal.App<F, T5>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        t6(): Internal.App<F, T6>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function6<T1, T2, T3, T4, T5, T6, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function6<T1, T2, T3, T4, T5, T6, R>>): Internal.App<F, R>;
        notifyAll(): void;
        notify(): void;
        hashCode(): number;
        and<T7>(arg0: Internal.App<F, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        and<T7, T8>(arg0: Internal.Products$P2<F, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FuncSupplier {
        create(arg0: Internal.List<dev.latvian.mods.rhino.util.unit.Unit>): dev.latvian.mods.rhino.util.unit.Unit;
    }
    interface Nameable {
    }
    abstract class Locale$IsoCountryCode extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Locale$IsoCountryCode;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Locale$IsoCountryCode[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Locale$IsoCountryCode): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Locale$IsoCountryCode>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Locale$IsoCountryCode>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly PART3 : Internal.Locale$IsoCountryCode;
        static readonly PART1_ALPHA2 : Internal.Locale$IsoCountryCode;
        static readonly PART1_ALPHA3 : Internal.Locale$IsoCountryCode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Locale$IsoCountryCode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class UUID implements Internal.Serializable, Internal.Comparable<Internal.UUID> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        static nameUUIDFromBytes(arg0: number[]): Internal.UUID;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.UUID): number;
        getLeastSignificantBits(): number;
        version(): number;
        notify(): void;
        node(): number;
        getMostSignificantBits(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        variant(): number;
        static randomUUID(): Internal.UUID;
        toString(): string;
        static fromString(arg0: string): Internal.UUID;
        clockSequence(): number;
        timestamp(): number;
        get mostSignificantBits(): number;
        get class(): Internal.Class<any>;
        get leastSignificantBits(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ChannelHandler {
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void;
        handlerAdded(arg0: Internal.ChannelHandlerContext): void;
        handlerRemoved(arg0: Internal.ChannelHandlerContext): void;
    }
    class InformationREIEventJS extends Internal.EventJS {
        cancel(): void;
        add(stacks: any, title: Internal.Component, description: any): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlastFurnaceFuelRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        energy(e: number): Internal.IERecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        time(t: number): Internal.IERecipeJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<net.minecraftforge.fluids.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EntityAccess {
    }
    interface EntityTargetKJS {
        getNameKJS(): string;
    }
    interface JsonSerializable {
        toJson(): Internal.JsonElement;
    }
    interface Supplier <T> {
        get(): T;
    }
    interface Byte2CharFunction extends it.unimi.dsi.fastutil.Function<number, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: number, arg1: string): string;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: number, arg1: string): string;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: string): string;
        remove(arg0: number): string;
        remove(arg0: any): string;
        remove(arg0: any): any;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): string;
        get(arg0: any): any;
        get(arg0: number): string;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): string;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => string;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface Cloneable {
    }
    interface IngredientKJS extends Internal.AsKJS {
        getItemsKJS(): Internal.ItemStack[];
        asKJS(): any;
    }
    class FakeServerPlayerDataJS extends Internal.ServerPlayerDataJS {
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.ServerPlayerJS;
        getPlayer(): Internal.PlayerJS<any>;
        getName(): string;
        notifyAll(): void;
        getProfile(): Internal.GameProfile;
        getId(): Internal.UUID;
        getOverworld(): Internal.LevelJS;
        notify(): void;
        getMinecraftPlayer(): Internal.Player;
        getMinecraftPlayer(): Internal.ServerPlayer;
        hashCode(): number;
        equals(arg0: any): boolean;
        hasClientMod(): boolean;
        toString(): string;
        getData(): Internal.AttachedData;
        player : Internal.ServerPlayer;
        get server(): Internal.ServerJS;
        get data(): Internal.AttachedData;
        get minecraftPlayer(): Internal.ServerPlayer;
        get profile(): Internal.GameProfile;
        get name(): string;
        get id(): Internal.UUID;
        get overworld(): Internal.LevelJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeMobEffectInstance {
        writeCurativeItems(arg0: Internal.CompoundTag): void;
        addCurativeItem(arg0: Internal.ItemStack): void;
        setCurativeItems(arg0: Internal.List<Internal.ItemStack>): void;
        isCurativeItem(arg0: Internal.ItemStack): boolean;
        getCurativeItems(): Internal.List<Internal.ItemStack>;
    }
    abstract class EntityEventJS extends Internal.LevelEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.LevelJS;
        post(id: string, sub: string): boolean;
        post(id: string): boolean;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Function8 <T1, T2, T3, T4, T5, T6, T7, T8, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, (arg0: T8) => R>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function3<T6, T7, T8, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, (arg0: T7, arg1: T8) => R>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function5<T4, T5, T6, T7, T8, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function4<T5, T6, T7, T8, R>>;
        curry2(): (arg0: T1, arg1: T2) => Internal.Function6<T3, T4, T5, T6, T7, T8, R>;
        curry(): (arg0: T1) => Internal.Function7<T2, T3, T4, T5, T6, T7, T8, R>;
    }
    interface Function3 <T1, T2, T3, R> {
        apply(arg0: T1, arg1: T2, arg2: T3): R;
        curry2(): (arg0: T1, arg1: T2) => (arg0: T3) => R;
        curry(): (arg0: T1) => (arg0: T2, arg1: T3) => R;
    }
    interface ByteProcessor {
        process(arg0: number): boolean;
    }
    interface MinecraftServerAccessor {
        getResources(): Internal.ServerResources;
    }
    abstract class CharsetDecoder {
        averageCharsPerByte(): number;
        getClass(): Internal.Class<any>;
        charset(): Internal.Charset;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        maxCharsPerByte(): number;
        onUnmappableCharacter(arg0: Internal.CodingErrorAction): Internal.CharsetDecoder;
        notifyAll(): void;
        isCharsetDetected(): boolean;
        decode(arg0: Internal.ByteBuffer): Internal.CharBuffer;
        decode(arg0: Internal.ByteBuffer, arg1: Internal.CharBuffer, arg2: boolean): Internal.CoderResult;
        notify(): void;
        isAutoDetecting(): boolean;
        unmappableCharacterAction(): Internal.CodingErrorAction;
        detectedCharset(): Internal.Charset;
        malformedInputAction(): Internal.CodingErrorAction;
        flush(arg0: Internal.CharBuffer): Internal.CoderResult;
        hashCode(): number;
        equals(arg0: any): boolean;
        onMalformedInput(arg0: Internal.CodingErrorAction): Internal.CharsetDecoder;
        reset(): Internal.CharsetDecoder;
        toString(): string;
        replacement(): string;
        replaceWith(arg0: string): Internal.CharsetDecoder;
        get autoDetecting(): boolean;
        get charsetDetected(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Decoder$Simple <A> {
        decoder(): Internal.Decoder<A>;
        decode<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<A>;
    }
    interface IngredientJS extends Internal.JsonSerializable, Internal.WrappedJS, Internal.Copyable {
        anyStackMatches(ingredient: Internal.IngredientJS): boolean;
        getItemIds(): Internal.Set<string>;
        testVanillaItem(item: Internal.Item): boolean;
        test(arg0: Internal.ItemStackJS): boolean;
        getStacks(): Internal.Set<Internal.ItemStackJS>;
        getVanillaItems(): Internal.Set<Internal.Item>;
        isEmpty(): boolean;
        isInvalidRecipeIngredient(): boolean;
        asIngredientStack(): Internal.IngredientStackJS;
        getVanillaPredicate(): (arg0: Internal.ItemStack) => boolean;
        filter(filter: Internal.IngredientJS): Internal.IngredientJS;
        createVanillaIngredient(): (arg0: any) => boolean;
        toJson(): Internal.JsonElement;
        not(): Internal.IngredientJS;
        withCount(count: number): Internal.IngredientJS;
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>;
        getFirst(): Internal.ItemStackJS;
        testVanilla(stack: Internal.ItemStack): boolean;
        x(c: number): Internal.IngredientJS;
        copy(): Internal.IngredientJS;
        copy(): Internal.Copyable;
        getCount(): number;
    }
    class ListJS extends Internal.ArrayList<any> implements Internal.StringBuilderAppendable, Internal.ChangeListener<any>, Internal.Copyable, Internal.JsonSerializable, Internal.NBTSerializable {
        getClass(): Internal.Class<any>;
        shift(): any;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.Iterator<any>;
        toArray<T_>(arg0: T_[]): T_[];
        toArray(): any[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        static orSelf(o: any): Internal.ListJS;
        parallelStream(): Internal.Stream<any>;
        indexOf(arg0: any): number;
        add(index: number, value: any): void;
        add(value: any): boolean;
        appendString(builder: Internal.StringBuilder): void;
        spliterator(): Internal.Spliterator<any>;
        sort(arg0: Internal.Comparator<any>): void;
        push(o: any[]): Internal.ListJS;
        removeIf(arg0: (arg0: any) => boolean): boolean;
        contains(arg0: any): boolean;
        toJson(): Internal.JsonArray;
        toJson(): Internal.JsonElement;
        size(): number;
        listIterator(): Internal.ListIterator<any>;
        listIterator(arg0: number): Internal.ListIterator<any>;
        ensureCapacity(arg0: number): void;
        static nbt(list: any): Internal.CollectionTag<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        replaceAll(arg0: (arg0: any) => any): void;
        notify(): void;
        remove(index: number): any;
        remove(o: any): boolean;
        pop(): any;
        toNBT(): Internal.CollectionTag<any>;
        toNBT(): Internal.Tag;
        stream(): Internal.Stream<any>;
        hashCode(): number;
        get(arg0: number): any;
        static of(o: any): Internal.ListJS;
        static of(array: number[]): Internal.ListJS;
        static of(array: number[]): Internal.ListJS;
        static of(array: number[]): Internal.ListJS;
        static of(array: number[]): Internal.ListJS;
        static of(array: number[]): Internal.ListJS;
        static of(array: string[]): Internal.ListJS;
        static of(array: number[]): Internal.ListJS;
        static json(array: any): Internal.JsonArray;
        copy(): Internal.ListJS;
        copy(): Internal.Copyable;
        map(transformer: (arg0: any) => any): Internal.ListJS;
        subList(arg0: number, arg1: number): Internal.List<any>;
        trimToSize(): void;
        set(arg0: number, arg1: any): any;
        onChanged(o: any): void;
        forEach(arg0: (arg0: any) => void): void;
        splice(pos: number, deleteCount: number, items: any[]): Internal.ListJS;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        static ofArray(array: any): Internal.ListJS;
        reverse(): Internal.ListJS;
        filter(predicate: (arg0: any) => boolean): Internal.ListJS;
        lastIndexOf(arg0: any): number;
        addAll(index: number, c: Internal.Collection<any>): boolean;
        addAll(c: Internal.Collection<any>): boolean;
        equals(arg0: any): boolean;
        clone(): any;
        getLength(): number;
        unshift(o: any[]): Internal.ListJS;
        toString(): string;
        retainAll(arg0: Internal.Collection<any>): boolean;
        changeListener : Internal.ChangeListener<Internal.ListJS>;
        get length(): number;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface List <E> extends Internal.Collection<E> {
        replaceAll(arg0: (arg0: any) => any): void;
        remove(arg0: any): boolean;
        remove(arg0: number): E;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.Iterator<E>;
        stream(): Internal.Stream<E>;
        hashCode(): number;
        get(arg0: number): E;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: E): void;
        add(arg0: E): boolean;
        subList(arg0: number, arg1: number): Internal.List<E>;
        set(arg0: number, arg1: E): E;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: (arg0: E) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator<E>): void;
        removeIf(arg0: (arg0: E) => boolean): boolean;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean;
        addAll(arg0: Internal.Collection<E>): boolean;
        equals(arg0: any): boolean;
        listIterator(arg0: number): Internal.ListIterator<E>;
        listIterator(): Internal.ListIterator<E>;
        retainAll(arg0: Internal.Collection<any>): boolean;
    }
    class ProtectionDomain {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getPermissions(): Internal.PermissionCollection;
        getClassLoader(): Internal.ClassLoader;
        toString(): string;
        getPrincipals(): Internal.Principal[];
        implies(arg0: Internal.Permission): boolean;
        staticPermissionsOnly(): boolean;
        getCodeSource(): Internal.CodeSource;
        notify(): void;
        get classLoader(): Internal.ClassLoader;
        get permissions(): Internal.PermissionCollection;
        get principals(): Internal.Principal[];
        get codeSource(): Internal.CodeSource;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractConstant <T> implements Internal.Constant<T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        id(): number;
        compareTo(arg0: T): number;
        compareTo(arg0: any): number;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FixedUnit extends dev.latvian.mods.rhino.util.unit.Unit {
        getClass(): Internal.Class<any>;
        mod(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        log1p(): dev.latvian.mods.rhino.util.unit.Unit;
        cos(): dev.latvian.mods.rhino.util.unit.Unit;
        deg(): dev.latvian.mods.rhino.util.unit.Unit;
        lt(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        atan(): dev.latvian.mods.rhino.util.unit.Unit;
        getAsInt(): number;
        div(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        neg(): dev.latvian.mods.rhino.util.unit.Unit;
        shiftLeft(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        rad(): dev.latvian.mods.rhino.util.unit.Unit;
        sqrt(): dev.latvian.mods.rhino.util.unit.Unit;
        gte(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        neq(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        atan2(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        tan(): dev.latvian.mods.rhino.util.unit.Unit;
        add(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        newValue(v: number): dev.latvian.mods.rhino.util.unit.Unit;
        toBool(): dev.latvian.mods.rhino.util.unit.Unit;
        ceil(): dev.latvian.mods.rhino.util.unit.Unit;
        eq(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        shiftRight(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        sub(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mul(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        log(): dev.latvian.mods.rhino.util.unit.Unit;
        log10(): dev.latvian.mods.rhino.util.unit.Unit;
        notifyAll(): void;
        notify(): void;
        not(): dev.latvian.mods.rhino.util.unit.Unit;
        min(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        hashCode(): number;
        and(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        static of(value: number): Internal.FixedUnit;
        get(): number;
        pow(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        sin(): dev.latvian.mods.rhino.util.unit.Unit;
        xor(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        lte(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        floor(): dev.latvian.mods.rhino.util.unit.Unit;
        isFixed(): boolean;
        sq(): dev.latvian.mods.rhino.util.unit.Unit;
        or(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        max(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        gt(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        abs(): dev.latvian.mods.rhino.util.unit.Unit;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        append(sb: Internal.StringBuilder): void;
        static readonly ZERO : Internal.FixedUnit;
        static readonly ONE : Internal.FixedUnit;
        static readonly POS_INFINITY : Internal.FixedUnit;
        static readonly NEG_INFINITY : Internal.FixedUnit;
        static readonly NAN : Internal.FixedUnit;
        get asInt(): number;
        get fixed(): boolean;
        get class(): Internal.Class<any>;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Double2LongFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleToLongFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsLong(arg0: number): number;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class EventPriority extends Internal.Enum<any> implements Internal.IEventListener {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.EventPriority;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.EventPriority[];
        invoke(arg0: Internal.Event): void;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.EventPriority): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.EventPriority>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.EventPriority>;
        hashCode(): number;
        listenerName(): string;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly LOWEST : Internal.EventPriority;
        static readonly HIGH : Internal.EventPriority;
        static readonly LOW : Internal.EventPriority;
        static readonly HIGHEST : Internal.EventPriority;
        static readonly NORMAL : Internal.EventPriority;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.EventPriority>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjectBidirectionalIterator <K> extends Internal.ObjectIterator<K>, Internal.BidirectionalIterator<K> {
        next(): K;
        previous(): K;
        hasPrevious(): boolean;
        back(arg0: number): number;
        hasNext(): boolean;
        skip(arg0: number): number;
        forEachRemaining(arg0: (arg0: K) => void): void;
        remove(): void;
    }
    interface ServerWorldExtended {
        setNavigationActive(arg0: Internal.Mob): void;
        setNavigationInactive(arg0: Internal.Mob): void;
    }
    interface ListIterator <E> extends Internal.Iterator<E> {
        next(): E;
        add(arg0: E): void;
        set(arg0: E): void;
        previous(): E;
        hasPrevious(): boolean;
        hasNext(): boolean;
        forEachRemaining(arg0: (arg0: E) => void): void;
        nextIndex(): number;
        previousIndex(): number;
        remove(): void;
    }
    class LootModificationEventJS extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        addBlockLootModifier(arg0: BlockStatePredicate): Internal.LootActionsBuilderJS;
        notifyAll(): void;
        removeGlobalModifier(arg0: string[]): void;
        splitLocationsOrPattern(arg0: string[], arg1: Internal.List<Internal.Pattern>, arg2: Internal.List<ResourceLocation>): void;
        notify(): void;
        disableLootModification(arg0: string[]): void;
        addLootTableModifier(arg0: string[]): Internal.LootActionsBuilderJS;
        getGlobalModifiers(): Internal.List<string>;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        addLootTypeModifier(arg0: LootType[]): Internal.LootActionsBuilderJS;
        hashCode(): number;
        equals(arg0: any): boolean;
        addEntityLootModifier(arg0: Internal.EntityType<any>[]): Internal.LootActionsBuilderJS;
        toString(): string;
        enableLogging(): void;
        canCancel(): boolean;
        get globalModifiers(): Internal.List<string>;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Random implements Internal.RandomGenerator, Internal.Serializable {
        nextFloat(): number;
        nextFloat(arg0: number): number;
        nextFloat(arg0: number, arg1: number): number;
        getClass(): Internal.Class<any>;
        isDeprecated(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        nextInt(): number;
        nextInt(arg0: number): number;
        nextInt(arg0: number, arg1: number): number;
        nextLong(): number;
        nextLong(arg0: number, arg1: number): number;
        nextLong(arg0: number): number;
        notify(): void;
        nextGaussian(): number;
        nextGaussian(arg0: number, arg1: number): number;
        nextDouble(): number;
        nextDouble(arg0: number): number;
        nextDouble(arg0: number, arg1: number): number;
        nextBytes(arg0: number[]): void;
        longs(arg0: number, arg1: number, arg2: number): Internal.LongStream;
        longs(arg0: number): Internal.LongStream;
        longs(): Internal.LongStream;
        longs(arg0: number, arg1: number): Internal.LongStream;
        nextExponential(): number;
        ints(arg0: number): Internal.IntStream;
        ints(): Internal.IntStream;
        ints(arg0: number, arg1: number): Internal.IntStream;
        ints(arg0: number, arg1: number, arg2: number): Internal.IntStream;
        doubles(arg0: number): Internal.DoubleStream;
        doubles(arg0: number, arg1: number, arg2: number): Internal.DoubleStream;
        doubles(): Internal.DoubleStream;
        doubles(arg0: number, arg1: number): Internal.DoubleStream;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        nextBoolean(): boolean;
        setSeed(arg0: number): void;
        get deprecated(): boolean;
        get class(): Internal.Class<any>;
        set seed(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractInstance implements Internal.Instance, Internal.LightListener {
        getClass(): Internal.Class<any>;
        init(): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        onLightUpdate(arg0: Internal.LightProvider, arg1: Internal.LightLayer, arg2: Internal.ImmutableBox): void;
        notifyAll(): void;
        update(): void;
        updateLight(): void;
        notify(): void;
        remove(): void;
        getWorldPosition(): BlockPos;
        getVolume(): Internal.ImmutableBox;
        hashCode(): number;
        onLightPacket(arg0: Internal.LightProvider, arg1: number, arg2: number): void;
        equals(arg0: any): boolean;
        toString(): string;
        shouldReset(): boolean;
        status(): Internal.ListenerStatus;
        readonly world : net.minecraft.world.level.Level;
        get volume(): Internal.ImmutableBox;
        get worldPosition(): BlockPos;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Products$P2 <F, T1, T2> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: (arg0: T1, arg1: T2) => R): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, (arg0: T1, arg1: T2) => R>): Internal.App<F, R>;
        hashCode(): number;
        and<T3, T4, T5, T6, T7>(arg0: Internal.Products$P5<F, T3, T4, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        and<T3, T4, T5, T6, T7, T8>(arg0: Internal.Products$P6<F, T3, T4, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        and<T3>(arg0: Internal.App<F, T3>): Internal.Products$P3<F, T1, T2, T3>;
        and<T3, T4>(arg0: Internal.Products$P2<F, T3, T4>): Internal.Products$P4<F, T1, T2, T3, T4>;
        and<T3, T4, T5>(arg0: Internal.Products$P3<F, T3, T4, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>;
        and<T3, T4, T5, T6>(arg0: Internal.Products$P4<F, T3, T4, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        notify(): void;
        t2(): Internal.App<F, T2>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockContainerJS implements Internal.SpecialEquality {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        spawnFireworks(fireworks: Internal.FireworksJS): void;
        notifyAll(): void;
        getBiomeId(): string;
        getItem(): Internal.ItemStackJS;
        getUp(): Internal.BlockContainerJS;
        getTags(): Internal.Collection<ResourceLocation>;
        getId(): string;
        clearCache(): void;
        getCanSeeSky(): boolean;
        getEast(): Internal.BlockContainerJS;
        notify(): void;
        getNorth(): Internal.BlockContainerJS;
        hashCode(): number;
        getPos(): BlockPos;
        setEntityData(tag: Internal.CompoundTag): void;
        getDimension(): string;
        mergeEntityData(tag: Internal.CompoundTag): void;
        getEntityId(): string;
        getInventory(facing: Internal.Direction): Internal.InventoryJS;
        getLight(): number;
        getWest(): Internal.BlockContainerJS;
        getPlayersInRadius(radius: number): Internal.EntityArrayList;
        getPlayersInRadius(): Internal.EntityArrayList;
        set(id: ResourceLocation, properties: Internal.Map<any, any>): void;
        set(id: ResourceLocation, properties: Internal.Map<any, any>, flags: number): void;
        set(id: ResourceLocation): void;
        hasTag(tag: ResourceLocation): boolean;
        offset(x: number, y: number, z: number): Internal.BlockContainerJS;
        offset(f: Internal.Direction): Internal.BlockContainerJS;
        offset(f: Internal.Direction, d: number): Internal.BlockContainerJS;
        getDown(): Internal.BlockContainerJS;
        getProperties(): Internal.Map<string, string>;
        createExplosion(): Internal.ExplosionJS;
        setBlockState(state: Internal.BlockState, flags: number): void;
        getEntity(): Internal.BlockEntity;
        createEntity(id: ResourceLocation): Internal.EntityJS;
        getMaterial(): Internal.MaterialJS;
        getSouth(): Internal.BlockContainerJS;
        spawnLightning(effectOnly: boolean): void;
        spawnLightning(effectOnly: boolean, player: Internal.EntityJS): void;
        getLevel(): Internal.LevelJS;
        getX(): number;
        getY(): number;
        getZ(): number;
        getEntityData(): Internal.CompoundTag;
        equals(obj: any): boolean;
        toString(): string;
        getBlockState(): Internal.BlockState;
        specialEquals(o: any, shallow: boolean): boolean;
        readonly minecraftLevel : net.minecraft.world.level.Level;
        get blockState(): Internal.BlockState;
        get biomeId(): string;
        get south(): Internal.BlockContainerJS;
        get playersInRadius(): Internal.EntityArrayList;
        get north(): Internal.BlockContainerJS;
        get down(): Internal.BlockContainerJS;
        get east(): Internal.BlockContainerJS;
        get pos(): BlockPos;
        get west(): Internal.BlockContainerJS;
        get up(): Internal.BlockContainerJS;
        get id(): string;
        get class(): Internal.Class<any>;
        get dimension(): string;
        get item(): Internal.ItemStackJS;
        get level(): Internal.LevelJS;
        get canSeeSky(): boolean;
        get entityId(): string;
        get tags(): Internal.Collection<ResourceLocation>;
        get material(): Internal.MaterialJS;
        get light(): number;
        get x(): number;
        get y(): number;
        get z(): number;
        get properties(): Internal.Map<string, string>;
        get entity(): Internal.BlockEntity;
        get entityData(): Internal.CompoundTag;
        set entityData(tag: Internal.CompoundTag);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractCollection <E> implements Internal.Collection<E> {
        add(arg0: E): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: (arg0: E) => void): void;
        notifyAll(): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        notify(): void;
        remove(arg0: any): boolean;
        removeIf(arg0: (arg0: E) => boolean): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.Iterator<E>;
        size(): number;
        stream(): Internal.Stream<E>;
        addAll(arg0: Internal.Collection<E>): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        toString(): string;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface SpecialEquality {
        specialEquals(o: any, shallow: boolean): boolean;
    }
    abstract class AgeableListModel <E> extends Internal.EntityModel<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Level implements Internal.Comparable<Internal.Level>, Internal.Serializable {
        isLessSpecificThan(level: Internal.Level): boolean;
        isMoreSpecificThan(level: Internal.Level): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static forName(name: string, intValue: number): Internal.Level;
        static valueOf(name: string): Internal.Level;
        static valueOf<T_>(enumType: Internal.Class<T_>, name: string): T_;
        notifyAll(): void;
        static values(): Internal.Level[];
        isInRange(minLevel: Internal.Level, maxLevel: Internal.Level): boolean;
        compareTo(other: Internal.Level): number;
        compareTo(other: any): number;
        intLevel(): number;
        notify(): void;
        static getLevel(name: string): Internal.Level;
        getDeclaringClass(): Internal.Class<Internal.Level>;
        static toLevel(name: string, defaultLevel: Internal.Level): Internal.Level;
        static toLevel(sArg: string): Internal.Level;
        getStandardLevel(): Internal.StandardLevel;
        hashCode(): number;
        equals(other: any): boolean;
        clone(): Internal.Level;
        clone(): any;
        name(): string;
        toString(): string;
        static readonly TRACE : Internal.Level;
        static readonly ALL : Internal.Level;
        static readonly CATEGORY : "Level";
        static readonly ERROR : Internal.Level;
        static readonly INFO : Internal.Level;
        static readonly FATAL : Internal.Level;
        static readonly DEBUG : Internal.Level;
        static readonly OFF : Internal.Level;
        static readonly WARN : Internal.Level;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Level>;
        get standardLevel(): Internal.StandardLevel;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractClientPlayer extends Internal.Player {
        getClass(): Internal.Class<any>;
        backpackedMoved(): boolean;
        handler$zdn000$onIsScoping(arg0: Internal.CallbackInfoReturnable<any>): void;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>;
        handler$zje000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void;
        handler$zbc000$onFallFlying(arg0: number, arg1: number, arg2: number, arg3: Internal.CallbackInfo): void;
        onEndimationEnd(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        canBeRiddenInWater(arg0: Internal.Entity): boolean;
        handler$zzo000$tickHead(arg0: Internal.CallbackInfo): void;
        setCitadelEntityData(arg0: Internal.CompoundTag): void;
        isEndimationPlaying(arg0: Internal.PlayableEndimation): boolean;
        isActive(): boolean;
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void;
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity;
        getCachedFeetBlockState(): Internal.BlockState;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        handler$bfj000$tryShortcutFluidPushing(tag: net.minecraft.tags.Tag<any>, speed: number, cir: Internal.CallbackInfoReturnable<any>, box: Internal.AABB, x1: number, x2: number, y1: number, y2: number, z1: number, z2: number, zero: number): void;
        getPos(): Internal.Position;
        foodEatenKJS(is: Internal.ItemStack): void;
        revive(): void;
        static getDataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        getDigSpeed(arg0: Internal.BlockState, arg1: BlockPos): number;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(arg0: boolean): void;
        canUpdate(): boolean;
        getEndimatedState(): Internal.Endimatable$EndimatedState;
        getSuffixes(): Internal.Collection<Internal.MutableComponent>;
        resetEndimation(): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean;
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number;
        reviveCaps(): void;
        handler$zfk000$diet$constructPlayer(arg0: Internal.CallbackInfo): void;
        lithiumOnBlockCacheDeleted(): void;
        setForcedPose(arg0: Internal.Pose): void;
        canRiderInteract(): boolean;
        handler$zbc000$locateAmmo(arg0: Internal.ItemStack, arg1: Internal.CallbackInfoReturnable<any>, arg2: (arg0: any) => boolean): void;
        getEntries(arg0: boolean): Internal.Set<any>;
        getEffectHandler(): Internal.EndimationEffectHandler;
        onAddedToWorld(): void;
        setAnimationTick(arg0: number): void;
        getPrefixes(): Internal.Collection<Internal.MutableComponent>;
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        static getDataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        getListener(): Internal.NearbyEntityListenerMulti;
        getClassification(arg0: boolean): Internal.MobCategory;
        isNoEndimationPlaying(): boolean;
        onEndimationStart(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listenForCachedBlockChanges: boolean): void;
        shouldRiderSit(): boolean;
        getIsInsidePortal(): boolean;
        handler$zdk000$onGetFieldOfViewModifier(arg0: Internal.CallbackInfoReturnable<any>): void;
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$zje000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        handler$zcg000$read(arg0: Internal.CompoundTag, arg1: Internal.CallbackInfo): void;
        getRemainingFireTicks(): number;
        lithiumOnEquipmentChanged(): void;
        getStagesRawKJS(): Internal.Stages;
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void;
        notify(): void;
        getDataMap(): Internal.Map<any, any>;
        handler$zzo000$moveStep(arg0: Internal.MoverType, arg1: Vec3, arg2: Internal.CallbackInfo): void;
        getStages(): Internal.Stages;
        getEntityChangeListener(): Internal.EntityInLevelCallback;
        endimateTick(): void;
        setDataMap(arg0: Internal.Map<any, any>): void;
        isDirty(): boolean;
        hashCode(): number;
        getLastPos(): BlockPos;
        isAddedToWorld(): boolean;
        getParts(): any[];
        addListener(listener: Internal.NearbyEntityListener): void;
        onRemovedFromWorld(): void;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        curePotionEffects(arg0: Internal.ItemStack): boolean;
        clean(): void;
        asKJS(): any;
        getPlayingEndimation(): Internal.PlayableEndimation;
        getDirtyEntries(): Internal.Set<any>;
        getValue(arg0: Internal.TrackedData<any>): any;
        shouldRiderFaceForward(arg0: Internal.Player): boolean;
        setPlayingEndimation(arg0: Internal.PlayableEndimation): void;
        setValue(arg0: Internal.TrackedData<any>, arg1: any): void;
        equals(arg0: any): boolean;
        getAnimationTick(): number;
        toString(): string;
        setRemainingFireTicks(arg0: number): void;
        handler$zgd001$tick(arg0: Internal.CallbackInfo): void;
        getBackpackedInventory(): Internal.BackpackInventory;
        refreshDisplayName(): void;
        getForcedPose(): Internal.Pose;
        backpackedInventory : Internal.BackpackInventory;
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
        get suffixes(): Internal.Collection<Internal.MutableComponent>;
        get citadelEntityData(): Internal.CompoundTag;
        get listener(): Internal.NearbyEntityListenerMulti;
        get stagesRawKJS(): Internal.Stages;
        get addedToWorld(): boolean;
        get animationTick(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get pos(): Internal.Position;
        get dataMap(): Internal.Map<any, any>;
        get noEndimationPlaying(): boolean;
        get class(): Internal.Class<any>;
        get dirty(): boolean;
        get dataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get entityChangeListener(): Internal.EntityInLevelCallback;
        get multipartEntity(): boolean;
        get active(): boolean;
        get playingEndimation(): Internal.PlayableEndimation;
        get effectHandler(): Internal.EndimationEffectHandler;
        get cachedFeetBlockState(): Internal.BlockState;
        get lastPos(): BlockPos;
        get dirtyEntries(): Internal.Set<any>;
        get dataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        get prefixes(): Internal.Collection<Internal.MutableComponent>;
        get forcedPose(): Internal.Pose;
        get stages(): Internal.Stages;
        get parts(): any[];
        get endimatedState(): Internal.Endimatable$EndimatedState;
        set animationTick(arg0: number);
        set forcedPose(arg0: Internal.Pose);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set dataMap(arg0: Internal.Map<any, any>);
        set playingEndimation(arg0: Internal.PlayableEndimation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BiFunction <T, U, R> {
        apply(arg0: T, arg1: U): R;
        andThen<V>(arg0: (arg0: R) => V): (arg0: T, arg1: U) => V;
    }
    interface Hash {
    }
    class ModuleDescriptor$Provides implements Internal.Comparable<Internal.ModuleDescriptor$Provides> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        service(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ModuleDescriptor$Provides): number;
        notify(): void;
        providers(): Internal.List<string>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ChannelHandlerAdapter implements Internal.ChannelHandler {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void;
        toString(): string;
        handlerAdded(arg0: Internal.ChannelHandlerContext): void;
        isSharable(): boolean;
        notify(): void;
        handlerRemoved(arg0: Internal.ChannelHandlerContext): void;
        get sharable(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ToIntFunction <T> {
        applyAsInt(arg0: T): number;
    }
    interface Byte2ShortFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class FontSet implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class IntBuffer extends Internal.Buffer implements Internal.Comparable<Internal.IntBuffer> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        compact(): Internal.IntBuffer;
        notifyAll(): void;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.IntBuffer): number;
        notify(): void;
        asReadOnlyBuffer(): Internal.IntBuffer;
        put(arg0: number[]): Internal.IntBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.IntBuffer;
        put(arg0: number, arg1: number[]): Internal.IntBuffer;
        put(arg0: number[], arg1: number, arg2: number): Internal.IntBuffer;
        put(arg0: number, arg1: Internal.IntBuffer, arg2: number, arg3: number): Internal.IntBuffer;
        put(arg0: Internal.IntBuffer): Internal.IntBuffer;
        put(arg0: number, arg1: number): Internal.IntBuffer;
        put(arg0: number): Internal.IntBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        slice(): Internal.Buffer;
        slice(): Internal.IntBuffer;
        slice(arg0: number, arg1: number): Internal.Buffer;
        slice(arg0: number, arg1: number): Internal.IntBuffer;
        array(): number[];
        array(): any;
        hashCode(): number;
        get(): number;
        get(arg0: number, arg1: number[]): Internal.IntBuffer;
        get(arg0: number): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.IntBuffer;
        get(arg0: number[], arg1: number, arg2: number): Internal.IntBuffer;
        get(arg0: number[]): Internal.IntBuffer;
        limit(arg0: number): Internal.IntBuffer;
        limit(arg0: number): Internal.Buffer;
        limit(): number;
        arrayOffset(): number;
        flip(): Internal.Buffer;
        flip(): Internal.IntBuffer;
        order(): Internal.ByteOrder;
        hasArray(): boolean;
        hasRemaining(): boolean;
        clear(): Internal.Buffer;
        clear(): Internal.IntBuffer;
        duplicate(): Internal.IntBuffer;
        duplicate(): Internal.Buffer;
        remaining(): number;
        static allocate(arg0: number): Internal.IntBuffer;
        rewind(): Internal.Buffer;
        rewind(): Internal.IntBuffer;
        mismatch(arg0: Internal.IntBuffer): number;
        equals(arg0: any): boolean;
        reset(): Internal.Buffer;
        reset(): Internal.IntBuffer;
        toString(): string;
        position(arg0: number): Internal.IntBuffer;
        position(arg0: number): Internal.Buffer;
        position(): number;
        isDirect(): boolean;
        static wrap(arg0: number[]): Internal.IntBuffer;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.IntBuffer;
        mark(): Internal.Buffer;
        mark(): Internal.IntBuffer;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Logger {
        getName(): string;
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any): void;
        log(level: Internal.Level, messageSupplier: Internal.Supplier<any>, throwable: Internal.Throwable): void;
        log(level: Internal.Level, messageSupplier: Internal.Supplier<any>): void;
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any): void;
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any): void;
        log(level: Internal.Level, message: any, throwable: Internal.Throwable): void;
        log(level: Internal.Level, message: string): void;
        log(level: Internal.Level, message: string, params: any[]): void;
        log(level: Internal.Level, message: string, paramSuppliers: Internal.Supplier<any>[]): void;
        log(level: Internal.Level, message: string, throwable: Internal.Throwable): void;
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void;
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void;
        log(level: Internal.Level, message: string, p0: any): void;
        log(level: Internal.Level, message: string, p0: any, p1: any): void;
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any): void;
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any): void;
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void;
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void;
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void;
        log(level: Internal.Level, marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void;
        log(level: Internal.Level, marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void;
        log(level: Internal.Level, marker: Internal.Marker, message: any): void;
        log(level: Internal.Level, marker: Internal.Marker, message: any, throwable: Internal.Throwable): void;
        log(level: Internal.Level, marker: Internal.Marker, message: string): void;
        log(level: Internal.Level, marker: Internal.Marker, message: string, paramSuppliers: Internal.Supplier<any>[]): void;
        log(level: Internal.Level, marker: Internal.Marker, message: Internal.Message): void;
        log(level: Internal.Level, marker: Internal.Marker, message: Internal.Message, throwable: Internal.Throwable): void;
        log(level: Internal.Level, marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void;
        log(level: Internal.Level, marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void;
        log(level: Internal.Level, marker: Internal.Marker, message: Internal.CharSequence): void;
        log(level: Internal.Level, messageSupplier: Internal.MessageSupplier): void;
        log(level: Internal.Level, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void;
        log(level: Internal.Level, message: Internal.CharSequence): void;
        log(level: Internal.Level, message: Internal.CharSequence, throwable: Internal.Throwable): void;
        log(level: Internal.Level, message: any): void;
        log(level: Internal.Level, marker: Internal.Marker, message: string, throwable: Internal.Throwable): void;
        log(level: Internal.Level, marker: Internal.Marker, messageSupplier: Internal.Supplier<any>): void;
        log(level: Internal.Level, marker: Internal.Marker, messageSupplier: Internal.Supplier<any>, throwable: Internal.Throwable): void;
        log(level: Internal.Level, message: Internal.Message): void;
        log(level: Internal.Level, message: Internal.Message, throwable: Internal.Throwable): void;
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void;
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void;
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void;
        log(level: Internal.Level, marker: Internal.Marker, message: string, params: any[]): void;
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any, p3: any): void;
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void;
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void;
        log(level: Internal.Level, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void;
        logMessage(level: Internal.Level, marker: Internal.Marker, fqcn: string, location: Internal.StackTraceElement, message: Internal.Message, throwable: Internal.Throwable): void;
        atWarn(): Internal.LogBuilder;
        atInfo(): Internal.LogBuilder;
        isWarnEnabled(marker: Internal.Marker): boolean;
        isWarnEnabled(): boolean;
        error(message: Internal.Message, throwable: Internal.Throwable): void;
        error(messageSupplier: Internal.MessageSupplier): void;
        error(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void;
        error(message: Internal.CharSequence): void;
        error(message: Internal.Message): void;
        error(marker: Internal.Marker, messageSupplier: Internal.Supplier<any>, throwable: Internal.Throwable): void;
        error(marker: Internal.Marker, messageSupplier: Internal.Supplier<any>): void;
        error(message: string, paramSuppliers: Internal.Supplier<any>[]): void;
        error(message: string, params: any[]): void;
        error(message: string): void;
        error(message: any, throwable: Internal.Throwable): void;
        error(message: any): void;
        error(message: Internal.CharSequence, throwable: Internal.Throwable): void;
        error(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void;
        error(marker: Internal.Marker, message: Internal.CharSequence): void;
        error(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void;
        error(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void;
        error(marker: Internal.Marker, message: Internal.Message, throwable: Internal.Throwable): void;
        error(marker: Internal.Marker, message: Internal.Message): void;
        error(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void;
        error(marker: Internal.Marker, message: string, paramSuppliers: Internal.Supplier<any>[]): void;
        error(marker: Internal.Marker, message: string, params: any[]): void;
        error(marker: Internal.Marker, message: string): void;
        error(marker: Internal.Marker, message: any, throwable: Internal.Throwable): void;
        error(marker: Internal.Marker, message: any): void;
        error(message: string, p0: any, p1: any, p2: any, p3: any): void;
        error(message: string, p0: any, p1: any, p2: any): void;
        error(message: string, p0: any, p1: any): void;
        error(message: string, p0: any): void;
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void;
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void;
        error(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void;
        error(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void;
        error(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void;
        error(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void;
        error(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void;
        error(message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void;
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any): void;
        error(marker: Internal.Marker, message: string, p0: any, p1: any): void;
        error(marker: Internal.Marker, message: string, p0: any): void;
        error(messageSupplier: Internal.Supplier<any>, throwable: Internal.Throwable): void;
        error(messageSupplier: Internal.Supplier<any>): void;
        error(message: string, throwable: Internal.Throwable): void;
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void;
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void;
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void;
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void;
        error(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any): void;
        fatal(message: string, p0: any, p1: any): void;
        fatal(message: string, p0: any): void;
        fatal(message: string, p0: any, p1: any, p2: any): void;
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void;
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void;
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void;
        fatal(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void;
        fatal(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void;
        fatal(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void;
        fatal(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void;
        fatal(message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void;
        fatal(message: string, p0: any, p1: any, p2: any, p3: any): void;
        fatal(marker: Internal.Marker, message: string, p0: any): void;
        fatal(messageSupplier: Internal.Supplier<any>, throwable: Internal.Throwable): void;
        fatal(messageSupplier: Internal.Supplier<any>): void;
        fatal(message: string, throwable: Internal.Throwable): void;
        fatal(message: string, paramSuppliers: Internal.Supplier<any>[]): void;
        fatal(message: string, params: any[]): void;
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void;
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void;
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void;
        fatal(message: string): void;
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any): void;
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any): void;
        fatal(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void;
        fatal(marker: Internal.Marker, message: any): void;
        fatal(marker: Internal.Marker, message: any, throwable: Internal.Throwable): void;
        fatal(marker: Internal.Marker, message: string): void;
        fatal(marker: Internal.Marker, message: string, params: any[]): void;
        fatal(marker: Internal.Marker, message: string, paramSuppliers: Internal.Supplier<any>[]): void;
        fatal(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any): void;
        fatal(marker: Internal.Marker, message: Internal.Message): void;
        fatal(marker: Internal.Marker, message: Internal.Message, throwable: Internal.Throwable): void;
        fatal(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void;
        fatal(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void;
        fatal(marker: Internal.Marker, message: Internal.CharSequence): void;
        fatal(messageSupplier: Internal.MessageSupplier): void;
        fatal(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void;
        fatal(message: Internal.CharSequence): void;
        fatal(message: Internal.CharSequence, throwable: Internal.Throwable): void;
        fatal(message: any): void;
        fatal(message: any, throwable: Internal.Throwable): void;
        fatal(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void;
        fatal(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void;
        fatal(marker: Internal.Marker, messageSupplier: Internal.Supplier<any>): void;
        fatal(marker: Internal.Marker, messageSupplier: Internal.Supplier<any>, throwable: Internal.Throwable): void;
        fatal(message: Internal.Message): void;
        fatal(message: Internal.Message, throwable: Internal.Throwable): void;
        printf(level: Internal.Level, format: string, params: any[]): void;
        printf(level: Internal.Level, marker: Internal.Marker, format: string, params: any[]): void;
        throwing<T>(throwable: T): T;
        throwing<T>(level: Internal.Level, throwable: T): T;
        atTrace(): Internal.LogBuilder;
        trace(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void;
        trace(message: any): void;
        trace(message: Internal.CharSequence, throwable: Internal.Throwable): void;
        trace(marker: Internal.Marker, message: string, paramSuppliers: Internal.Supplier<any>[]): void;
        trace(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void;
        trace(marker: Internal.Marker, messageSupplier: Internal.Supplier<any>, throwable: Internal.Throwable): void;
        trace(message: Internal.Message): void;
        trace(message: Internal.Message, throwable: Internal.Throwable): void;
        trace(messageSupplier: Internal.MessageSupplier): void;
        trace(marker: Internal.Marker, messageSupplier: Internal.Supplier<any>): void;
        trace(message: Internal.CharSequence): void;
        trace(marker: Internal.Marker, message: string, p0: any, p1: any): void;
        trace(marker: Internal.Marker, message: string, p0: any): void;
        trace(messageSupplier: Internal.Supplier<any>, throwable: Internal.Throwable): void;
        trace(messageSupplier: Internal.Supplier<any>): void;
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any): void;
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any): void;
        trace(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void;
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void;
        trace(message: any, throwable: Internal.Throwable): void;
        trace(message: string): void;
        trace(message: string, params: any[]): void;
        trace(message: string, paramSuppliers: Internal.Supplier<any>[]): void;
        trace(message: string, throwable: Internal.Throwable): void;
        trace(message: string, p0: any): void;
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void;
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void;
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void;
        trace(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void;
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void;
        trace(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void;
        trace(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void;
        trace(message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void;
        trace(message: string, p0: any, p1: any, p2: any, p3: any): void;
        trace(message: string, p0: any, p1: any, p2: any): void;
        trace(message: string, p0: any, p1: any): void;
        trace(marker: Internal.Marker, message: Internal.CharSequence): void;
        trace(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void;
        trace(marker: Internal.Marker, message: any): void;
        trace(marker: Internal.Marker, message: any, throwable: Internal.Throwable): void;
        trace(marker: Internal.Marker, message: string): void;
        trace(marker: Internal.Marker, message: string, params: any[]): void;
        trace(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void;
        trace(marker: Internal.Marker, message: Internal.Message): void;
        trace(marker: Internal.Marker, message: Internal.Message, throwable: Internal.Throwable): void;
        trace(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void;
        trace(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void;
        trace(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void;
        isInfoEnabled(marker: Internal.Marker): boolean;
        isInfoEnabled(): boolean;
        traceEntry(message: Internal.Message): Internal.EntryMessage;
        traceEntry(): Internal.EntryMessage;
        traceEntry(format: string, params: any[]): Internal.EntryMessage;
        traceEntry(format: string, paramSuppliers: Internal.Supplier<any>[]): Internal.EntryMessage;
        traceEntry(paramSuppliers: Internal.Supplier<any>[]): Internal.EntryMessage;
        isErrorEnabled(): boolean;
        isErrorEnabled(marker: Internal.Marker): boolean;
        isTraceEnabled(): boolean;
        isTraceEnabled(marker: Internal.Marker): boolean;
        atLevel(level: Internal.Level): Internal.LogBuilder;
        info(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void;
        info(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void;
        info(marker: Internal.Marker, message: Internal.CharSequence): void;
        info(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void;
        info(marker: Internal.Marker, message: Internal.Message, throwable: Internal.Throwable): void;
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void;
        info(marker: Internal.Marker, message: string, paramSuppliers: Internal.Supplier<any>[]): void;
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void;
        info(marker: Internal.Marker, message: string, params: any[]): void;
        info(marker: Internal.Marker, message: string): void;
        info(marker: Internal.Marker, message: any, throwable: Internal.Throwable): void;
        info(marker: Internal.Marker, message: any): void;
        info(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void;
        info(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void;
        info(marker: Internal.Marker, message: Internal.Message): void;
        info(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void;
        info(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void;
        info(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void;
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void;
        info(message: string, p0: any, p1: any): void;
        info(message: string, p0: any, p1: any, p2: any): void;
        info(message: string, p0: any, p1: any, p2: any, p3: any): void;
        info(message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void;
        info(marker: Internal.Marker, message: string, p0: any): void;
        info(messageSupplier: Internal.Supplier<any>, throwable: Internal.Throwable): void;
        info(messageSupplier: Internal.Supplier<any>): void;
        info(message: string, throwable: Internal.Throwable): void;
        info(message: string, paramSuppliers: Internal.Supplier<any>[]): void;
        info(message: string, params: any[]): void;
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void;
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void;
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void;
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any): void;
        info(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any): void;
        info(marker: Internal.Marker, message: string, p0: any, p1: any): void;
        info(messageSupplier: Internal.MessageSupplier): void;
        info(message: Internal.Message, throwable: Internal.Throwable): void;
        info(message: Internal.Message): void;
        info(marker: Internal.Marker, messageSupplier: Internal.Supplier<any>, throwable: Internal.Throwable): void;
        info(marker: Internal.Marker, messageSupplier: Internal.Supplier<any>): void;
        info(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void;
        info(message: string): void;
        info(message: any, throwable: Internal.Throwable): void;
        info(message: any): void;
        info(message: Internal.CharSequence, throwable: Internal.Throwable): void;
        info(message: Internal.CharSequence): void;
        info(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void;
        info(message: string, p0: any): void;
        always(): Internal.LogBuilder;
        getMessageFactory<MF>(): MF;
        catching(level: Internal.Level, throwable: Internal.Throwable): void;
        catching(throwable: Internal.Throwable): void;
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void;
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any): void;
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any): void;
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void;
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void;
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void;
        debug(message: string, paramSuppliers: Internal.Supplier<any>[]): void;
        debug(message: string, throwable: Internal.Throwable): void;
        debug(messageSupplier: Internal.Supplier<any>): void;
        debug(messageSupplier: Internal.Supplier<any>, throwable: Internal.Throwable): void;
        debug(marker: Internal.Marker, message: string, p0: any): void;
        debug(marker: Internal.Marker, message: string, p0: any, p1: any): void;
        debug(message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void;
        debug(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void;
        debug(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void;
        debug(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void;
        debug(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void;
        debug(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void;
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void;
        debug(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void;
        debug(message: string, p0: any): void;
        debug(message: string, p0: any, p1: any): void;
        debug(message: string, p0: any, p1: any, p2: any): void;
        debug(message: string, p0: any, p1: any, p2: any, p3: any): void;
        debug(marker: Internal.Marker, message: any): void;
        debug(marker: Internal.Marker, message: any, throwable: Internal.Throwable): void;
        debug(marker: Internal.Marker, message: string): void;
        debug(marker: Internal.Marker, message: string, params: any[]): void;
        debug(marker: Internal.Marker, message: string, paramSuppliers: Internal.Supplier<any>[]): void;
        debug(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void;
        debug(marker: Internal.Marker, message: Internal.Message): void;
        debug(marker: Internal.Marker, message: Internal.Message, throwable: Internal.Throwable): void;
        debug(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void;
        debug(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void;
        debug(marker: Internal.Marker, message: Internal.CharSequence): void;
        debug(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void;
        debug(message: Internal.CharSequence): void;
        debug(message: Internal.CharSequence, throwable: Internal.Throwable): void;
        debug(message: any): void;
        debug(message: any, throwable: Internal.Throwable): void;
        debug(message: string): void;
        debug(message: string, params: any[]): void;
        debug(marker: Internal.Marker, messageSupplier: Internal.Supplier<any>): void;
        debug(marker: Internal.Marker, messageSupplier: Internal.Supplier<any>, throwable: Internal.Throwable): void;
        debug(message: Internal.Message): void;
        debug(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void;
        debug(messageSupplier: Internal.MessageSupplier): void;
        debug(message: Internal.Message, throwable: Internal.Throwable): void;
        atError(): Internal.LogBuilder;
        atFatal(): Internal.LogBuilder;
        traceExit<R>(message: Internal.EntryMessage, result: R): R;
        traceExit<R>(format: string, result: R): R;
        traceExit<R>(message: Internal.Message, result: R): R;
        traceExit<R>(result: R): R;
        traceExit(): void;
        traceExit(message: Internal.EntryMessage): void;
        isFatalEnabled(): boolean;
        isFatalEnabled(marker: Internal.Marker): boolean;
        getLevel(): Internal.Level;
        warn(message: Internal.Message, throwable: Internal.Throwable): void;
        warn(messageSupplier: Internal.MessageSupplier): void;
        warn(messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void;
        warn(message: Internal.CharSequence): void;
        warn(message: Internal.Message): void;
        warn(marker: Internal.Marker, messageSupplier: Internal.Supplier<any>): void;
        warn(marker: Internal.Marker, messageSupplier: Internal.Supplier<any>, throwable: Internal.Throwable): void;
        warn(message: string, paramSuppliers: Internal.Supplier<any>[]): void;
        warn(message: string, params: any[]): void;
        warn(message: string): void;
        warn(message: any, throwable: Internal.Throwable): void;
        warn(message: any): void;
        warn(message: Internal.CharSequence, throwable: Internal.Throwable): void;
        warn(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier): void;
        warn(marker: Internal.Marker, messageSupplier: Internal.MessageSupplier, throwable: Internal.Throwable): void;
        warn(marker: Internal.Marker, message: Internal.CharSequence): void;
        warn(marker: Internal.Marker, message: Internal.CharSequence, throwable: Internal.Throwable): void;
        warn(marker: Internal.Marker, message: Internal.Message, throwable: Internal.Throwable): void;
        warn(marker: Internal.Marker, message: Internal.Message): void;
        warn(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void;
        warn(marker: Internal.Marker, message: string, throwable: Internal.Throwable): void;
        warn(marker: Internal.Marker, message: string, paramSuppliers: Internal.Supplier<any>[]): void;
        warn(marker: Internal.Marker, message: string, params: any[]): void;
        warn(marker: Internal.Marker, message: string): void;
        warn(marker: Internal.Marker, message: any, throwable: Internal.Throwable): void;
        warn(marker: Internal.Marker, message: any): void;
        warn(message: string, p0: any, p1: any, p2: any): void;
        warn(message: string, p0: any, p1: any): void;
        warn(message: string, p0: any): void;
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void;
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void;
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void;
        warn(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void;
        warn(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void;
        warn(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void;
        warn(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void;
        warn(message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void;
        warn(message: string, p0: any, p1: any, p2: any, p3: any): void;
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any): void;
        warn(marker: Internal.Marker, message: string, p0: any, p1: any): void;
        warn(marker: Internal.Marker, message: string, p0: any): void;
        warn(messageSupplier: Internal.Supplier<any>, throwable: Internal.Throwable): void;
        warn(messageSupplier: Internal.Supplier<any>): void;
        warn(message: string, throwable: Internal.Throwable): void;
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void;
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any): void;
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void;
        warn(marker: Internal.Marker, message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void;
        entry(): void;
        entry(params: any[]): void;
        exit<R>(result: R): R;
        exit(): void;
        isEnabled(level: Internal.Level): boolean;
        isEnabled(level: Internal.Level, marker: Internal.Marker): boolean;
        isDebugEnabled(): boolean;
        isDebugEnabled(marker: Internal.Marker): boolean;
        atDebug(): Internal.LogBuilder;
    }
    interface Serializable {
    }
    interface Double2IntFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface IForgeFriendlyByteBuf {
        readRegistryIdSafe<T>(arg0: Internal.Class<T>): T;
        readRegistryId<T>(): T;
        readFluidStack(): net.minecraftforge.fluids.FluidStack;
        writeRegistryId<T>(arg0: T): void;
        readRegistryIdUnsafe<T>(arg0: Internal.IForgeRegistry<T>): T;
        writeFluidStack(arg0: net.minecraftforge.fluids.FluidStack): void;
        writeRegistryIdUnsafe(arg0: Internal.IForgeRegistry<any>, arg1: ResourceLocation): void;
        writeRegistryIdUnsafe<T>(arg0: Internal.IForgeRegistry<T>, arg1: T): void;
    }
    class StageChangeEvent {
        getStage(): string;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.Player;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        getPlayerStages(): Internal.Stages;
        get stage(): string;
        get playerStages(): Internal.Stages;
        get class(): Internal.Class<any>;
        get player(): Internal.Player;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Int2IntMap extends Internal.Int2IntFunction, Internal.Map<number, number> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        replace(arg0: number, arg1: number, arg2: number): boolean;
        replace(arg0: number, arg1: number, arg2: number): boolean;
        replace(arg0: number, arg1: number): number;
        replace(arg0: number, arg1: number): number;
        replace(arg0: any, arg1: any): any;
        replace(arg0: any, arg1: any, arg2: any): boolean;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        containsValue(arg0: number): boolean;
        containsValue(arg0: any): boolean;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        mergeInt(arg0: number, arg1: number, arg2: Internal.IntBinaryOperator): number;
        mergeInt(arg0: number, arg1: number, arg2: (arg0: any, arg1: any) => any): number;
        compute(arg0: any, arg1: (arg0: any, arg1: any) => any): any;
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number;
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number;
        defaultReturnValue(arg0: number): void;
        defaultReturnValue(): number;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        merge(arg0: any, arg1: any, arg2: (arg0: any, arg1: any) => any): any;
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number;
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, number>>;
        entrySet(): Internal.Set<any>;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        computeIfAbsent(arg0: number, arg1: Internal.IntUnaryOperator): number;
        computeIfAbsent(arg0: any, arg1: (arg0: any) => any): any;
        computeIfAbsent(arg0: number, arg1: (arg0: number) => number): number;
        computeIfAbsent(arg0: number, arg1: (arg0: any) => any): number;
        values(): Internal.Collection<any>;
        values(): Internal.IntCollection;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        computeIfAbsentPartial(arg0: number, arg1: (arg0: any) => any): number;
        replaceAll(arg0: (arg0: number, arg1: number) => number): void;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        remove(arg0: number, arg1: number): boolean;
        remove(arg0: any): any;
        remove(arg0: any): number;
        remove(arg0: any, arg1: any): boolean;
        remove(arg0: number): number;
        int2IntEntrySet(): Internal.ObjectSet<Internal.Int2IntMap$Entry>;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        hashCode(): number;
        putAll(arg0: Internal.Map<number, number>): void;
        get(arg0: any): any;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        keySet(): Internal.Set<any>;
        keySet(): Internal.IntSet;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        computeIfAbsentNullable(arg0: number, arg1: Internal.IntFunction<number>): number;
        forEach(arg0: (arg0: number, arg1: number) => void): void;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        isEmpty(): boolean;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number;
        computeIfPresent(arg0: any, arg1: (arg0: any, arg1: any) => any): any;
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        putIfAbsent(arg0: any, arg1: any): any;
        putIfAbsent(arg0: number, arg1: number): number;
        putIfAbsent(arg0: number, arg1: number): number;
    }
    abstract class RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(arg0: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        serialize(): void;
        setGroup(g: string): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        parseResultItem(o: any): Internal.ItemStackJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IPlaceableItem {
        addPlaceable(arg0: Internal.Block): void;
        getBlockItemOverride(): Internal.BlockItem;
    }
    interface IntComparator extends Internal.Comparator<number> {
        compare(arg0: number, arg1: number): number;
        compare(arg0: any, arg1: any): number;
        compare(arg0: number, arg1: number): number;
        thenComparingLong(arg0: Internal.ToLongFunction<number>): Internal.Comparator<number>;
        thenComparingInt(arg0: Internal.ToIntFunction<number>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.Comparator<number>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.IntComparator): Internal.IntComparator;
        thenComparing<U_>(arg0: (arg0: number) => U_, arg1: Internal.Comparator<U_>): Internal.Comparator<number>;
        thenComparing<U_>(arg0: (arg0: number) => U_): Internal.Comparator<number>;
        thenComparingDouble(arg0: Internal.ToDoubleFunction<number>): Internal.Comparator<number>;
        equals(arg0: any): boolean;
        reversed(): Internal.IntComparator;
        reversed(): Internal.Comparator<any>;
    }
    class Rarity extends Internal.Enum<any> implements Internal.IExtensibleEnum {
        init(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Rarity;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Rarity[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Rarity): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Rarity>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Rarity>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        static create(arg0: string, arg1: Internal.ChatFormatting): Internal.Rarity;
        toString(): string;
        ordinal(): number;
        static readonly RARE : Internal.Rarity;
        static readonly EPIC : Internal.Rarity;
        static readonly UNCOMMON : Internal.Rarity;
        static readonly COMMON : Internal.Rarity;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Rarity>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EquipmentEntity$EquipmentTrackingEntity {
    }
    class ConstantUnit extends Internal.FixedUnit {
        getClass(): Internal.Class<any>;
        mod(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        log1p(): dev.latvian.mods.rhino.util.unit.Unit;
        cos(): dev.latvian.mods.rhino.util.unit.Unit;
        deg(): dev.latvian.mods.rhino.util.unit.Unit;
        lt(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        atan(): dev.latvian.mods.rhino.util.unit.Unit;
        getAsInt(): number;
        div(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        neg(): dev.latvian.mods.rhino.util.unit.Unit;
        shiftLeft(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        rad(): dev.latvian.mods.rhino.util.unit.Unit;
        sqrt(): dev.latvian.mods.rhino.util.unit.Unit;
        gte(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        neq(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        atan2(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        tan(): dev.latvian.mods.rhino.util.unit.Unit;
        add(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        newValue(v: number): dev.latvian.mods.rhino.util.unit.Unit;
        toBool(): dev.latvian.mods.rhino.util.unit.Unit;
        ceil(): dev.latvian.mods.rhino.util.unit.Unit;
        eq(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        shiftRight(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        sub(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mul(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        log(): dev.latvian.mods.rhino.util.unit.Unit;
        log10(): dev.latvian.mods.rhino.util.unit.Unit;
        notifyAll(): void;
        notify(): void;
        not(): dev.latvian.mods.rhino.util.unit.Unit;
        min(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        hashCode(): number;
        and(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        static of(value: number): Internal.FixedUnit;
        get(): number;
        pow(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        sin(): dev.latvian.mods.rhino.util.unit.Unit;
        xor(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        lte(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        floor(): dev.latvian.mods.rhino.util.unit.Unit;
        isFixed(): boolean;
        sq(): dev.latvian.mods.rhino.util.unit.Unit;
        or(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        max(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        gt(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        abs(): dev.latvian.mods.rhino.util.unit.Unit;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        append(sb: Internal.StringBuilder): void;
        static readonly ZERO : Internal.FixedUnit;
        static readonly ONE : Internal.FixedUnit;
        static readonly POS_INFINITY : Internal.FixedUnit;
        static readonly NEG_INFINITY : Internal.FixedUnit;
        readonly name : string;
        static readonly NAN : Internal.FixedUnit;
        get asInt(): number;
        get fixed(): boolean;
        get class(): Internal.Class<any>;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class VarHandle$VarHandleDesc extends Internal.DynamicConstantDesc<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static ofCanonical<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: string, arg2: Internal.ClassDesc, arg3: Internal.ConstantDesc[]): Internal.ConstantDesc;
        bootstrapMethod(): Internal.DirectMethodHandleDesc;
        constantName(): string;
        notifyAll(): void;
        bootstrapArgsList(): Internal.List<Internal.ConstantDesc>;
        static ofArray(arg0: Internal.ClassDesc): Internal.VarHandle$VarHandleDesc;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): any;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): Internal.VarHandle;
        notify(): void;
        static ofField(arg0: Internal.ClassDesc, arg1: string, arg2: Internal.ClassDesc): Internal.VarHandle$VarHandleDesc;
        static ofStaticField(arg0: Internal.ClassDesc, arg1: string, arg2: Internal.ClassDesc): Internal.VarHandle$VarHandleDesc;
        varType(): Internal.ClassDesc;
        constantType(): Internal.ClassDesc;
        hashCode(): number;
        bootstrapArgs(): Internal.ConstantDesc[];
        static of<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: Internal.ConstantDesc[]): Internal.DynamicConstantDesc<T_>;
        static of<T_>(arg0: Internal.DirectMethodHandleDesc): Internal.DynamicConstantDesc<T_>;
        equals(arg0: any): boolean;
        static ofNamed<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: string, arg2: Internal.ClassDesc, arg3: Internal.ConstantDesc[]): Internal.DynamicConstantDesc<T_>;
        toString(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Reference2CharFunction <K> extends it.unimi.dsi.fastutil.Function<K, string>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: any, arg1: string): string;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        removeChar(arg0: any): string;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: K) => T_;
        put(arg0: K, arg1: string): string;
        put(arg0: K, arg1: string): string;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): any;
        remove(arg0: any): string;
        defaultReturnValue(arg0: string): void;
        defaultReturnValue(): string;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        get(arg0: any): string;
        get(arg0: any): any;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: K): number;
        apply(arg0: K): string;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        getChar(arg0: any): string;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => string;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface LevelReader extends Internal.BlockAndTintGetter, Internal.CollisionGetter, Internal.BiomeManager$NoiseBiomeSource {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean;
    }
    interface Short2LongFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsLong(arg0: number): number;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class SimpleMapCodec <K, V> extends Internal.MapCodec<any> implements Internal.BaseMapCodec<K, V> {
        encode(arg0: any, arg1: Internal.DynamicOps<any>, arg2: Internal.RecordBuilder<any>): Internal.RecordBuilder<any>;
        encode<T_>(arg0: Internal.Map<K, V>, arg1: Internal.DynamicOps<T_>, arg2: Internal.RecordBuilder<T_>): Internal.RecordBuilder<T_>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setPartial(arg0: () => Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>;
        keys<T_>(arg0: Internal.DynamicOps<T_>): Internal.Stream<T_>;
        notifyAll(): void;
        deprecated(arg0: number): Internal.MapCodec<Internal.Map<K, V>>;
        decode<T_>(arg0: Internal.DynamicOps<T_>, arg1: Internal.MapLike<T_>): Internal.DataResult<Internal.Map<K, V>>;
        notify(): void;
        flatXmap<S_>(arg0: (arg0: Internal.Map<K, V>) => Internal.DataResult<S_>, arg1: (arg0: S_) => Internal.DataResult<Internal.Map<K, V>>): Internal.MapCodec<S_>;
        hashCode(): number;
        comap<B_>(arg0: (arg0: B_) => Internal.Map<K, V>): Internal.MapEncoder<B_>;
        static of<A_>(arg0: Internal.MapEncoder<A_>, arg1: Internal.MapDecoder<A_>, arg2: () => string): Internal.MapCodec<A_>;
        static of<A_>(arg0: Internal.MapEncoder<A_>, arg1: Internal.MapDecoder<A_>): Internal.MapCodec<A_>;
        fieldOf(arg0: string): Internal.MapCodec<Internal.Map<K, V>>;
        xmap<S_>(arg0: (arg0: Internal.Map<K, V>) => S_, arg1: (arg0: S_) => Internal.Map<K, V>): Internal.MapCodec<S_>;
        map<B_>(arg0: (arg0: Internal.Map<K, V>) => B_): Internal.MapDecoder<B_>;
        dependent<E_>(arg0: Internal.MapCodec<E_>, arg1: (arg0: Internal.Map<K, V>) => Internal.Pair<E_, Internal.MapCodec<E_>>, arg2: (arg0: Internal.Map<K, V>, arg1: E_) => Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>;
        flatComap<B_>(arg0: (arg0: B_) => Internal.DataResult<Internal.Map<K, V>>): Internal.MapEncoder<B_>;
        compressedDecode<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<Internal.Map<K, V>>;
        compressedBuilder<T_>(arg0: Internal.DynamicOps<T_>): Internal.RecordBuilder<T_>;
        keyCodec(): Internal.Codec<K>;
        decoder(): Internal.Decoder<Internal.Map<K, V>>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapDecoder<any>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapEncoder<any>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.MapCodec<Internal.Map<K, V>>;
        encoder(): Internal.Encoder<Internal.Map<K, V>>;
        orElse(arg0: Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>;
        orElse(arg0: (arg0: string) => void, arg1: Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>;
        orElse(arg0: (arg0: any) => any, arg1: Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>;
        forGetter<O_>(arg0: (arg0: O_) => Internal.Map<K, V>): Internal.RecordCodecBuilder<O_, Internal.Map<K, V>>;
        ap<E_>(arg0: Internal.MapDecoder<(arg0: Internal.Map<K, V>) => E_>): Internal.MapDecoder<E_>;
        flatMap<B_>(arg0: (arg0: Internal.Map<K, V>) => Internal.DataResult<B_>): Internal.MapDecoder<B_>;
        codec(): Internal.Codec<Internal.Map<K, V>>;
        static unit<A_>(arg0: () => A_): Internal.MapCodec<A_>;
        static unit<A_>(arg0: A_): Internal.MapCodec<A_>;
        elementCodec(): Internal.Codec<V>;
        orElseGet(arg0: (arg0: any) => any, arg1: () => Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>;
        orElseGet(arg0: (arg0: string) => void, arg1: () => Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>;
        orElseGet(arg0: () => Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>;
        stable(): Internal.MapCodec<Internal.Map<K, V>>;
        equals(arg0: any): boolean;
        mapResult(arg0: Internal.MapCodec$ResultFunction<Internal.Map<K, V>>): Internal.MapCodec<Internal.Map<K, V>>;
        toString(): string;
        compressor<T_>(arg0: Internal.DynamicOps<T_>): Internal.KeyCompressor<T_>;
        get class(): Internal.Class<any>;
        set partial(arg0: () => Internal.Map<K, V>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ServerLevelAccessor extends Internal.LevelAccessor {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean;
    }
    interface RecipeType <T> {
    }
    interface EnhancedCelestialsWorldData {
        getLunarContext(): Internal.LunarContext;
        setLunarContext(arg0: Internal.LunarContext): Internal.LunarContext;
    }
    class ChronoUnit extends Internal.Enum<any> implements Internal.TemporalUnit {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ChronoUnit;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ChronoUnit[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ChronoUnit): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ChronoUnit>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ChronoUnit>;
        isDurationEstimated(): boolean;
        getDuration(): Internal.Duration;
        hashCode(): number;
        equals(arg0: any): boolean;
        isTimeBased(): boolean;
        name(): string;
        addTo<R_>(arg0: R_, arg1: number): R_;
        toString(): string;
        isDateBased(): boolean;
        between(arg0: Internal.Temporal, arg1: Internal.Temporal): number;
        ordinal(): number;
        isSupportedBy(arg0: Internal.Temporal): boolean;
        static readonly FOREVER : Internal.ChronoUnit;
        static readonly MICROS : Internal.ChronoUnit;
        static readonly SECONDS : Internal.ChronoUnit;
        static readonly DECADES : Internal.ChronoUnit;
        static readonly MILLENNIA : Internal.ChronoUnit;
        static readonly DAYS : Internal.ChronoUnit;
        static readonly MILLIS : Internal.ChronoUnit;
        static readonly HALF_DAYS : Internal.ChronoUnit;
        static readonly MONTHS : Internal.ChronoUnit;
        static readonly YEARS : Internal.ChronoUnit;
        static readonly HOURS : Internal.ChronoUnit;
        static readonly WEEKS : Internal.ChronoUnit;
        static readonly NANOS : Internal.ChronoUnit;
        static readonly CENTURIES : Internal.ChronoUnit;
        static readonly MINUTES : Internal.ChronoUnit;
        static readonly ERAS : Internal.ChronoUnit;
        get duration(): Internal.Duration;
        get durationEstimated(): boolean;
        get timeBased(): boolean;
        get dateBased(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ChronoUnit>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class PlayerJS <E> extends Internal.LivingEntityJS implements Internal.WithAttachedData {
        getXpLevel(): number;
        getLastAttackedEntity(): Internal.LivingEntityJS;
        sendData(channel: string, data: Internal.CompoundTag): void;
        setY(y: number): void;
        setX(x: number): void;
        isOnScoreboardTeam(teamID: string): boolean;
        isLiving(): boolean;
        isSprinting(): boolean;
        getItem(): Internal.ItemStackJS;
        getRevengeTarget(): Internal.LivingEntityJS;
        paint(arg0: Internal.CompoundTag): void;
        getTags(): Internal.Set<string>;
        getOffHandItem(): Internal.ItemStackJS;
        setGlowing(glowing: boolean): void;
        setZ(z: number): void;
        setXpLevel(l: number): void;
        getHasCustomName(): boolean;
        setInvisible(invisible: boolean): void;
        runCommandSilent(command: string): number;
        getIdleTime(): number;
        getMovementSpeed(): number;
        setSelectedSlot(index: number): void;
        getDistanceSq(x: number, y: number, z: number): number;
        getDistanceSq(pos: BlockPos): number;
        isBoss(): boolean;
        isGlowing(): boolean;
        getHorizontalFacing(): Internal.Direction;
        addFood(f: number, m: number): void;
        setLegsArmorItem(item: Internal.ItemStackJS): void;
        getHealth(): number;
        getServer(): Internal.ServerJS;
        setFeetArmorItem(item: Internal.ItemStackJS): void;
        give(item: Internal.ItemStackJS): void;
        setMaxHealth(hp: number): void;
        setMotion(x: number, y: number, z: number): void;
        getProfile(): Internal.GameProfile;
        setRotation(yaw: number, pitch: number): void;
        isMiningBlock(): boolean;
        isSpectator(): boolean;
        setAbsorptionAmount(amount: number): void;
        isOnSameTeam(e: Internal.EntityJS): boolean;
        isAnimal(): boolean;
        getDisplayName(): Internal.Text;
        getType(): string;
        getXp(): number;
        addExhaustion(exhaustion: number): void;
        setCustomNameAlwaysVisible(b: boolean): void;
        setOffHandItem(item: Internal.ItemStackJS): void;
        getFoodLevel(): number;
        addMotion(x: number, y: number, z: number): void;
        isFake(): boolean;
        isInvisible(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMaxHealth(): number;
        isUnderWater(): boolean;
        getHeldItem(hand: Hand): Internal.ItemStackJS;
        getEyeHeight(): number;
        getEquipment(slot: EquipmentSlot): Internal.ItemStackJS;
        notify(): void;
        getFallDistance(): number;
        damageHeldItem(hand: Hand, amount: number): void;
        damageHeldItem(hand: Hand, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void;
        damageHeldItem(): void;
        setAirSupply(air: number): void;
        setOnFire(seconds: number): void;
        removePassengers(): void;
        attack(hp: number): void;
        attack(source: string, hp: number): void;
        isUndead(): boolean;
        isOnLadder(): boolean;
        playSound(id: Internal.SoundEvent): void;
        playSound(id: Internal.SoundEvent, volume: number, pitch: number): void;
        getInventory(): Internal.InventoryJS;
        boostElytraFlight(): void;
        getData(): Internal.AttachedData;
        getDistance(x: number, y: number, z: number): number;
        getDistance(pos: BlockPos): number;
        getLastDamageSource(): Internal.DamageSourceJS;
        setStatusMessage(message: Internal.Component): void;
        isSwimming(): boolean;
        getReachDistance(): number;
        getCustomName(): Internal.Text;
        getStepHeight(): number;
        mergeFullNBT(tag: Internal.CompoundTag): Internal.EntityJS;
        kill(): void;
        getRidingEntity(): Internal.EntityJS;
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void;
        getLevel(): Internal.LevelJS;
        getPitch(): number;
        getPassengers(): Internal.EntityArrayList;
        getLastAttackedEntityTime(): number;
        isMonster(): boolean;
        equals(arg0: any): boolean;
        addItemCooldown(item: Internal.Item, ticks: number): void;
        setPitch(pitch: number): void;
        isOnGround(): boolean;
        getFacing(): Internal.Direction;
        toString(): string;
        isSilent(): boolean;
        isPassenger(e: Internal.EntityJS): boolean;
        setXp(xp: number): void;
        getMaxAirSupply(): number;
        getClass(): Internal.Class<any>;
        getNbt(): Internal.CompoundTag;
        getRecursivePassengers(): Internal.EntityArrayList;
        setFallDistance(fallDistance: number): void;
        getName(): Internal.Text;
        getFeetArmorItem(): Internal.ItemStackJS;
        sendInventoryUpdate(): void;
        setCustomName(name: Internal.Component): void;
        setMainHandItem(item: Internal.ItemStackJS): void;
        setStepHeight(stepHeight: number): void;
        tell(message: Internal.Component): void;
        getTeamId(): string;
        isWaterCreature(): boolean;
        setNoClip(noClip: boolean): void;
        setPosition(x: number, y: number, z: number): void;
        setPosition(block: Internal.BlockContainerJS): void;
        closeInventory(): void;
        extinguish(): void;
        setInvulnerable(invulnerable: boolean): void;
        setRevengeTarget(target: Internal.LivingEntityJS): void;
        setMovementSpeed(speed: number): void;
        isChild(): boolean;
        setEquipment(slot: EquipmentSlot, item: Internal.ItemStackJS): void;
        giveInHand(item: Internal.ItemStackJS): void;
        getAirSupply(): number;
        getLegsArmorItem(): Internal.ItemStackJS;
        setFullNBT(nbt: Internal.CompoundTag): void;
        getAttackingEntity(): Internal.LivingEntityJS;
        isHoldingInAnyHand(ingredient: any): boolean;
        isCreativeMode(): boolean;
        getFullNBT(): Internal.CompoundTag;
        getNoClip(): boolean;
        setYaw(yaw: number): void;
        damageEquipment(slot: EquipmentSlot, amount: number): void;
        damageEquipment(slot: EquipmentSlot): void;
        damageEquipment(slot: EquipmentSlot, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void;
        getYaw(): number;
        isAlive(): boolean;
        getHeadArmorItem(): Internal.ItemStackJS;
        setNoGravity(noGravity: boolean): void;
        setMouseItem(item: Internal.ItemStackJS): void;
        setHeldItem(hand: Hand, item: Internal.ItemStackJS): void;
        isPlayer(): boolean;
        getRevengeTimer(): number;
        getStats(): Internal.PlayerStatsJS;
        getAbsorptionAmount(): number;
        isCrouching(): boolean;
        notifyAll(): void;
        getId(): Internal.UUID;
        addXPLevels(l: number): void;
        getTicksExisted(): number;
        getOpenInventory(): Internal.AbstractContainerMenu;
        getStages(): Internal.Stages;
        setSilent(isSilent: boolean): void;
        hashCode(): number;
        getChestArmorItem(): Internal.ItemStackJS;
        isFrame(): boolean;
        heal(hp: number): void;
        startRiding(e: Internal.EntityJS, force: boolean): boolean;
        runCommand(command: string): number;
        setChestArmorItem(item: Internal.ItemStackJS): void;
        getCustomNameAlwaysVisible(): boolean;
        addXP(xp: number): void;
        getMainHandItem(): Internal.ItemStackJS;
        setHealth(hp: number): void;
        setMotionZ(z: number): void;
        setMotionY(y: number): void;
        getBlock(): Internal.BlockContainerJS;
        setMotionX(x: number): void;
        isElytraFlying(): boolean;
        isInWater(): boolean;
        dismountRidingEntity(): void;
        isSleeping(): boolean;
        isAmbientCreature(): boolean;
        swingArm(hand: Hand): void;
        getPotionEffects(): Internal.EntityPotionEffectsJS;
        rayTrace(): Internal.RayTraceResultJS;
        rayTrace(distance: number): Internal.RayTraceResultJS;
        isInvulnerable(): boolean;
        setHeadArmorItem(item: Internal.ItemStackJS): void;
        getSelectedSlot(): number;
        canEntityBeSeen(entity: Internal.LivingEntityJS): boolean;
        getX(): number;
        getY(): number;
        spawn(): void;
        getZ(): number;
        isPeacefulCreature(): boolean;
        getMouseItem(): Internal.ItemStackJS;
        setFoodLevel(foodLevel: number): void;
        getMotionZ(): number;
        getMotionX(): number;
        getMotionY(): number;
        getNoGravity(): boolean;
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftPlayer : E;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        get data(): Internal.AttachedData;
        get xpLevel(): number;
        get invisible(): boolean;
        get creativeMode(): boolean;
        get customNameAlwaysVisible(): boolean;
        get movementSpeed(): number;
        get type(): string;
        get idleTime(): number;
        get legsArmorItem(): Internal.ItemStackJS;
        get maxAirSupply(): number;
        get stats(): Internal.PlayerStatsJS;
        get revengeTarget(): Internal.LivingEntityJS;
        get hasCustomName(): boolean;
        get undead(): boolean;
        get lastAttackedEntity(): Internal.LivingEntityJS;
        get maxHealth(): number;
        get block(): Internal.BlockContainerJS;
        get pitch(): number;
        get id(): Internal.UUID;
        get potionEffects(): Internal.EntityPotionEffectsJS;
        get item(): Internal.ItemStackJS;
        get passengers(): Internal.EntityArrayList;
        get level(): Internal.LevelJS;
        get profile(): Internal.GameProfile;
        get onLadder(): boolean;
        get feetArmorItem(): Internal.ItemStackJS;
        get offHandItem(): Internal.ItemStackJS;
        get customName(): Internal.Text;
        get lastAttackedEntityTime(): number;
        get horizontalFacing(): Internal.Direction;
        get tags(): Internal.Set<string>;
        get sprinting(): boolean;
        get crouching(): boolean;
        get mouseItem(): Internal.ItemStackJS;
        get noGravity(): boolean;
        get fullNBT(): Internal.CompoundTag;
        get name(): Internal.Text;
        get animal(): boolean;
        get peacefulCreature(): boolean;
        get lastDamageSource(): Internal.DamageSourceJS;
        get stepHeight(): number;
        get child(): boolean;
        get frame(): boolean;
        get noClip(): boolean;
        get server(): Internal.ServerJS;
        get nbt(): Internal.CompoundTag;
        get boss(): boolean;
        get alive(): boolean;
        get ticksExisted(): number;
        get displayName(): Internal.Text;
        get fallDistance(): number;
        get revengeTimer(): number;
        get mainHandItem(): Internal.ItemStackJS;
        get facing(): Internal.Direction;
        get ambientCreature(): boolean;
        get elytraFlying(): boolean;
        get inventory(): Internal.InventoryJS;
        get airSupply(): number;
        get sleeping(): boolean;
        get swimming(): boolean;
        get waterCreature(): boolean;
        get invulnerable(): boolean;
        get miningBlock(): boolean;
        get selectedSlot(): number;
        get eyeHeight(): number;
        get headArmorItem(): Internal.ItemStackJS;
        get underWater(): boolean;
        get class(): Internal.Class<any>;
        get reachDistance(): number;
        get player(): boolean;
        get absorptionAmount(): number;
        get openInventory(): Internal.AbstractContainerMenu;
        get motionZ(): number;
        get silent(): boolean;
        get living(): boolean;
        get motionY(): number;
        get motionX(): number;
        get ridingEntity(): Internal.EntityJS;
        get health(): number;
        get inWater(): boolean;
        get chestArmorItem(): Internal.ItemStackJS;
        get recursivePassengers(): Internal.EntityArrayList;
        get yaw(): number;
        get monster(): boolean;
        get attackingEntity(): Internal.LivingEntityJS;
        get glowing(): boolean;
        get onGround(): boolean;
        get teamId(): string;
        get spectator(): boolean;
        get xp(): number;
        get stages(): Internal.Stages;
        get x(): number;
        get y(): number;
        get fake(): boolean;
        get z(): number;
        get foodLevel(): number;
        set noClip(noClip: boolean);
        set xpLevel(l: number);
        set fallDistance(fallDistance: number);
        set mainHandItem(item: Internal.ItemStackJS);
        set invisible(invisible: boolean);
        set customNameAlwaysVisible(b: boolean);
        set movementSpeed(speed: number);
        set airSupply(air: number);
        set invulnerable(invulnerable: boolean);
        set legsArmorItem(item: Internal.ItemStackJS);
        set selectedSlot(index: number);
        set revengeTarget(target: Internal.LivingEntityJS);
        set maxHealth(hp: number);
        set headArmorItem(item: Internal.ItemStackJS);
        set pitch(pitch: number);
        set motionZ(z: number);
        set absorptionAmount(amount: number);
        set silent(isSilent: boolean);
        set motionY(y: number);
        set motionX(x: number);
        set health(hp: number);
        set feetArmorItem(item: Internal.ItemStackJS);
        set offHandItem(item: Internal.ItemStackJS);
        set chestArmorItem(item: Internal.ItemStackJS);
        set onFire(seconds: number);
        set yaw(yaw: number);
        set statusMessage(message: Internal.Component);
        set glowing(glowing: boolean);
        set mouseItem(item: Internal.ItemStackJS);
        set noGravity(noGravity: boolean);
        set fullNBT(nbt: Internal.CompoundTag);
        set xp(xp: number);
        set x(x: number);
        set y(y: number);
        set z(z: number);
        set foodLevel(foodLevel: number);
        set position(block: Internal.BlockContainerJS);
        set stepHeight(stepHeight: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Object2ShortFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        removeShort(arg0: any): number;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_;
        put(arg0: K, arg1: number): number;
        put(arg0: K, arg1: number): number;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): any;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        get(arg0: any): number;
        get(arg0: any): any;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: K): number;
        apply(arg0: K): number;
        getShort(arg0: any): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class TrackedData <T> {
        getProcessor(): Internal.IDataProcessor<T>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        isPersistent(): boolean;
        getSyncType(): Internal.SyncType;
        toString(): string;
        shouldSave(): boolean;
        notify(): void;
        getDefaultValue(): T;
        get defaultValue(): T;
        get persistent(): boolean;
        get syncType(): Internal.SyncType;
        get processor(): Internal.IDataProcessor<T>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class IntervalJS {
        matchesSqr(arg0: number): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        max(arg0: number): Internal.IntervalJS;
        notifyAll(): void;
        getVanillaInt(): Internal.MinMaxBounds$Ints;
        getVanillaDoubles(): Internal.MinMaxBounds$Doubles;
        matches(arg0: number): boolean;
        notify(): void;
        static ofInt(arg0: any): Internal.MinMaxBounds$Ints;
        min(arg0: number): Internal.IntervalJS;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        between(arg0: number, arg1: number): Internal.IntervalJS;
        static ofDoubles(arg0: any): Internal.MinMaxBounds$Doubles;
        get vanillaInt(): Internal.MinMaxBounds$Ints;
        get vanillaDoubles(): Internal.MinMaxBounds$Doubles;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Unit extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Unit;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Unit[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Unit): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Unit>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Unit>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly INSTANCE : Internal.Unit;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Unit>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class RayTraceResultJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        readonly fromEntity : Internal.EntityJS;
        readonly distance : number;
        hitX : number;
        hitY : number;
        hitZ : number;
        facing : Internal.Direction;
        block : Internal.BlockContainerJS;
        readonly type : string;
        entity : Internal.EntityJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockIDPredicate$PropertyObject {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ScriptManager {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        loadFromDirectory(): void;
        load(): void;
        hashCode(): number;
        isClassAllowed(name: string): boolean;
        notifyAll(): void;
        equals(arg0: any): boolean;
        loadJavaClass(scope: Internal.Scriptable, args: any[]): Internal.NativeJavaClass;
        unload(): void;
        toString(): string;
        notify(): void;
        readonly exampleScript : string;
        readonly type : Internal.ScriptType;
        firstLoad : boolean;
        readonly directory : Internal.Path;
        readonly packs : Internal.Map<string, Internal.ScriptPack>;
        readonly events : Internal.EventsJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Rotation extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Rotation;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Rotation[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Rotation): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Rotation>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Rotation>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly COUNTERCLOCKWISE_90 : Internal.Rotation;
        static readonly CLOCKWISE_90 : Internal.Rotation;
        static readonly CLOCKWISE_180 : Internal.Rotation;
        static readonly NONE : Internal.Rotation;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Rotation>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface WorldGenLevel extends Internal.ServerLevelAccessor {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean;
    }
    abstract class AbstractByteBuf extends Internal.ByteBuf {
        asReadOnly(): Internal.ByteBuf;
        markReaderIndex(): Internal.ByteBuf;
        getByte(arg0: number): number;
        release(arg0: number): boolean;
        release(): boolean;
        readDoubleLE(): number;
        writeZero(arg0: number): Internal.ByteBuf;
        resetReaderIndex(): Internal.ByteBuf;
        writeFloat(arg0: number): Internal.ByteBuf;
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf;
        readRetainedSlice(arg0: number): Internal.ByteBuf;
        slice(): Internal.ByteBuf;
        slice(arg0: number, arg1: number): Internal.ByteBuf;
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf;
        getMediumLE(arg0: number): number;
        readUnsignedIntLE(): number;
        writeFloatLE(arg0: number): Internal.ByteBuf;
        readInt(): number;
        order(arg0: Internal.ByteOrder): Internal.ByteBuf;
        order(): Internal.ByteOrder;
        writeMedium(arg0: number): Internal.ByteBuf;
        resetWriterIndex(): Internal.ByteBuf;
        writableBytes(): number;
        maxCapacity(): number;
        getUnsignedShort(arg0: number): number;
        nioBufferCount(): number;
        bytesBefore(arg0: number): number;
        bytesBefore(arg0: number, arg1: number): number;
        bytesBefore(arg0: number, arg1: number, arg2: number): number;
        setInt(arg0: number, arg1: number): Internal.ByteBuf;
        getInt(arg0: number): number;
        markWriterIndex(): Internal.ByteBuf;
        isReadable(arg0: number): boolean;
        isReadable(): boolean;
        writeBoolean(arg0: boolean): Internal.ByteBuf;
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        writeLongLE(arg0: number): Internal.ByteBuf;
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf;
        retain(arg0: number): Internal.ReferenceCounted;
        retain(arg0: number): Internal.ByteBuf;
        retain(): Internal.ByteBuf;
        retain(): Internal.ReferenceCounted;
        isWritable(arg0: number): boolean;
        isWritable(): boolean;
        notify(): void;
        readChar(): string;
        hasMemoryAddress(): boolean;
        capacity(): number;
        capacity(arg0: number): Internal.ByteBuf;
        readCharSequence(arg0: number, arg1: Internal.Charset): Internal.CharSequence;
        isReadOnly(): boolean;
        readUnsignedShortLE(): number;
        readDouble(): number;
        readFloat(): number;
        getLongLE(arg0: number): number;
        getBoolean(arg0: number): boolean;
        copy(): Internal.ByteBuf;
        copy(arg0: number, arg1: number): Internal.ByteBuf;
        readShortLE(): number;
        readUnsignedMedium(): number;
        ensureWritable(arg0: number, arg1: boolean): number;
        ensureWritable(arg0: number): Internal.ByteBuf;
        writeInt(arg0: number): Internal.ByteBuf;
        readFloatLE(): number;
        getDoubleLE(arg0: number): number;
        hasArray(): boolean;
        memoryAddress(): number;
        maxFastWritableBytes(): number;
        readableBytes(): number;
        readSlice(arg0: number): Internal.ByteBuf;
        getIntLE(arg0: number): number;
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number;
        forEachByteDesc(arg0: Internal.ByteProcessor): number;
        nioBuffers(): Internal.ByteBuffer[];
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        skipBytes(arg0: number): Internal.ByteBuf;
        getLong(arg0: number): number;
        readLong(): number;
        readShort(): number;
        equals(arg0: any): boolean;
        getUnsignedMedium(arg0: number): number;
        setZero(arg0: number, arg1: number): Internal.ByteBuf;
        readBytes(arg0: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: Internal.GatheringByteChannel, arg1: number): number;
        readBytes(arg0: number[]): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf;
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf;
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number;
        readBoolean(): boolean;
        toString(): string;
        toString(arg0: Internal.Charset): string;
        toString(arg0: number, arg1: number, arg2: Internal.Charset): string;
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf;
        retainedSlice(): Internal.ByteBuf;
        readMediumLE(): number;
        isDirect(): boolean;
        setMedium(arg0: number, arg1: number): Internal.ByteBuf;
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf;
        getClass(): Internal.Class<any>;
        getFloatLE(arg0: number): number;
        readerIndex(arg0: number): Internal.ByteBuf;
        readerIndex(): number;
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset): Internal.CharSequence;
        setShort(arg0: number, arg1: number): Internal.ByteBuf;
        compareTo(arg0: Internal.ByteBuf): number;
        compareTo(arg0: any): number;
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number;
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel, arg2: number): number;
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf;
        unwrap(): Internal.ByteBuf;
        setDouble(arg0: number, arg1: number): Internal.ByteBuf;
        setChar(arg0: number, arg1: number): Internal.ByteBuf;
        refCnt(): number;
        getUnsignedIntLE(arg0: number): number;
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf;
        getUnsignedInt(arg0: number): number;
        indexOf(arg0: number, arg1: number, arg2: number): number;
        writeByte(arg0: number): Internal.ByteBuf;
        nioBuffer(): Internal.ByteBuffer;
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        touch(): Internal.ReferenceCounted;
        touch(): Internal.ByteBuf;
        touch(arg0: any): Internal.ByteBuf;
        touch(arg0: any): Internal.ReferenceCounted;
        discardSomeReadBytes(): Internal.ByteBuf;
        duplicate(): Internal.ByteBuf;
        writerIndex(): number;
        writerIndex(arg0: number): Internal.ByteBuf;
        getUnsignedShortLE(arg0: number): number;
        writeCharSequence(arg0: Internal.CharSequence, arg1: Internal.Charset): number;
        readUnsignedInt(): number;
        retainedDuplicate(): Internal.ByteBuf;
        getChar(arg0: number): string;
        setLong(arg0: number, arg1: number): Internal.ByteBuf;
        readMedium(): number;
        writeBytes(arg0: Internal.ScatteringByteChannel, arg1: number): number;
        writeBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf;
        writeBytes(arg0: Internal.InputStream, arg1: number): number;
        writeBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number;
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: number[]): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf;
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number;
        forEachByte(arg0: Internal.ByteProcessor): number;
        setIndex(arg0: number, arg1: number): Internal.ByteBuf;
        writeShort(arg0: number): Internal.ByteBuf;
        alloc(): Internal.ByteBufAllocator;
        getShortLE(arg0: number): number;
        getMedium(arg0: number): number;
        readUnsignedShort(): number;
        setByte(arg0: number, arg1: number): Internal.ByteBuf;
        maxWritableBytes(): number;
        writeShortLE(arg0: number): Internal.ByteBuf;
        notifyAll(): void;
        getDouble(arg0: number): number;
        getFloat(arg0: number): number;
        writeLong(arg0: number): Internal.ByteBuf;
        writeIntLE(arg0: number): Internal.ByteBuf;
        array(): number[];
        setCharSequence(arg0: number, arg1: Internal.CharSequence, arg2: Internal.Charset): number;
        hashCode(): number;
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        arrayOffset(): number;
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf;
        readIntLE(): number;
        readUnsignedByte(): number;
        readLongLE(): number;
        readUnsignedMediumLE(): number;
        writeDouble(arg0: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel, arg2: number): number;
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.InputStream, arg2: number): number;
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number;
        setFloat(arg0: number, arg1: number): Internal.ByteBuf;
        getShort(arg0: number): number;
        writeMediumLE(arg0: number): Internal.ByteBuf;
        clear(): Internal.ByteBuf;
        getUnsignedByte(arg0: number): number;
        discardReadBytes(): Internal.ByteBuf;
        writeChar(arg0: number): Internal.ByteBuf;
        writeDoubleLE(arg0: number): Internal.ByteBuf;
        isContiguous(): boolean;
        getUnsignedMediumLE(arg0: number): number;
        readByte(): number;
        get readable(): boolean;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get contiguous(): boolean;
        get writable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MinMaxBounds$Doubles extends Internal.MinMaxBounds<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IIngredientSerializer <T> {
        parse(arg0: Internal.JsonObject): T;
        parse(arg0: Internal.FriendlyByteBuf): T;
        write(arg0: Internal.FriendlyByteBuf, arg1: T): void;
    }
    interface ObjectList <K> extends Internal.List<K>, Internal.Comparable<Internal.List<K>>, Internal.ObjectCollection<K> {
        compareTo(arg0: Internal.List<K>): number;
        replaceAll(arg0: (arg0: any) => any): void;
        remove(arg0: any): boolean;
        remove(arg0: number): K;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.Iterator<any>;
        iterator(): Internal.ObjectIterator<any>;
        iterator(): Internal.ObjectListIterator<K>;
        stream(): Internal.Stream<K>;
        hashCode(): number;
        addElements(arg0: number, arg1: K[]): void;
        addElements(arg0: number, arg1: K[], arg2: number, arg3: number): void;
        get(arg0: number): K;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<K>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: K): void;
        add(arg0: K): boolean;
        subList(arg0: number, arg1: number): Internal.ObjectList<K>;
        subList(arg0: number, arg1: number): Internal.List<any>;
        set(arg0: number, arg1: K): K;
        spliterator(): Internal.Spliterator<any>;
        spliterator(): Internal.ObjectSpliterator<K>;
        forEach(arg0: (arg0: Internal.List<K>) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        setElements(arg0: K[]): void;
        setElements(arg0: number, arg1: K[]): void;
        setElements(arg0: number, arg1: K[], arg2: number, arg3: number): void;
        sort(arg0: Internal.Comparator<K>): void;
        removeElements(arg0: number, arg1: number): void;
        removeIf(arg0: (arg0: K) => boolean): boolean;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        size(arg0: number): void;
        size(): number;
        addAll(arg0: Internal.ObjectList<K>): boolean;
        addAll(arg0: number, arg1: Internal.ObjectList<K>): boolean;
        addAll(arg0: number, arg1: Internal.Collection<K>): boolean;
        addAll(arg0: Internal.Collection<K>): boolean;
        equals(arg0: any): boolean;
        getElements(arg0: number, arg1: any[], arg2: number, arg3: number): void;
        listIterator(arg0: number): Internal.ObjectListIterator<K>;
        listIterator(arg0: number): Internal.ListIterator<any>;
        listIterator(): Internal.ListIterator<any>;
        listIterator(): Internal.ObjectListIterator<K>;
        unstableSort(arg0: Internal.Comparator<K>): void;
        retainAll(arg0: Internal.Collection<any>): boolean;
    }
    interface RegistryAccess {
    }
    class LootContext implements Internal.LootContextAccessor {
        getClass(): Internal.Class<any>;
        getLootingModifier(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setQueriedLootTableId(arg0: ResourceLocation): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        repurposedstructures_setQueriedLootTableId(arg0: ResourceLocation): void;
        notify(): void;
        getQueriedLootTableId(): ResourceLocation;
        get lootingModifier(): number;
        get queriedLootTableId(): ResourceLocation;
        get class(): Internal.Class<any>;
        set queriedLootTableId(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class URLConnection {
        getClass(): Internal.Class<any>;
        setConnectTimeout(arg0: number): void;
        getHeaderFieldLong(arg0: string, arg1: number): number;
        setUseCaches(arg0: boolean): void;
        setRequestProperty(arg0: string, arg1: string): void;
        getDoInput(): boolean;
        getIfModifiedSince(): number;
        getPermission(): Internal.Permission;
        static getDefaultAllowUserInteraction(): boolean;
        static getDefaultUseCaches(arg0: string): boolean;
        getDefaultUseCaches(): boolean;
        getAllowUserInteraction(): boolean;
        getConnectTimeout(): number;
        getContentLength(): number;
        getInputStream(): Internal.InputStream;
        setAllowUserInteraction(arg0: boolean): void;
        getRequestProperties(): Internal.Map<string, Internal.List<string>>;
        getURL(): Internal.URL;
        getHeaderField(arg0: number): string;
        getHeaderField(arg0: string): string;
        getHeaderFields(): Internal.Map<string, Internal.List<string>>;
        getContentLengthLong(): number;
        static setDefaultAllowUserInteraction(arg0: boolean): void;
        getContentType(): string;
        setDefaultUseCaches(arg0: boolean): void;
        static setDefaultUseCaches(arg0: string, arg1: boolean): void;
        setDoOutput(arg0: boolean): void;
        static guessContentTypeFromName(arg0: string): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLastModified(): number;
        setIfModifiedSince(arg0: number): void;
        notifyAll(): void;
        getReadTimeout(): number;
        getContent(): any;
        getContent(arg0: Internal.Class<any>[]): any;
        notify(): void;
        getHeaderFieldInt(arg0: string, arg1: number): number;
        getRequestProperty(arg0: string): string;
        static guessContentTypeFromStream(arg0: Internal.InputStream): string;
        hashCode(): number;
        static setDefaultRequestProperty(arg0: string, arg1: string): void;
        getHeaderFieldDate(arg0: string, arg1: number): number;
        static getFileNameMap(): Internal.FileNameMap;
        getDate(): number;
        getHeaderFieldKey(arg0: number): string;
        connect(): void;
        static setContentHandlerFactory(arg0: Internal.ContentHandlerFactory): void;
        getContentEncoding(): string;
        getUseCaches(): boolean;
        setDoInput(arg0: boolean): void;
        addRequestProperty(arg0: string, arg1: string): void;
        setReadTimeout(arg0: number): void;
        getExpiration(): number;
        static getDefaultRequestProperty(arg0: string): string;
        equals(arg0: any): boolean;
        static setFileNameMap(arg0: Internal.FileNameMap): void;
        getOutputStream(): Internal.OutputStream;
        toString(): string;
        getDoOutput(): boolean;
        get date(): number;
        get contentLengthLong(): number;
        get defaultUseCaches(): boolean;
        get requestProperties(): Internal.Map<string, Internal.List<string>>;
        get useCaches(): boolean;
        get ifModifiedSince(): number;
        get content(): any;
        get doOutput(): boolean;
        get connectTimeout(): number;
        get contentEncoding(): string;
        get headerFields(): Internal.Map<string, Internal.List<string>>;
        get outputStream(): Internal.OutputStream;
        get class(): Internal.Class<any>;
        get contentType(): string;
        get defaultAllowUserInteraction(): boolean;
        get inputStream(): Internal.InputStream;
        get permission(): Internal.Permission;
        get doInput(): boolean;
        get uRL(): Internal.URL;
        get allowUserInteraction(): boolean;
        get readTimeout(): number;
        get contentLength(): number;
        get fileNameMap(): Internal.FileNameMap;
        get expiration(): number;
        get lastModified(): number;
        set doOutput(arg0: boolean);
        set defaultUseCaches(arg0: boolean);
        set defaultAllowUserInteraction(arg0: boolean);
        set useCaches(arg0: boolean);
        set readTimeout(arg0: number);
        set connectTimeout(arg0: number);
        set fileNameMap(arg0: Internal.FileNameMap);
        set ifModifiedSince(arg0: number);
        set doInput(arg0: boolean);
        set contentHandlerFactory(arg0: Internal.ContentHandlerFactory);
        set allowUserInteraction(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AttributeMap {
        hasAttr<T>(arg0: Internal.AttributeKey<T>): boolean;
        attr<T>(arg0: Internal.AttributeKey<T>): io.netty.util.Attribute<T>;
    }
    interface Model {
        size(): number;
        getReader(): Internal.VertexList;
        getType(): com.jozufozu.flywheel.api.vertex.VertexType;
        writeInto(arg0: Internal.ByteBuffer): void;
        name(): string;
        vertexCount(): number;
        createEBO(): Internal.ElementBuffer;
        empty(): boolean;
    }
    class FriendlyByteBuf extends Internal.ByteBuf implements Internal.IForgeFriendlyByteBuf {
        asReadOnly(): Internal.ByteBuf;
        markReaderIndex(): Internal.ByteBuf;
        getByte(arg0: number): number;
        writeItemStack(arg0: Internal.ItemStack, arg1: boolean): Internal.FriendlyByteBuf;
        release(): boolean;
        release(arg0: number): boolean;
        readDoubleLE(): number;
        writeZero(arg0: number): Internal.ByteBuf;
        resetReaderIndex(): Internal.ByteBuf;
        writeFloat(arg0: number): Internal.ByteBuf;
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf;
        readRegistryId<T_>(): T_;
        readRetainedSlice(arg0: number): Internal.ByteBuf;
        slice(): Internal.ByteBuf;
        slice(arg0: number, arg1: number): Internal.ByteBuf;
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf;
        getMediumLE(arg0: number): number;
        readUnsignedIntLE(): number;
        writeFloatLE(arg0: number): Internal.ByteBuf;
        readInt(): number;
        order(): Internal.ByteOrder;
        order(arg0: Internal.ByteOrder): Internal.ByteBuf;
        writeMedium(arg0: number): Internal.ByteBuf;
        resetWriterIndex(): Internal.ByteBuf;
        writableBytes(): number;
        maxCapacity(): number;
        getUnsignedShort(arg0: number): number;
        nioBufferCount(): number;
        bytesBefore(arg0: number, arg1: number): number;
        bytesBefore(arg0: number): number;
        bytesBefore(arg0: number, arg1: number, arg2: number): number;
        setInt(arg0: number, arg1: number): Internal.ByteBuf;
        getInt(arg0: number): number;
        markWriterIndex(): Internal.ByteBuf;
        isReadable(): boolean;
        isReadable(arg0: number): boolean;
        writeBoolean(arg0: boolean): Internal.ByteBuf;
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        writeLongLE(arg0: number): Internal.ByteBuf;
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf;
        retain(): Internal.ReferenceCounted;
        retain(): Internal.ByteBuf;
        retain(arg0: number): Internal.ByteBuf;
        retain(arg0: number): Internal.ReferenceCounted;
        isWritable(arg0: number): boolean;
        isWritable(): boolean;
        notify(): void;
        readChar(): string;
        hasMemoryAddress(): boolean;
        capacity(arg0: number): Internal.ByteBuf;
        capacity(): number;
        readRegistryIdSafe<T_>(arg0: Internal.Class<T_>): T_;
        readCharSequence(arg0: number, arg1: Internal.Charset): Internal.CharSequence;
        isReadOnly(): boolean;
        readUnsignedShortLE(): number;
        readDouble(): number;
        readFloat(): number;
        getLongLE(arg0: number): number;
        getBoolean(arg0: number): boolean;
        copy(arg0: number, arg1: number): Internal.ByteBuf;
        copy(): Internal.ByteBuf;
        readShortLE(): number;
        readUnsignedMedium(): number;
        ensureWritable(arg0: number, arg1: boolean): number;
        ensureWritable(arg0: number): Internal.ByteBuf;
        writeInt(arg0: number): Internal.ByteBuf;
        readFloatLE(): number;
        getDoubleLE(arg0: number): number;
        hasArray(): boolean;
        memoryAddress(): number;
        maxFastWritableBytes(): number;
        readableBytes(): number;
        readSlice(arg0: number): Internal.ByteBuf;
        getIntLE(arg0: number): number;
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number;
        forEachByteDesc(arg0: Internal.ByteProcessor): number;
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        nioBuffers(): Internal.ByteBuffer[];
        skipBytes(arg0: number): Internal.ByteBuf;
        getLong(arg0: number): number;
        readLong(): number;
        readShort(): number;
        equals(arg0: any): boolean;
        getUnsignedMedium(arg0: number): number;
        setZero(arg0: number, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf;
        readBytes(arg0: Internal.GatheringByteChannel, arg1: number): number;
        readBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number;
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: number[]): Internal.ByteBuf;
        readBytes(arg0: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.ByteBuf;
        readBoolean(): boolean;
        toString(): string;
        toString(arg0: number, arg1: number, arg2: Internal.Charset): string;
        toString(arg0: Internal.Charset): string;
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf;
        retainedSlice(): Internal.ByteBuf;
        readMediumLE(): number;
        setMedium(arg0: number, arg1: number): Internal.ByteBuf;
        isDirect(): boolean;
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf;
        getClass(): Internal.Class<any>;
        getFloatLE(arg0: number): number;
        readerIndex(arg0: number): Internal.ByteBuf;
        readerIndex(): number;
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset): Internal.CharSequence;
        setShort(arg0: number, arg1: number): Internal.ByteBuf;
        compareTo(arg0: Internal.ByteBuf): number;
        compareTo(arg0: any): number;
        getBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number;
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel, arg2: number): number;
        unwrap(): Internal.ByteBuf;
        setDouble(arg0: number, arg1: number): Internal.ByteBuf;
        setChar(arg0: number, arg1: number): Internal.ByteBuf;
        refCnt(): number;
        getUnsignedIntLE(arg0: number): number;
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf;
        getUnsignedInt(arg0: number): number;
        writeRegistryIdUnsafe(arg0: Internal.IForgeRegistry<any>, arg1: ResourceLocation): void;
        writeRegistryIdUnsafe<T_>(arg0: Internal.IForgeRegistry<T_>, arg1: T_): void;
        indexOf(arg0: number, arg1: number, arg2: number): number;
        writeByte(arg0: number): Internal.ByteBuf;
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        nioBuffer(): Internal.ByteBuffer;
        discardSomeReadBytes(): Internal.ByteBuf;
        touch(): Internal.ByteBuf;
        touch(): Internal.ReferenceCounted;
        touch(arg0: any): Internal.ReferenceCounted;
        touch(arg0: any): Internal.ByteBuf;
        readRegistryIdUnsafe<T_>(arg0: Internal.IForgeRegistry<T_>): T_;
        duplicate(): Internal.ByteBuf;
        writerIndex(): number;
        writerIndex(arg0: number): Internal.ByteBuf;
        getUnsignedShortLE(arg0: number): number;
        writeCharSequence(arg0: Internal.CharSequence, arg1: Internal.Charset): number;
        readUnsignedInt(): number;
        retainedDuplicate(): Internal.ByteBuf;
        getChar(arg0: number): string;
        setLong(arg0: number, arg1: number): Internal.ByteBuf;
        readMedium(): number;
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: number[]): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number;
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf): Internal.ByteBuf;
        writeBytes(arg0: Internal.ScatteringByteChannel, arg1: number): number;
        writeBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf;
        writeBytes(arg0: Internal.InputStream, arg1: number): number;
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number;
        forEachByte(arg0: Internal.ByteProcessor): number;
        setIndex(arg0: number, arg1: number): Internal.ByteBuf;
        writeShort(arg0: number): Internal.ByteBuf;
        getShortLE(arg0: number): number;
        alloc(): Internal.ByteBufAllocator;
        getMedium(arg0: number): number;
        readUnsignedShort(): number;
        setByte(arg0: number, arg1: number): Internal.ByteBuf;
        maxWritableBytes(): number;
        writeShortLE(arg0: number): Internal.ByteBuf;
        readFluidStack(): net.minecraftforge.fluids.FluidStack;
        notifyAll(): void;
        getDouble(arg0: number): number;
        getFloat(arg0: number): number;
        writeLong(arg0: number): Internal.ByteBuf;
        writeIntLE(arg0: number): Internal.ByteBuf;
        array(): number[];
        setCharSequence(arg0: number, arg1: Internal.CharSequence, arg2: Internal.Charset): number;
        hashCode(): number;
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        arrayOffset(): number;
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf;
        readIntLE(): number;
        readUnsignedByte(): number;
        readLongLE(): number;
        readUnsignedMediumLE(): number;
        writeDouble(arg0: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number;
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel, arg2: number): number;
        setBytes(arg0: number, arg1: Internal.InputStream, arg2: number): number;
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        setFloat(arg0: number, arg1: number): Internal.ByteBuf;
        getShort(arg0: number): number;
        writeMediumLE(arg0: number): Internal.ByteBuf;
        clear(): Internal.ByteBuf;
        writeRegistryId<T_>(arg0: T_): void;
        getUnsignedByte(arg0: number): number;
        writeFluidStack(arg0: net.minecraftforge.fluids.FluidStack): void;
        discardReadBytes(): Internal.ByteBuf;
        writeChar(arg0: number): Internal.ByteBuf;
        writeDoubleLE(arg0: number): Internal.ByteBuf;
        isContiguous(): boolean;
        getUnsignedMediumLE(arg0: number): number;
        readByte(): number;
        get readable(): boolean;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get contiguous(): boolean;
        get writable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FileNameMap {
        getContentTypeFor(arg0: string): string;
    }
    interface BlockStatePathingCache {
        getNeighborPathNodeType(): Internal.BlockPathTypes;
        getPathNodeType(): Internal.BlockPathTypes;
    }
    class ModelGenerator$Element {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        face(direction: Internal.Direction, consumer: (arg0: Internal.ModelGenerator$Face) => void): void;
        toJson(): Internal.JsonObject;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        box(b: Internal.AABB): Internal.ModelGenerator$Element;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CookingRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        cookingTime(time: number): Internal.CookingRecipeJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        xp(xp: number): Internal.CookingRecipeJS;
        toString(): string;
        parseResultItem(o: any): Internal.ItemStackJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Reference2LongFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToLongFunction<K> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_;
        put(arg0: K, arg1: number): number;
        put(arg0: K, arg1: number): number;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): any;
        remove(arg0: any): number;
        defaultReturnValue(arg0: number): void;
        defaultReturnValue(): number;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        removeLong(arg0: any): number;
        get(arg0: any): number;
        get(arg0: any): any;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        getLong(arg0: any): number;
        applyAsLong(arg0: K): number;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface Tag$Named <T> extends net.minecraft.tags.Tag<T> {
    }
    interface Instance {
        getWorldPosition(): BlockPos;
    }
    interface TickAccess <T> {
    }
    class ContinuationPending extends Internal.RuntimeException {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        printStackTrace(): void;
        printStackTrace(arg0: Internal.PrintStream): void;
        printStackTrace(arg0: Internal.PrintWriter): void;
        getLocalizedMessage(): string;
        notifyAll(): void;
        initCause(arg0: Internal.Throwable): Internal.Throwable;
        getMessage(): string;
        getApplicationState(): any;
        getCause(): Internal.Throwable;
        notify(): void;
        getContinuation(): any;
        addSuppressed(arg0: Internal.Throwable): void;
        setStackTrace(arg0: Internal.StackTraceElement[]): void;
        getStackTrace(): Internal.StackTraceElement[];
        setApplicationState(applicationState: any): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getSuppressed(): Internal.Throwable[];
        toString(): string;
        fillInStackTrace(): Internal.Throwable;
        setContinuation(continuation: Internal.NativeContinuation): void;
        get localizedMessage(): string;
        get applicationState(): any;
        get cause(): Internal.Throwable;
        get stackTrace(): Internal.StackTraceElement[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        get continuation(): any;
        set applicationState(applicationState: any);
        set stackTrace(arg0: Internal.StackTraceElement[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Clearable {
    }
    class Biome$BiomeCategory extends Internal.Enum<any> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Biome$BiomeCategory;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Biome$BiomeCategory[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Biome$BiomeCategory): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Biome$BiomeCategory>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Biome$BiomeCategory>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly BEACH : Internal.Biome$BiomeCategory;
        static readonly UNDERGROUND : Internal.Biome$BiomeCategory;
        static readonly MESA : Internal.Biome$BiomeCategory;
        static readonly SAVANNA : Internal.Biome$BiomeCategory;
        static readonly THEEND : Internal.Biome$BiomeCategory;
        static readonly JUNGLE : Internal.Biome$BiomeCategory;
        static readonly OCEAN : Internal.Biome$BiomeCategory;
        static readonly TAIGA : Internal.Biome$BiomeCategory;
        static readonly MOUNTAIN : Internal.Biome$BiomeCategory;
        static readonly DESERT : Internal.Biome$BiomeCategory;
        static readonly RIVER : Internal.Biome$BiomeCategory;
        static readonly FOREST : Internal.Biome$BiomeCategory;
        static readonly MUSHROOM : Internal.Biome$BiomeCategory;
        static readonly NETHER : Internal.Biome$BiomeCategory;
        static readonly PLAINS : Internal.Biome$BiomeCategory;
        static readonly SWAMP : Internal.Biome$BiomeCategory;
        static readonly NONE : Internal.Biome$BiomeCategory;
        static readonly EXTREME_HILLS : Internal.Biome$BiomeCategory;
        static readonly ICY : Internal.Biome$BiomeCategory;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Biome$BiomeCategory>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class InvertedLootItemCondition implements Internal.LootItemCondition {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: (arg0: Internal.LootContext) => boolean): (arg0: Internal.LootContext) => boolean;
        test(arg0: Internal.LootContext): boolean;
        test(arg0: any): boolean;
        and(arg0: (arg0: Internal.LootContext) => boolean): (arg0: Internal.LootContext) => boolean;
        negate(): (arg0: Internal.LootContext) => boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Slot implements Internal.SlotAccessor {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setY(arg0: number): void;
        setX(arg0: number): void;
        hashCode(): number;
        getSlotIndex(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        isSameInventory(arg0: Internal.Slot): boolean;
        setBackground(arg0: ResourceLocation, arg1: ResourceLocation): Internal.Slot;
        notify(): void;
        get class(): Internal.Class<any>;
        get slotIndex(): number;
        set x(arg0: number);
        set y(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PrimitiveIterator$OfInt extends Internal.PrimitiveIterator<number, java_.util.function_.IntConsumer> {
        next(): any;
        next(): number;
        hasNext(): boolean;
        nextInt(): number;
        forEachRemaining(arg0: any): void;
        forEachRemaining(arg0: java_.util.function_.IntConsumer): void;
        forEachRemaining(arg0: (arg0: number) => void): void;
        remove(): void;
    }
    class Excluder implements Internal.TypeAdapterFactory, Internal.Cloneable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        disableInnerClassSerialization(): Internal.Excluder;
        withModifiers(arg0: number[]): Internal.Excluder;
        withVersion(arg0: number): Internal.Excluder;
        excludeField(arg0: Internal.Field, arg1: boolean): boolean;
        notify(): void;
        hashCode(): number;
        withExclusionStrategy(arg0: Internal.ExclusionStrategy, arg1: boolean, arg2: boolean): Internal.Excluder;
        equals(arg0: any): boolean;
        create<T_>(arg0: Internal.Gson, arg1: Internal.TypeToken<T_>): Internal.TypeAdapter<T_>;
        toString(): string;
        excludeClass(arg0: Internal.Class<any>, arg1: boolean): boolean;
        excludeFieldsWithoutExposeAnnotation(): Internal.Excluder;
        static readonly DEFAULT : Internal.Excluder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AirItem extends Internal.Item {
        getClass(): Internal.Class<any>;
        canElytraFly(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean;
        setBurnTime(i: number): void;
        getTags(): Internal.Set<ResourceLocation>;
        setDamage(arg0: Internal.ItemStack, arg1: number): void;
        canPerformAction(arg0: Internal.ItemStack, arg1: Internal.ToolAction): boolean;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean;
        getItemEnchantability(arg0: Internal.ItemStack): number;
        damageItem<T_>(arg0: Internal.ItemStack, arg1: number, arg2: T_, arg3: (arg0: T_) => void): number;
        setFireResistantKJS(arg0: boolean): void;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: boolean): boolean;
        setCategory(arg0: Internal.CreativeModeTab): void;
        getXpRepairRatio(arg0: Internal.ItemStack): number;
        readShareTag(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): void;
        onEntityItemUpdate(arg0: Internal.ItemStack, arg1: Internal.ItemEntity): boolean;
        getDamage(arg0: Internal.ItemStack): number;
        setFoodPropertiesKJS(arg0: Internal.FoodProperties): void;
        isBookEnchantable(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean;
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.LivingEntity, arg3: Internal.LivingEntity): boolean;
        getCategory(): Internal.CreativeModeTab;
        onUsingTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        createEntity(arg0: net.minecraft.world.level.Level, arg1: Internal.Entity, arg2: Internal.ItemStack): Internal.Entity;
        callAllowdedIn(arg0: Internal.CreativeModeTab): boolean;
        getSweepHitBox(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): Internal.AABB;
        handler$baf000$overrideStackedOnOther(arg0: Internal.ItemStack, arg1: Internal.Slot, arg2: Internal.ClickAction, arg3: Internal.Player, arg4: Internal.CallbackInfoReturnable<any>): void;
        isRepairable(arg0: Internal.ItemStack): boolean;
        getShareTag(arg0: Internal.ItemStack): Internal.CompoundTag;
        getBurnTime(arg0: Internal.ItemStack, arg1: Internal.RecipeType<any>): number;
        onDroppedByPlayer(arg0: Internal.ItemStack, arg1: Internal.Player): boolean;
        isDamageable(arg0: Internal.ItemStack): boolean;
        onEntitySwing(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean;
        getRegistryType(): Internal.Class<Internal.Item>;
        setItemBuilderKJS(b: Internal.ItemBuilder): void;
        elytraFlightTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean;
        getItemBuilderKJS(): Internal.ItemBuilder;
        getBlockItemOverride(): Internal.BlockItem;
        setMaxStackSizeKJS(arg0: number): void;
        getAttributeModifiers(arg0: EquipmentSlot, arg1: Internal.ItemStack): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        onLeftClickEntity(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): boolean;
        canEquip(arg0: Internal.ItemStack, arg1: EquipmentSlot, arg2: Internal.Entity): boolean;
        notifyAll(): void;
        getId(): string;
        notify(): void;
        onBlockStartBreak(arg0: Internal.ItemStack, arg1: BlockPos, arg2: Internal.Player): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Mob): void;
        canContinueUsing(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean;
        getEntityLifespan(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level): number;
        getRenderPropertiesInternal(): any;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack): number;
        getArmorTexture(arg0: Internal.ItemStack, arg1: Internal.Entity, arg2: EquipmentSlot, arg3: string): string;
        hashCode(): number;
        hasCustomEntity(arg0: Internal.ItemStack): boolean;
        setCraftingRemainderKJS(arg0: Internal.Item): void;
        setMaxDamageKJS(arg0: number): void;
        getHighlightTip(arg0: Internal.ItemStack, arg1: Internal.Component): Internal.Component;
        initializeClient(arg0: (arg0: Internal.IItemRenderProperties) => void): void;
        getMaxDamage(arg0: Internal.ItemStack): number;
        getCreatorModId(arg0: Internal.ItemStack): string;
        setRarityKJS(arg0: Internal.Rarity): void;
        isDamaged(arg0: Internal.ItemStack): boolean;
        onArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Player): void;
        addPlaceable(arg0: Internal.Block): void;
        hasContainerItem(arg0: Internal.ItemStack): boolean;
        doesSneakBypassUse(arg0: Internal.ItemStack, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Player): boolean;
        onItemUseFirst(arg0: Internal.ItemStack, arg1: Internal.UseOnContext): Internal.InteractionResult;
        getContainerItem(arg0: Internal.ItemStack): Internal.ItemStack;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: string, arg1: string): Internal.Item;
        setRegistryName(arg0: ResourceLocation): any;
        setRegistryName(arg0: ResourceLocation): Internal.Item;
        setRegistryName(arg0: string): Internal.Item;
        onDestroyed(arg0: Internal.ItemEntity, arg1: Internal.DamageSource): void;
        isCorrectToolForDrops(arg0: Internal.ItemStack, arg1: Internal.BlockState): boolean;
        getEquipmentSlot(arg0: Internal.ItemStack): EquipmentSlot;
        handler$zjo000$getUseDuration(arg0: Internal.ItemStack, arg1: Internal.CallbackInfoReturnable<any>): void;
        initCapabilities(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): Internal.ICapabilityProvider;
        getItemStackLimit(arg0: Internal.ItemStack): number;
        equals(arg0: any): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean;
        handler$baf000$overrideOtherStackedOnMe(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.Slot, arg3: Internal.ClickAction, arg4: Internal.Player, arg5: Internal.SlotAccess, arg6: Internal.CallbackInfoReturnable<any>): void;
        toString(): string;
        isEnderMask(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.EnderMan): boolean;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean;
        readonly delegate : () => Internal.Item;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get category(): Internal.CreativeModeTab;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        get blockItemOverride(): Internal.BlockItem;
        set rarityKJS(arg0: Internal.Rarity);
        set maxStackSizeKJS(arg0: number);
        set itemBuilderKJS(b: Internal.ItemBuilder);
        set foodPropertiesKJS(arg0: Internal.FoodProperties);
        set burnTime(i: number);
        set fireResistantKJS(arg0: boolean);
        set registryName(arg0: ResourceLocation);
        set category(arg0: Internal.CreativeModeTab);
        set craftingRemainderKJS(arg0: Internal.Item);
        set maxDamageKJS(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Ingredient implements Internal.Predicate<Internal.ItemStack>, Internal.IngredientKJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: (arg0: Internal.ItemStack) => boolean): (arg0: Internal.ItemStack) => boolean;
        test(arg0: Internal.ItemStack): boolean;
        test(arg0: any): boolean;
        checkInvalidation(): boolean;
        notifyAll(): void;
        isVanilla(): boolean;
        asKJS(): any;
        notify(): void;
        getSerializer(): Internal.IIngredientSerializer<(arg0: any) => boolean>;
        static invalidateAll(): void;
        and(arg0: (arg0: Internal.ItemStack) => boolean): (arg0: Internal.ItemStack) => boolean;
        negate(): (arg0: Internal.ItemStack) => boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        static merge(arg0: Internal.Collection<(arg0: any) => boolean>): (arg0: any) => boolean;
        isSimple(): boolean;
        toString(): string;
        getItemsKJS(): Internal.ItemStack[];
        get serializer(): Internal.IIngredientSerializer<(arg0: any) => boolean>;
        get itemsKJS(): Internal.ItemStack[];
        get simple(): boolean;
        get class(): Internal.Class<any>;
        get vanilla(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DamageSourceAccessor {
        callBypassArmor(): Internal.DamageSource;
        callBypassMagic(): Internal.DamageSource;
        callBypassInvul(): Internal.DamageSource;
    }
    interface Multiset$Entry <E> {
        getElement(): E;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getCount(): number;
    }
    interface IdFunctionCall {
        execIdCall(arg0: Internal.IdFunctionObject, arg1: Internal.Context, arg2: Internal.Scriptable, arg3: Internal.Scriptable, arg4: any[]): any;
    }
    abstract class AsynchronousFileChannel implements Internal.AsynchronousChannel {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        read(arg0: Internal.ByteBuffer, arg1: number): java_.util.concurrent.Future<number>;
        read<A_>(arg0: Internal.ByteBuffer, arg1: number, arg2: A_, arg3: Internal.CompletionHandler<number, A_>): void;
        notifyAll(): void;
        notify(): void;
        tryLock(): Internal.FileLock;
        tryLock(arg0: number, arg1: number, arg2: boolean): Internal.FileLock;
        isOpen(): boolean;
        truncate(arg0: number): Internal.AsynchronousFileChannel;
        size(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        lock(arg0: number, arg1: number, arg2: boolean): java_.util.concurrent.Future<Internal.FileLock>;
        lock<A_>(arg0: A_, arg1: Internal.CompletionHandler<Internal.FileLock, A_>): void;
        lock<A_>(arg0: number, arg1: number, arg2: boolean, arg3: A_, arg4: Internal.CompletionHandler<Internal.FileLock, A_>): void;
        lock(): java_.util.concurrent.Future<Internal.FileLock>;
        toString(): string;
        force(arg0: boolean): void;
        close(): void;
        write(arg0: Internal.ByteBuffer, arg1: number): java_.util.concurrent.Future<number>;
        write<A_>(arg0: Internal.ByteBuffer, arg1: number, arg2: A_, arg3: Internal.CompletionHandler<number, A_>): void;
        static open(arg0: Internal.Path, arg1: Internal.Set<Internal.OpenOption>, arg2: Internal.ExecutorService, arg3: any[]): Internal.AsynchronousFileChannel;
        static open(arg0: Internal.Path, arg1: Internal.OpenOption[]): Internal.AsynchronousFileChannel;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EventLoopGroup extends Internal.EventExecutorGroup {
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>;
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        next(): Internal.EventLoop;
        next(): Internal.EventExecutor;
        terminationFuture(): Internal.Future<any>;
        shutdownGracefully(): Internal.Future<any>;
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit): Internal.Future<any>;
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): Internal.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): java_.util.concurrent.Future<T_>;
        submit(arg0: Internal.Runnable): Internal.Future<any>;
        submit(arg0: Internal.Runnable): java_.util.concurrent.Future<any>;
        submit<T_>(arg0: Internal.Runnable, arg1: T_): Internal.Future<T_>;
        submit<T_>(arg0: Internal.Runnable, arg1: T_): java_.util.concurrent.Future<T_>;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        isTerminated(): boolean;
        forEach(arg0: (arg0: Internal.EventExecutor) => void): void;
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>;
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<java_.util.concurrent.Future<T_>>;
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): Internal.List<java_.util.concurrent.Future<T_>>;
        execute(arg0: Internal.Runnable): void;
        isShuttingDown(): boolean;
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<any>;
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V_>;
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<V_>;
        iterator(): Internal.Iterator<Internal.EventExecutor>;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean;
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): T_;
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): T_;
        shutdownNow(): Internal.List<Internal.Runnable>;
        shutdown(): void;
        isShutdown(): boolean;
        register(arg0: io.netty.channel.Channel, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        register(arg0: Internal.ChannelPromise): Internal.ChannelFuture;
        register(arg0: io.netty.channel.Channel): Internal.ChannelFuture;
    }
    interface IRegistryDelegate <T> extends java_.util.function_.Supplier<T> {
        get(): T;
        name(): ResourceLocation;
        type(): Internal.Class<T>;
    }
    interface IntPredicate {
        or(arg0: Internal.IntPredicate): Internal.IntPredicate;
        test(arg0: number): boolean;
        and(arg0: Internal.IntPredicate): Internal.IntPredicate;
        negate(): Internal.IntPredicate;
    }
    interface RecipeFilter extends Internal.Predicate<Internal.RecipeJS> {
        or(arg0: (arg0: Internal.RecipeJS) => boolean): (arg0: Internal.RecipeJS) => boolean;
        test(arg0: Internal.RecipeJS): boolean;
        test(arg0: any): boolean;
        and(arg0: (arg0: Internal.RecipeJS) => boolean): (arg0: Internal.RecipeJS) => boolean;
        negate(): (arg0: Internal.RecipeJS) => boolean;
    }
    interface ByteBufAllocator {
        directBuffer(arg0: number): Internal.ByteBuf;
        directBuffer(arg0: number, arg1: number): Internal.ByteBuf;
        directBuffer(): Internal.ByteBuf;
        isDirectBufferPooled(): boolean;
        calculateNewCapacity(arg0: number, arg1: number): number;
        compositeDirectBuffer(): Internal.CompositeByteBuf;
        compositeDirectBuffer(arg0: number): Internal.CompositeByteBuf;
        ioBuffer(): Internal.ByteBuf;
        ioBuffer(arg0: number): Internal.ByteBuf;
        ioBuffer(arg0: number, arg1: number): Internal.ByteBuf;
        compositeBuffer(arg0: number): Internal.CompositeByteBuf;
        compositeBuffer(): Internal.CompositeByteBuf;
        compositeHeapBuffer(): Internal.CompositeByteBuf;
        compositeHeapBuffer(arg0: number): Internal.CompositeByteBuf;
        buffer(): Internal.ByteBuf;
        buffer(arg0: number, arg1: number): Internal.ByteBuf;
        buffer(arg0: number): Internal.ByteBuf;
        heapBuffer(): Internal.ByteBuf;
        heapBuffer(arg0: number): Internal.ByteBuf;
        heapBuffer(arg0: number, arg1: number): Internal.ByteBuf;
    }
    interface ICustomPacket <T> {
        setName(arg0: ResourceLocation): void;
        getThis(): T;
        getName(): ResourceLocation;
        getDirection(): Internal.NetworkDirection;
        getIndex(): number;
        setData(arg0: Internal.FriendlyByteBuf): void;
        setIndex(arg0: number): void;
        getInternalData(): Internal.FriendlyByteBuf;
    }
    interface Multiset <E> extends Internal.Collection<E> {
        add(arg0: E, arg1: number): number;
        add(arg0: E): boolean;
        forEachEntry(arg0: Internal.ObjIntConsumer<E>): void;
        entrySet(): Internal.Set<Internal.Multiset$Entry<E>>;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: (arg0: E) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        count(arg0: any): number;
        remove(arg0: any, arg1: number): number;
        remove(arg0: any): boolean;
        removeIf(arg0: (arg0: E) => boolean): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.Iterator<E>;
        size(): number;
        addAll(arg0: Internal.Collection<E>): boolean;
        stream(): Internal.Stream<E>;
        elementSet(): Internal.Set<E>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<E>;
        toString(): string;
        setCount(arg0: E, arg1: number, arg2: number): boolean;
        setCount(arg0: E, arg1: number): number;
        retainAll(arg0: Internal.Collection<any>): boolean;
    }
    class ArcFurnaceRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        energy(e: number): Internal.IERecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        time(t: number): Internal.IERecipeJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<net.minecraftforge.fluids.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MethodTypeDesc extends Internal.ConstantDesc, Internal.TypeDescriptor$OfMethod<Internal.ClassDesc, Internal.MethodTypeDesc> {
        parameterType(arg0: number): Internal.TypeDescriptor$OfField<any>;
        parameterType(arg0: number): Internal.ClassDesc;
        dropParameterTypes(arg0: number, arg1: number): Internal.TypeDescriptor$OfMethod<any, any>;
        dropParameterTypes(arg0: number, arg1: number): Internal.MethodTypeDesc;
        parameterCount(): number;
        changeReturnType(arg0: Internal.ClassDesc): Internal.MethodTypeDesc;
        changeReturnType(arg0: Internal.TypeDescriptor$OfField<any>): Internal.TypeDescriptor$OfMethod<any, any>;
        descriptorString(): string;
        insertParameterTypes(arg0: number, arg1: Internal.ClassDesc[]): Internal.MethodTypeDesc;
        insertParameterTypes(arg0: number, arg1: Internal.TypeDescriptor$OfField[]): Internal.TypeDescriptor$OfMethod<any, any>;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): any;
        changeParameterType(arg0: number, arg1: Internal.TypeDescriptor$OfField<any>): Internal.TypeDescriptor$OfMethod<any, any>;
        changeParameterType(arg0: number, arg1: Internal.ClassDesc): Internal.MethodTypeDesc;
        parameterArray(): Internal.ClassDesc[];
        parameterArray(): Internal.TypeDescriptor$OfField[];
        equals(arg0: any): boolean;
        parameterList(): Internal.List<Internal.ClassDesc>;
        displayDescriptor(): string;
        returnType(): Internal.ClassDesc;
        returnType(): Internal.TypeDescriptor$OfField<any>;
    }
    interface Int2IntFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface Component extends com.mojang.brigadier.Message, Internal.FormattedText {
        getString(): string;
    }
    interface Function6 <T1, T2, T3, T4, T5, T6, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6): R;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, (arg0: T6) => R>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function3<T4, T5, T6, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, (arg0: T5, arg1: T6) => R>;
        curry2(): (arg0: T1, arg1: T2) => Internal.Function4<T3, T4, T5, T6, R>;
        curry(): (arg0: T1) => Internal.Function5<T2, T3, T4, T5, T6, R>;
    }
    interface Object2FloatFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        applyAsDouble(arg0: K): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        getFloat(arg0: any): number;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_;
        put(arg0: K, arg1: number): number;
        put(arg0: K, arg1: number): number;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): any;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        get(arg0: any): number;
        get(arg0: any): any;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        removeFloat(arg0: any): number;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class ListenerList {
        getListeners(arg0: number): Internal.IEventListener[];
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static clearBusID(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        unregister(arg0: number, arg1: Internal.IEventListener): void;
        toString(): string;
        static unregisterAll(arg0: number, arg1: Internal.IEventListener): void;
        notify(): void;
        register(arg0: number, arg1: Internal.EventPriority, arg2: Internal.IEventListener): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class SectionPos extends Vec3i {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getX(): number;
        getY(): number;
        getZ(): number;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        compareTo(arg0: any): number;
        compareTo(arg0: Vec3i): number;
        notify(): void;
        get x(): number;
        get y(): number;
        get z(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjectSet <K> extends Internal.ObjectCollection<K>, Internal.Set<K> {
        add(arg0: K): boolean;
        spliterator(): Internal.Spliterator<any>;
        spliterator(): Internal.ObjectSpliterator<K>;
        forEach(arg0: (arg0: K) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        remove(arg0: any): boolean;
        removeIf(arg0: (arg0: K) => boolean): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.Iterator<any>;
        iterator(): Internal.ObjectIterator<K>;
        size(): number;
        addAll(arg0: Internal.Collection<K>): boolean;
        stream(): Internal.Stream<K>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<K>;
        retainAll(arg0: Internal.Collection<any>): boolean;
    }
    interface SlotAccess {
    }
    class Stat <T> extends Internal.ObjectiveCriteria {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PausedPartialTickAccessor {
        flywheel$getPartialTicksPaused(): number;
    }
    class ProcessingRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        superheated(): Internal.ProcessingRecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        processingTime(t: number): Internal.ProcessingRecipeJS;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        heated(): Internal.ProcessingRecipeJS;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        heatRequirement(req: string): Internal.ProcessingRecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        parseResultItem(o: any): Internal.ItemStackJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<net.minecraftforge.fluids.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeTransformation {
        blockCornerToCenter(): Internal.Transformation;
        applyOrigin(arg0: Internal.Vector3f): Internal.Transformation;
        rotateTransform(arg0: Internal.Direction): Internal.Direction;
        isIdentity(): boolean;
        transformPosition(arg0: Internal.Vector4f): void;
        transformNormal(arg0: Internal.Vector3f): void;
        push(arg0: Internal.PoseStack): void;
        blockCenterToCorner(): Internal.Transformation;
    }
    class Type {
        getDescriptor(): string;
        static getDescriptor(arg0: Internal.Class<any>): string;
        getClass(): Internal.Class<any>;
        getElementType(): Internal.Type;
        static getArgumentTypes(arg0: string): Internal.Type[];
        static getArgumentTypes(arg0: Internal.Method): Internal.Type[];
        getArgumentTypes(): Internal.Type[];
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        static getArgumentsAndReturnSizes(arg0: string): number;
        getArgumentsAndReturnSizes(): number;
        notify(): void;
        getDimensions(): number;
        getSort(): number;
        getSize(): number;
        static getMethodDescriptor(arg0: Internal.Type, arg1: Internal.Type[]): string;
        static getMethodDescriptor(arg0: Internal.Method): string;
        getReturnType(): Internal.Type;
        static getReturnType(arg0: string): Internal.Type;
        static getReturnType(arg0: Internal.Method): Internal.Type;
        getInternalName(): string;
        static getInternalName(arg0: Internal.Class<any>): string;
        static getType(arg0: Internal.Class<any>): Internal.Type;
        static getType(arg0: string): Internal.Type;
        static getType(arg0: Internal.Method): Internal.Type;
        static getType(arg0: Internal.Constructor<any>): Internal.Type;
        hashCode(): number;
        equals(arg0: any): boolean;
        static getObjectType(arg0: string): Internal.Type;
        static getConstructorDescriptor(arg0: Internal.Constructor<any>): string;
        static getMethodType(arg0: Internal.Type, arg1: Internal.Type[]): Internal.Type;
        static getMethodType(arg0: string): Internal.Type;
        toString(): string;
        getClassName(): string;
        getOpcode(arg0: number): number;
        static readonly CHAR_TYPE : Internal.Type;
        static readonly FLOAT : 6;
        static readonly DOUBLE_TYPE : Internal.Type;
        static readonly ARRAY : 9;
        static readonly LONG_TYPE : Internal.Type;
        static readonly BYTE_TYPE : Internal.Type;
        static readonly CHAR : 2;
        static readonly VOID_TYPE : Internal.Type;
        static readonly OBJECT : 10;
        static readonly BOOLEAN_TYPE : Internal.Type;
        static readonly FLOAT_TYPE : Internal.Type;
        static readonly BOOLEAN : 1;
        static readonly INT : 5;
        static readonly SHORT : 4;
        static readonly BYTE : 3;
        static readonly METHOD : 11;
        static readonly SHORT_TYPE : Internal.Type;
        static readonly DOUBLE : 8;
        static readonly VOID : 0;
        static readonly LONG : 7;
        static readonly INT_TYPE : Internal.Type;
        get argumentsAndReturnSizes(): number;
        get internalName(): string;
        get size(): number;
        get className(): string;
        get descriptor(): string;
        get argumentTypes(): Internal.Type[];
        get sort(): number;
        get class(): Internal.Class<any>;
        get elementType(): Internal.Type;
        get returnType(): Internal.Type;
        get dimensions(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ReentrantBlockableEventLoop <R> extends Internal.BlockableEventLoop<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        execute(arg0: Internal.Runnable): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FrustumAdapter {
        sodium$createFrustum(): me.jellysquid.mods.sodium.client.util.frustum.Frustum;
    }
    interface BufferBuilderExtension {
        flywheel$getVertices(): number;
        flywheel$injectForRender(arg0: Internal.ByteBuffer, arg1: Internal.VertexFormat, arg2: number): void;
        flywheel$freeBuffer(): void;
        flywheel$appendBufferUnsafe(arg0: Internal.ByteBuffer): void;
    }
    class PlatformWrapper$ModInfo {
        getVersion(): string;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getId(): string;
        notify(): void;
        get name(): string;
        get id(): string;
        get version(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Float2ReferenceFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: number, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        put(arg0: number, arg1: V): V;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: V): V;
        remove(arg0: number): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): V;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface ArmorMaterial {
    }
    class ItemFoodEatenEventJS extends Internal.PlayerEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        addGameStage(stage: string): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getPlayer(): Internal.PlayerJS<any>;
        notifyAll(): void;
        getItem(): Internal.ItemStackJS;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.LevelJS;
        getMinecraftPlayer(): Internal.Player;
        post(id: string, sub: string): boolean;
        post(id: string): boolean;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        hasGameStage(stage: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        removeGameStage(stage: string): void;
        toString(): string;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get item(): Internal.ItemStackJS;
        get level(): Internal.LevelJS;
        get minecraftPlayer(): Internal.Player;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class URL implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static setURLStreamHandlerFactory(arg0: Internal.URLStreamHandlerFactory): void;
        getDefaultPort(): number;
        openConnection(): Internal.URLConnection;
        openConnection(arg0: Internal.Proxy): Internal.URLConnection;
        notifyAll(): void;
        toURI(): Internal.URI;
        getContent(): any;
        getContent(arg0: Internal.Class<any>[]): any;
        getProtocol(): string;
        getAuthority(): string;
        getFile(): string;
        openStream(): Internal.InputStream;
        notify(): void;
        toExternalForm(): string;
        getPort(): number;
        getRef(): string;
        sameFile(arg0: Internal.URL): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        getPath(): string;
        toString(): string;
        getUserInfo(): string;
        getQuery(): string;
        getHost(): string;
        get defaultPort(): number;
        get path(): string;
        get userInfo(): string;
        get protocol(): string;
        get ref(): string;
        get file(): string;
        get port(): number;
        get authority(): string;
        get query(): string;
        get host(): string;
        get class(): Internal.Class<any>;
        get content(): any;
        set uRLStreamHandlerFactory(arg0: Internal.URLStreamHandlerFactory);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BakedModel extends Internal.IForgeBakedModel {
        doesHandlePerspectives(): boolean;
        getModelData(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.BlockState, arg3: Internal.IModelData): Internal.IModelData;
        isLayered(): boolean;
        handlePerspective(arg0: Internal.ItemTransforms$TransformType, arg1: Internal.PoseStack): Internal.BakedModel;
        useAmbientOcclusion(arg0: Internal.BlockState): boolean;
        getQuads(arg0: Internal.BlockState, arg1: Internal.Direction, arg2: Internal.Random, arg3: Internal.IModelData): Internal.List<Internal.BakedQuad>;
        getLayerModels(arg0: Internal.ItemStack, arg1: boolean): Internal.List<Internal.Pair<Internal.BakedModel, Internal.RenderType>>;
        getParticleIcon(arg0: Internal.IModelData): Internal.TextureAtlasSprite;
    }
    class ChatFormatting extends Internal.Enum<any> implements Internal.Color {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRgbKJS(): number;
        static valueOf(arg0: string): Internal.ChatFormatting;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ChatFormatting[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ChatFormatting): number;
        getSerializeKJS(): string;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ChatFormatting>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ChatFormatting>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        createTextColorKJS(): Internal.TextColor;
        getHexKJS(): string;
        getArgbKJS(): number;
        toString(): string;
        getFireworkColorKJS(): number;
        specialEquals(o: any, shallow: boolean): boolean;
        ordinal(): number;
        static readonly ITALIC : Internal.ChatFormatting;
        static readonly GOLD : Internal.ChatFormatting;
        static readonly GRAY : Internal.ChatFormatting;
        static readonly AQUA : Internal.ChatFormatting;
        static readonly WHITE : Internal.ChatFormatting;
        static readonly BLUE : Internal.ChatFormatting;
        static readonly OBFUSCATED : Internal.ChatFormatting;
        static readonly DARK_AQUA : Internal.ChatFormatting;
        static readonly RESET : Internal.ChatFormatting;
        static readonly DARK_BLUE : Internal.ChatFormatting;
        static readonly GREEN : Internal.ChatFormatting;
        static readonly UNDERLINE : Internal.ChatFormatting;
        static readonly RED : Internal.ChatFormatting;
        static readonly DARK_PURPLE : Internal.ChatFormatting;
        static readonly STRIKETHROUGH : Internal.ChatFormatting;
        static readonly DARK_RED : Internal.ChatFormatting;
        static readonly LIGHT_PURPLE : Internal.ChatFormatting;
        static readonly BLACK : Internal.ChatFormatting;
        static readonly BOLD : Internal.ChatFormatting;
        static readonly DARK_GREEN : Internal.ChatFormatting;
        static readonly YELLOW : Internal.ChatFormatting;
        static readonly DARK_GRAY : Internal.ChatFormatting;
        get fireworkColorKJS(): number;
        get rgbKJS(): number;
        get argbKJS(): number;
        get serializeKJS(): string;
        get hexKJS(): string;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ChatFormatting>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IntUnaryOperator {
        applyAsInt(arg0: number): number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
    }
    class WorldGenSettings {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IVertexProducer {
        pipe(arg0: Internal.IVertexConsumer): void;
    }
    interface Float2ShortFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class ObjectiveCriteria {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class CharsetEncoder {
        encode(arg0: Internal.CharBuffer, arg1: Internal.ByteBuffer, arg2: boolean): Internal.CoderResult;
        encode(arg0: Internal.CharBuffer): Internal.ByteBuffer;
        getClass(): Internal.Class<any>;
        charset(): Internal.Charset;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        onUnmappableCharacter(arg0: Internal.CodingErrorAction): Internal.CharsetEncoder;
        notifyAll(): void;
        maxBytesPerChar(): number;
        isLegalReplacement(arg0: number[]): boolean;
        notify(): void;
        unmappableCharacterAction(): Internal.CodingErrorAction;
        malformedInputAction(): Internal.CodingErrorAction;
        flush(arg0: Internal.ByteBuffer): Internal.CoderResult;
        hashCode(): number;
        equals(arg0: any): boolean;
        canEncode(arg0: Internal.CharSequence): boolean;
        canEncode(arg0: string): boolean;
        averageBytesPerChar(): number;
        onMalformedInput(arg0: Internal.CodingErrorAction): Internal.CharsetEncoder;
        reset(): Internal.CharsetEncoder;
        toString(): string;
        replacement(): number[];
        replaceWith(arg0: number[]): Internal.CharsetEncoder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeItem {
        canElytraFly(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean;
        getTags(): Internal.Set<ResourceLocation>;
        setDamage(arg0: Internal.ItemStack, arg1: number): void;
        canPerformAction(arg0: Internal.ItemStack, arg1: Internal.ToolAction): boolean;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean;
        getItemEnchantability(arg0: Internal.ItemStack): number;
        damageItem<T>(arg0: Internal.ItemStack, arg1: number, arg2: T, arg3: (arg0: T) => void): number;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: boolean): boolean;
        getXpRepairRatio(arg0: Internal.ItemStack): number;
        readShareTag(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): void;
        onEntityItemUpdate(arg0: Internal.ItemStack, arg1: Internal.ItemEntity): boolean;
        getDamage(arg0: Internal.ItemStack): number;
        isBookEnchantable(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean;
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.LivingEntity, arg3: Internal.LivingEntity): boolean;
        onUsingTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        createEntity(arg0: net.minecraft.world.level.Level, arg1: Internal.Entity, arg2: Internal.ItemStack): Internal.Entity;
        getSweepHitBox(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): Internal.AABB;
        isRepairable(arg0: Internal.ItemStack): boolean;
        getShareTag(arg0: Internal.ItemStack): Internal.CompoundTag;
        getBurnTime(arg0: Internal.ItemStack, arg1: Internal.RecipeType<any>): number;
        onDroppedByPlayer(arg0: Internal.ItemStack, arg1: Internal.Player): boolean;
        isDamageable(arg0: Internal.ItemStack): boolean;
        onEntitySwing(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean;
        elytraFlightTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean;
        getAttributeModifiers(arg0: EquipmentSlot, arg1: Internal.ItemStack): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        onLeftClickEntity(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): boolean;
        canEquip(arg0: Internal.ItemStack, arg1: EquipmentSlot, arg2: Internal.Entity): boolean;
        onBlockStartBreak(arg0: Internal.ItemStack, arg1: BlockPos, arg2: Internal.Player): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Mob): void;
        canContinueUsing(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean;
        getEntityLifespan(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level): number;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack): number;
        getArmorTexture(arg0: Internal.ItemStack, arg1: Internal.Entity, arg2: EquipmentSlot, arg3: string): string;
        hasCustomEntity(arg0: Internal.ItemStack): boolean;
        getHighlightTip(arg0: Internal.ItemStack, arg1: Internal.Component): Internal.Component;
        getMaxDamage(arg0: Internal.ItemStack): number;
        getCreatorModId(arg0: Internal.ItemStack): string;
        isDamaged(arg0: Internal.ItemStack): boolean;
        onArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Player): void;
        hasContainerItem(arg0: Internal.ItemStack): boolean;
        doesSneakBypassUse(arg0: Internal.ItemStack, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Player): boolean;
        onItemUseFirst(arg0: Internal.ItemStack, arg1: Internal.UseOnContext): Internal.InteractionResult;
        getContainerItem(arg0: Internal.ItemStack): Internal.ItemStack;
        onDestroyed(arg0: Internal.ItemEntity, arg1: Internal.DamageSource): void;
        isCorrectToolForDrops(arg0: Internal.ItemStack, arg1: Internal.BlockState): boolean;
        getEquipmentSlot(arg0: Internal.ItemStack): EquipmentSlot;
        initCapabilities(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): Internal.ICapabilityProvider;
        getItemStackLimit(arg0: Internal.ItemStack): number;
        makesPiglinsNeutral(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean;
        isEnderMask(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.EnderMan): boolean;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean;
    }
    interface OpSupplier {
        create(arg0: dev.latvian.mods.rhino.util.unit.Unit, arg1: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
    }
    interface Long2ByteFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.LongToIntFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class SoundType {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class NetworkDirection extends Internal.Enum<any> {
        getEvent(arg0: Internal.ICustomPacket<any>, arg1: () => Internal.NetworkEvent$Context): Internal.NetworkEvent;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static directionFor<T_>(arg0: Internal.Class<T_>): Internal.NetworkDirection;
        static valueOf(arg0: string): Internal.NetworkDirection;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.NetworkDirection[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.NetworkDirection): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.NetworkDirection>>;
        notify(): void;
        getOriginationSide(): Internal.LogicalSide;
        getReceptionSide(): Internal.LogicalSide;
        getDeclaringClass(): Internal.Class<Internal.NetworkDirection>;
        buildPacket<T_>(arg0: org.apache.commons.lang3.tuple.Pair<Internal.FriendlyByteBuf, number>, arg1: ResourceLocation): Internal.ICustomPacket<T_>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        reply(): Internal.NetworkDirection;
        ordinal(): number;
        static readonly LOGIN_TO_CLIENT : Internal.NetworkDirection;
        static readonly PLAY_TO_SERVER : Internal.NetworkDirection;
        static readonly LOGIN_TO_SERVER : Internal.NetworkDirection;
        static readonly PLAY_TO_CLIENT : Internal.NetworkDirection;
        get receptionSide(): Internal.LogicalSide;
        get originationSide(): Internal.LogicalSide;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.NetworkDirection>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EntityTypeTest <B, T> {
    }
    interface VertexWriter {
        seekToVertex(arg0: number): void;
        writeVertexList(arg0: Internal.VertexList): void;
        writeVertex(arg0: Internal.VertexList, arg1: number): void;
        intoReader(): Internal.VertexList;
    }
    interface Object2CharFunction <K> extends it.unimi.dsi.fastutil.Function<K, string>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: any, arg1: string): string;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        removeChar(arg0: any): string;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: K) => T_;
        put(arg0: K, arg1: string): string;
        put(arg0: K, arg1: string): string;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): any;
        remove(arg0: any): string;
        defaultReturnValue(arg0: string): void;
        defaultReturnValue(): string;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        get(arg0: any): string;
        get(arg0: any): any;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: K): number;
        apply(arg0: K): string;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        getChar(arg0: any): string;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => string;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface EventExecutorGroup extends Internal.ScheduledExecutorService, Internal.Iterable<Internal.EventExecutor> {
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>;
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        next(): Internal.EventExecutor;
        terminationFuture(): Internal.Future<any>;
        shutdownGracefully(): Internal.Future<any>;
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit): Internal.Future<any>;
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): Internal.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): java_.util.concurrent.Future<T_>;
        submit(arg0: Internal.Runnable): Internal.Future<any>;
        submit(arg0: Internal.Runnable): java_.util.concurrent.Future<any>;
        submit<T_>(arg0: Internal.Runnable, arg1: T_): Internal.Future<T_>;
        submit<T_>(arg0: Internal.Runnable, arg1: T_): java_.util.concurrent.Future<T_>;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        isTerminated(): boolean;
        forEach(arg0: (arg0: Internal.EventExecutor) => void): void;
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>;
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<java_.util.concurrent.Future<T_>>;
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): Internal.List<java_.util.concurrent.Future<T_>>;
        execute(arg0: Internal.Runnable): void;
        isShuttingDown(): boolean;
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<any>;
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V_>;
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<V_>;
        iterator(): Internal.Iterator<Internal.EventExecutor>;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean;
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): T_;
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): T_;
        shutdownNow(): Internal.List<Internal.Runnable>;
        shutdown(): void;
        isShutdown(): boolean;
    }
    interface Char2ReferenceFunction <V> extends it.unimi.dsi.fastutil.Function<string, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: string, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: string) => V_;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        put(arg0: string, arg1: V): V;
        put(arg0: any, arg1: any): any;
        put(arg0: string, arg1: V): V;
        remove(arg0: string): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        get(arg0: any): V;
        get(arg0: string): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): V;
        apply(arg0: string): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface WatchKey {
        cancel(): void;
        watchable(): Internal.Watchable;
        pollEvents(): Internal.List<Internal.WatchEvent<any>>;
        isValid(): boolean;
        reset(): boolean;
    }
    interface DoubleBinaryOperator {
        applyAsDouble(arg0: number, arg1: number): number;
    }
    class EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ToLongFunction <T> {
        applyAsLong(arg0: T): number;
    }
    class Products$P12 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractContainerScreen <T> extends Internal.Screen implements Internal.MenuAccess<T>, net.blay09.mods.balm.mixin.AbstractContainerScreenAccessor, Internal.AbstractContainerScreenAccessor {
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.ItemStack): void;
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.Font): void;
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.Font, arg5: Internal.ItemStack): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getHoveredSlot(): Internal.Slot;
        notifyAll(): void;
        getYSize(): number;
        getIsQuickCrafting(): boolean;
        getLeftPos(): number;
        notify(): void;
        getImageHeight(): number;
        balm_getNarratables(): Internal.List<any>;
        static renderSlotHighlight(arg0: Internal.PoseStack, arg1: number, arg2: number, arg3: number, arg4: number): void;
        invokeFindSlot(arg0: number, arg1: number): Internal.Slot;
        hashCode(): number;
        setIsQuickCrafting(arg0: boolean): void;
        getQuickCraftingButton(): number;
        getSlotColor(arg0: number): number;
        callIsHovering(arg0: Internal.Slot, arg1: number, arg2: number): boolean;
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.ItemStack): void;
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.Font): void;
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedCharSequence>, arg2: number, arg3: number, arg4: Internal.Font): void;
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.Font, arg6: Internal.ItemStack): void;
        handler$zjd000$renderSlot(arg0: Internal.PoseStack, arg1: Internal.Slot, arg2: Internal.CallbackInfo): void;
        setSkipNextRelease(arg0: boolean): void;
        callRenderSlot(arg0: Internal.PoseStack, arg1: Internal.Slot): void;
        getRenderables(): Internal.List<any>;
        getImageWidth(): number;
        invokeSlotClicked(arg0: Internal.Slot, arg1: number, arg2: number, arg3: Internal.ClickType): void;
        getMinecraft(): Internal.Minecraft;
        getTopPos(): number;
        getGuiTop(): number;
        getGuiLeft(): number;
        balm_getChildren(): Internal.List<any>;
        balm_getRenderables(): Internal.List<any>;
        equals(arg0: any): boolean;
        getSlotUnderMouse(): Internal.Slot;
        toString(): string;
        getXSize(): number;
        tooltipStack : Internal.ItemStack;
        get leftPos(): number;
        get imageWidth(): number;
        get minecraft(): Internal.Minecraft;
        get quickCraftingButton(): number;
        get isQuickCrafting(): boolean;
        get ySize(): number;
        get imageHeight(): number;
        get renderables(): Internal.List<any>;
        get hoveredSlot(): Internal.Slot;
        get slotUnderMouse(): Internal.Slot;
        get guiLeft(): number;
        get xSize(): number;
        get class(): Internal.Class<any>;
        get topPos(): number;
        get guiTop(): number;
        set isQuickCrafting(arg0: boolean);
        set skipNextRelease(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class DoubleBuffer extends Internal.Buffer implements Internal.Comparable<Internal.DoubleBuffer> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        compact(): Internal.DoubleBuffer;
        notifyAll(): void;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.DoubleBuffer): number;
        notify(): void;
        asReadOnlyBuffer(): Internal.DoubleBuffer;
        put(arg0: number[]): Internal.DoubleBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.DoubleBuffer;
        put(arg0: number, arg1: number[]): Internal.DoubleBuffer;
        put(arg0: number[], arg1: number, arg2: number): Internal.DoubleBuffer;
        put(arg0: number, arg1: Internal.DoubleBuffer, arg2: number, arg3: number): Internal.DoubleBuffer;
        put(arg0: Internal.DoubleBuffer): Internal.DoubleBuffer;
        put(arg0: number, arg1: number): Internal.DoubleBuffer;
        put(arg0: number): Internal.DoubleBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        slice(): Internal.Buffer;
        slice(): Internal.DoubleBuffer;
        slice(arg0: number, arg1: number): Internal.Buffer;
        slice(arg0: number, arg1: number): Internal.DoubleBuffer;
        array(): number[];
        array(): any;
        hashCode(): number;
        get(): number;
        get(arg0: number, arg1: number[]): Internal.DoubleBuffer;
        get(arg0: number): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.DoubleBuffer;
        get(arg0: number[], arg1: number, arg2: number): Internal.DoubleBuffer;
        get(arg0: number[]): Internal.DoubleBuffer;
        limit(arg0: number): Internal.DoubleBuffer;
        limit(arg0: number): Internal.Buffer;
        limit(): number;
        arrayOffset(): number;
        flip(): Internal.Buffer;
        flip(): Internal.DoubleBuffer;
        order(): Internal.ByteOrder;
        hasArray(): boolean;
        hasRemaining(): boolean;
        clear(): Internal.Buffer;
        clear(): Internal.DoubleBuffer;
        duplicate(): Internal.DoubleBuffer;
        duplicate(): Internal.Buffer;
        remaining(): number;
        static allocate(arg0: number): Internal.DoubleBuffer;
        rewind(): Internal.Buffer;
        rewind(): Internal.DoubleBuffer;
        mismatch(arg0: Internal.DoubleBuffer): number;
        equals(arg0: any): boolean;
        reset(): Internal.Buffer;
        reset(): Internal.DoubleBuffer;
        toString(): string;
        position(arg0: number): Internal.DoubleBuffer;
        position(arg0: number): Internal.Buffer;
        position(): number;
        isDirect(): boolean;
        static wrap(arg0: number[]): Internal.DoubleBuffer;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.DoubleBuffer;
        mark(): Internal.Buffer;
        mark(): Internal.DoubleBuffer;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModelBakeEvent extends Internal.Event implements Internal.IModBusEvent {
        setCanceled(arg0: boolean): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCanceled(): boolean;
        setResult(arg0: Internal.Event$Result): void;
        getModelRegistry(): Internal.Map<ResourceLocation, Internal.BakedModel>;
        notifyAll(): void;
        hasResult(): boolean;
        getModelManager(): Internal.ModelManager;
        notify(): void;
        getListenerList(): Internal.ListenerList;
        hashCode(): number;
        equals(arg0: any): boolean;
        getResult(): Internal.Event$Result;
        toString(): string;
        isCancelable(): boolean;
        getPhase(): Internal.EventPriority;
        getModelLoader(): Internal.ForgeModelBakery;
        setPhase(arg0: Internal.EventPriority): void;
        get result(): Internal.Event$Result;
        get phase(): Internal.EventPriority;
        get canceled(): boolean;
        get modelRegistry(): Internal.Map<ResourceLocation, Internal.BakedModel>;
        get cancelable(): boolean;
        get listenerList(): Internal.ListenerList;
        get modelManager(): Internal.ModelManager;
        get modelLoader(): Internal.ForgeModelBakery;
        get class(): Internal.Class<any>;
        set phase(arg0: Internal.EventPriority);
        set result(arg0: Internal.Event$Result);
        set canceled(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Player extends Internal.LivingEntity implements Internal.BackpackedInventoryAccess, Internal.PlayerKJS {
        getClass(): Internal.Class<any>;
        backpackedMoved(): boolean;
        handler$zdn000$onIsScoping(arg0: Internal.CallbackInfoReturnable<any>): void;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>;
        handler$zje000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void;
        handler$zbc000$onFallFlying(arg0: number, arg1: number, arg2: number, arg3: Internal.CallbackInfo): void;
        onEndimationEnd(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        canBeRiddenInWater(arg0: Internal.Entity): boolean;
        handler$zzo000$tickHead(arg0: Internal.CallbackInfo): void;
        setCitadelEntityData(arg0: Internal.CompoundTag): void;
        isEndimationPlaying(arg0: Internal.PlayableEndimation): boolean;
        isActive(): boolean;
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void;
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity;
        getCachedFeetBlockState(): Internal.BlockState;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        handler$bfj000$tryShortcutFluidPushing(tag: net.minecraft.tags.Tag<any>, speed: number, cir: Internal.CallbackInfoReturnable<any>, box: Internal.AABB, x1: number, x2: number, y1: number, y2: number, z1: number, z2: number, zero: number): void;
        getPos(): Internal.Position;
        foodEatenKJS(is: Internal.ItemStack): void;
        revive(): void;
        static getDataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        getDigSpeed(arg0: Internal.BlockState, arg1: BlockPos): number;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(arg0: boolean): void;
        canUpdate(): boolean;
        getEndimatedState(): Internal.Endimatable$EndimatedState;
        getSuffixes(): Internal.Collection<Internal.MutableComponent>;
        resetEndimation(): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean;
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number;
        reviveCaps(): void;
        handler$zfk000$diet$constructPlayer(arg0: Internal.CallbackInfo): void;
        lithiumOnBlockCacheDeleted(): void;
        setForcedPose(arg0: Internal.Pose): void;
        canRiderInteract(): boolean;
        handler$zbc000$locateAmmo(arg0: Internal.ItemStack, arg1: Internal.CallbackInfoReturnable<any>, arg2: (arg0: any) => boolean): void;
        getEntries(arg0: boolean): Internal.Set<any>;
        getEffectHandler(): Internal.EndimationEffectHandler;
        onAddedToWorld(): void;
        setAnimationTick(arg0: number): void;
        getPrefixes(): Internal.Collection<Internal.MutableComponent>;
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        static getDataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        getListener(): Internal.NearbyEntityListenerMulti;
        getClassification(arg0: boolean): Internal.MobCategory;
        isNoEndimationPlaying(): boolean;
        onEndimationStart(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listenForCachedBlockChanges: boolean): void;
        shouldRiderSit(): boolean;
        getIsInsidePortal(): boolean;
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$zje000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        handler$zcg000$read(arg0: Internal.CompoundTag, arg1: Internal.CallbackInfo): void;
        getRemainingFireTicks(): number;
        lithiumOnEquipmentChanged(): void;
        getStagesRawKJS(): Internal.Stages;
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void;
        notify(): void;
        getDataMap(): Internal.Map<any, any>;
        handler$zzo000$moveStep(arg0: Internal.MoverType, arg1: Vec3, arg2: Internal.CallbackInfo): void;
        getStages(): Internal.Stages;
        getEntityChangeListener(): Internal.EntityInLevelCallback;
        endimateTick(): void;
        setDataMap(arg0: Internal.Map<any, any>): void;
        isDirty(): boolean;
        hashCode(): number;
        getLastPos(): BlockPos;
        isAddedToWorld(): boolean;
        getParts(): any[];
        addListener(listener: Internal.NearbyEntityListener): void;
        onRemovedFromWorld(): void;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        curePotionEffects(arg0: Internal.ItemStack): boolean;
        clean(): void;
        asKJS(): any;
        getPlayingEndimation(): Internal.PlayableEndimation;
        getDirtyEntries(): Internal.Set<any>;
        getValue(arg0: Internal.TrackedData<any>): any;
        shouldRiderFaceForward(arg0: Internal.Player): boolean;
        setPlayingEndimation(arg0: Internal.PlayableEndimation): void;
        setValue(arg0: Internal.TrackedData<any>, arg1: any): void;
        equals(arg0: any): boolean;
        getAnimationTick(): number;
        toString(): string;
        setRemainingFireTicks(arg0: number): void;
        handler$zgd001$tick(arg0: Internal.CallbackInfo): void;
        getBackpackedInventory(): Internal.BackpackInventory;
        refreshDisplayName(): void;
        getForcedPose(): Internal.Pose;
        backpackedInventory : Internal.BackpackInventory;
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
        get suffixes(): Internal.Collection<Internal.MutableComponent>;
        get citadelEntityData(): Internal.CompoundTag;
        get listener(): Internal.NearbyEntityListenerMulti;
        get stagesRawKJS(): Internal.Stages;
        get addedToWorld(): boolean;
        get animationTick(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get pos(): Internal.Position;
        get dataMap(): Internal.Map<any, any>;
        get noEndimationPlaying(): boolean;
        get class(): Internal.Class<any>;
        get dirty(): boolean;
        get dataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get entityChangeListener(): Internal.EntityInLevelCallback;
        get multipartEntity(): boolean;
        get active(): boolean;
        get playingEndimation(): Internal.PlayableEndimation;
        get effectHandler(): Internal.EndimationEffectHandler;
        get cachedFeetBlockState(): Internal.BlockState;
        get lastPos(): BlockPos;
        get dirtyEntries(): Internal.Set<any>;
        get dataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        get prefixes(): Internal.Collection<Internal.MutableComponent>;
        get forcedPose(): Internal.Pose;
        get stages(): Internal.Stages;
        get parts(): any[];
        get endimatedState(): Internal.Endimatable$EndimatedState;
        set animationTick(arg0: number);
        set forcedPose(arg0: Internal.Pose);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set dataMap(arg0: Internal.Map<any, any>);
        set playingEndimation(arg0: Internal.PlayableEndimation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Script {
        exec(arg0: Internal.Context, arg1: Internal.Scriptable): any;
    }
    class GridAlignedBB implements Internal.ImmutableBox {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setMinY(arg0: number): Internal.GridAlignedBB;
        setMinX(arg0: number): Internal.GridAlignedBB;
        intersects(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        intersects(arg0: Internal.ImmutableBox): boolean;
        notifyAll(): void;
        setMinZ(arg0: number): Internal.GridAlignedBB;
        forEachContained(arg0: Internal.CoordinateConsumer): void;
        nextPowerOf2(): void;
        fixMinMax(): void;
        notify(): void;
        translate(arg0: number, arg1: number, arg2: number): void;
        translate(arg0: Vec3i): void;
        empty(): boolean;
        setMin(arg0: Vec3i): Internal.GridAlignedBB;
        setMin(arg0: number, arg1: number, arg2: number): Internal.GridAlignedBB;
        mirrorAbout(arg0: (arg0: any) => boolean): void;
        hashCode(): number;
        static ofRadius(arg0: number): Internal.GridAlignedBB;
        static from(arg0: Internal.SectionPos): Internal.GridAlignedBB;
        static from(arg0: Internal.AABB): Internal.GridAlignedBB;
        static from(arg0: BlockPos, arg1: BlockPos): Internal.GridAlignedBB;
        static from(arg0: number, arg1: number): Internal.GridAlignedBB;
        static from(arg0: BlockPos): Internal.GridAlignedBB;
        copy(): Internal.GridAlignedBB;
        intersectAssign(arg0: Internal.ImmutableBox): void;
        setMax(arg0: Vec3i): Internal.GridAlignedBB;
        setMax(arg0: number, arg1: number, arg2: number): Internal.GridAlignedBB;
        hasPowerOf2Sides(): boolean;
        grow(arg0: number): void;
        grow(arg0: number, arg1: number, arg2: number): void;
        intersect(arg0: Internal.ImmutableBox): Internal.GridAlignedBB;
        nextPowerOf2Centered(): void;
        getMaxX(): number;
        getMaxY(): number;
        union(arg0: Internal.ImmutableBox): Internal.ImmutableBox;
        static containingAll(arg0: Internal.Collection<BlockPos>): Internal.ImmutableBox;
        getMaxZ(): number;
        volume(): number;
        sizeX(): number;
        contains(arg0: Internal.ImmutableBox): boolean;
        contains(arg0: number, arg1: number, arg2: number): boolean;
        isContainedBy(arg0: Internal.GridAlignedBB): boolean;
        unionAssign(arg0: Internal.AABB): void;
        unionAssign(arg0: Internal.ImmutableBox): void;
        setMaxZ(arg0: number): Internal.GridAlignedBB;
        toAABB(): Internal.AABB;
        equals(arg0: any): boolean;
        setMaxY(arg0: number): Internal.GridAlignedBB;
        toString(): string;
        setMaxX(arg0: number): Internal.GridAlignedBB;
        getMinZ(): number;
        getMinX(): number;
        sizeY(): number;
        getMinY(): number;
        sameAs(arg0: Internal.ImmutableBox): boolean;
        sameAs(arg0: Internal.AABB): boolean;
        sizeZ(): number;
        assign(arg0: BlockPos, arg1: BlockPos): Internal.GridAlignedBB;
        assign(arg0: Internal.ImmutableBox): void;
        assign(arg0: Internal.AABB): void;
        get minY(): number;
        get maxZ(): number;
        get minX(): number;
        get maxY(): number;
        get maxX(): number;
        get minZ(): number;
        get class(): Internal.Class<any>;
        set min(arg0: Vec3i);
        set minY(arg0: number);
        set maxZ(arg0: number);
        set max(arg0: Vec3i);
        set minX(arg0: number);
        set maxY(arg0: number);
        set maxX(arg0: number);
        set minZ(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EntryMessage extends Internal.FlowMessage {
        getText(): string;
        getParameters(): any[];
        getFormattedMessage(): string;
        getMessage(): Internal.Message;
        getFormat(): string;
        getThrowable(): Internal.Throwable;
    }
    interface TriPredicate <T, U, V> {
        or(arg0: Internal.TriPredicate<T, U, V>): Internal.TriPredicate<T, U, V>;
        test(arg0: T, arg1: U, arg2: V): boolean;
        and(arg0: Internal.TriPredicate<T, U, V>): Internal.TriPredicate<T, U, V>;
        negate(): Internal.TriPredicate<T, U, V>;
    }
    interface AutoCloseable {
        close(): void;
    }
    interface Function14 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, (arg0: T13, arg1: T14) => R>;
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function5<T10, T11, T12, T13, T14, R>>;
        curry13(): Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, (arg0: T14) => R>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13, arg13: T14): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function7<T8, T9, T10, T11, T12, T13, T14, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function6<T9, T10, T11, T12, T13, T14, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function4<T11, T12, T13, T14, R>>;
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function3<T12, T13, T14, R>>;
        curry(): (arg0: T1) => Internal.Function13<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function9<T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function8<T7, T8, T9, T10, T11, T12, T13, T14, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function11<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function10<T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>;
        curry2(): (arg0: T1, arg1: T2) => Internal.Function12<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>;
    }
    interface FuncSupplier$Func2 extends Internal.FuncSupplier {
        create2(arg0: dev.latvian.mods.rhino.util.unit.Unit, arg1: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        create(args: Internal.List<dev.latvian.mods.rhino.util.unit.Unit>): dev.latvian.mods.rhino.util.unit.Unit;
    }
    abstract class ChunkAccess implements Internal.BlockGetter, Internal.BiomeManager$NoiseBiomeSource, Internal.FeatureAccess, Internal.ExtendedChunk {
        getClass(): Internal.Class<any>;
        getWorldForge(): Internal.LevelAccessor;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getBlockNibbles(): any[];
        setBlockEmptinessMap(arg0: boolean[]): void;
        notify(): void;
        setSkyNibbles(arg0: any[]): void;
        hashCode(): number;
        getSkyEmptinessMap(): boolean[];
        equals(arg0: any): boolean;
        getSkyNibbles(): any[];
        toString(): string;
        localvar$bna000$modifyHeightmapType(arg0: Internal.Heightmap$Types): Internal.Heightmap$Types;
        setSkyEmptinessMap(arg0: boolean[]): void;
        getBlockEmptinessMap(): boolean[];
        setBlockNibbles(arg0: any[]): void;
        get skyNibbles(): any[];
        get skyEmptinessMap(): boolean[];
        get blockEmptinessMap(): boolean[];
        get worldForge(): Internal.LevelAccessor;
        get class(): Internal.Class<any>;
        get blockNibbles(): any[];
        set skyNibbles(arg0: any[]);
        set skyEmptinessMap(arg0: boolean[]);
        set blockEmptinessMap(arg0: boolean[]);
        set blockNibbles(arg0: any[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Channel extends Internal.Closeable {
        isOpen(): boolean;
        close(): void;
    }
    class AdvancementJS {
        hasDisplay(): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getParent(): Internal.AdvancementJS;
        notifyAll(): void;
        getId(): ResourceLocation;
        getDescription(): Internal.Text;
        notify(): void;
        getChildren(): Internal.Set<Internal.AdvancementJS>;
        getTitle(): Internal.Text;
        hashCode(): number;
        equals(o: any): boolean;
        toString(): string;
        id(): ResourceLocation;
        getDisplayText(): Internal.Text;
        addChild(a: Internal.AdvancementJS): void;
        readonly advancement : Internal.Advancement;
        get parent(): Internal.AdvancementJS;
        get displayText(): Internal.Text;
        get children(): Internal.Set<Internal.AdvancementJS>;
        get description(): Internal.Text;
        get title(): Internal.Text;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DataOutputStream extends Internal.FilterOutputStream implements Internal.DataOutput {
        writeInt(arg0: number): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        writeByte(arg0: number): void;
        notifyAll(): void;
        writeFloat(arg0: number): void;
        notify(): void;
        writeChar(arg0: number): void;
        writeLong(arg0: number): void;
        writeBytes(arg0: string): void;
        size(): number;
        flush(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        writeUTF(arg0: string): void;
        toString(): string;
        static nullOutputStream(): Internal.OutputStream;
        writeShort(arg0: number): void;
        writeChars(arg0: string): void;
        close(): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        write(arg0: number): void;
        write(arg0: number[]): void;
        writeBoolean(arg0: boolean): void;
        writeDouble(arg0: number): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ByteBuf implements Internal.ReferenceCounted, Internal.Comparable<Internal.ByteBuf> {
        asReadOnly(): Internal.ByteBuf;
        markReaderIndex(): Internal.ByteBuf;
        getByte(arg0: number): number;
        release(arg0: number): boolean;
        release(): boolean;
        readDoubleLE(): number;
        writeZero(arg0: number): Internal.ByteBuf;
        resetReaderIndex(): Internal.ByteBuf;
        writeFloat(arg0: number): Internal.ByteBuf;
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf;
        readRetainedSlice(arg0: number): Internal.ByteBuf;
        slice(): Internal.ByteBuf;
        slice(arg0: number, arg1: number): Internal.ByteBuf;
        getMediumLE(arg0: number): number;
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf;
        readUnsignedIntLE(): number;
        writeFloatLE(arg0: number): Internal.ByteBuf;
        readInt(): number;
        order(): Internal.ByteOrder;
        order(arg0: Internal.ByteOrder): Internal.ByteBuf;
        writeMedium(arg0: number): Internal.ByteBuf;
        resetWriterIndex(): Internal.ByteBuf;
        writableBytes(): number;
        maxCapacity(): number;
        getUnsignedShort(arg0: number): number;
        nioBufferCount(): number;
        bytesBefore(arg0: number, arg1: number): number;
        bytesBefore(arg0: number): number;
        bytesBefore(arg0: number, arg1: number, arg2: number): number;
        setInt(arg0: number, arg1: number): Internal.ByteBuf;
        getInt(arg0: number): number;
        markWriterIndex(): Internal.ByteBuf;
        isReadable(): boolean;
        isReadable(arg0: number): boolean;
        writeBoolean(arg0: boolean): Internal.ByteBuf;
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        writeLongLE(arg0: number): Internal.ByteBuf;
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf;
        retain(arg0: number): Internal.ReferenceCounted;
        retain(arg0: number): Internal.ByteBuf;
        retain(): Internal.ByteBuf;
        retain(): Internal.ReferenceCounted;
        isWritable(): boolean;
        isWritable(arg0: number): boolean;
        notify(): void;
        readChar(): string;
        hasMemoryAddress(): boolean;
        capacity(): number;
        capacity(arg0: number): Internal.ByteBuf;
        readCharSequence(arg0: number, arg1: Internal.Charset): Internal.CharSequence;
        isReadOnly(): boolean;
        readUnsignedShortLE(): number;
        readDouble(): number;
        readFloat(): number;
        getLongLE(arg0: number): number;
        getBoolean(arg0: number): boolean;
        copy(arg0: number, arg1: number): Internal.ByteBuf;
        copy(): Internal.ByteBuf;
        readShortLE(): number;
        readUnsignedMedium(): number;
        ensureWritable(arg0: number): Internal.ByteBuf;
        ensureWritable(arg0: number, arg1: boolean): number;
        writeInt(arg0: number): Internal.ByteBuf;
        readFloatLE(): number;
        getDoubleLE(arg0: number): number;
        hasArray(): boolean;
        memoryAddress(): number;
        maxFastWritableBytes(): number;
        readableBytes(): number;
        readSlice(arg0: number): Internal.ByteBuf;
        getIntLE(arg0: number): number;
        forEachByteDesc(arg0: Internal.ByteProcessor): number;
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number;
        nioBuffers(): Internal.ByteBuffer[];
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        skipBytes(arg0: number): Internal.ByteBuf;
        getLong(arg0: number): number;
        readLong(): number;
        readShort(): number;
        equals(arg0: any): boolean;
        getUnsignedMedium(arg0: number): number;
        setZero(arg0: number, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: number[]): Internal.ByteBuf;
        readBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number;
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf;
        readBytes(arg0: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf): Internal.ByteBuf;
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf;
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.GatheringByteChannel, arg1: number): number;
        readBoolean(): boolean;
        toString(arg0: number, arg1: number, arg2: Internal.Charset): string;
        toString(arg0: Internal.Charset): string;
        toString(): string;
        retainedSlice(): Internal.ByteBuf;
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf;
        readMediumLE(): number;
        setMedium(arg0: number, arg1: number): Internal.ByteBuf;
        isDirect(): boolean;
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf;
        getClass(): Internal.Class<any>;
        getFloatLE(arg0: number): number;
        readerIndex(): number;
        readerIndex(arg0: number): Internal.ByteBuf;
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset): Internal.CharSequence;
        setShort(arg0: number, arg1: number): Internal.ByteBuf;
        compareTo(arg0: Internal.ByteBuf): number;
        compareTo(arg0: any): number;
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number;
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel, arg2: number): number;
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf;
        unwrap(): Internal.ByteBuf;
        setDouble(arg0: number, arg1: number): Internal.ByteBuf;
        setChar(arg0: number, arg1: number): Internal.ByteBuf;
        refCnt(): number;
        getUnsignedIntLE(arg0: number): number;
        getUnsignedInt(arg0: number): number;
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf;
        indexOf(arg0: number, arg1: number, arg2: number): number;
        writeByte(arg0: number): Internal.ByteBuf;
        nioBuffer(): Internal.ByteBuffer;
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        discardSomeReadBytes(): Internal.ByteBuf;
        touch(): Internal.ReferenceCounted;
        touch(): Internal.ByteBuf;
        touch(arg0: any): Internal.ByteBuf;
        touch(arg0: any): Internal.ReferenceCounted;
        duplicate(): Internal.ByteBuf;
        writerIndex(): number;
        writerIndex(arg0: number): Internal.ByteBuf;
        getUnsignedShortLE(arg0: number): number;
        writeCharSequence(arg0: Internal.CharSequence, arg1: Internal.Charset): number;
        readUnsignedInt(): number;
        retainedDuplicate(): Internal.ByteBuf;
        getChar(arg0: number): string;
        setLong(arg0: number, arg1: number): Internal.ByteBuf;
        readMedium(): number;
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.ScatteringByteChannel, arg1: number): number;
        writeBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number;
        writeBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf;
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: number[]): Internal.ByteBuf;
        writeBytes(arg0: Internal.InputStream, arg1: number): number;
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number;
        forEachByte(arg0: Internal.ByteProcessor): number;
        setIndex(arg0: number, arg1: number): Internal.ByteBuf;
        writeShort(arg0: number): Internal.ByteBuf;
        getShortLE(arg0: number): number;
        alloc(): Internal.ByteBufAllocator;
        getMedium(arg0: number): number;
        readUnsignedShort(): number;
        setByte(arg0: number, arg1: number): Internal.ByteBuf;
        maxWritableBytes(): number;
        writeShortLE(arg0: number): Internal.ByteBuf;
        notifyAll(): void;
        getDouble(arg0: number): number;
        getFloat(arg0: number): number;
        writeLong(arg0: number): Internal.ByteBuf;
        writeIntLE(arg0: number): Internal.ByteBuf;
        array(): number[];
        setCharSequence(arg0: number, arg1: Internal.CharSequence, arg2: Internal.Charset): number;
        hashCode(): number;
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        arrayOffset(): number;
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf;
        readIntLE(): number;
        readUnsignedByte(): number;
        readLongLE(): number;
        readUnsignedMediumLE(): number;
        writeDouble(arg0: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel, arg2: number): number;
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.InputStream, arg2: number): number;
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number;
        setFloat(arg0: number, arg1: number): Internal.ByteBuf;
        getShort(arg0: number): number;
        writeMediumLE(arg0: number): Internal.ByteBuf;
        clear(): Internal.ByteBuf;
        getUnsignedByte(arg0: number): number;
        discardReadBytes(): Internal.ByteBuf;
        writeChar(arg0: number): Internal.ByteBuf;
        writeDoubleLE(arg0: number): Internal.ByteBuf;
        isContiguous(): boolean;
        getUnsignedMediumLE(arg0: number): number;
        readByte(): number;
        get readable(): boolean;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get contiguous(): boolean;
        get writable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Dynamic <T> extends Internal.DynamicLike<any> {
        createIntList(arg0: Internal.IntStream): Internal.Dynamic<any>;
        createLong(arg0: number): Internal.Dynamic<T>;
        getClass(): Internal.Class<any>;
        getElementGeneric(arg0: T): Internal.DataResult<T>;
        getElementGeneric(arg0: T, arg1: T): T;
        updateMapValues(arg0: (arg0: Internal.Pair<Internal.Dynamic<any>, Internal.Dynamic<any>>) => Internal.Pair<Internal.Dynamic<any>, Internal.Dynamic<any>>): Internal.Dynamic<T>;
        createLongList(arg0: Internal.LongStream): Internal.Dynamic<any>;
        readMap<K_, V_>(arg0: Internal.Decoder<K_>, arg1: Internal.Decoder<V_>): Internal.DataResult<Internal.List<Internal.Pair<K_, V_>>>;
        readMap<K_, V_>(arg0: Internal.Decoder<K_>, arg1: (arg0: K_) => Internal.Decoder<V_>): Internal.DataResult<Internal.List<Internal.Pair<K_, V_>>>;
        readMap<R_>(arg0: Internal.DataResult<R_>, arg1: Internal.Function3<R_, Internal.Dynamic<T>, Internal.Dynamic<T>, Internal.DataResult<R_>>): Internal.DataResult<R_>;
        asListOpt<U_>(arg0: (arg0: Internal.Dynamic<T>) => U_): Internal.DataResult<Internal.List<U_>>;
        createShort(arg0: number): Internal.Dynamic<T>;
        static convert<S_, T_>(arg0: Internal.DynamicOps<S_>, arg1: Internal.DynamicOps<T_>, arg2: S_): T_;
        convert<R_>(arg0: Internal.DynamicOps<R_>): Internal.Dynamic<R_>;
        decode<A_>(arg0: Internal.Decoder<A_>): Internal.DataResult<Internal.Pair<A_, T>>;
        asIntStreamOpt(): Internal.DataResult<Internal.IntStream>;
        asList<U_>(arg0: (arg0: Internal.Dynamic<T>) => U_): Internal.List<U_>;
        getMapValues(): Internal.DataResult<Internal.Map<Internal.Dynamic<T>, Internal.Dynamic<T>>>;
        cast<U_>(arg0: Internal.DynamicOps<U_>): U_;
        readList<E_>(arg0: (arg0: Internal.Dynamic<any>) => Internal.DataResult<E_>): Internal.DataResult<Internal.List<E_>>;
        readList<E_>(arg0: Internal.Decoder<E_>): Internal.DataResult<Internal.List<E_>>;
        merge(arg0: Internal.Dynamic<any>, arg1: Internal.Dynamic<any>): Internal.OptionalDynamic<T>;
        merge(arg0: Internal.Dynamic<any>): Internal.OptionalDynamic<T>;
        asString(): Internal.DataResult<string>;
        asString(arg0: string): string;
        asByte(arg0: number): number;
        createList(arg0: Internal.Stream<Internal.Dynamic<any>>): Internal.Dynamic<T>;
        read<A_>(arg0: Internal.Decoder<A_>): Internal.DataResult<A_>;
        asByteBufferOpt(): Internal.DataResult<Internal.ByteBuffer>;
        createString(arg0: string): Internal.Dynamic<T>;
        asMapOpt(): Internal.DataResult<Internal.Stream<Internal.Pair<Internal.Dynamic<T>, Internal.Dynamic<T>>>>;
        asMapOpt<K_, V_>(arg0: (arg0: Internal.Dynamic<T>) => K_, arg1: (arg0: Internal.Dynamic<T>) => V_): Internal.DataResult<Internal.Map<K_, V_>>;
        getGeneric(arg0: T): Internal.DataResult<T>;
        asStream(): Internal.Stream<Internal.Dynamic<T>>;
        asLong(arg0: number): number;
        createByte(arg0: number): Internal.Dynamic<T>;
        asDouble(arg0: number): number;
        asBoolean(arg0: boolean): boolean;
        updateGeneric(arg0: T, arg1: (arg0: T) => T): Internal.Dynamic<T>;
        createDouble(arg0: number): Internal.Dynamic<T>;
        asLongStreamOpt(): Internal.DataResult<Internal.LongStream>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        asMap<K_, V_>(arg0: (arg0: Internal.Dynamic<T>) => K_, arg1: (arg0: Internal.Dynamic<T>) => V_): Internal.Map<K_, V_>;
        asStreamOpt(): Internal.DataResult<Internal.Stream<Internal.Dynamic<T>>>;
        notifyAll(): void;
        update(arg0: string, arg1: (arg0: Internal.Dynamic<any>) => Internal.Dynamic<any>): Internal.Dynamic<T>;
        asIntStream(): Internal.IntStream;
        createByteList(arg0: Internal.ByteBuffer): Internal.Dynamic<any>;
        asByteBuffer(): Internal.ByteBuffer;
        asFloat(arg0: number): number;
        asLongStream(): Internal.LongStream;
        notify(): void;
        createBoolean(arg0: boolean): Internal.Dynamic<T>;
        remove(arg0: string): Internal.Dynamic<T>;
        asInt(arg0: number): number;
        into<V_>(arg0: (arg0: Internal.Dynamic<T>) => V_): V_;
        emptyList(): Internal.Dynamic<T>;
        asShort(arg0: number): number;
        hashCode(): number;
        get(arg0: string): Internal.OptionalDynamic<T>;
        emptyMap(): Internal.Dynamic<T>;
        createNumeric(arg0: Internal.Number): Internal.Dynamic<T>;
        map(arg0: (arg0: T) => T): Internal.Dynamic<T>;
        set(arg0: string, arg1: Internal.Dynamic<any>): Internal.Dynamic<T>;
        asNumber(): Internal.DataResult<Internal.Number>;
        asNumber(arg0: Internal.Number): Internal.Number;
        createMap(arg0: Internal.Map<Internal.Dynamic<any>, Internal.Dynamic<any>>): Internal.Dynamic<T>;
        castTyped<U_>(arg0: Internal.DynamicOps<U_>): Internal.Dynamic<U_>;
        createFloat(arg0: number): Internal.Dynamic<T>;
        getValue(): T;
        getOps(): Internal.DynamicOps<T>;
        getElement(arg0: string): Internal.DataResult<T>;
        getElement(arg0: string, arg1: T): T;
        equals(arg0: any): boolean;
        createInt(arg0: number): Internal.Dynamic<T>;
        toString(): string;
        get ops(): Internal.DynamicOps<T>;
        get mapValues(): Internal.DataResult<Internal.Map<Internal.Dynamic<T>, Internal.Dynamic<T>>>;
        get class(): Internal.Class<any>;
        get value(): T;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Double2FloatFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class Pose extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Pose;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Pose[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Pose): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Pose>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Pose>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SLEEPING : Internal.Pose;
        static readonly FALL_FLYING : Internal.Pose;
        static readonly LONG_JUMPING : Internal.Pose;
        static readonly DYING : Internal.Pose;
        static readonly CROUCHING : Internal.Pose;
        static readonly STANDING : Internal.Pose;
        static readonly SWIMMING : Internal.Pose;
        static readonly SPIN_ATTACK : Internal.Pose;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Pose>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IExtendedLootCondition extends Internal.LootItemCondition, Internal.ILootHandler {
        or(arg0: (arg0: Internal.LootContext) => boolean): (arg0: Internal.LootContext) => boolean;
        test(arg0: Internal.LootContext): boolean;
        and(arg0: (arg0: Internal.LootContext) => boolean): (arg0: Internal.LootContext) => boolean;
        negate(): (arg0: Internal.LootContext) => boolean;
    }
    abstract class GuiComponent {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PropertyChangeEvent extends Internal.EventObject {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setPropagationId(arg0: any): void;
        hashCode(): number;
        getSource(): any;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getPropagationId(): any;
        getOldValue(): any;
        getNewValue(): any;
        notify(): void;
        getPropertyName(): string;
        get newValue(): any;
        get propertyName(): string;
        get source(): any;
        get oldValue(): any;
        get class(): Internal.Class<any>;
        get propagationId(): any;
        set propagationId(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ModuleReference {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        location(): Internal.Optional<Internal.URI>;
        descriptor(): Internal.ModuleDescriptor;
        notify(): void;
        open(): Internal.ModuleReader;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Double2CharFunction extends it.unimi.dsi.fastutil.Function<number, string>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: number, arg1: string): string;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: string): string;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: string): string;
        remove(arg0: number): string;
        remove(arg0: any): string;
        remove(arg0: any): any;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): string;
        get(arg0: any): any;
        get(arg0: number): string;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): string;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => string;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface NonNullPredicate <T> {
        test(arg0: T): boolean;
    }
    class BlockLootEventJS extends Internal.LootEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        addSimpleBlock(blocks: BlockStatePredicate): void;
        addSimpleBlock(blocks: BlockStatePredicate, item: Internal.ItemStack): void;
        notifyAll(): void;
        modifyBlock(blocks: BlockStatePredicate, b: (arg0: Internal.LootBuilder) => void): void;
        addJson(id: ResourceLocation, json: Internal.JsonObject): void;
        notify(): void;
        modify(id: ResourceLocation, b: (arg0: Internal.LootBuilder) => void): void;
        removeAll(): void;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        build(blocks: BlockStatePredicate, b: (arg0: Internal.LootBuilder) => void): void;
        getType(): string;
        hashCode(): number;
        addBlock(blocks: BlockStatePredicate, b: (arg0: Internal.LootBuilder) => void): void;
        equals(arg0: any): boolean;
        toString(): string;
        getDirectory(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get type(): string;
        get class(): Internal.Class<any>;
        get directory(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MethodHandles$Lookup {
        getClass(): Internal.Class<any>;
        findStaticVarHandle(arg0: Internal.Class<any>, arg1: string, arg2: Internal.Class<any>): Internal.VarHandle;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        hasFullPrivilegeAccess(): boolean;
        findStaticGetter(arg0: Internal.Class<any>, arg1: string, arg2: Internal.Class<any>): Internal.MethodHandle;
        lookupClass(): Internal.Class<any>;
        defineHiddenClass(arg0: number[], arg1: boolean, arg2: any[]): Internal.MethodHandles$Lookup;
        notify(): void;
        unreflectSetter(arg0: Internal.Field): Internal.MethodHandle;
        findVirtual(arg0: Internal.Class<any>, arg1: string, arg2: Internal.MethodType): Internal.MethodHandle;
        findConstructor(arg0: Internal.Class<any>, arg1: Internal.MethodType): Internal.MethodHandle;
        dropLookupMode(arg0: number): Internal.MethodHandles$Lookup;
        findStaticSetter(arg0: Internal.Class<any>, arg1: string, arg2: Internal.Class<any>): Internal.MethodHandle;
        bind(arg0: any, arg1: string, arg2: Internal.MethodType): Internal.MethodHandle;
        hashCode(): number;
        findGetter(arg0: Internal.Class<any>, arg1: string, arg2: Internal.Class<any>): Internal.MethodHandle;
        hasPrivateAccess(): boolean;
        unreflectGetter(arg0: Internal.Field): Internal.MethodHandle;
        accessClass(arg0: Internal.Class<any>): Internal.Class<any>;
        findSpecial(arg0: Internal.Class<any>, arg1: string, arg2: Internal.MethodType, arg3: Internal.Class<any>): Internal.MethodHandle;
        in(arg0: Internal.Class<any>): Internal.MethodHandles$Lookup;
        defineClass(arg0: number[]): Internal.Class<any>;
        unreflectConstructor(arg0: Internal.Constructor<any>): Internal.MethodHandle;
        unreflectVarHandle(arg0: Internal.Field): Internal.VarHandle;
        findClass(arg0: string): Internal.Class<any>;
        defineHiddenClassWithClassData(arg0: number[], arg1: any, arg2: boolean, arg3: any[]): Internal.MethodHandles$Lookup;
        unreflectSpecial(arg0: Internal.Method, arg1: Internal.Class<any>): Internal.MethodHandle;
        lookupModes(): number;
        findStatic(arg0: Internal.Class<any>, arg1: string, arg2: Internal.MethodType): Internal.MethodHandle;
        ensureInitialized(arg0: Internal.Class<any>): Internal.Class<any>;
        unreflect(arg0: Internal.Method): Internal.MethodHandle;
        findVarHandle(arg0: Internal.Class<any>, arg1: string, arg2: Internal.Class<any>): Internal.VarHandle;
        findSetter(arg0: Internal.Class<any>, arg1: string, arg2: Internal.Class<any>): Internal.MethodHandle;
        equals(arg0: any): boolean;
        toString(): string;
        previousLookupClass(): Internal.Class<any>;
        revealDirect(arg0: Internal.MethodHandle): Internal.MethodHandleInfo;
        static readonly MODULE : 16;
        static readonly PACKAGE : 8;
        static readonly PUBLIC : 1;
        static readonly ORIGINAL : 64;
        static readonly UNCONDITIONAL : 32;
        static readonly PROTECTED : 4;
        static readonly PRIVATE : 2;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Frustum$Visibility extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(name: string): Internal.Frustum$Visibility;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Frustum$Visibility[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Frustum$Visibility): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Frustum$Visibility>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Frustum$Visibility>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly OUTSIDE : Internal.Frustum$Visibility;
        static readonly INTERSECT : Internal.Frustum$Visibility;
        static readonly INSIDE : Internal.Frustum$Visibility;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Frustum$Visibility>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Object2DoubleFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        applyAsDouble(arg0: K): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        getDouble(arg0: any): number;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_;
        put(arg0: K, arg1: number): number;
        put(arg0: K, arg1: number): number;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): any;
        remove(arg0: any): number;
        defaultReturnValue(arg0: number): void;
        defaultReturnValue(): number;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        get(arg0: any): number;
        get(arg0: any): any;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number;
        removeDouble(arg0: any): number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface MatrixWrite {
        flywheel$writeUnsafe(arg0: number): void;
        flywheel$write(arg0: Internal.VecBuffer): void;
    }
    class LivingEntityJS extends Internal.EntityJS {
        getLastAttackedEntity(): Internal.LivingEntityJS;
        setY(y: number): void;
        setX(x: number): void;
        isOnScoreboardTeam(teamID: string): boolean;
        isLiving(): boolean;
        isSprinting(): boolean;
        getItem(): Internal.ItemStackJS;
        getRevengeTarget(): Internal.LivingEntityJS;
        getTags(): Internal.Set<string>;
        getOffHandItem(): Internal.ItemStackJS;
        setGlowing(glowing: boolean): void;
        setZ(z: number): void;
        getHasCustomName(): boolean;
        setInvisible(invisible: boolean): void;
        runCommandSilent(command: string): number;
        getIdleTime(): number;
        getMovementSpeed(): number;
        getDistanceSq(x: number, y: number, z: number): number;
        getDistanceSq(pos: BlockPos): number;
        isBoss(): boolean;
        isGlowing(): boolean;
        getHorizontalFacing(): Internal.Direction;
        setLegsArmorItem(item: Internal.ItemStackJS): void;
        getHealth(): number;
        getServer(): Internal.ServerJS;
        setFeetArmorItem(item: Internal.ItemStackJS): void;
        setMaxHealth(hp: number): void;
        setMotion(x: number, y: number, z: number): void;
        getProfile(): Internal.GameProfile;
        setRotation(yaw: number, pitch: number): void;
        setAbsorptionAmount(amount: number): void;
        isOnSameTeam(e: Internal.EntityJS): boolean;
        isAnimal(): boolean;
        getDisplayName(): Internal.Text;
        getType(): string;
        setCustomNameAlwaysVisible(b: boolean): void;
        setOffHandItem(item: Internal.ItemStackJS): void;
        addMotion(x: number, y: number, z: number): void;
        isInvisible(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMaxHealth(): number;
        isUnderWater(): boolean;
        getHeldItem(hand: Hand): Internal.ItemStackJS;
        getEyeHeight(): number;
        getEquipment(slot: EquipmentSlot): Internal.ItemStackJS;
        notify(): void;
        getFallDistance(): number;
        damageHeldItem(hand: Hand, amount: number): void;
        damageHeldItem(hand: Hand, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void;
        damageHeldItem(): void;
        setOnFire(seconds: number): void;
        removePassengers(): void;
        attack(hp: number): void;
        attack(source: string, hp: number): void;
        isUndead(): boolean;
        isOnLadder(): boolean;
        playSound(id: Internal.SoundEvent): void;
        playSound(id: Internal.SoundEvent, volume: number, pitch: number): void;
        getDistance(x: number, y: number, z: number): number;
        getDistance(pos: BlockPos): number;
        setStatusMessage(message: Internal.Component): void;
        getLastDamageSource(): Internal.DamageSourceJS;
        isSwimming(): boolean;
        getReachDistance(): number;
        getCustomName(): Internal.Text;
        getStepHeight(): number;
        mergeFullNBT(tag: Internal.CompoundTag): Internal.EntityJS;
        kill(): void;
        getRidingEntity(): Internal.EntityJS;
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void;
        getLevel(): Internal.LevelJS;
        getPitch(): number;
        getPassengers(): Internal.EntityArrayList;
        getLastAttackedEntityTime(): number;
        isMonster(): boolean;
        equals(arg0: any): boolean;
        setPitch(pitch: number): void;
        isOnGround(): boolean;
        getFacing(): Internal.Direction;
        toString(): string;
        isSilent(): boolean;
        isPassenger(e: Internal.EntityJS): boolean;
        getClass(): Internal.Class<any>;
        getNbt(): Internal.CompoundTag;
        getRecursivePassengers(): Internal.EntityArrayList;
        setFallDistance(fallDistance: number): void;
        getName(): Internal.Text;
        getFeetArmorItem(): Internal.ItemStackJS;
        setCustomName(name: Internal.Component): void;
        setMainHandItem(item: Internal.ItemStackJS): void;
        setStepHeight(stepHeight: number): void;
        tell(message: Internal.Component): void;
        getTeamId(): string;
        isWaterCreature(): boolean;
        setNoClip(noClip: boolean): void;
        setPosition(x: number, y: number, z: number): void;
        setPosition(block: Internal.BlockContainerJS): void;
        extinguish(): void;
        setInvulnerable(invulnerable: boolean): void;
        setRevengeTarget(target: Internal.LivingEntityJS): void;
        setMovementSpeed(speed: number): void;
        isChild(): boolean;
        setEquipment(slot: EquipmentSlot, item: Internal.ItemStackJS): void;
        getLegsArmorItem(): Internal.ItemStackJS;
        setFullNBT(nbt: Internal.CompoundTag): void;
        getAttackingEntity(): Internal.LivingEntityJS;
        isHoldingInAnyHand(ingredient: any): boolean;
        getFullNBT(): Internal.CompoundTag;
        getNoClip(): boolean;
        setYaw(yaw: number): void;
        damageEquipment(slot: EquipmentSlot, amount: number): void;
        damageEquipment(slot: EquipmentSlot): void;
        damageEquipment(slot: EquipmentSlot, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void;
        getYaw(): number;
        isAlive(): boolean;
        getHeadArmorItem(): Internal.ItemStackJS;
        setNoGravity(noGravity: boolean): void;
        setHeldItem(hand: Hand, item: Internal.ItemStackJS): void;
        isPlayer(): boolean;
        getRevengeTimer(): number;
        getAbsorptionAmount(): number;
        isCrouching(): boolean;
        notifyAll(): void;
        getId(): Internal.UUID;
        getTicksExisted(): number;
        setSilent(isSilent: boolean): void;
        hashCode(): number;
        getChestArmorItem(): Internal.ItemStackJS;
        isFrame(): boolean;
        heal(hp: number): void;
        startRiding(e: Internal.EntityJS, force: boolean): boolean;
        runCommand(command: string): number;
        setChestArmorItem(item: Internal.ItemStackJS): void;
        getCustomNameAlwaysVisible(): boolean;
        getMainHandItem(): Internal.ItemStackJS;
        setHealth(hp: number): void;
        setMotionZ(z: number): void;
        setMotionY(y: number): void;
        getBlock(): Internal.BlockContainerJS;
        setMotionX(x: number): void;
        isElytraFlying(): boolean;
        isInWater(): boolean;
        dismountRidingEntity(): void;
        isSleeping(): boolean;
        isAmbientCreature(): boolean;
        swingArm(hand: Hand): void;
        getPotionEffects(): Internal.EntityPotionEffectsJS;
        rayTrace(): Internal.RayTraceResultJS;
        rayTrace(distance: number): Internal.RayTraceResultJS;
        isInvulnerable(): boolean;
        setHeadArmorItem(item: Internal.ItemStackJS): void;
        canEntityBeSeen(entity: Internal.LivingEntityJS): boolean;
        getX(): number;
        spawn(): void;
        getY(): number;
        getZ(): number;
        isPeacefulCreature(): boolean;
        getMotionZ(): number;
        getMotionX(): number;
        getMotionY(): number;
        getNoGravity(): boolean;
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        get invisible(): boolean;
        get customNameAlwaysVisible(): boolean;
        get movementSpeed(): number;
        get type(): string;
        get idleTime(): number;
        get legsArmorItem(): Internal.ItemStackJS;
        get revengeTarget(): Internal.LivingEntityJS;
        get hasCustomName(): boolean;
        get undead(): boolean;
        get lastAttackedEntity(): Internal.LivingEntityJS;
        get maxHealth(): number;
        get block(): Internal.BlockContainerJS;
        get pitch(): number;
        get id(): Internal.UUID;
        get potionEffects(): Internal.EntityPotionEffectsJS;
        get item(): Internal.ItemStackJS;
        get passengers(): Internal.EntityArrayList;
        get level(): Internal.LevelJS;
        get profile(): Internal.GameProfile;
        get onLadder(): boolean;
        get feetArmorItem(): Internal.ItemStackJS;
        get offHandItem(): Internal.ItemStackJS;
        get customName(): Internal.Text;
        get lastAttackedEntityTime(): number;
        get horizontalFacing(): Internal.Direction;
        get tags(): Internal.Set<string>;
        get sprinting(): boolean;
        get crouching(): boolean;
        get noGravity(): boolean;
        get fullNBT(): Internal.CompoundTag;
        get name(): Internal.Text;
        get animal(): boolean;
        get peacefulCreature(): boolean;
        get lastDamageSource(): Internal.DamageSourceJS;
        get stepHeight(): number;
        get child(): boolean;
        get frame(): boolean;
        get noClip(): boolean;
        get server(): Internal.ServerJS;
        get nbt(): Internal.CompoundTag;
        get boss(): boolean;
        get alive(): boolean;
        get ticksExisted(): number;
        get displayName(): Internal.Text;
        get fallDistance(): number;
        get revengeTimer(): number;
        get mainHandItem(): Internal.ItemStackJS;
        get facing(): Internal.Direction;
        get ambientCreature(): boolean;
        get elytraFlying(): boolean;
        get sleeping(): boolean;
        get swimming(): boolean;
        get waterCreature(): boolean;
        get invulnerable(): boolean;
        get eyeHeight(): number;
        get headArmorItem(): Internal.ItemStackJS;
        get underWater(): boolean;
        get class(): Internal.Class<any>;
        get reachDistance(): number;
        get player(): boolean;
        get absorptionAmount(): number;
        get motionZ(): number;
        get silent(): boolean;
        get living(): boolean;
        get motionY(): number;
        get motionX(): number;
        get ridingEntity(): Internal.EntityJS;
        get health(): number;
        get inWater(): boolean;
        get chestArmorItem(): Internal.ItemStackJS;
        get recursivePassengers(): Internal.EntityArrayList;
        get yaw(): number;
        get monster(): boolean;
        get attackingEntity(): Internal.LivingEntityJS;
        get glowing(): boolean;
        get onGround(): boolean;
        get teamId(): string;
        get x(): number;
        get y(): number;
        get z(): number;
        set noClip(noClip: boolean);
        set fallDistance(fallDistance: number);
        set mainHandItem(item: Internal.ItemStackJS);
        set invisible(invisible: boolean);
        set customNameAlwaysVisible(b: boolean);
        set movementSpeed(speed: number);
        set invulnerable(invulnerable: boolean);
        set legsArmorItem(item: Internal.ItemStackJS);
        set revengeTarget(target: Internal.LivingEntityJS);
        set maxHealth(hp: number);
        set headArmorItem(item: Internal.ItemStackJS);
        set pitch(pitch: number);
        set motionZ(z: number);
        set absorptionAmount(amount: number);
        set silent(isSilent: boolean);
        set motionY(y: number);
        set motionX(x: number);
        set health(hp: number);
        set feetArmorItem(item: Internal.ItemStackJS);
        set offHandItem(item: Internal.ItemStackJS);
        set chestArmorItem(item: Internal.ItemStackJS);
        set onFire(seconds: number);
        set yaw(yaw: number);
        set statusMessage(message: Internal.Component);
        set glowing(glowing: boolean);
        set noGravity(noGravity: boolean);
        set fullNBT(nbt: Internal.CompoundTag);
        set x(x: number);
        set y(y: number);
        set z(z: number);
        set position(block: Internal.BlockContainerJS);
        set stepHeight(stepHeight: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AtlasSet implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Wrapper {
        unwrap(): any;
    }
    interface Int2IntMap$Entry extends Internal.Map$Entry<number, number> {
        getIntKey(): number;
        getKey(): any;
        getKey(): number;
        getValue(): number;
        getValue(): any;
        hashCode(): number;
        getIntValue(): number;
        equals(arg0: any): boolean;
        setValue(arg0: any): any;
        setValue(arg0: number): number;
        setValue(arg0: number): number;
    }
    class AirBlock extends Internal.Block {
        rotate(arg0: Internal.BlockState, arg1: Internal.LevelAccessor, arg2: BlockPos, arg3: Internal.Rotation): Internal.BlockState;
        getClass(): Internal.Class<any>;
        getStateAtViewpoint(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Vec3): Internal.BlockState;
        onBlockExploded(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Explosion): void;
        getBedDirection(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): Internal.Direction;
        getTags(): Internal.Set<ResourceLocation>;
        isBed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean;
        canHarvestBlock(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Player): boolean;
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.BlockState): boolean;
        setMaterialKJS(arg0: net.minecraft.world.level.material.Material): void;
        isLadder(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockState, arg1: Internal.BlockAndTintGetter, arg2: BlockPos, arg3: Internal.FluidState): boolean;
        canStickTo(arg0: Internal.BlockState, arg1: Internal.BlockState): boolean;
        onNeighborChange(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): void;
        getWeakChanges(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): boolean;
        isBurning(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean;
        canEntityDestroy(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean;
        getFriction(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): number;
        isValidSpawn(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.SpawnPlacements$Type, arg4: Internal.EntityType<any>): boolean;
        isPortalFrame(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean;
        getExplosionResistance(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): number;
        getPathNodeType(state: Internal.BlockState): Internal.BlockPathTypes;
        isScaffolding(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean;
        setExplosionResistanceKJS(arg0: number): void;
        canSustainPlant(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.IPlantable): boolean;
        setJumpFactorKJS(arg0: number): void;
        canDropFromExplosion(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): boolean;
        getMaterial(): net.minecraft.world.level.material.Material;
        isStickyBlock(arg0: Internal.BlockState): boolean;
        setSoundTypeKJS(arg0: Internal.SoundType): void;
        isFertile(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean;
        getAiPathNodeType(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Mob): Internal.BlockPathTypes;
        getBlockBuilderKJS(): Internal.BlockBuilder;
        isSlimeBlock(arg0: Internal.BlockState): boolean;
        getRegistryType(): Internal.Class<Internal.Block>;
        getFireSpreadSpeed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number;
        getToolModifiedState(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Player, arg4: Internal.ItemStack, arg5: Internal.ToolAction): Internal.BlockState;
        getBeaconColorMultiplier(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): number[];
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getExpDrop(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: number, arg4: number): number;
        isConduitFrame(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): boolean;
        notifyAll(): void;
        getPathNodeTypeAsNeighbor(state: Internal.BlockState): Internal.BlockPathTypes;
        getLightEmission(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): number;
        onDestroyedByPlayer(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Player, arg4: boolean, arg5: Internal.FluidState): boolean;
        getId(): string;
        shouldCheckWeakPower(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean;
        collisionExtendsVertically(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean;
        notify(): void;
        addLandingEffects(arg0: Internal.BlockState, arg1: Internal.ServerLevel, arg2: BlockPos, arg3: Internal.BlockState, arg4: Internal.LivingEntity, arg5: number): boolean;
        getRenderPropertiesInternal(): any;
        getSoundType(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): Internal.SoundType;
        hashCode(): number;
        addRunningEffects(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Entity): boolean;
        initializeClient(arg0: (arg0: Internal.IBlockRenderProperties) => void): void;
        getCloneItemStack(arg0: Internal.BlockState, arg1: Internal.HitResult, arg2: Internal.BlockGetter, arg3: BlockPos, arg4: Internal.Player): Internal.ItemStack;
        setFrictionKJS(arg0: number): void;
        setHasCollisionKJS(arg0: boolean): void;
        getBlockStatesKJS(): Internal.List<Internal.BlockState>;
        isFlammable(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean;
        onCaughtFire(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.LivingEntity): void;
        getEnchantPowerBonus(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): number;
        getRegistryName(): ResourceLocation;
        setBedOccupied(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.LivingEntity, arg4: boolean): void;
        setRegistryName(arg0: string, arg1: string): Internal.Block;
        setRegistryName(arg0: ResourceLocation): any;
        setRegistryName(arg0: ResourceLocation): Internal.Block;
        setRegistryName(arg0: string): Internal.Block;
        isFireSource(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean;
        setIsRandomlyTickingKJS(arg0: boolean): void;
        getRespawnPosition(arg0: Internal.BlockState, arg1: Internal.EntityType<any>, arg2: Internal.LevelReader, arg3: BlockPos, arg4: number, arg5: Internal.LivingEntity): Internal.Optional<Vec3>;
        equals(arg0: any): boolean;
        canConnectRedstone(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean;
        setSpeedFactorKJS(arg0: number): void;
        setBlockBuilderKJS(b: Internal.BlockBuilder): void;
        toString(): string;
        getFlammability(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number;
        readonly delegate : () => Internal.Block;
        get registryType(): Internal.Class<Internal.Block>;
        get blockBuilderKJS(): Internal.BlockBuilder;
        get material(): net.minecraft.world.level.material.Material;
        get renderPropertiesInternal(): any;
        get blockStatesKJS(): Internal.List<Internal.BlockState>;
        get id(): string;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        set jumpFactorKJS(arg0: number);
        set isRandomlyTickingKJS(arg0: boolean);
        set blockBuilderKJS(b: Internal.BlockBuilder);
        set frictionKJS(arg0: number);
        set hasCollisionKJS(arg0: boolean);
        set materialKJS(arg0: net.minecraft.world.level.material.Material);
        set speedFactorKJS(arg0: number);
        set soundTypeKJS(arg0: Internal.SoundType);
        set explosionResistanceKJS(arg0: number);
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PoseStack implements Internal.TransformStack {
        rotate(arg0: number, arg1: (arg0: any) => boolean): Internal.TransformStack;
        rotate(arg0: Internal.Direction, arg1: number): Internal.TransformStack;
        getClass(): Internal.Class<any>;
        translateAll(arg0: number): Internal.TransformStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        scale(arg0: number, arg1: number, arg2: number): Internal.TransformStack;
        scale(arg0: number, arg1: number, arg2: number): any;
        scale(arg0: number): Internal.TransformStack;
        notify(): void;
        translate(arg0: number, arg1: number, arg2: number): any;
        translate(arg0: number, arg1: number, arg2: number): Internal.TransformStack;
        translate(arg0: Internal.Vector3f): Internal.TransformStack;
        translate(arg0: Vec3): Internal.TransformStack;
        translate(arg0: Vec3i): Internal.TransformStack;
        translateZ(arg0: number): Internal.TransformStack;
        mulNormal(arg0: Internal.Matrix3f): Internal.TransformStack;
        transform(arg0: Internal.Matrix4f, arg1: Internal.Matrix3f): Internal.TransformStack;
        transform(arg0: Internal.PoseStack): Internal.TransformStack;
        pushPose(): any;
        pushPose(): Internal.TransformStack;
        translateY(arg0: number): Internal.TransformStack;
        hashCode(): number;
        translateX(arg0: number): Internal.TransformStack;
        multiply(arg0: Internal.Quaternion): Internal.TransformStack;
        multiply(arg0: Internal.Quaternion): any;
        multiply(arg0: Internal.Vector3f, arg1: number): Internal.TransformStack;
        rotateX(arg0: number): Internal.TransformStack;
        rotateY(arg0: number): Internal.TransformStack;
        translateBack(arg0: Vec3i): Internal.TransformStack;
        translateBack(arg0: number, arg1: number, arg2: number): Internal.TransformStack;
        translateBack(arg0: Vec3): Internal.TransformStack;
        rotateZ(arg0: number): Internal.TransformStack;
        rotateToFace(arg0: Internal.Direction): Internal.TransformStack;
        nudge(arg0: number): Internal.TransformStack;
        rotateCentered(arg0: Internal.Direction, arg1: number): Internal.TransformStack;
        rotateCentered(arg0: Internal.Quaternion): Internal.TransformStack;
        centre(): Internal.TransformStack;
        multiplyRadians(arg0: Internal.Vector3f, arg1: number): Internal.TransformStack;
        rotateZRadians(arg0: number): Internal.TransformStack;
        mulPose(arg0: Internal.Matrix4f): Internal.TransformStack;
        rotateYRadians(arg0: number): Internal.TransformStack;
        rotateXRadians(arg0: number): Internal.TransformStack;
        popPose(): any;
        popPose(): Internal.TransformStack;
        equals(arg0: any): boolean;
        unCentre(): Internal.TransformStack;
        toString(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class HideREIEventJS <T> extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        getAllIngredients(): Internal.Collection<T>;
        notify(): void;
        hide(o: any): void;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        hideAll(): void;
        canCancel(): boolean;
        get allIngredients(): Internal.Collection<T>;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PlayMessages$SpawnEntity {
        static encode(arg0: Internal.PlayMessages$SpawnEntity, arg1: Internal.FriendlyByteBuf): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAdditionalData(): Internal.FriendlyByteBuf;
        notifyAll(): void;
        static handle(arg0: Internal.PlayMessages$SpawnEntity, arg1: () => Internal.NetworkEvent$Context): void;
        getEntity(): Internal.Entity;
        static decode(arg0: Internal.FriendlyByteBuf): Internal.PlayMessages$SpawnEntity;
        getHeadYaw(): number;
        getTypeId(): number;
        notify(): void;
        getYaw(): number;
        getPitch(): number;
        getVelY(): number;
        getVelZ(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        getUuid(): Internal.UUID;
        getVelX(): number;
        getPosZ(): number;
        toString(): string;
        getEntityId(): number;
        getPosX(): number;
        getPosY(): number;
        get headYaw(): number;
        get velZ(): number;
        get entityId(): number;
        get velY(): number;
        get velX(): number;
        get uuid(): Internal.UUID;
        get yaw(): number;
        get posX(): number;
        get posY(): number;
        get posZ(): number;
        get typeId(): number;
        get additionalData(): Internal.FriendlyByteBuf;
        get pitch(): number;
        get class(): Internal.Class<any>;
        get entity(): Internal.Entity;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class CharBuffer extends Internal.Buffer implements Internal.Comparable<Internal.CharBuffer>, Internal.Appendable, Internal.CharSequence, Internal.Readable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        compact(): Internal.CharBuffer;
        notifyAll(): void;
        compareTo(arg0: Internal.CharBuffer): number;
        compareTo(arg0: any): number;
        notify(): void;
        asReadOnlyBuffer(): Internal.CharBuffer;
        put(arg0: Internal.CharBuffer): Internal.CharBuffer;
        put(arg0: string, arg1: number, arg2: number): Internal.CharBuffer;
        put(arg0: number, arg1: string[]): Internal.CharBuffer;
        put(arg0: number, arg1: string): Internal.CharBuffer;
        put(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.CharBuffer;
        put(arg0: string[]): Internal.CharBuffer;
        put(arg0: string[], arg1: number, arg2: number): Internal.CharBuffer;
        put(arg0: number, arg1: Internal.CharBuffer, arg2: number, arg3: number): Internal.CharBuffer;
        put(arg0: string): Internal.CharBuffer;
        put(arg0: string): Internal.CharBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        slice(): Internal.CharBuffer;
        slice(): Internal.Buffer;
        slice(arg0: number, arg1: number): Internal.CharBuffer;
        slice(arg0: number, arg1: number): Internal.Buffer;
        array(): string[];
        array(): any;
        hashCode(): number;
        get(): string;
        get(arg0: number): string;
        get(arg0: string[], arg1: number, arg2: number): Internal.CharBuffer;
        get(arg0: string[]): Internal.CharBuffer;
        get(arg0: number, arg1: string[]): Internal.CharBuffer;
        get(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.CharBuffer;
        limit(arg0: number): Internal.CharBuffer;
        limit(arg0: number): Internal.Buffer;
        limit(): number;
        arrayOffset(): number;
        flip(): Internal.CharBuffer;
        flip(): Internal.Buffer;
        codePoints(): Internal.IntStream;
        order(): Internal.ByteOrder;
        hasArray(): boolean;
        read(arg0: Internal.CharBuffer): number;
        hasRemaining(): boolean;
        isEmpty(): boolean;
        clear(): Internal.CharBuffer;
        clear(): Internal.Buffer;
        length(): number;
        duplicate(): Internal.CharBuffer;
        duplicate(): Internal.Buffer;
        subSequence(arg0: number, arg1: number): Internal.CharSequence;
        subSequence(arg0: number, arg1: number): Internal.CharBuffer;
        remaining(): number;
        static allocate(arg0: number): Internal.CharBuffer;
        rewind(): Internal.Buffer;
        rewind(): Internal.CharBuffer;
        mismatch(arg0: Internal.CharBuffer): number;
        equals(arg0: any): boolean;
        reset(): Internal.CharBuffer;
        reset(): Internal.Buffer;
        toString(): string;
        position(arg0: number): Internal.Buffer;
        position(arg0: number): Internal.CharBuffer;
        position(): number;
        isDirect(): boolean;
        static wrap(arg0: string[], arg1: number, arg2: number): Internal.CharBuffer;
        static wrap(arg0: string[]): Internal.CharBuffer;
        static wrap(arg0: Internal.CharSequence): Internal.CharBuffer;
        static wrap(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.CharBuffer;
        mark(): Internal.Buffer;
        mark(): Internal.CharBuffer;
        chars(): Internal.IntStream;
        charAt(arg0: number): string;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.CharBuffer;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable;
        append(arg0: Internal.CharSequence): Internal.Appendable;
        append(arg0: Internal.CharSequence): Internal.CharBuffer;
        append(arg0: string): Internal.CharBuffer;
        append(arg0: string): Internal.Appendable;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MovingListener extends Internal.LightListener {
        getVolume(): Internal.ImmutableBox;
        onLightUpdate(arg0: Internal.LightProvider, arg1: Internal.LightLayer, arg2: Internal.ImmutableBox): void;
        onLightPacket(arg0: Internal.LightProvider, arg1: number, arg2: number): void;
        update(arg0: Internal.LightProvider): boolean;
        status(): Internal.ListenerStatus;
    }
    interface ChannelOutboundBuffer$MessageProcessor {
        processMessage(arg0: any): boolean;
    }
    class DataResult$Mu implements Internal.K1 {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CrusherRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        energy(e: number): Internal.IERecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        time(t: number): Internal.IERecipeJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<net.minecraftforge.fluids.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Reference2ShortFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        removeShort(arg0: any): number;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_;
        put(arg0: K, arg1: number): number;
        put(arg0: K, arg1: number): number;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): any;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        get(arg0: any): number;
        get(arg0: any): any;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: K): number;
        apply(arg0: K): number;
        getShort(arg0: any): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class LocalPlayer extends Internal.AbstractClientPlayer {
        handler$zdn000$onIsScoping(arg0: Internal.CallbackInfoReturnable<any>): void;
        canBeRiddenInWater(arg0: Internal.Entity): boolean;
        handler$zzo000$tickHead(arg0: Internal.CallbackInfo): void;
        setCitadelEntityData(arg0: Internal.CompoundTag): void;
        getCachedFeetBlockState(): Internal.BlockState;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        handler$bfj000$tryShortcutFluidPushing(tag: net.minecraft.tags.Tag<any>, speed: number, cir: Internal.CallbackInfoReturnable<any>, box: Internal.AABB, x1: number, x2: number, y1: number, y2: number, z1: number, z2: number, zero: number): void;
        revive(): void;
        static getDataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        getEndimatedState(): Internal.Endimatable$EndimatedState;
        getSuffixes(): Internal.Collection<Internal.MutableComponent>;
        resetEndimation(): void;
        reviveCaps(): void;
        handler$zfk000$diet$constructPlayer(arg0: Internal.CallbackInfo): void;
        handler$zbc000$locateAmmo(arg0: Internal.ItemStack, arg1: Internal.CallbackInfoReturnable<any>, arg2: (arg0: any) => boolean): void;
        getEffectHandler(): Internal.EndimationEffectHandler;
        getPrefixes(): Internal.Collection<Internal.MutableComponent>;
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        getListener(): Internal.NearbyEntityListenerMulti;
        isNoEndimationPlaying(): boolean;
        handler$zdk000$onGetFieldOfViewModifier(arg0: Internal.CallbackInfoReturnable<any>): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notify(): void;
        handler$zzo000$moveStep(arg0: Internal.MoverType, arg1: Vec3, arg2: Internal.CallbackInfo): void;
        getEntityChangeListener(): Internal.EntityInLevelCallback;
        isDirty(): boolean;
        getLastPos(): BlockPos;
        addListener(listener: Internal.NearbyEntityListener): void;
        curePotionEffects(arg0: Internal.ItemStack): boolean;
        getPlayingEndimation(): Internal.PlayableEndimation;
        getDirtyEntries(): Internal.Set<any>;
        shouldRiderFaceForward(arg0: Internal.Player): boolean;
        setPlayingEndimation(arg0: Internal.PlayableEndimation): void;
        equals(arg0: any): boolean;
        toString(): string;
        handler$zdm000$onIsUsingItem(arg0: Internal.CallbackInfoReturnable<any>): void;
        refreshDisplayName(): void;
        getForcedPose(): Internal.Pose;
        getClass(): Internal.Class<any>;
        backpackedMoved(): boolean;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>;
        handler$zje000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void;
        handler$zbc000$onFallFlying(arg0: number, arg1: number, arg2: number, arg3: Internal.CallbackInfo): void;
        onEndimationEnd(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        isEndimationPlaying(arg0: Internal.PlayableEndimation): boolean;
        isActive(): boolean;
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void;
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity;
        getPos(): Internal.Position;
        foodEatenKJS(is: Internal.ItemStack): void;
        getDigSpeed(arg0: Internal.BlockState, arg1: BlockPos): number;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(arg0: boolean): void;
        canUpdate(): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean;
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number;
        lithiumOnBlockCacheDeleted(): void;
        setForcedPose(arg0: Internal.Pose): void;
        canRiderInteract(): boolean;
        getEntries(arg0: boolean): Internal.Set<any>;
        onAddedToWorld(): void;
        setAnimationTick(arg0: number): void;
        static getDataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        getClassification(arg0: boolean): Internal.MobCategory;
        onEndimationStart(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listenForCachedBlockChanges: boolean): void;
        shouldRiderSit(): boolean;
        getIsInsidePortal(): boolean;
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack;
        handler$zje000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        handler$zcg000$read(arg0: Internal.CompoundTag, arg1: Internal.CallbackInfo): void;
        getRemainingFireTicks(): number;
        lithiumOnEquipmentChanged(): void;
        getStagesRawKJS(): Internal.Stages;
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void;
        getDataMap(): Internal.Map<any, any>;
        getStages(): Internal.Stages;
        endimateTick(): void;
        setDataMap(arg0: Internal.Map<any, any>): void;
        hashCode(): number;
        updateSyncFields(arg0: Internal.LocalPlayer): void;
        isAddedToWorld(): boolean;
        getParts(): any[];
        onRemovedFromWorld(): void;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        clean(): void;
        asKJS(): any;
        handler$ccm000$noSwimmingWithHeavyBootsOn(arg0: Internal.CallbackInfoReturnable<any>): void;
        getValue(arg0: Internal.TrackedData<any>): any;
        setValue(arg0: Internal.TrackedData<any>, arg1: any): void;
        getAnimationTick(): number;
        setRemainingFireTicks(arg0: number): void;
        handler$zgd001$tick(arg0: Internal.CallbackInfo): void;
        getBackpackedInventory(): Internal.BackpackInventory;
        backpackedInventory : Internal.BackpackInventory;
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
        get suffixes(): Internal.Collection<Internal.MutableComponent>;
        get citadelEntityData(): Internal.CompoundTag;
        get listener(): Internal.NearbyEntityListenerMulti;
        get stagesRawKJS(): Internal.Stages;
        get addedToWorld(): boolean;
        get animationTick(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get pos(): Internal.Position;
        get dataMap(): Internal.Map<any, any>;
        get noEndimationPlaying(): boolean;
        get class(): Internal.Class<any>;
        get dirty(): boolean;
        get dataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        get isInsidePortal(): boolean;
        get entityChangeListener(): Internal.EntityInLevelCallback;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get multipartEntity(): boolean;
        get playingEndimation(): Internal.PlayableEndimation;
        get active(): boolean;
        get effectHandler(): Internal.EndimationEffectHandler;
        get cachedFeetBlockState(): Internal.BlockState;
        get lastPos(): BlockPos;
        get dirtyEntries(): Internal.Set<any>;
        get dataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        get prefixes(): Internal.Collection<Internal.MutableComponent>;
        get forcedPose(): Internal.Pose;
        get stages(): Internal.Stages;
        get parts(): any[];
        get endimatedState(): Internal.Endimatable$EndimatedState;
        set animationTick(arg0: number);
        set forcedPose(arg0: Internal.Pose);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set dataMap(arg0: Internal.Map<any, any>);
        set playingEndimation(arg0: Internal.PlayableEndimation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Thread implements Internal.Runnable {
        setName(arg0: string): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getThreadGroup(): Internal.ThreadGroup;
        getName(): string;
        static getAllStackTraces(): Internal.Map<Internal.Thread, Internal.StackTraceElement[]>;
        notifyAll(): void;
        static onSpinWait(): void;
        getId(): number;
        run(): void;
        notify(): void;
        setContextClassLoader(arg0: Internal.ClassLoader): void;
        static sleep(arg0: number): void;
        static sleep(arg0: number, arg1: number): void;
        getStackTrace(): Internal.StackTraceElement[];
        hashCode(): number;
        isDaemon(): boolean;
        static yield(): void;
        interrupt(): void;
        static enumerate(arg0: Internal.Thread[]): number;
        join(): void;
        join(arg0: number, arg1: number): void;
        join(arg0: number): void;
        suspend(): void;
        static activeCount(): number;
        resume(): void;
        static currentThread(): Internal.Thread;
        setUncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler): void;
        isInterrupted(): boolean;
        static dumpStack(): void;
        static setDefaultUncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler): void;
        start(): void;
        static interrupted(): boolean;
        getUncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler;
        checkAccess(): void;
        static getDefaultUncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler;
        isAlive(): boolean;
        setDaemon(arg0: boolean): void;
        static holdsLock(arg0: any): boolean;
        getState(): Internal.Thread$State;
        stop(): void;
        getContextClassLoader(): Internal.ClassLoader;
        equals(arg0: any): boolean;
        getPriority(): number;
        countStackFrames(): number;
        toString(): string;
        setPriority(arg0: number): void;
        static readonly MIN_PRIORITY : 1;
        static readonly MAX_PRIORITY : 10;
        static readonly NORM_PRIORITY : 5;
        get allStackTraces(): Internal.Map<Internal.Thread, Internal.StackTraceElement[]>;
        get alive(): boolean;
        get priority(): number;
        get uncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler;
        get daemon(): boolean;
        get defaultUncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler;
        get threadGroup(): Internal.ThreadGroup;
        get contextClassLoader(): Internal.ClassLoader;
        get name(): string;
        get id(): number;
        get stackTrace(): Internal.StackTraceElement[];
        get state(): Internal.Thread$State;
        get class(): Internal.Class<any>;
        set defaultUncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler);
        set contextClassLoader(arg0: Internal.ClassLoader);
        set name(arg0: string);
        set priority(arg0: number);
        set uncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler);
        set daemon(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Pair <F, S> implements Internal.App<Internal.Pair$Mu<S>, F> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        swap(): Internal.Pair<S, Internal.Pair$Mu<S>>;
        notifyAll(): void;
        notify(): void;
        mapFirst<F2_>(arg0: (arg0: Internal.Pair$Mu<S>) => F2_): Internal.Pair<F2_, S>;
        static unbox<F_, S_>(arg0: Internal.App<Internal.Pair$Mu<S_>, F_>): Internal.Pair<F_, S_>;
        getFirst(): Internal.Pair$Mu<S>;
        hashCode(): number;
        static toMap<F_, S_>(): Internal.Collector<Internal.Pair<F_, S_>, any, Internal.Map<F_, S_>>;
        static of<F_, S_>(arg0: F_, arg1: S_): Internal.Pair<F_, S_>;
        equals(arg0: any): boolean;
        getSecond(): S;
        toString(): string;
        mapSecond<S2_>(arg0: (arg0: S) => S2_): Internal.Pair<Internal.Pair$Mu<S>, S2_>;
        get class(): Internal.Class<any>;
        get first(): Internal.Pair$Mu<S>;
        get second(): S;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LunarTextComponents {
        getSetNotification(): Internal.LunarTextComponents$Notification;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): Internal.CustomTranslationTextComponent;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        getRiseNotification(): Internal.LunarTextComponents$Notification;
        static readonly CODEC : Internal.Codec<Internal.LunarTextComponents>;
        static readonly LEGACY_CODEC : Internal.Codec<Internal.LunarTextComponents>;
        get name(): Internal.CustomTranslationTextComponent;
        get riseNotification(): Internal.LunarTextComponents$Notification;
        get setNotification(): Internal.LunarTextComponents$Notification;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface SetMultimap <K, V> extends Internal.Multimap<K, V> {
        containsEntry(arg0: any, arg1: any): boolean;
        keys(): Internal.Multiset<K>;
        containsKey(arg0: any): boolean;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        asMap(): Internal.Map<K, Internal.Collection<V>>;
        values(): Internal.Collection<V>;
        isEmpty(): boolean;
        clear(): void;
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.Set<V>;
        replaceValues(arg0: any, arg1: Internal.Iterable<any>): Internal.Collection<any>;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): boolean;
        remove(arg0: any, arg1: any): boolean;
        removeAll(arg0: any): Internal.Set<V>;
        removeAll(arg0: any): Internal.Collection<any>;
        entries(): Internal.Collection<any>;
        entries(): Internal.Set<Internal.Map$Entry<K, V>>;
        size(): number;
        hashCode(): number;
        putAll(arg0: Internal.Multimap<K, V>): boolean;
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean;
        equals(arg0: any): boolean;
        get(arg0: K): Internal.Set<V>;
        get(arg0: any): Internal.Collection<any>;
        keySet(): Internal.Set<K>;
    }
    class Matcher implements Internal.MatchResult {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hasTransparentBounds(): boolean;
        requireEnd(): boolean;
        notifyAll(): void;
        useTransparentBounds(arg0: boolean): Internal.Matcher;
        pattern(): Internal.Pattern;
        replaceFirst(arg0: string): string;
        replaceFirst(arg0: (arg0: Internal.MatchResult) => string): string;
        regionStart(): number;
        replaceAll(arg0: (arg0: Internal.MatchResult) => string): string;
        replaceAll(arg0: string): string;
        notify(): void;
        lookingAt(): boolean;
        toMatchResult(): Internal.MatchResult;
        static quoteReplacement(arg0: string): string;
        hashCode(): number;
        find(): boolean;
        find(arg0: number): boolean;
        end(arg0: string): number;
        end(arg0: number): number;
        end(): number;
        results(): Internal.Stream<Internal.MatchResult>;
        group(arg0: string): string;
        group(arg0: number): string;
        group(): string;
        start(arg0: number): number;
        start(): number;
        start(arg0: string): number;
        regionEnd(): number;
        matches(): boolean;
        hasAnchoringBounds(): boolean;
        appendReplacement(arg0: Internal.StringBuffer, arg1: string): Internal.Matcher;
        appendReplacement(arg0: Internal.StringBuilder, arg1: string): Internal.Matcher;
        appendTail(arg0: Internal.StringBuffer): Internal.StringBuffer;
        appendTail(arg0: Internal.StringBuilder): Internal.StringBuilder;
        groupCount(): number;
        equals(arg0: any): boolean;
        reset(): Internal.Matcher;
        reset(arg0: Internal.CharSequence): Internal.Matcher;
        toString(): string;
        region(arg0: number, arg1: number): Internal.Matcher;
        useAnchoringBounds(arg0: boolean): Internal.Matcher;
        hitEnd(): boolean;
        usePattern(arg0: Internal.Pattern): Internal.Matcher;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class GameProfile {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        isLegacy(): boolean;
        hashCode(): number;
        notifyAll(): void;
        getProperties(): Internal.PropertyMap;
        equals(arg0: any): boolean;
        getId(): Internal.UUID;
        toString(): string;
        notify(): void;
        isComplete(): boolean;
        get legacy(): boolean;
        get name(): string;
        get id(): Internal.UUID;
        get complete(): boolean;
        get class(): Internal.Class<any>;
        get properties(): Internal.PropertyMap;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeRegistry <V> extends Internal.Iterable<V> {
        getKey(arg0: V): ResourceLocation;
        getCodec(): Internal.Codec<V>;
        getValues(): Internal.Collection<V>;
        spliterator(): Internal.Spliterator<V>;
        forEach(arg0: (arg0: V) => void): void;
        registerAll(arg0: V[]): void;
        containsKey(arg0: ResourceLocation): boolean;
        getDefaultKey(): ResourceLocation;
        isEmpty(): boolean;
        getRegistryName(): ResourceLocation;
        getRegistrySuperType(): Internal.Class<V>;
        getKeys(): Internal.Set<ResourceLocation>;
        getSlaveMap<T_>(arg0: ResourceLocation, arg1: Internal.Class<T_>): T_;
        containsValue(arg0: V): boolean;
        getResourceKey(arg0: V): Internal.Optional<Internal.ResourceKey<V>>;
        getValue(arg0: ResourceLocation): V;
        iterator(): Internal.Iterator<V>;
        getEntries(): Internal.Set<Internal.Map$Entry<Internal.ResourceKey<V>, V>>;
        register(arg0: V): void;
    }
    interface CustomIngredientActionCallback {
        transform(arg0: Internal.ItemStackJS, arg1: number, arg2: Internal.InventoryJS): any;
    }
    interface ICapabilityProvider {
        getCapability<T>(arg0: Internal.Capability<T>, arg1: Internal.Direction): Internal.LazyOptional<T>;
        getCapability<T>(arg0: Internal.Capability<T>): Internal.LazyOptional<T>;
    }
    interface IntCollection extends Internal.Collection<number>, Internal.IntIterable {
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
        remove(arg0: any): boolean;
        intStream(): Internal.IntStream;
        removeAll(arg0: Internal.IntCollection): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.IntIterator;
        iterator(): Internal.Iterator<any>;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toIntArray(arg0: number[]): number[];
        toIntArray(): number[];
        toArray(arg0: number[]): number[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        add(arg0: number): boolean;
        add(arg0: any): boolean;
        spliterator(): Internal.Spliterator<any>;
        spliterator(): Internal.IntSpliterator;
        forEach(arg0: (arg0: number) => void): void;
        forEach(arg0: java_.util.function_.IntConsumer): void;
        forEach(arg0: (arg0: any) => void): void;
        containsAll(arg0: Internal.IntCollection): boolean;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        removeIf(arg0: (arg0: number) => boolean): boolean;
        removeIf(arg0: Internal.IntPredicate): boolean;
        removeIf(arg0: (arg0: any) => boolean): boolean;
        contains(arg0: any): boolean;
        contains(arg0: number): boolean;
        size(): number;
        addAll(arg0: Internal.IntCollection): boolean;
        addAll(arg0: Internal.Collection<number>): boolean;
        equals(arg0: any): boolean;
        intParallelStream(): Internal.IntStream;
        retainAll(arg0: Internal.IntCollection): boolean;
        retainAll(arg0: Internal.Collection<any>): boolean;
    }
    class NativeContinuation extends Internal.IdScriptableObject implements dev.latvian.mods.rhino.Function {
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        setParentScope(m: Internal.Scriptable): void;
        static redefineProperty(obj: Internal.Scriptable, name: string, isConst: boolean): void;
        putConst(name: string, start: Internal.Scriptable, value: any): void;
        static getTypedProperty<T_>(s: Internal.Scriptable, index: number, type: Internal.Class<T_>): T_;
        static getTypedProperty<T_>(s: Internal.Scriptable, name: string, type: Internal.Class<T_>): T_;
        getIds(): any[];
        static getArrayPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        construct(cx: Internal.Context, scope: Internal.Scriptable, args: any[]): Internal.Scriptable;
        getAllIds(): any[];
        put(key: Internal.Symbol, start: Internal.Scriptable, value: any): void;
        put(name: string, start: Internal.Scriptable, value: any): void;
        put(index: number, start: Internal.Scriptable, value: any): void;
        getDefaultValue(typeHint: Internal.Class<any>): any;
        static getDefaultValue(object: Internal.Scriptable, typeHint: Internal.Class<any>): any;
        defineOwnProperties(cx: Internal.Context, props: Internal.ScriptableObject): void;
        defineProperty(propertyName: string, clazz: Internal.Class<any>, attributes: number): void;
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method, setter: Internal.Method, attributes: number): void;
        defineProperty(propertyName: string, value: any, attributes: number): void;
        defineProperty(key: Internal.Symbol, value: any, attributes: number): void;
        static defineProperty(destination: Internal.Scriptable, propertyName: string, value: any, attributes: number): void;
        hasPrototypeMap(): boolean;
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable, isSetter: boolean): void;
        avoidObjectDetection(): boolean;
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean;
        has(name: string, start: Internal.Scriptable): boolean;
        has(index: number, start: Internal.Scriptable): boolean;
        getExternalArrayLength(): any;
        static init(cx: Internal.Context, scope: Internal.Scriptable, sealed: boolean): void;
        getAttributes(name: string): number;
        getAttributes(key: Internal.Symbol): number;
        getAttributes(index: number): number;
        hasInstance(instance: Internal.Scriptable): boolean;
        getAssociatedValue(key: any): any;
        execIdCall(f: Internal.IdFunctionObject, cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any;
        static getPropertyIds(obj: Internal.Scriptable): any[];
        static hasProperty(obj: Internal.Scriptable, index: number): boolean;
        static hasProperty(obj: Internal.Scriptable, name: string): boolean;
        static hasProperty(obj: Internal.Scriptable, key: Internal.Symbol): boolean;
        getExternalArrayData(): Internal.ExternalArrayData;
        size(): number;
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol, functionName: string, arity: number): Internal.IdFunctionObject;
        defineOwnProperty(cx: Internal.Context, key: any, desc: Internal.ScriptableObject): void;
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void;
        initPrototypeValue(id: number, key: Internal.Symbol, value: any, attributes: number): void;
        static equalImplementations(c1: Internal.NativeContinuation, c2: Internal.NativeContinuation): boolean;
        static getFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        preventExtensions(): void;
        setExternalArrayData(array: Internal.ExternalArrayData): void;
        static callMethod(obj: Internal.Scriptable, methodName: string, args: any[]): any;
        static callMethod(cx: Internal.Context, obj: Internal.Scriptable, methodName: string, args: any[]): any;
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        getTypeOf(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getTopScopeValue(scope: Internal.Scriptable, key: any): any;
        initPrototypeConstructor(f: Internal.IdFunctionObject): void;
        getImplementation(): any;
        notifyAll(): void;
        sealObject(): void;
        setAttributes(name: string, attributes: number): void;
        setAttributes(index: number, attributes: number): void;
        setAttributes(key: Internal.Symbol, attributes: number): void;
        static putProperty(obj: Internal.Scriptable, index: number, value: any): void;
        static putProperty(obj: Internal.Scriptable, key: Internal.Symbol, value: any): void;
        static putProperty(obj: Internal.Scriptable, name: string, value: any): void;
        delete(key: Internal.Symbol): void;
        delete(name: string): void;
        delete(index: number): void;
        initImplementation(implementation: any): void;
        notify(): void;
        associateValue(key: any, value: any): any;
        static deleteProperty(obj: Internal.Scriptable, name: string): boolean;
        static deleteProperty(obj: Internal.Scriptable, index: number): boolean;
        getPrototype(): Internal.Scriptable;
        static getObjectPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        isExtensible(): boolean;
        hashCode(): number;
        isConst(name: string): boolean;
        get(name: string, start: Internal.Scriptable): any;
        get(key: Internal.Symbol, start: Internal.Scriptable): any;
        get(index: number, start: Internal.Scriptable): any;
        get(key: any): any;
        static putConstProperty(obj: Internal.Scriptable, name: string, value: any): void;
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any;
        static getTopLevelScope(obj: Internal.Scriptable): Internal.Scriptable;
        static getProperty(obj: Internal.Scriptable, name: string): any;
        static getProperty(obj: Internal.Scriptable, key: Internal.Symbol): any;
        static getProperty(obj: Internal.Scriptable, index: number): any;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean): void;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>): void;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean, mapInheritance: boolean): string;
        activatePrototypeMap(maxPrototypeId: number): void;
        isEmpty(): boolean;
        defineFunctionProperties(names: string[], clazz: Internal.Class<any>, attributes: number): void;
        static getClassPrototype(scope: Internal.Scriptable, className: string): Internal.Scriptable;
        setPrototype(m: Internal.Scriptable): void;
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable, sealed: boolean): Internal.IdFunctionObject;
        call(cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any;
        defineConst(name: string, start: Internal.Scriptable): void;
        equals(arg0: any): boolean;
        static defineConstProperty(destination: Internal.Scriptable, propertyName: string): void;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        static isContinuationConstructor(f: Internal.IdFunctionObject): boolean;
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get implementation(): any;
        get className(): string;
        get prototype(): Internal.Scriptable;
        get empty(): boolean;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get externalArrayLength(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get extensible(): boolean;
        get typeOf(): string;
        set externalArrayData(array: Internal.ExternalArrayData);
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Member {
        getDeclaringClass(): Internal.Class<any>;
        getName(): string;
        isSynthetic(): boolean;
        getModifiers(): number;
    }
    interface UnaryOperator <T> extends Internal.Function<T, T> {
        compose<V_>(arg0: (arg0: V_) => T): (arg0: V_) => T;
        apply(arg0: T): T;
        andThen<V_>(arg0: (arg0: T) => V_): (arg0: T) => V_;
    }
    class ItemBuilder extends Internal.BuilderBase {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        maxStackSize(v: number): Internal.ItemBuilder;
        translationKey(key: string): Internal.BuilderBase;
        color(index: number, c: number): Internal.ItemBuilder;
        getBuilderType(): string;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase;
        notifyAll(): void;
        maxDamage(v: number): Internal.ItemBuilder;
        tooltip(text: Internal.Component): Internal.ItemBuilder;
        containerItem(id: string): Internal.ItemBuilder;
        type(t: Internal.ItemType): Internal.ItemBuilder;
        notify(): void;
        subtypes(fn: (arg0: Internal.ItemStackJS) => Internal.Collection<Internal.ItemStackJS>): Internal.ItemBuilder;
        tier(t: string): Internal.ItemBuilder;
        hashCode(): number;
        getAttackSpeed(): number;
        burnTime(v: number): Internal.ItemBuilder;
        tag(tag: ResourceLocation): Internal.BuilderBase;
        parentModel(m: string): Internal.ItemBuilder;
        attackDamage(f: number): Internal.ItemBuilder;
        group(g: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        getMiningSpeed(): number;
        miningSpeed(f: number): Internal.ItemBuilder;
        food(b: (arg0: Internal.FoodBuilder) => void): Internal.ItemBuilder;
        unstackable(): Internal.ItemBuilder;
        getAttackDamage(): number;
        equals(arg0: any): boolean;
        attackSpeed(f: number): Internal.ItemBuilder;
        toString(): string;
        glow(v: boolean): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        rarity(v: Rarity): Internal.ItemBuilder;
        toolTier : Internal.Tier;
        foodBuilder : Internal.FoodBuilder;
        defaultTags : Internal.Set<ResourceLocation>;
        armorTier : Internal.ArmorMaterial;
        modelJson : Internal.JsonObject;
        static readonly ARMOR_TIERS : Internal.Map<string, Internal.ArmorMaterial>;
        readonly id : ResourceLocation;
        item : Internal.Item;
        attackSpeedBaseline : number;
        static readonly TOOL_TIERS : Internal.Map<string, Internal.Tier>;
        attackDamageBaseline : number;
        get builderType(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class URLStreamHandler {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Callable {
        call(arg0: Internal.Context, arg1: Internal.Scriptable, arg2: Internal.Scriptable, arg3: any[]): any;
    }
    interface LevelChunk$PostLoadProcessor {
    }
    class Camera implements Internal.CameraInvokerMixin {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setAnglesInternal(arg0: number, arg1: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        callMove(arg0: number, arg1: number, arg2: number): void;
        getBlockAtCamera(): Internal.BlockState;
        notify(): void;
        get blockAtCamera(): Internal.BlockState;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Short2IntFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface IntStream extends Internal.BaseStream<number, Internal.IntStream> {
        average(): Internal.OptionalDouble;
        sequential(): Internal.BaseStream<any, any>;
        sequential(): Internal.IntStream;
        takeWhile(arg0: Internal.IntPredicate): Internal.IntStream;
        distinct(): Internal.IntStream;
        findFirst(): Internal.OptionalInt;
        sum(): number;
        skip(arg0: number): Internal.IntStream;
        asLongStream(): Internal.LongStream;
        allMatch(arg0: Internal.IntPredicate): boolean;
        mapToObj<U_>(arg0: Internal.IntFunction<U_>): Internal.Stream<U_>;
        mapMulti(arg0: Internal.IntStream$IntMapMultiConsumer): Internal.IntStream;
        iterator(): Internal.Iterator<any>;
        iterator(): Internal.PrimitiveIterator$OfInt;
        asDoubleStream(): Internal.DoubleStream;
        min(): Internal.OptionalInt;
        mapToLong(arg0: Internal.IntToLongFunction): Internal.LongStream;
        parallel(): Internal.IntStream;
        parallel(): Internal.BaseStream<any, any>;
        noneMatch(arg0: Internal.IntPredicate): boolean;
        findAny(): Internal.OptionalInt;
        isParallel(): boolean;
        limit(arg0: number): Internal.IntStream;
        toArray(): number[];
        forEachOrdered(arg0: java_.util.function_.IntConsumer): void;
        close(): void;
        anyMatch(arg0: Internal.IntPredicate): boolean;
        map(arg0: Internal.IntUnaryOperator): Internal.IntStream;
        mapToDouble(arg0: Internal.IntToDoubleFunction): Internal.DoubleStream;
        unordered(): Internal.IntStream;
        reduce(arg0: number, arg1: Internal.IntBinaryOperator): number;
        reduce(arg0: Internal.IntBinaryOperator): Internal.OptionalInt;
        spliterator(): Internal.Spliterator$OfInt;
        spliterator(): Internal.Spliterator<any>;
        max(): Internal.OptionalInt;
        forEach(arg0: java_.util.function_.IntConsumer): void;
        count(): number;
        dropWhile(arg0: Internal.IntPredicate): Internal.IntStream;
        peek(arg0: java_.util.function_.IntConsumer): Internal.IntStream;
        flatMap(arg0: Internal.IntFunction<Internal.IntStream>): Internal.IntStream;
        filter(arg0: Internal.IntPredicate): Internal.IntStream;
        onClose(arg0: Internal.Runnable): Internal.IntStream;
        sorted(): Internal.IntStream;
        boxed(): Internal.Stream<number>;
        summaryStatistics(): Internal.IntSummaryStatistics;
        collect<R_>(arg0: () => R_, arg1: Internal.ObjIntConsumer<R_>, arg2: (arg0: R_, arg1: R_) => void): R_;
    }
    class ChunkPos {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Transformation implements Internal.IForgeTransformation {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        applyOrigin(arg0: Internal.Vector3f): Internal.Transformation;
        notifyAll(): void;
        rotateTransform(arg0: Internal.Direction): Internal.Direction;
        isIdentity(): boolean;
        push(arg0: Internal.PoseStack): void;
        notify(): void;
        getNormalMatrix(): Internal.Matrix3f;
        blockCornerToCenter(): Internal.Transformation;
        hashCode(): number;
        equals(arg0: any): boolean;
        transformPosition(arg0: Internal.Vector4f): void;
        toString(): string;
        transformNormal(arg0: Internal.Vector3f): void;
        blockCenterToCorner(): Internal.Transformation;
        get normalMatrix(): Internal.Matrix3f;
        get identity(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockHitResult extends Internal.HitResult {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BlockEntityGetter {
        getLoadedExistingBlockEntity(arg0: BlockPos): Internal.BlockEntity;
    }
    class Method extends Internal.Executable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        getParameterCount(): number;
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean;
        getGenericReturnType(): java_.lang.reflect.Type;
        notifyAll(): void;
        isSynthetic(): boolean;
        getAnnotatedParameterTypes(): Internal.AnnotatedType[];
        getParameterTypes(): Internal.Class<any>[];
        invoke(arg0: any, arg1: any[]): any;
        isBridge(): boolean;
        getGenericExceptionTypes(): java_.lang.reflect.Type[];
        notify(): void;
        getAnnotatedReceiverType(): Internal.AnnotatedType;
        getDefaultValue(): any;
        getDeclaredAnnotations(): Internal.Annotation[];
        getDeclaringClass(): Internal.Class<any>;
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        hashCode(): number;
        canAccess(arg0: any): boolean;
        toGenericString(): string;
        getTypeParameters(): any[];
        getModifiers(): number;
        trySetAccessible(): boolean;
        isAccessible(): boolean;
        setAccessible(arg0: boolean): void;
        static setAccessible(arg0: Internal.AccessibleObject[], arg1: boolean): void;
        isVarArgs(): boolean;
        getAnnotations(): Internal.Annotation[];
        getAnnotatedExceptionTypes(): Internal.AnnotatedType[];
        getExceptionTypes(): Internal.Class<any>[];
        isDefault(): boolean;
        getGenericParameterTypes(): java_.lang.reflect.Type[];
        getReturnType(): Internal.Class<any>;
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        equals(arg0: any): boolean;
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        getParameters(): any[];
        toString(): string;
        getAnnotatedReturnType(): Internal.AnnotatedType;
        getParameterAnnotations(): Internal.Annotation[][];
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get accessible(): boolean;
        get annotatedReturnType(): Internal.AnnotatedType;
        get defaultValue(): any;
        get annotations(): Internal.Annotation[];
        get modifiers(): number;
        get typeParameters(): any[];
        get default(): boolean;
        get exceptionTypes(): Internal.Class<any>[];
        get genericReturnType(): java_.lang.reflect.Type;
        get annotatedReceiverType(): Internal.AnnotatedType;
        get genericExceptionTypes(): java_.lang.reflect.Type[];
        get class(): Internal.Class<any>;
        get annotatedParameterTypes(): Internal.AnnotatedType[];
        get declaredAnnotations(): Internal.Annotation[];
        get parameterTypes(): Internal.Class<any>[];
        get parameterCount(): number;
        get declaringClass(): Internal.Class<any>;
        get varArgs(): boolean;
        get synthetic(): boolean;
        get genericParameterTypes(): java_.lang.reflect.Type[];
        get name(): string;
        get bridge(): boolean;
        get parameterAnnotations(): Internal.Annotation[][];
        get parameters(): any[];
        get annotatedExceptionTypes(): Internal.AnnotatedType[];
        get returnType(): Internal.Class<any>;
        set accessible(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MessageSizeEstimator {
        newHandle(): Internal.MessageSizeEstimator$Handle;
    }
    class ChannelOutboundBuffer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isWritable(): boolean;
        notify(): void;
        addMessage(arg0: any, arg1: number, arg2: Internal.ChannelPromise): void;
        remove(): boolean;
        remove(arg0: Internal.Throwable): boolean;
        addFlush(): void;
        forEachFlushedMessage(arg0: Internal.ChannelOutboundBuffer$MessageProcessor): void;
        totalPendingWriteBytes(): number;
        current(): any;
        setUserDefinedWritability(arg0: number, arg1: boolean): void;
        hashCode(): number;
        nioBufferSize(): number;
        recycle(): void;
        bytesBeforeWritable(): number;
        currentProgress(): number;
        bytesBeforeUnwritable(): number;
        getUserDefinedWritability(arg0: number): boolean;
        isEmpty(): boolean;
        removeBytes(arg0: number): void;
        nioBufferCount(): number;
        nioBuffers(): Internal.ByteBuffer[];
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        size(): number;
        equals(arg0: any): boolean;
        progress(arg0: number): void;
        toString(): string;
        get class(): Internal.Class<any>;
        get writable(): boolean;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class IFluidHandler$FluidAction extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.IFluidHandler$FluidAction;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.IFluidHandler$FluidAction[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.IFluidHandler$FluidAction): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.IFluidHandler$FluidAction>>;
        execute(): boolean;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.IFluidHandler$FluidAction>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        simulate(): boolean;
        ordinal(): number;
        static readonly EXECUTE : Internal.IFluidHandler$FluidAction;
        static readonly SIMULATE : Internal.IFluidHandler$FluidAction;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.IFluidHandler$FluidAction>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Object2ReferenceFunction <K, V> extends it.unimi.dsi.fastutil.Function<K, V> {
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: K) => V_;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        defaultReturnValue(): V;
        defaultReturnValue(arg0: V): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        get(arg0: any): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: K): V;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface WindowEventHandler {
    }
    class Module implements Internal.AnnotatedElement {
        getDescriptor(): Internal.ModuleDescriptor;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean;
        canRead(arg0: Internal.Module): boolean;
        notifyAll(): void;
        addUses(arg0: Internal.Class<any>): Internal.Module;
        getClassLoader(): Internal.ClassLoader;
        isNamed(): boolean;
        notify(): void;
        getDeclaredAnnotations(): Internal.Annotation[];
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        hashCode(): number;
        addReads(arg0: Internal.Module): Internal.Module;
        getLayer(): Internal.ModuleLayer;
        getResourceAsStream(arg0: string): Internal.InputStream;
        addExports(arg0: string, arg1: Internal.Module): Internal.Module;
        getAnnotations(): Internal.Annotation[];
        canUse(arg0: Internal.Class<any>): boolean;
        isOpen(arg0: string): boolean;
        isOpen(arg0: string, arg1: Internal.Module): boolean;
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        equals(arg0: any): boolean;
        isExported(arg0: string, arg1: Internal.Module): boolean;
        isExported(arg0: string): boolean;
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        getPackages(): Internal.Set<string>;
        toString(): string;
        addOpens(arg0: string, arg1: Internal.Module): Internal.Module;
        get declaredAnnotations(): Internal.Annotation[];
        get named(): boolean;
        get classLoader(): Internal.ClassLoader;
        get name(): string;
        get annotations(): Internal.Annotation[];
        get descriptor(): Internal.ModuleDescriptor;
        get packages(): Internal.Set<string>;
        get class(): Internal.Class<any>;
        get layer(): Internal.ModuleLayer;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ScheduledEvent {
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isUsingTicks(): boolean;
        notify(): void;
        getTimerDuration(): number;
        reschedule(timer: number): Internal.ScheduledEvent;
        reschedule(): void;
        getEndTime(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getTimer(): number;
        getData(): any;
        get server(): Internal.ServerJS;
        get timer(): number;
        get timerDuration(): number;
        get data(): any;
        get usingTicks(): boolean;
        get endTime(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class VariantBlockStateGenerator$Variant {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toJson(): Internal.JsonElement;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        model(s: string): Internal.VariantBlockStateGenerator$Model;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class RecordCodecBuilder$Instance <O> implements Internal.Applicative<Internal.RecordCodecBuilder$Mu<O>, any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        deprecated<A_>(arg0: A_, arg1: number): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>;
        notify(): void;
        point<A_>(arg0: A_, arg1: Internal.Lifecycle): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>;
        point<A_>(arg0: A_): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>;
        hashCode(): number;
        map<T_, R_>(arg0: (arg0: T_) => R_, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>): Internal.Products$P11<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>): Internal.Products$P10<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>): Internal.Products$P9<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>, arg13: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T14_>, arg14: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T15_>, arg15: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T16_>): Internal.Products$P16<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>, arg13: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T14_>, arg14: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T15_>): Internal.Products$P15<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>, arg13: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T14_>): Internal.Products$P14<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>): Internal.Products$P13<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>): Internal.Products$P12<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>;
        group<T1_, T2_, T3_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>): Internal.Products$P3<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_>;
        group<T1_, T2_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>): Internal.Products$P2<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_>;
        group<T1_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>): Internal.Products$P1<Internal.RecordCodecBuilder$Mu<O>, T1_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>): Internal.Products$P8<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>): Internal.Products$P7<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>): Internal.Products$P6<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_>;
        group<T1_, T2_, T3_, T4_, T5_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>): Internal.Products$P5<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_>;
        group<T1_, T2_, T3_, T4_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>): Internal.Products$P4<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_>;
        apply2<A_, B_, R_>(arg0: (arg0: A_, arg1: B_) => R_, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, B_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        apply3<T1_, T2_, T3_, R_>(arg0: Internal.Function3<T1_, T2_, T3_, R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        apply4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.Function4<T1_, T2_, T3_, T4_, R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap11<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function11<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap2<A_, B_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, (arg0: A_, arg1: B_) => R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, B_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        apply5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap10<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function10<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift2<A_, B_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, (arg0: A_, arg1: B_) => R_>): (arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, B_>) => Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function4<T1_, T2_, T3_, T4_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap3<T1_, T2_, T3_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function3<T1_, T2_, T3_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift1<A_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, (arg0: A_) => R_>): (arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>) => Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>>): Internal.Function6<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        ap7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>>): Internal.Function5<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        lift4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function4<T1_, T2_, T3_, T4_, R_>>): Internal.Function4<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        ap9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift3<T1_, T2_, T3_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function3<T1_, T2_, T3_, R_>>): Internal.Function3<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        apply6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        apply7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>): Internal.Function9<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        apply8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>): Internal.Function8<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        apply9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>): Internal.Function7<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        ap<A_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, (arg0: A_) => R_>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap<A_, R_>(arg0: (arg0: A_) => R_, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        stable<A_>(arg0: A_): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>;
        equals(arg0: any): boolean;
        ap16<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function16<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg13: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>, arg14: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T14_>, arg15: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T15_>, arg16: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T16_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        toString(): string;
        ap13<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function13<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg13: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap12<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function12<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap15<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function15<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg13: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>, arg14: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T14_>, arg15: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T15_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap14<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O>, Internal.Function14<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>>, arg1: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, arg2: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, arg3: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, arg4: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, arg5: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, arg6: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, arg7: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, arg8: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, arg9: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, arg10: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T10_>, arg11: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T11_>, arg12: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T12_>, arg13: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T13_>, arg14: Internal.App<Internal.RecordCodecBuilder$Mu<O>, T14_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AccessScreen {
        getRenderables(): Internal.List<Internal.Widget>;
    }
    interface Double2DoubleFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface RecordBuilder <T> {
        withErrorsFrom(arg0: Internal.DataResult<any>): Internal.RecordBuilder<T>;
        add(arg0: string, arg1: T): Internal.RecordBuilder<T>;
        add(arg0: string, arg1: Internal.DataResult<T>): Internal.RecordBuilder<T>;
        add(arg0: Internal.DataResult<T>, arg1: Internal.DataResult<T>): Internal.RecordBuilder<T>;
        add<E>(arg0: string, arg1: E, arg2: Internal.Encoder<E>): Internal.RecordBuilder<T>;
        add(arg0: T, arg1: T): Internal.RecordBuilder<T>;
        add(arg0: T, arg1: Internal.DataResult<T>): Internal.RecordBuilder<T>;
        mapError(arg0: (arg0: any) => any): Internal.RecordBuilder<T>;
        ops(): Internal.DynamicOps<T>;
        setLifecycle(arg0: Internal.Lifecycle): Internal.RecordBuilder<T>;
        build(arg0: Internal.DataResult<T>): Internal.DataResult<T>;
        build(arg0: T): Internal.DataResult<T>;
    }
    interface WatchEvent <T> {
        kind(): Internal.WatchEvent$Kind<T>;
        count(): number;
        context(): T;
    }
    interface Table$Cell <R, C, V> {
        getValue(): V;
        getColumnKey(): C;
        hashCode(): number;
        equals(arg0: any): boolean;
        getRowKey(): R;
    }
    class OreConfiguration$TargetBlockState {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Quaternion {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Byte2FloatFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    abstract class MappedByteBuffer extends Internal.ByteBuffer {
        asIntBuffer(): Internal.IntBuffer;
        getClass(): Internal.Class<any>;
        compact(): Internal.MappedByteBuffer;
        compact(): Internal.ByteBuffer;
        asLongBuffer(): Internal.LongBuffer;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ByteBuffer): number;
        isLoaded(): boolean;
        put(arg0: Internal.ByteBuffer): Internal.ByteBuffer;
        put(arg0: number, arg1: number): Internal.ByteBuffer;
        put(arg0: number, arg1: Internal.ByteBuffer, arg2: number, arg3: number): Internal.ByteBuffer;
        put(arg0: number[]): Internal.ByteBuffer;
        put(arg0: number, arg1: number[]): Internal.ByteBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuffer;
        put(arg0: number): Internal.ByteBuffer;
        put(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer;
        slice(arg0: number, arg1: number): Internal.ByteBuffer;
        slice(arg0: number, arg1: number): Internal.Buffer;
        slice(arg0: number, arg1: number): Internal.MappedByteBuffer;
        slice(): Internal.ByteBuffer;
        slice(): Internal.MappedByteBuffer;
        slice(): Internal.Buffer;
        limit(arg0: number): Internal.Buffer;
        limit(arg0: number): Internal.ByteBuffer;
        limit(arg0: number): Internal.MappedByteBuffer;
        limit(): number;
        order(): Internal.ByteOrder;
        order(arg0: Internal.ByteOrder): Internal.ByteBuffer;
        asFloatBuffer(): Internal.FloatBuffer;
        asCharBuffer(): Internal.CharBuffer;
        static allocateDirect(arg0: number): Internal.ByteBuffer;
        putInt(arg0: number, arg1: number): Internal.ByteBuffer;
        putInt(arg0: number): Internal.ByteBuffer;
        duplicate(): Internal.MappedByteBuffer;
        duplicate(): Internal.Buffer;
        duplicate(): Internal.ByteBuffer;
        remaining(): number;
        putFloat(arg0: number): Internal.ByteBuffer;
        putFloat(arg0: number, arg1: number): Internal.ByteBuffer;
        getInt(): number;
        getInt(arg0: number): number;
        getChar(): string;
        getChar(arg0: number): string;
        static allocate(arg0: number): Internal.ByteBuffer;
        reset(): Internal.Buffer;
        reset(): Internal.MappedByteBuffer;
        reset(): Internal.ByteBuffer;
        force(): Internal.MappedByteBuffer;
        force(arg0: number, arg1: number): Internal.MappedByteBuffer;
        position(arg0: number): Internal.ByteBuffer;
        position(arg0: number): Internal.MappedByteBuffer;
        position(arg0: number): Internal.Buffer;
        position(): number;
        asShortBuffer(): Internal.ShortBuffer;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        putDouble(arg0: number, arg1: number): Internal.ByteBuffer;
        putDouble(arg0: number): Internal.ByteBuffer;
        getDouble(): number;
        getDouble(arg0: number): number;
        getFloat(arg0: number): number;
        getFloat(): number;
        putLong(arg0: number, arg1: number): Internal.ByteBuffer;
        putLong(arg0: number): Internal.ByteBuffer;
        notify(): void;
        asReadOnlyBuffer(): Internal.ByteBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        load(): Internal.MappedByteBuffer;
        asDoubleBuffer(): Internal.DoubleBuffer;
        array(): number[];
        array(): any;
        hashCode(): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuffer;
        get(arg0: number): number;
        get(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer;
        get(): number;
        get(arg0: number, arg1: number[]): Internal.ByteBuffer;
        get(arg0: number[]): Internal.ByteBuffer;
        arrayOffset(): number;
        putShort(arg0: number): Internal.ByteBuffer;
        putShort(arg0: number, arg1: number): Internal.ByteBuffer;
        flip(): Internal.Buffer;
        flip(): Internal.ByteBuffer;
        flip(): Internal.MappedByteBuffer;
        hasArray(): boolean;
        getShort(arg0: number): number;
        getShort(): number;
        putChar(arg0: number, arg1: string): Internal.ByteBuffer;
        putChar(arg0: string): Internal.ByteBuffer;
        hasRemaining(): boolean;
        clear(): Internal.Buffer;
        clear(): Internal.MappedByteBuffer;
        clear(): Internal.ByteBuffer;
        getLong(arg0: number): number;
        getLong(): number;
        alignmentOffset(arg0: number, arg1: number): number;
        rewind(): Internal.MappedByteBuffer;
        rewind(): Internal.Buffer;
        rewind(): Internal.ByteBuffer;
        mismatch(arg0: Internal.ByteBuffer): number;
        equals(arg0: any): boolean;
        toString(): string;
        alignedSlice(arg0: number): Internal.ByteBuffer;
        isDirect(): boolean;
        static wrap(arg0: number[]): Internal.ByteBuffer;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer;
        mark(): Internal.MappedByteBuffer;
        mark(): Internal.ByteBuffer;
        mark(): Internal.Buffer;
        get loaded(): boolean;
        get double(): number;
        get char(): string;
        get direct(): boolean;
        get short(): number;
        get readOnly(): boolean;
        get float(): number;
        get class(): Internal.Class<any>;
        get int(): number;
        get long(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ServerPlayerDataJS extends Internal.PlayerDataJS<any, any> {
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.ServerPlayerJS;
        getPlayer(): Internal.PlayerJS<any>;
        getName(): string;
        notifyAll(): void;
        getProfile(): Internal.GameProfile;
        getId(): Internal.UUID;
        getOverworld(): Internal.LevelJS;
        notify(): void;
        getMinecraftPlayer(): Internal.ServerPlayer;
        getMinecraftPlayer(): Internal.Player;
        hashCode(): number;
        equals(arg0: any): boolean;
        hasClientMod(): boolean;
        toString(): string;
        getData(): Internal.AttachedData;
        get server(): Internal.ServerJS;
        get data(): Internal.AttachedData;
        get minecraftPlayer(): Internal.Player;
        get profile(): Internal.GameProfile;
        get name(): string;
        get id(): Internal.UUID;
        get overworld(): Internal.LevelJS;
        get class(): Internal.Class<any>;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface WatchService extends Internal.Closeable {
        take(): Internal.WatchKey;
        poll(arg0: number, arg1: Internal.TimeUnit): Internal.WatchKey;
        poll(): Internal.WatchKey;
        close(): void;
    }
    interface VertexConsumer extends Internal.IForgeVertexConsumer, Internal.VertexDrain {
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer): number;
        createSink(factory: Internal.VertexType<any>): Internal.VertexSink;
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        applyBakedNormals(arg0: Internal.Vector3f, arg1: Internal.ByteBuffer, arg2: Internal.Matrix3f): void;
    }
    interface Context$ClassShutterSetter {
        setClassShutter(arg0: Internal.ClassShutter): void;
        getClassShutter(): Internal.ClassShutter;
    }
    abstract class ImmutableMultisetGwtSerializationDependencies <E> extends Internal.ImmutableCollection<any> {
        add(arg0: E): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: (arg0: E) => void): void;
        notifyAll(): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        notify(): void;
        asList(): Internal.ImmutableList<E>;
        remove(arg0: any): boolean;
        removeIf(arg0: (arg0: E) => boolean): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.UnmodifiableIterator<E>;
        iterator(): Internal.Iterator<any>;
        size(): number;
        stream(): Internal.Stream<E>;
        addAll(arg0: Internal.Collection<E>): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        toString(): string;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FuncSupplier$Func1 extends Internal.FuncSupplier {
        create(args: Internal.List<dev.latvian.mods.rhino.util.unit.Unit>): dev.latvian.mods.rhino.util.unit.Unit;
        create1(arg0: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
    }
    abstract class EntityInstance <E> extends Internal.AbstractInstance implements Internal.LightListener, Internal.MovingListener {
        getClass(): Internal.Class<any>;
        init(): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        onLightUpdate(arg0: Internal.LightProvider, arg1: Internal.LightLayer, arg2: Internal.ImmutableBox): void;
        notifyAll(): void;
        getInstancePosition(): Internal.Vector3f;
        getInstancePosition(arg0: number): Internal.Vector3f;
        update(arg0: Internal.LightProvider): boolean;
        update(): void;
        updateLight(): void;
        notify(): void;
        remove(): void;
        getWorldPosition(): BlockPos;
        getVolume(): Internal.ImmutableBox;
        getVolume(): Internal.GridAlignedBB;
        hashCode(): number;
        onLightPacket(arg0: Internal.LightProvider, arg1: number, arg2: number): void;
        equals(arg0: any): boolean;
        toString(): string;
        shouldReset(): boolean;
        status(): Internal.ListenerStatus;
        readonly world : net.minecraft.world.level.Level;
        get volume(): Internal.GridAlignedBB;
        get worldPosition(): BlockPos;
        get instancePosition(): Internal.Vector3f;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjectSpliterator <K> extends Internal.Spliterator<K> {
        trySplit(): Internal.Spliterator<any>;
        trySplit(): Internal.ObjectSpliterator<K>;
        tryAdvance(arg0: (arg0: K) => void): boolean;
        characteristics(): number;
        getComparator(): Internal.Comparator<K>;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        skip(arg0: number): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: (arg0: K) => void): void;
    }
    interface URLStreamHandlerFactory {
        createURLStreamHandler(arg0: string): Internal.URLStreamHandler;
    }
    interface IEventListener {
        listenerName(): string;
        invoke(arg0: Internal.Event): void;
    }
    interface WorldEntityByChunkAccess {
        getEntitiesInChunk(arg0: number, arg1: number): Internal.Collection<Internal.Entity>;
    }
    interface ClientWorldAccessor {
        getEntityManager(): Internal.TransientEntitySectionManager<Internal.Entity>;
    }
    abstract class FluidIngredient implements Internal.Predicate<net.minecraftforge.fluids.FluidStack> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: (arg0: net.minecraftforge.fluids.FluidStack) => boolean): (arg0: net.minecraftforge.fluids.FluidStack) => boolean;
        static fromTag(arg0: Internal.Tag$Named<Internal.Fluid>, arg1: number): (arg0: any) => boolean;
        static read(arg0: Internal.FriendlyByteBuf): (arg0: any) => boolean;
        test(arg0: net.minecraftforge.fluids.FluidStack): boolean;
        test(arg0: any): boolean;
        notifyAll(): void;
        static isFluidIngredient(arg0: Internal.JsonElement): boolean;
        static fromFluid(arg0: Internal.Fluid, arg1: number): (arg0: any) => boolean;
        notify(): void;
        getMatchingFluidStacks(): Internal.List<net.minecraftforge.fluids.FluidStack>;
        serialize(): Internal.JsonObject;
        and(arg0: (arg0: net.minecraftforge.fluids.FluidStack) => boolean): (arg0: net.minecraftforge.fluids.FluidStack) => boolean;
        negate(): (arg0: net.minecraftforge.fluids.FluidStack) => boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        getRequiredAmount(): number;
        toString(): string;
        write(arg0: Internal.FriendlyByteBuf): void;
        static fromFluidStack(arg0: net.minecraftforge.fluids.FluidStack): (arg0: any) => boolean;
        static deserialize(arg0: Internal.JsonElement): (arg0: any) => boolean;
        matchingFluidStacks : Internal.List<net.minecraftforge.fluids.FluidStack>;
        static readonly EMPTY : (arg0: any) => boolean;
        get requiredAmount(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeMobEffect {
        getCurativeItems(): Internal.List<Internal.ItemStack>;
        getSortOrder(arg0: Internal.MobEffectInstance): number;
    }
    interface Encoder <A> {
        encode<T>(arg0: A, arg1: Internal.DynamicOps<T>, arg2: T): Internal.DataResult<T>;
        flatComap<B>(arg0: (arg0: B) => Internal.DataResult<A>): Internal.Encoder<B>;
        comap<B>(arg0: (arg0: B) => A): Internal.Encoder<B>;
        fieldOf(arg0: string): Internal.MapEncoder<A>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.Encoder<A>;
        encodeStart<T>(arg0: Internal.DynamicOps<T>, arg1: A): Internal.DataResult<T>;
    }
    class OptionalDynamic <T> extends Internal.DynamicLike<any> {
        createIntList(arg0: Internal.IntStream): Internal.Dynamic<any>;
        createLong(arg0: number): Internal.Dynamic<T>;
        getClass(): Internal.Class<any>;
        getElementGeneric(arg0: T): Internal.DataResult<T>;
        getElementGeneric(arg0: T, arg1: T): T;
        createLongList(arg0: Internal.LongStream): Internal.Dynamic<any>;
        readMap<K_, V_>(arg0: Internal.Decoder<K_>, arg1: Internal.Decoder<V_>): Internal.DataResult<Internal.List<Internal.Pair<K_, V_>>>;
        readMap<K_, V_>(arg0: Internal.Decoder<K_>, arg1: (arg0: K_) => Internal.Decoder<V_>): Internal.DataResult<Internal.List<Internal.Pair<K_, V_>>>;
        readMap<R_>(arg0: Internal.DataResult<R_>, arg1: Internal.Function3<R_, Internal.Dynamic<T>, Internal.Dynamic<T>, Internal.DataResult<R_>>): Internal.DataResult<R_>;
        asListOpt<U_>(arg0: (arg0: Internal.Dynamic<T>) => U_): Internal.DataResult<Internal.List<U_>>;
        orElseEmptyList(): Internal.Dynamic<T>;
        createShort(arg0: number): Internal.Dynamic<T>;
        decode<A_>(arg0: Internal.Decoder<A_>): Internal.DataResult<Internal.Pair<A_, T>>;
        asIntStreamOpt(): Internal.DataResult<Internal.IntStream>;
        asList<U_>(arg0: (arg0: Internal.Dynamic<T>) => U_): Internal.List<U_>;
        readList<E_>(arg0: (arg0: Internal.Dynamic<any>) => Internal.DataResult<E_>): Internal.DataResult<Internal.List<E_>>;
        readList<E_>(arg0: Internal.Decoder<E_>): Internal.DataResult<Internal.List<E_>>;
        asString(): Internal.DataResult<string>;
        asString(arg0: string): string;
        asByte(arg0: number): number;
        createList(arg0: Internal.Stream<Internal.Dynamic<any>>): Internal.Dynamic<T>;
        read<A_>(arg0: Internal.Decoder<A_>): Internal.DataResult<A_>;
        asByteBufferOpt(): Internal.DataResult<Internal.ByteBuffer>;
        createString(arg0: string): Internal.Dynamic<T>;
        asMapOpt(): Internal.DataResult<Internal.Stream<Internal.Pair<Internal.Dynamic<T>, Internal.Dynamic<T>>>>;
        asMapOpt<K_, V_>(arg0: (arg0: Internal.Dynamic<T>) => K_, arg1: (arg0: Internal.Dynamic<T>) => V_): Internal.DataResult<Internal.Map<K_, V_>>;
        getGeneric(arg0: T): Internal.DataResult<T>;
        asStream(): Internal.Stream<Internal.Dynamic<T>>;
        asLong(arg0: number): number;
        createByte(arg0: number): Internal.Dynamic<T>;
        flatMap<U_>(arg0: (arg0: Internal.Dynamic<T>) => Internal.DataResult<U_>): Internal.DataResult<U_>;
        asDouble(arg0: number): number;
        asBoolean(arg0: boolean): boolean;
        createDouble(arg0: number): Internal.Dynamic<T>;
        asLongStreamOpt(): Internal.DataResult<Internal.LongStream>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        asMap<K_, V_>(arg0: (arg0: Internal.Dynamic<T>) => K_, arg1: (arg0: Internal.Dynamic<T>) => V_): Internal.Map<K_, V_>;
        asStreamOpt(): Internal.DataResult<Internal.Stream<Internal.Dynamic<T>>>;
        notifyAll(): void;
        asIntStream(): Internal.IntStream;
        createByteList(arg0: Internal.ByteBuffer): Internal.Dynamic<any>;
        asByteBuffer(): Internal.ByteBuffer;
        asFloat(arg0: number): number;
        asLongStream(): Internal.LongStream;
        notify(): void;
        createBoolean(arg0: boolean): Internal.Dynamic<T>;
        result(): Internal.Optional<Internal.Dynamic<T>>;
        asInt(arg0: number): number;
        into<V_>(arg0: (arg0: Internal.Dynamic<T>) => V_): Internal.DataResult<V_>;
        emptyList(): Internal.Dynamic<T>;
        hashCode(): number;
        asShort(arg0: number): number;
        get(arg0: string): Internal.OptionalDynamic<T>;
        get(): Internal.DataResult<Internal.Dynamic<T>>;
        emptyMap(): Internal.Dynamic<T>;
        createNumeric(arg0: Internal.Number): Internal.Dynamic<T>;
        map<U_>(arg0: (arg0: Internal.Dynamic<T>) => U_): Internal.DataResult<U_>;
        orElseEmptyMap(): Internal.Dynamic<T>;
        asNumber(): Internal.DataResult<Internal.Number>;
        asNumber(arg0: Internal.Number): Internal.Number;
        createMap(arg0: Internal.Map<Internal.Dynamic<any>, Internal.Dynamic<any>>): Internal.Dynamic<T>;
        createFloat(arg0: number): Internal.Dynamic<T>;
        getOps(): Internal.DynamicOps<T>;
        getElement(arg0: string): Internal.DataResult<T>;
        getElement(arg0: string, arg1: T): T;
        equals(arg0: any): boolean;
        createInt(arg0: number): Internal.Dynamic<T>;
        toString(): string;
        get ops(): Internal.DynamicOps<T>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface SeekableByteChannel extends Internal.ByteChannel {
        isOpen(): boolean;
        read(arg0: Internal.ByteBuffer): number;
        truncate(arg0: number): Internal.SeekableByteChannel;
        size(): number;
        position(): number;
        position(arg0: number): Internal.SeekableByteChannel;
        close(): void;
        write(arg0: Internal.ByteBuffer): number;
    }
    class CraftingContainer implements Internal.Container, Internal.StackedContentsCompatible {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Constable {
        describeConstable(): Internal.Optional<Internal.ConstantDesc>;
    }
    class BakedQuad implements Internal.IVertexProducer, Internal.BakedQuadAccess, Internal.ModelQuadView {
        getNormal(idx: number): number;
        getTexV(idx: number): number;
        getLight(idx: number): number;
        getClass(): Internal.Class<any>;
        getTexU(idx: number): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getColorIndex(): number;
        notifyAll(): void;
        getColor(idx: number): number;
        notify(): void;
        getSprite(): Internal.TextureAtlasSprite;
        getX(idx: number): number;
        getY(idx: number): number;
        setVertices(arg0: number[]): void;
        getZ(idx: number): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        pipe(arg0: Internal.IVertexConsumer): void;
        getFlags(): number;
        get sprite(): Internal.TextureAtlasSprite;
        get flags(): number;
        get colorIndex(): number;
        get class(): Internal.Class<any>;
        set vertices(arg0: number[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface CoordinateConsumer {
        consume(arg0: number, arg1: number, arg2: number): void;
    }
    class MultipartBlockStateGenerator$Part {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toJson(): Internal.JsonObject;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        model(s: string): Internal.VariantBlockStateGenerator$Model;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ClassShutter {
        visibleToScripts(arg0: string, arg1: number): boolean;
    }
    interface IntToDoubleFunction {
        applyAsDouble(arg0: number): number;
    }
    interface VoxelShapeAccess {
        setFaces(arg0: Internal.VoxelShape[]): void;
        getFaces(): Internal.VoxelShape[];
        getShape(): Internal.DiscreteVoxelShape;
        setShape(arg0: Internal.DiscreteVoxelShape): void;
    }
    class DyeColor extends Internal.Enum<any> implements Internal.StringRepresentable, Internal.Color {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRgbKJS(): number;
        static valueOf(arg0: string): Internal.DyeColor;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.DyeColor[];
        static getColor(arg0: Internal.ItemStack): Internal.DyeColor;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.DyeColor): number;
        getSerializeKJS(): string;
        getTag(): Internal.Tags$IOptionalNamedTag<Internal.Item>;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.DyeColor>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.DyeColor>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        createTextColorKJS(): Internal.TextColor;
        getHexKJS(): string;
        getArgbKJS(): number;
        toString(): string;
        getFireworkColorKJS(): number;
        specialEquals(o: any, shallow: boolean): boolean;
        ordinal(): number;
        static readonly WHITE : Internal.DyeColor;
        static readonly GRAY : Internal.DyeColor;
        static readonly BLUE : Internal.DyeColor;
        static readonly PURPLE : Internal.DyeColor;
        static readonly GREEN : Internal.DyeColor;
        static readonly RED : Internal.DyeColor;
        static readonly PINK : Internal.DyeColor;
        static readonly LIGHT_GRAY : Internal.DyeColor;
        static readonly LIGHT_BLUE : Internal.DyeColor;
        static readonly LIME : Internal.DyeColor;
        static readonly MAGENTA : Internal.DyeColor;
        static readonly BLACK : Internal.DyeColor;
        static readonly YELLOW : Internal.DyeColor;
        static readonly CYAN : Internal.DyeColor;
        static readonly BROWN : Internal.DyeColor;
        static readonly ORANGE : Internal.DyeColor;
        get fireworkColorKJS(): number;
        get rgbKJS(): number;
        get argbKJS(): number;
        get serializeKJS(): string;
        get hexKJS(): string;
        get tag(): Internal.Tags$IOptionalNamedTag<Internal.Item>;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.DyeColor>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Writer implements Internal.Appendable, Internal.Closeable, Internal.Flushable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        flush(): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static nullWriter(): Internal.Writer;
        toString(): string;
        close(): void;
        write(arg0: string, arg1: number, arg2: number): void;
        write(arg0: number): void;
        write(arg0: string): void;
        write(arg0: string[], arg1: number, arg2: number): void;
        write(arg0: string[]): void;
        notify(): void;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Writer;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable;
        append(arg0: string): Internal.Writer;
        append(arg0: string): Internal.Appendable;
        append(arg0: Internal.CharSequence): Internal.Appendable;
        append(arg0: Internal.CharSequence): Internal.Writer;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ProfilerMeasured {
    }
    interface ProgressiveFuture <V> extends Internal.Future<V> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.ProgressiveFuture<V>;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>;
        getNow(): V;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): Internal.ProgressiveFuture<V>;
        awaitUninterruptibly(): Internal.Future<V>;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.ProgressiveFuture<V>;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>;
        isDone(): boolean;
        sync(): Internal.ProgressiveFuture<V>;
        sync(): Internal.Future<V>;
        syncUninterruptibly(): Internal.ProgressiveFuture<V>;
        syncUninterruptibly(): Internal.Future<V>;
        get(arg0: number, arg1: Internal.TimeUnit): V;
        get(): V;
        isCancellable(): boolean;
        await(): Internal.ProgressiveFuture<V>;
        await(): Internal.Future<V>;
        await(arg0: number, arg1: Internal.TimeUnit): boolean;
        await(arg0: number): boolean;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.ProgressiveFuture<V>;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>;
        isSuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.ProgressiveFuture<V>;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>;
    }
    class FoodProperties {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockPathTypes extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.BlockPathTypes;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.BlockPathTypes[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.BlockPathTypes): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.BlockPathTypes>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.BlockPathTypes>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        getDanger(): Internal.BlockPathTypes;
        static readonly DAMAGE_CACTUS : Internal.BlockPathTypes;
        static readonly LAVA : Internal.BlockPathTypes;
        static readonly LEAVES : Internal.BlockPathTypes;
        static readonly BLOCKED : Internal.BlockPathTypes;
        static readonly WALKABLE : Internal.BlockPathTypes;
        static readonly DANGER_CACTUS : Internal.BlockPathTypes;
        static readonly TRAPDOOR : Internal.BlockPathTypes;
        static readonly BREACH : Internal.BlockPathTypes;
        static readonly POWDER_SNOW : Internal.BlockPathTypes;
        static readonly DOOR_WOOD_CLOSED : Internal.BlockPathTypes;
        static readonly DANGER_FIRE : Internal.BlockPathTypes;
        static readonly DAMAGE_FIRE : Internal.BlockPathTypes;
        static readonly WATER : Internal.BlockPathTypes;
        static readonly WATER_BORDER : Internal.BlockPathTypes;
        static readonly WALKABLE_DOOR : Internal.BlockPathTypes;
        static readonly DOOR_IRON_CLOSED : Internal.BlockPathTypes;
        static readonly FENCE : Internal.BlockPathTypes;
        static readonly OPEN : Internal.BlockPathTypes;
        static readonly RAIL : Internal.BlockPathTypes;
        static readonly DAMAGE_OTHER : Internal.BlockPathTypes;
        static readonly DOOR_OPEN : Internal.BlockPathTypes;
        static readonly UNPASSABLE_RAIL : Internal.BlockPathTypes;
        static readonly COCOA : Internal.BlockPathTypes;
        static readonly DANGER_OTHER : Internal.BlockPathTypes;
        static readonly STICKY_HONEY : Internal.BlockPathTypes;
        get danger(): Internal.BlockPathTypes;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.BlockPathTypes>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class GsonBuilder {
        setFieldNamingPolicy(arg0: Internal.FieldNamingPolicy): Internal.GsonBuilder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        enableComplexMapKeySerialization(): Internal.GsonBuilder;
        notifyAll(): void;
        disableInnerClassSerialization(): Internal.GsonBuilder;
        excludeFieldsWithModifiers(arg0: number[]): Internal.GsonBuilder;
        setLenient(): Internal.GsonBuilder;
        notify(): void;
        serializeNulls(): Internal.GsonBuilder;
        addSerializationExclusionStrategy(arg0: Internal.ExclusionStrategy): Internal.GsonBuilder;
        generateNonExecutableJson(): Internal.GsonBuilder;
        registerTypeHierarchyAdapter(arg0: Internal.Class<any>, arg1: any): Internal.GsonBuilder;
        addDeserializationExclusionStrategy(arg0: Internal.ExclusionStrategy): Internal.GsonBuilder;
        hashCode(): number;
        setLongSerializationPolicy(arg0: Internal.LongSerializationPolicy): Internal.GsonBuilder;
        registerTypeAdapterFactory(arg0: Internal.TypeAdapterFactory): Internal.GsonBuilder;
        create(): Internal.Gson;
        disableHtmlEscaping(): Internal.GsonBuilder;
        setDateFormat(arg0: string): Internal.GsonBuilder;
        setDateFormat(arg0: number): Internal.GsonBuilder;
        setDateFormat(arg0: number, arg1: number): Internal.GsonBuilder;
        setVersion(arg0: number): Internal.GsonBuilder;
        setFieldNamingStrategy(arg0: Internal.FieldNamingStrategy): Internal.GsonBuilder;
        serializeSpecialFloatingPointValues(): Internal.GsonBuilder;
        registerTypeAdapter(arg0: java_.lang.reflect.Type, arg1: any): Internal.GsonBuilder;
        setPrettyPrinting(): Internal.GsonBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        setExclusionStrategies(arg0: Internal.ExclusionStrategy[]): Internal.GsonBuilder;
        excludeFieldsWithoutExposeAnnotation(): Internal.GsonBuilder;
        get class(): Internal.Class<any>;
        set exclusionStrategies(arg0: Internal.ExclusionStrategy[]);
        set fieldNamingStrategy(arg0: Internal.FieldNamingStrategy);
        set fieldNamingPolicy(arg0: Internal.FieldNamingPolicy);
        set dateFormat(arg0: string);
        set longSerializationPolicy(arg0: Internal.LongSerializationPolicy);
        set version(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModelBakery {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getSpriteMap(): Internal.AtlasSet;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        bake(arg0: ResourceLocation, arg1: Internal.ModelState, arg2: (arg0: net.minecraft.client.resources.model.Material) => Internal.TextureAtlasSprite): Internal.BakedModel;
        getSpecialModels(): Internal.Set<ResourceLocation>;
        toString(): string;
        notify(): void;
        get spriteMap(): Internal.AtlasSet;
        get specialModels(): Internal.Set<ResourceLocation>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ScriptType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isServer(): boolean;
        static valueOf(name: string): Internal.ScriptType;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ScriptType[];
        isClient(): boolean;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ScriptType): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ScriptType>>;
        notify(): void;
        getLogFile(): Internal.Path;
        getDeclaringClass(): Internal.Class<Internal.ScriptType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        static of(level: Internal.LevelReader): Internal.ScriptType;
        name(): string;
        toString(): string;
        ordinal(): number;
        readonly console : Internal.ConsoleJS;
        readonly manager : () => Internal.ScriptManager;
        static readonly SERVER : Internal.ScriptType;
        readonly executor : Internal.ExecutorService;
        readonly warnings : Internal.List<string>;
        static readonly STARTUP : Internal.ScriptType;
        static readonly CLIENT : Internal.ScriptType;
        readonly errors : Internal.List<string>;
        get server(): boolean;
        get logFile(): Internal.Path;
        get client(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ScriptType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class PermissionCollection implements Internal.Serializable {
        add(arg0: Internal.Permission): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        elementsAsStream(): Internal.Stream<Internal.Permission>;
        isReadOnly(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        elements(): Internal.Enumeration<Internal.Permission>;
        toString(): string;
        implies(arg0: Internal.Permission): boolean;
        notify(): void;
        setReadOnly(): void;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DynamicOps <T> {
        listBuilder(): Internal.ListBuilder<T>;
        updateGeneric(arg0: T, arg1: T, arg2: (arg0: T) => T): T;
        createIntList(arg0: Internal.IntStream): T;
        createLong(arg0: number): T;
        createDouble(arg0: number): T;
        createLongList(arg0: Internal.LongStream): T;
        createShort(arg0: number): T;
        mergeToList(arg0: T, arg1: T): Internal.DataResult<T>;
        mergeToList(arg0: T, arg1: Internal.List<T>): Internal.DataResult<T>;
        update(arg0: T, arg1: string, arg2: (arg0: T) => T): T;
        createByteList(arg0: Internal.ByteBuffer): T;
        getByteBuffer(arg0: T): Internal.DataResult<Internal.ByteBuffer>;
        withDecoder<E>(arg0: Internal.Decoder<E>): (arg0: T) => Internal.DataResult<Internal.Pair<E, T>>;
        createBoolean(arg0: boolean): T;
        remove(arg0: T, arg1: string): T;
        getMapValues(arg0: T): Internal.DataResult<Internal.Stream<Internal.Pair<T, T>>>;
        empty(): T;
        withParser<E>(arg0: Internal.Decoder<E>): (arg0: T) => Internal.DataResult<E>;
        mergeToMap(arg0: T, arg1: Internal.Map<T, T>): Internal.DataResult<T>;
        mergeToMap(arg0: T, arg1: T, arg2: T): Internal.DataResult<T>;
        mergeToMap(arg0: T, arg1: Internal.MapLike<T>): Internal.DataResult<T>;
        convertList<U>(arg0: Internal.DynamicOps<U>, arg1: T): U;
        emptyList(): T;
        getIntStream(arg0: T): Internal.DataResult<Internal.IntStream>;
        getList(arg0: T): Internal.DataResult<(arg0: (arg0: T) => void) => void>;
        getLongStream(arg0: T): Internal.DataResult<Internal.LongStream>;
        get(arg0: T, arg1: string): Internal.DataResult<T>;
        getMapEntries(arg0: T): Internal.DataResult<(arg0: (arg0: T, arg1: T) => void) => void>;
        emptyMap(): T;
        getBooleanValue(arg0: T): Internal.DataResult<boolean>;
        createNumeric(arg0: Internal.Number): T;
        getStream(arg0: T): Internal.DataResult<Internal.Stream<T>>;
        convertMap<U>(arg0: Internal.DynamicOps<U>, arg1: T): U;
        mergeToPrimitive(arg0: T, arg1: T): Internal.DataResult<T>;
        createList(arg0: Internal.Stream<T>): T;
        getStringValue(arg0: T): Internal.DataResult<string>;
        withEncoder<E>(arg0: Internal.Encoder<E>): (arg0: E) => Internal.DataResult<T>;
        set(arg0: T, arg1: string, arg2: T): T;
        getGeneric(arg0: T, arg1: T): Internal.DataResult<T>;
        createString(arg0: string): T;
        convertTo<U>(arg0: Internal.DynamicOps<U>, arg1: T): U;
        createMap(arg0: Internal.Map<T, T>): T;
        createMap(arg0: Internal.Stream<Internal.Pair<T, T>>): T;
        mapBuilder(): Internal.RecordBuilder<T>;
        getMap(arg0: T): Internal.DataResult<Internal.MapLike<T>>;
        createByte(arg0: number): T;
        createFloat(arg0: number): T;
        createInt(arg0: number): T;
        compressMaps(): boolean;
        getNumberValue(arg0: T): Internal.DataResult<Internal.Number>;
        getNumberValue(arg0: T, arg1: Internal.Number): Internal.Number;
    }
    class LightTexture implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface VertexSink {
        flush(): void;
        ensureCapacity(arg0: number): void;
        getVertexCount(): number;
    }
    interface LevelTimeAccess extends Internal.LevelReader {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean;
    }
    class DamageSourceJS {
        getClass(): Internal.Class<any>;
        getLevel(): Internal.LevelJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getActual(): Internal.EntityJS;
        getPlayer(): Internal.PlayerJS<any>;
        getType(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getImmediate(): Internal.EntityJS;
        toString(): string;
        notify(): void;
        readonly source : Internal.DamageSource;
        get actual(): Internal.EntityJS;
        get level(): Internal.LevelJS;
        get immediate(): Internal.EntityJS;
        get type(): string;
        get class(): Internal.Class<any>;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ServerPlayer extends Internal.Player {
        handler$zdn000$onIsScoping(arg0: Internal.CallbackInfoReturnable<any>): void;
        canBeRiddenInWater(arg0: Internal.Entity): boolean;
        handler$zzo000$tickHead(arg0: Internal.CallbackInfo): void;
        setCitadelEntityData(arg0: Internal.CompoundTag): void;
        getCachedFeetBlockState(): Internal.BlockState;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        handler$bfj000$tryShortcutFluidPushing(tag: net.minecraft.tags.Tag<any>, speed: number, cir: Internal.CallbackInfoReturnable<any>, box: Internal.AABB, x1: number, x2: number, y1: number, y2: number, z1: number, z2: number, zero: number): void;
        revive(): void;
        static getDataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        getEndimatedState(): Internal.Endimatable$EndimatedState;
        getSuffixes(): Internal.Collection<Internal.MutableComponent>;
        resetEndimation(): void;
        reviveCaps(): void;
        handler$zfk000$diet$constructPlayer(arg0: Internal.CallbackInfo): void;
        handler$zbc000$locateAmmo(arg0: Internal.ItemStack, arg1: Internal.CallbackInfoReturnable<any>, arg2: (arg0: any) => boolean): void;
        getEffectHandler(): Internal.EndimationEffectHandler;
        getPrefixes(): Internal.Collection<Internal.MutableComponent>;
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        getListener(): Internal.NearbyEntityListenerMulti;
        isNoEndimationPlaying(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$znf000$changeDimensionHead(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter, arg2: Internal.CallbackInfoReturnable<any>): void;
        notify(): void;
        handler$zzo000$moveStep(arg0: Internal.MoverType, arg1: Vec3, arg2: Internal.CallbackInfo): void;
        getEntityChangeListener(): Internal.EntityInLevelCallback;
        isDirty(): boolean;
        getLastPos(): BlockPos;
        refreshTabListName(): void;
        handler$zne000$getExitPortal(arg0: Internal.ServerLevel, arg1: BlockPos, arg2: boolean, arg3: Internal.WorldBorder, arg4: Internal.CallbackInfoReturnable<any>): void;
        addListener(listener: Internal.NearbyEntityListener): void;
        getLanguage(): string;
        curePotionEffects(arg0: Internal.ItemStack): boolean;
        getPlayingEndimation(): Internal.PlayableEndimation;
        getDirtyEntries(): Internal.Set<any>;
        shouldRiderFaceForward(arg0: Internal.Player): boolean;
        setPlayingEndimation(arg0: Internal.PlayableEndimation): void;
        equals(arg0: any): boolean;
        toString(): string;
        refreshDisplayName(): void;
        getForcedPose(): Internal.Pose;
        getClass(): Internal.Class<any>;
        backpackedMoved(): boolean;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>;
        handler$zje000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void;
        handler$zbc000$onFallFlying(arg0: number, arg1: number, arg2: number, arg3: Internal.CallbackInfo): void;
        onEndimationEnd(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        isEndimationPlaying(arg0: Internal.PlayableEndimation): boolean;
        isActive(): boolean;
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void;
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity;
        getPos(): Internal.Position;
        foodEatenKJS(is: Internal.ItemStack): void;
        getDigSpeed(arg0: Internal.BlockState, arg1: BlockPos): number;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(arg0: boolean): void;
        canUpdate(): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean;
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number;
        lithiumOnBlockCacheDeleted(): void;
        setForcedPose(arg0: Internal.Pose): void;
        canRiderInteract(): boolean;
        getEntries(arg0: boolean): Internal.Set<any>;
        onAddedToWorld(): void;
        setAnimationTick(arg0: number): void;
        static getDataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        getClassification(arg0: boolean): Internal.MobCategory;
        onEndimationStart(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listenForCachedBlockChanges: boolean): void;
        handler$znf000$changeDimensionTail(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter, arg2: Internal.CallbackInfoReturnable<any>): void;
        shouldRiderSit(): boolean;
        getIsInsidePortal(): boolean;
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack;
        handler$zje000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        handler$zcg000$read(arg0: Internal.CompoundTag, arg1: Internal.CallbackInfo): void;
        getRemainingFireTicks(): number;
        lithiumOnEquipmentChanged(): void;
        getStagesRawKJS(): Internal.Stages;
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void;
        getDataMap(): Internal.Map<any, any>;
        getStages(): Internal.Stages;
        endimateTick(): void;
        setDataMap(arg0: Internal.Map<any, any>): void;
        hashCode(): number;
        isAddedToWorld(): boolean;
        getParts(): any[];
        onRemovedFromWorld(): void;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        clean(): void;
        asKJS(): any;
        getValue(arg0: Internal.TrackedData<any>): any;
        setValue(arg0: Internal.TrackedData<any>, arg1: any): void;
        getAnimationTick(): number;
        setRemainingFireTicks(arg0: number): void;
        handler$zgd001$tick(arg0: Internal.CallbackInfo): void;
        getBackpackedInventory(): Internal.BackpackInventory;
        backpackedInventory : Internal.BackpackInventory;
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
        get suffixes(): Internal.Collection<Internal.MutableComponent>;
        get citadelEntityData(): Internal.CompoundTag;
        get listener(): Internal.NearbyEntityListenerMulti;
        get stagesRawKJS(): Internal.Stages;
        get addedToWorld(): boolean;
        get language(): string;
        get animationTick(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get pos(): Internal.Position;
        get dataMap(): Internal.Map<any, any>;
        get noEndimationPlaying(): boolean;
        get class(): Internal.Class<any>;
        get dirty(): boolean;
        get dataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        get isInsidePortal(): boolean;
        get entityChangeListener(): Internal.EntityInLevelCallback;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get multipartEntity(): boolean;
        get playingEndimation(): Internal.PlayableEndimation;
        get active(): boolean;
        get effectHandler(): Internal.EndimationEffectHandler;
        get cachedFeetBlockState(): Internal.BlockState;
        get lastPos(): BlockPos;
        get dirtyEntries(): Internal.Set<any>;
        get dataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        get prefixes(): Internal.Collection<Internal.MutableComponent>;
        get forcedPose(): Internal.Pose;
        get stages(): Internal.Stages;
        get parts(): any[];
        get endimatedState(): Internal.Endimatable$EndimatedState;
        set animationTick(arg0: number);
        set forcedPose(arg0: Internal.Pose);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set dataMap(arg0: Internal.Map<any, any>);
        set playingEndimation(arg0: Internal.PlayableEndimation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DataPackEventJS extends Internal.ServerEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        add(id: ResourceLocation, content: string): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        addJson(id: ResourceLocation, json: Internal.JsonElement): void;
        notify(): void;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TagEventJS <T> extends Internal.EventJS {
        cancel(): void;
        add(tag: ResourceLocation, ids: any): Internal.TagEventJS$TagWrapper<T>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        removeAllTagsFrom(ids: any): void;
        setGlobalPriorityList(o: any): void;
        notify(): void;
        remove(tag: ResourceLocation, ids: any): Internal.TagEventJS$TagWrapper<T>;
        removeAll(tag: ResourceLocation): Internal.TagEventJS$TagWrapper<T>;
        post(event: string): void;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        getType(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(id: ResourceLocation): Internal.TagEventJS$TagWrapper<T>;
        toString(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get type(): string;
        get class(): Internal.Class<any>;
        set globalPriorityList(o: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class EntitySectionStorage <T> implements Internal.WorldEntityByChunkAccess, Internal.MovementTrackerCache {
        getClass(): Internal.Class<any>;
        handler$bgg000$forEachInBox(box: Internal.AABB, action: (arg0: any) => void, ci: Internal.CallbackInfo, minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        deduplicate(tracker: Internal.SectionedEntityMovementTracker<any, any>): Internal.SectionedEntityMovementTracker<any, any>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        getEntitiesInChunk(chunkX: number, chunkZ: number): Internal.Collection<any>;
        remove(tracker: Internal.SectionedEntityMovementTracker<any, any>): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ExplosionAccess {
    }
    class EnderMan extends Internal.Monster implements Internal.NeutralMob {
        getClass(): Internal.Class<any>;
        backpackedMoved(): boolean;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>;
        handler$zje000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void;
        updateNavigationRegistration(): void;
        onEndimationEnd(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        canBeRiddenInWater(arg0: Internal.Entity): boolean;
        handler$zzo000$tickHead(arg0: Internal.CallbackInfo): void;
        setCitadelEntityData(arg0: Internal.CompoundTag): void;
        isEndimationPlaying(arg0: Internal.PlayableEndimation): boolean;
        isActive(): boolean;
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void;
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity;
        getCachedFeetBlockState(): Internal.BlockState;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        handler$bfj000$tryShortcutFluidPushing(tag: net.minecraft.tags.Tag<any>, speed: number, cir: Internal.CallbackInfoReturnable<any>, box: Internal.AABB, x1: number, x2: number, y1: number, y2: number, z1: number, z2: number, zero: number): void;
        getPos(): Internal.Position;
        foodEatenKJS(is: Internal.ItemStack): void;
        revive(): void;
        static getDataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(arg0: boolean): void;
        canUpdate(): boolean;
        getEndimatedState(): Internal.Endimatable$EndimatedState;
        resetEndimation(): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean;
        getRegisteredNavigation(): Internal.PathNavigation;
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number;
        reviveCaps(): void;
        lithiumOnBlockCacheDeleted(): void;
        canRiderInteract(): boolean;
        getEntries(arg0: boolean): Internal.Set<any>;
        handler$zem000$curio$isLookingAtMe(arg0: Internal.Player, arg1: Internal.CallbackInfoReturnable<any>): void;
        getEffectHandler(): Internal.EndimationEffectHandler;
        onAddedToWorld(): void;
        setAnimationTick(arg0: number): void;
        isRegisteredToWorld(): boolean;
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        static getDataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        getListener(): Internal.NearbyEntityListenerMulti;
        getClassification(arg0: boolean): Internal.MobCategory;
        isNoEndimationPlaying(): boolean;
        onEndimationStart(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listenForCachedBlockChanges: boolean): void;
        shouldRiderSit(): boolean;
        getIsInsidePortal(): boolean;
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$zje000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        handler$zcg000$read(arg0: Internal.CompoundTag, arg1: Internal.CallbackInfo): void;
        getRemainingFireTicks(): number;
        lithiumOnEquipmentChanged(): void;
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void;
        notify(): void;
        getDataMap(): Internal.Map<any, any>;
        handler$zzo000$moveStep(arg0: Internal.MoverType, arg1: Vec3, arg2: Internal.CallbackInfo): void;
        getEntityChangeListener(): Internal.EntityInLevelCallback;
        endimateTick(): void;
        setDataMap(arg0: Internal.Map<any, any>): void;
        isDirty(): boolean;
        hashCode(): number;
        getLastPos(): BlockPos;
        isAddedToWorld(): boolean;
        setRegisteredToWorld(navigation: Internal.PathNavigation): void;
        getParts(): any[];
        addListener(listener: Internal.NearbyEntityListener): void;
        onRemovedFromWorld(): void;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        curePotionEffects(arg0: Internal.ItemStack): boolean;
        clean(): void;
        asKJS(): any;
        getPlayingEndimation(): Internal.PlayableEndimation;
        getDirtyEntries(): Internal.Set<any>;
        getValue(arg0: Internal.TrackedData<any>): any;
        shouldRiderFaceForward(arg0: Internal.Player): boolean;
        setPlayingEndimation(arg0: Internal.PlayableEndimation): void;
        setValue(arg0: Internal.TrackedData<any>, arg1: any): void;
        equals(arg0: any): boolean;
        getAnimationTick(): number;
        toString(): string;
        setRemainingFireTicks(arg0: number): void;
        handler$zgd001$tick(arg0: Internal.CallbackInfo): void;
        get citadelEntityData(): Internal.CompoundTag;
        get listener(): Internal.NearbyEntityListenerMulti;
        get addedToWorld(): boolean;
        get registeredNavigation(): Internal.PathNavigation;
        get animationTick(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get pos(): Internal.Position;
        get registeredToWorld(): boolean;
        get dataMap(): Internal.Map<any, any>;
        get noEndimationPlaying(): boolean;
        get class(): Internal.Class<any>;
        get dirty(): boolean;
        get dataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get entityChangeListener(): Internal.EntityInLevelCallback;
        get multipartEntity(): boolean;
        get active(): boolean;
        get playingEndimation(): Internal.PlayableEndimation;
        get effectHandler(): Internal.EndimationEffectHandler;
        get cachedFeetBlockState(): Internal.BlockState;
        get lastPos(): BlockPos;
        get dirtyEntries(): Internal.Set<any>;
        get dataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        get parts(): any[];
        get endimatedState(): Internal.Endimatable$EndimatedState;
        set animationTick(arg0: number);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set dataMap(arg0: Internal.Map<any, any>);
        set playingEndimation(arg0: Internal.PlayableEndimation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Property <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ItemEntity extends Internal.Entity implements Internal.ItemEntityAccess {
        getClass(): Internal.Class<any>;
        backpackedMoved(): boolean;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>;
        handler$zje000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void;
        onEndimationEnd(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        canBeRiddenInWater(arg0: Internal.Entity): boolean;
        handler$zzo000$tickHead(arg0: Internal.CallbackInfo): void;
        isEndimationPlaying(arg0: Internal.PlayableEndimation): boolean;
        isActive(): boolean;
        getCachedFeetBlockState(): Internal.BlockState;
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        handler$bfj000$tryShortcutFluidPushing(tag: net.minecraft.tags.Tag<any>, speed: number, cir: Internal.CallbackInfoReturnable<any>, box: Internal.AABB, x1: number, x2: number, y1: number, y2: number, z1: number, z2: number, zero: number): void;
        getPos(): Internal.Position;
        revive(): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(arg0: boolean): void;
        canUpdate(): boolean;
        getEndimatedState(): Internal.Endimatable$EndimatedState;
        handler$zfc000$onHurt(arg0: Internal.DamageSource, arg1: number, arg2: Internal.CallbackInfoReturnable<any>): void;
        resetEndimation(): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean;
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number;
        reviveCaps(): void;
        lithiumOnBlockCacheDeleted(): void;
        canRiderInteract(): boolean;
        getEntries(arg0: boolean): Internal.Set<any>;
        getEffectHandler(): Internal.EndimationEffectHandler;
        onAddedToWorld(): void;
        setAnimationTick(arg0: number): void;
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean;
        getListener(): Internal.NearbyEntityListenerMulti;
        getClassification(arg0: boolean): Internal.MobCategory;
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listening: boolean): void;
        isNoEndimationPlaying(): boolean;
        onEndimationStart(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        setAge(arg0: number): void;
        shouldRiderSit(): boolean;
        getIsInsidePortal(): boolean;
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$zje000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        handler$zcg000$read(arg0: Internal.CompoundTag, arg1: Internal.CallbackInfo): void;
        getRemainingFireTicks(): number;
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void;
        notify(): void;
        getDataMap(): Internal.Map<any, any>;
        handler$zzo000$moveStep(arg0: Internal.MoverType, arg1: Vec3, arg2: Internal.CallbackInfo): void;
        getEntityChangeListener(): Internal.EntityInLevelCallback;
        endimateTick(): void;
        setDataMap(arg0: Internal.Map<any, any>): void;
        isDirty(): boolean;
        hashCode(): number;
        isAddedToWorld(): boolean;
        getParts(): any[];
        addListener(listener: Internal.NearbyEntityListener): void;
        handler$zzp000$fireImmuneHead(arg0: Internal.CallbackInfoReturnable<any>): void;
        onRemovedFromWorld(): void;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        clean(): void;
        asKJS(): any;
        getPlayingEndimation(): Internal.PlayableEndimation;
        getDirtyEntries(): Internal.Set<any>;
        getValue(arg0: Internal.TrackedData<any>): any;
        setPlayingEndimation(arg0: Internal.PlayableEndimation): void;
        setValue(arg0: Internal.TrackedData<any>, arg1: any): void;
        equals(arg0: any): boolean;
        getAnimationTick(): number;
        toString(): string;
        setRemainingFireTicks(arg0: number): void;
        handler$zgd001$tick(arg0: Internal.CallbackInfo): void;
        lifespan : number;
        get dirty(): boolean;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get entityChangeListener(): Internal.EntityInLevelCallback;
        get listener(): Internal.NearbyEntityListenerMulti;
        get multipartEntity(): boolean;
        get active(): boolean;
        get addedToWorld(): boolean;
        get playingEndimation(): Internal.PlayableEndimation;
        get effectHandler(): Internal.EndimationEffectHandler;
        get cachedFeetBlockState(): Internal.BlockState;
        get dirtyEntries(): Internal.Set<any>;
        get animationTick(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get pos(): Internal.Position;
        get dataMap(): Internal.Map<any, any>;
        get noEndimationPlaying(): boolean;
        get parts(): any[];
        get endimatedState(): Internal.Endimatable$EndimatedState;
        get class(): Internal.Class<any>;
        set animationTick(arg0: number);
        set remainingFireTicks(arg0: number);
        set dataMap(arg0: Internal.Map<any, any>);
        set playingEndimation(arg0: Internal.PlayableEndimation);
        set age(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class StringBuffer extends Internal.AbstractStringBuilder implements Internal.Serializable, Internal.Comparable<Internal.StringBuffer>, Internal.CharSequence {
        deleteCharAt(arg0: number): Internal.StringBuffer;
        deleteCharAt(arg0: number): Internal.AbstractStringBuilder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        codePointAt(arg0: number): number;
        notifyAll(): void;
        setCharAt(arg0: number, arg1: string): void;
        replace(arg0: number, arg1: number, arg2: string): Internal.AbstractStringBuilder;
        replace(arg0: number, arg1: number, arg2: string): Internal.StringBuffer;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: number): Internal.StringBuffer;
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string): Internal.StringBuffer;
        insert(arg0: number, arg1: boolean): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: boolean): Internal.StringBuffer;
        insert(arg0: number, arg1: Internal.CharSequence, arg2: number, arg3: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: Internal.CharSequence, arg2: number, arg3: number): Internal.StringBuffer;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: number): Internal.StringBuffer;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: number): Internal.StringBuffer;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: number): Internal.StringBuffer;
        insert(arg0: number, arg1: any): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: any): Internal.StringBuffer;
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.StringBuffer;
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string): Internal.StringBuffer;
        insert(arg0: number, arg1: string[]): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string[]): Internal.StringBuffer;
        insert(arg0: number, arg1: Internal.CharSequence): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: Internal.CharSequence): Internal.StringBuffer;
        compareTo(arg0: Internal.StringBuffer): number;
        compareTo(arg0: any): number;
        delete(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        delete(arg0: number, arg1: number): Internal.StringBuffer;
        notify(): void;
        substring(arg0: number, arg1: number): string;
        substring(arg0: number): string;
        capacity(): number;
        appendCodePoint(arg0: number): Internal.AbstractStringBuilder;
        appendCodePoint(arg0: number): Internal.StringBuffer;
        hashCode(): number;
        codePointBefore(arg0: number): number;
        indexOf(arg0: string): number;
        indexOf(arg0: string, arg1: number): number;
        codePointCount(arg0: number, arg1: number): number;
        codePoints(): Internal.IntStream;
        trimToSize(): void;
        getChars(arg0: number, arg1: number, arg2: string[], arg3: number): void;
        isEmpty(): boolean;
        length(): number;
        subSequence(arg0: number, arg1: number): Internal.CharSequence;
        reverse(): Internal.StringBuffer;
        reverse(): Internal.AbstractStringBuilder;
        lastIndexOf(arg0: string, arg1: number): number;
        lastIndexOf(arg0: string): number;
        setLength(arg0: number): void;
        equals(arg0: any): boolean;
        toString(): string;
        ensureCapacity(arg0: number): void;
        chars(): Internal.IntStream;
        offsetByCodePoints(arg0: number, arg1: number): number;
        charAt(arg0: number): string;
        append(arg0: string[]): Internal.AbstractStringBuilder;
        append(arg0: string[]): Internal.StringBuffer;
        append(arg0: number): Internal.StringBuffer;
        append(arg0: number): Internal.AbstractStringBuilder;
        append(arg0: number): Internal.StringBuffer;
        append(arg0: number): Internal.AbstractStringBuilder;
        append(arg0: number): Internal.StringBuffer;
        append(arg0: number): Internal.AbstractStringBuilder;
        append(arg0: string[], arg1: number, arg2: number): Internal.StringBuffer;
        append(arg0: string[], arg1: number, arg2: number): Internal.AbstractStringBuilder;
        append(arg0: boolean): Internal.StringBuffer;
        append(arg0: boolean): Internal.AbstractStringBuilder;
        append(arg0: string): Internal.StringBuffer;
        append(arg0: string): Internal.AbstractStringBuilder;
        append(arg0: string): Internal.Appendable;
        append(arg0: number): Internal.AbstractStringBuilder;
        append(arg0: number): Internal.StringBuffer;
        append(arg0: string): Internal.AbstractStringBuilder;
        append(arg0: string): Internal.StringBuffer;
        append(arg0: Internal.StringBuffer): Internal.AbstractStringBuilder;
        append(arg0: Internal.StringBuffer): Internal.StringBuffer;
        append(arg0: Internal.CharSequence): Internal.AbstractStringBuilder;
        append(arg0: Internal.CharSequence): Internal.Appendable;
        append(arg0: Internal.CharSequence): Internal.StringBuffer;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.StringBuffer;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.AbstractStringBuilder;
        append(arg0: any): Internal.AbstractStringBuilder;
        append(arg0: any): Internal.StringBuffer;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LongConsumer {
        andThen(arg0: Internal.LongConsumer): Internal.LongConsumer;
        accept(arg0: number): void;
    }
    interface IdEnumerationIterator {
        enumerationIteratorNext(arg0: Internal.Context, arg1: (arg0: any) => void): boolean;
        enumerationIteratorHasNext(arg0: Internal.Context, arg1: (arg0: any) => void): boolean;
    }
    class LongSummaryStatistics implements Internal.LongConsumer, java_.util.function_.IntConsumer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMax(): number;
        notifyAll(): void;
        getAverage(): number;
        andThen(arg0: Internal.LongConsumer): Internal.LongConsumer;
        andThen(arg0: java_.util.function_.IntConsumer): java_.util.function_.IntConsumer;
        notify(): void;
        accept(arg0: number): void;
        accept(arg0: number): void;
        getMin(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getSum(): number;
        getCount(): number;
        combine(arg0: Internal.LongSummaryStatistics): void;
        get average(): number;
        get min(): number;
        get max(): number;
        get count(): number;
        get sum(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Appendable {
        append(arg0: Internal.CharSequence): Internal.Appendable;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable;
        append(arg0: string): Internal.Appendable;
    }
    class Font implements Internal.IAntiqueTextProvider {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setAntiqueInk(arg0: boolean): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        hasAntiqueInk(): boolean;
        get class(): Internal.Class<any>;
        set antiqueInk(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TransformStack extends Internal.Transform<Internal.TransformStack>, Internal.TStack<Internal.TransformStack> {
        rotate(arg0: number, arg1: (arg0: any) => boolean): Internal.TransformStack;
        rotate(arg0: Internal.Direction, arg1: number): Internal.TransformStack;
        translateAll(arg0: number): Internal.TransformStack;
        scale(arg0: number, arg1: number, arg2: number): Internal.TransformStack;
        scale(arg0: number): Internal.TransformStack;
        translate(arg0: number, arg1: number, arg2: number): Internal.TransformStack;
        translate(arg0: Internal.Vector3f): Internal.TransformStack;
        translate(arg0: Vec3): Internal.TransformStack;
        translate(arg0: Vec3i): Internal.TransformStack;
        translateZ(arg0: number): Internal.TransformStack;
        pushPose(): Internal.TransformStack;
        mulNormal(arg0: Internal.Matrix3f): Internal.TransformStack;
        transform(arg0: Internal.Matrix4f, arg1: Internal.Matrix3f): Internal.TransformStack;
        transform(arg0: Internal.PoseStack): Internal.TransformStack;
        translateY(arg0: number): Internal.TransformStack;
        translateX(arg0: number): Internal.TransformStack;
        multiply(arg0: Internal.Quaternion): Internal.TransformStack;
        multiply(arg0: Internal.Vector3f, arg1: number): Internal.TransformStack;
        rotateX(arg0: number): Internal.TransformStack;
        rotateY(arg0: number): Internal.TransformStack;
        translateBack(arg0: Vec3i): Internal.TransformStack;
        translateBack(arg0: number, arg1: number, arg2: number): Internal.TransformStack;
        translateBack(arg0: Vec3): Internal.TransformStack;
        rotateZ(arg0: number): Internal.TransformStack;
        rotateToFace(arg0: Internal.Direction): Internal.TransformStack;
        nudge(arg0: number): Internal.TransformStack;
        rotateCentered(arg0: Internal.Direction, arg1: number): Internal.TransformStack;
        rotateCentered(arg0: Internal.Quaternion): Internal.TransformStack;
        centre(): Internal.TransformStack;
        multiplyRadians(arg0: Internal.Vector3f, arg1: number): Internal.TransformStack;
        rotateZRadians(arg0: number): Internal.TransformStack;
        mulPose(arg0: Internal.Matrix4f): Internal.TransformStack;
        rotateYRadians(arg0: number): Internal.TransformStack;
        rotateXRadians(arg0: number): Internal.TransformStack;
        popPose(): Internal.TransformStack;
        unCentre(): Internal.TransformStack;
    }
    interface EntityAccessor {
        getIsInsidePortal(): boolean;
    }
    interface EndimationEffectSource {
        getPos(): Internal.Position;
        isActive(): boolean;
    }
    class ImmutableMultiset$Builder <E> extends Internal.ImmutableCollection$Builder<any> {
        add(arg0: any): Internal.ImmutableCollection$Builder<any>;
        add(arg0: E): Internal.ImmutableMultiset$Builder<E>;
        add(arg0: any[]): Internal.ImmutableCollection$Builder<any>;
        add(arg0: E[]): Internal.ImmutableMultiset$Builder<E>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.ImmutableCollection<any>;
        build(): Internal.ImmutableMultiset<E>;
        addAll(arg0: Internal.Iterable<any>): Internal.ImmutableCollection$Builder<any>;
        addAll(arg0: Internal.Iterable<E>): Internal.ImmutableMultiset$Builder<E>;
        addAll(arg0: Internal.Iterator<any>): Internal.ImmutableCollection$Builder<any>;
        addAll(arg0: Internal.Iterator<E>): Internal.ImmutableMultiset$Builder<E>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        addCopies(arg0: E, arg1: number): Internal.ImmutableMultiset$Builder<E>;
        notify(): void;
        setCount(arg0: E, arg1: number): Internal.ImmutableMultiset$Builder<E>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjLongConsumer <T> {
        accept(arg0: T, arg1: number): void;
    }
    abstract class ForwardingMultimap <K, V> extends Internal.ForwardingObject implements Internal.Multimap<K, V> {
        getClass(): Internal.Class<any>;
        containsEntry(arg0: any, arg1: any): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        asMap(): Internal.Map<K, Internal.Collection<V>>;
        keys(): Internal.Multiset<K>;
        containsKey(arg0: any): boolean;
        notifyAll(): void;
        values(): Internal.Collection<V>;
        isEmpty(): boolean;
        clear(): void;
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.Collection<V>;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): boolean;
        remove(arg0: any, arg1: any): boolean;
        removeAll(arg0: any): Internal.Collection<V>;
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>;
        size(): number;
        hashCode(): number;
        putAll(arg0: Internal.Multimap<K, V>): boolean;
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean;
        equals(arg0: any): boolean;
        get(arg0: K): Internal.Collection<V>;
        toString(): string;
        keySet(): Internal.Set<K>;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class NearbyEntityListenerMulti implements Internal.NearbyEntityListener {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        onSectionLeftRange<T_>(entityTrackingSection: any, collection: Internal.ClassInstanceMultiMap<T_>): void;
        onSectionEnteredRange<T_>(entityTrackingSection: any, collection: Internal.ClassInstanceMultiMap<T_>): void;
        onEntityLeftRange(entity: Internal.Entity): void;
        removeListener(listener: Internal.NearbyEntityListener): void;
        notify(): void;
        getEntityClass(): Internal.Class<Internal.Entity>;
        getChunkRange(): Internal.Range6Int;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        forEachChunkInRangeChange(entityCache: Internal.EntitySectionStorage<Internal.EntityAccess>, prevCenterPos: Internal.SectionPos, newCenterPos: Internal.SectionPos): void;
        onEntityEnteredRange(entity: Internal.Entity): void;
        addListener(listener: Internal.NearbyEntityListener): void;
        static readonly EMPTY_RANGE : Internal.Range6Int;
        get chunkRange(): Internal.Range6Int;
        get entityClass(): Internal.Class<Internal.Entity>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Runnable {
        run(): void;
    }
    class JsonReader implements Internal.Closeable {
        skipValue(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isLenient(): boolean;
        notifyAll(): void;
        hasNext(): boolean;
        nextInt(): number;
        endArray(): void;
        nextString(): string;
        nextLong(): number;
        setLenient(arg0: boolean): void;
        notify(): void;
        nextDouble(): number;
        endObject(): void;
        peek(): Internal.JsonToken;
        beginArray(): void;
        beginObject(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getPath(): string;
        toString(): string;
        nextBoolean(): boolean;
        nextName(): string;
        close(): void;
        nextNull(): void;
        get path(): string;
        get class(): Internal.Class<any>;
        get lenient(): boolean;
        set lenient(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MethodType implements Internal.Constable, Internal.TypeDescriptor$OfMethod<Internal.Class<any>, Internal.MethodType>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        toMethodDescriptorString(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        dropParameterTypes(arg0: number, arg1: number): Internal.TypeDescriptor$OfMethod<any, any>;
        dropParameterTypes(arg0: number, arg1: number): Internal.MethodType;
        changeReturnType(arg0: Internal.Class<any>): Internal.MethodType;
        changeReturnType(arg0: Internal.TypeDescriptor$OfField<any>): Internal.TypeDescriptor$OfMethod<any, any>;
        notifyAll(): void;
        static fromMethodDescriptorString(arg0: string, arg1: Internal.ClassLoader): Internal.MethodType;
        lastParameterType(): Internal.Class<any>;
        describeConstable(): Internal.Optional<Internal.MethodTypeDesc>;
        notify(): void;
        changeParameterType(arg0: number, arg1: Internal.TypeDescriptor$OfField<any>): Internal.TypeDescriptor$OfMethod<any, any>;
        changeParameterType(arg0: number, arg1: Internal.Class<any>): Internal.MethodType;
        unwrap(): Internal.MethodType;
        hasWrappers(): boolean;
        static methodType(arg0: Internal.Class<any>, arg1: Internal.Class<any>[]): Internal.MethodType;
        static methodType(arg0: Internal.Class<any>, arg1: Internal.MethodType): Internal.MethodType;
        static methodType(arg0: Internal.Class<any>, arg1: Internal.Class<any>, arg2: Internal.Class<any>[]): Internal.MethodType;
        static methodType(arg0: Internal.Class<any>, arg1: Internal.List<Internal.Class<any>>): Internal.MethodType;
        static methodType(arg0: Internal.Class<any>, arg1: Internal.Class<any>): Internal.MethodType;
        static methodType(arg0: Internal.Class<any>): Internal.MethodType;
        parameterArray(): Internal.Class<any>[];
        parameterArray(): Internal.TypeDescriptor$OfField[];
        hashCode(): number;
        appendParameterTypes(arg0: Internal.List<Internal.Class<any>>): Internal.MethodType;
        appendParameterTypes(arg0: Internal.Class<any>[]): Internal.MethodType;
        parameterType(arg0: number): Internal.Class<any>;
        parameterType(arg0: number): Internal.TypeDescriptor$OfField<any>;
        erase(): Internal.MethodType;
        parameterCount(): number;
        descriptorString(): string;
        insertParameterTypes(arg0: number, arg1: Internal.List<Internal.Class<any>>): Internal.MethodType;
        insertParameterTypes(arg0: number, arg1: Internal.Class<any>[]): Internal.MethodType;
        insertParameterTypes(arg0: number, arg1: Internal.TypeDescriptor$OfField[]): Internal.TypeDescriptor$OfMethod<any, any>;
        generic(): Internal.MethodType;
        hasPrimitives(): boolean;
        equals(arg0: any): boolean;
        parameterList(): Internal.List<Internal.Class<any>>;
        toString(): string;
        static genericMethodType(arg0: number, arg1: boolean): Internal.MethodType;
        static genericMethodType(arg0: number): Internal.MethodType;
        wrap(): Internal.MethodType;
        returnType(): Internal.Class<any>;
        returnType(): Internal.TypeDescriptor$OfField<any>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Long2ObjectFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.LongFunction<V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: number, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        put(arg0: number, arg1: V): V;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: V): V;
        remove(arg0: number): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): V;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface IntIterable extends Internal.Iterable<number> {
        iterator(): Internal.Iterator<any>;
        iterator(): Internal.IntIterator;
        spliterator(): Internal.Spliterator<any>;
        spliterator(): Internal.IntSpliterator;
        forEach(arg0: java_.util.function_.IntConsumer): void;
        forEach(arg0: (arg0: number) => void): void;
        forEach(arg0: (arg0: any) => void): void;
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
    }
    interface BlockGetter extends Internal.LevelHeightAccessor {
    }
    class LootContextJS {
        getBlockPos(): BlockPos;
        cancel(): void;
        getClass(): Internal.Class<any>;
        findLoot(arg0: Internal.IngredientJS): Internal.List<Internal.ItemStackJS>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.PlayerJS<any>;
        getCustomData(): Internal.Map<string, any>;
        isCanceled(): boolean;
        notifyAll(): void;
        getTool(): Internal.ItemStackJS;
        getLootTableId(): ResourceLocation;
        notify(): void;
        lootSize(): number;
        isExploded(): boolean;
        getRandom(): Internal.Random;
        hashCode(): number;
        forEachLoot(arg0: (arg0: Internal.ItemStackJS) => void): void;
        getVanillaContext(): Internal.LootContext;
        getDestroyedBlock(): Internal.BlockContainerJS;
        getServer(): Internal.ServerJS;
        hasLoot(arg0: Internal.IngredientJS): boolean;
        getLuck(): number;
        getEntity(): Internal.EntityJS;
        getLooting(): number;
        addLoot(arg0: Internal.ItemStackJS): void;
        getLevel(): Internal.LevelJS;
        getPosition(): Vec3;
        getDamageSource(): Internal.DamageSourceJS;
        getType(): LootType;
        equals(arg0: any): boolean;
        getExplosionRadius(): number;
        toString(): string;
        removeLoot(arg0: Internal.IngredientJS): void;
        getKillerEntity(): Internal.EntityJS;
        get server(): Internal.ServerJS;
        get luck(): number;
        get blockPos(): BlockPos;
        get exploded(): boolean;
        get level(): Internal.LevelJS;
        get looting(): number;
        get damageSource(): Internal.DamageSourceJS;
        get killerEntity(): Internal.EntityJS;
        get customData(): Internal.Map<string, any>;
        get vanillaContext(): Internal.LootContext;
        get type(): LootType;
        get tool(): Internal.ItemStackJS;
        get explosionRadius(): number;
        get lootTableId(): ResourceLocation;
        get canceled(): boolean;
        get random(): Internal.Random;
        get destroyedBlock(): Internal.BlockContainerJS;
        get position(): Vec3;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class BlockBehaviour extends Internal.ForgeRegistryEntry<any> implements Internal.BlockAccessor, Internal.BlockKJS {
        getBlockStatesKJS(): Internal.List<Internal.BlockState>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setExplosionResistanceKJS(arg0: number): void;
        notifyAll(): void;
        setJumpFactorKJS(arg0: number): void;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: string, arg1: string): Internal.Block;
        setRegistryName(arg0: ResourceLocation): any;
        setRegistryName(arg0: ResourceLocation): Internal.Block;
        setRegistryName(arg0: string): Internal.Block;
        setIsRandomlyTickingKJS(arg0: boolean): void;
        notify(): void;
        setMaterialKJS(arg0: net.minecraft.world.level.material.Material): void;
        getMaterial(): net.minecraft.world.level.material.Material;
        setSoundTypeKJS(arg0: Internal.SoundType): void;
        hashCode(): number;
        getBlockBuilderKJS(): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.Block>;
        setSpeedFactorKJS(arg0: number): void;
        setBlockBuilderKJS(b: Internal.BlockBuilder): void;
        toString(): string;
        setFrictionKJS(arg0: number): void;
        setHasCollisionKJS(arg0: boolean): void;
        readonly delegate : () => Internal.Block;
        get registryType(): Internal.Class<Internal.Block>;
        get blockBuilderKJS(): Internal.BlockBuilder;
        get material(): net.minecraft.world.level.material.Material;
        get blockStatesKJS(): Internal.List<Internal.BlockState>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set jumpFactorKJS(arg0: number);
        set isRandomlyTickingKJS(arg0: boolean);
        set frictionKJS(arg0: number);
        set blockBuilderKJS(b: Internal.BlockBuilder);
        set hasCollisionKJS(arg0: boolean);
        set materialKJS(arg0: net.minecraft.world.level.material.Material);
        set speedFactorKJS(arg0: number);
        set soundTypeKJS(arg0: Internal.SoundType);
        set explosionResistanceKJS(arg0: number);
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface CompletionStage <T> {
        exceptionallyAsync(arg0: (arg0: Internal.Throwable) => T, arg1: Internal.Executor): Internal.CompletionStage<T>;
        exceptionallyAsync(arg0: (arg0: Internal.Throwable) => T): Internal.CompletionStage<T>;
        thenRunAsync(arg0: Internal.Runnable): Internal.CompletionStage<void>;
        thenRunAsync(arg0: Internal.Runnable, arg1: Internal.Executor): Internal.CompletionStage<void>;
        runAfterBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletionStage<void>;
        runAfterBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<void>;
        applyToEitherAsync<U>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U, arg2: Internal.Executor): Internal.CompletionStage<U>;
        applyToEitherAsync<U>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U): Internal.CompletionStage<U>;
        acceptEitherAsync(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void): Internal.CompletionStage<void>;
        acceptEitherAsync(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void, arg2: Internal.Executor): Internal.CompletionStage<void>;
        runAfterEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<void>;
        runAfterEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletionStage<void>;
        acceptEither(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void): Internal.CompletionStage<void>;
        thenAcceptBoth<U>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => void): Internal.CompletionStage<void>;
        exceptionallyCompose(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>): Internal.CompletionStage<T>;
        applyToEither<U>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U): Internal.CompletionStage<U>;
        runAfterEither(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<void>;
        thenApply<U>(arg0: (arg0: T) => U): Internal.CompletionStage<U>;
        thenComposeAsync<U>(arg0: (arg0: T) => Internal.CompletionStage<U>, arg1: Internal.Executor): Internal.CompletionStage<U>;
        thenComposeAsync<U>(arg0: (arg0: T) => Internal.CompletionStage<U>): Internal.CompletionStage<U>;
        thenAccept(arg0: (arg0: T) => void): Internal.CompletionStage<void>;
        thenRun(arg0: Internal.Runnable): Internal.CompletionStage<void>;
        runAfterBoth(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<void>;
        exceptionally(arg0: (arg0: Internal.Throwable) => T): Internal.CompletionStage<T>;
        handleAsync<U>(arg0: (arg0: T, arg1: Internal.Throwable) => U, arg1: Internal.Executor): Internal.CompletionStage<U>;
        handleAsync<U>(arg0: (arg0: T, arg1: Internal.Throwable) => U): Internal.CompletionStage<U>;
        handle<U>(arg0: (arg0: T, arg1: Internal.Throwable) => U): Internal.CompletionStage<U>;
        thenCompose<U>(arg0: (arg0: T) => Internal.CompletionStage<U>): Internal.CompletionStage<U>;
        whenComplete(arg0: (arg0: T, arg1: Internal.Throwable) => void): Internal.CompletionStage<T>;
        thenCombineAsync<U, V>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => V, arg2: Internal.Executor): Internal.CompletionStage<V>;
        thenCombineAsync<U, V>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => V): Internal.CompletionStage<V>;
        thenAcceptBothAsync<U>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => void, arg2: Internal.Executor): Internal.CompletionStage<void>;
        thenAcceptBothAsync<U>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => void): Internal.CompletionStage<void>;
        exceptionallyComposeAsync(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>): Internal.CompletionStage<T>;
        exceptionallyComposeAsync(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>, arg1: Internal.Executor): Internal.CompletionStage<T>;
        thenCombine<U, V>(arg0: Internal.CompletionStage<U>, arg1: (arg0: T, arg1: U) => V): Internal.CompletionStage<V>;
        whenCompleteAsync(arg0: (arg0: T, arg1: Internal.Throwable) => void): Internal.CompletionStage<T>;
        whenCompleteAsync(arg0: (arg0: T, arg1: Internal.Throwable) => void, arg1: Internal.Executor): Internal.CompletionStage<T>;
        thenApplyAsync<U>(arg0: (arg0: T) => U, arg1: Internal.Executor): Internal.CompletionStage<U>;
        thenApplyAsync<U>(arg0: (arg0: T) => U): Internal.CompletionStage<U>;
        thenAcceptAsync(arg0: (arg0: T) => void): Internal.CompletionStage<void>;
        thenAcceptAsync(arg0: (arg0: T) => void, arg1: Internal.Executor): Internal.CompletionStage<void>;
        toCompletableFuture(): Internal.CompletableFuture<T>;
    }
    class ClocheFertilizerRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        growthModifier(f: number): Internal.ClocheFertilizerRecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        energy(e: number): Internal.IERecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        time(t: number): Internal.IERecipeJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<net.minecraftforge.fluids.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DataResult <R> implements Internal.App<Internal.DataResult$Mu, R> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static instance(): Internal.DataResult$Instance;
        setPartial(arg0: R): Internal.DataResult<R>;
        setPartial(arg0: () => R): Internal.DataResult<R>;
        notifyAll(): void;
        addLifecycle(arg0: Internal.Lifecycle): Internal.DataResult<R>;
        static partialGet<K_, V_>(arg0: (arg0: K_) => V_, arg1: () => string): (arg0: K_) => Internal.DataResult<V_>;
        static error<R_>(arg0: string, arg1: R_, arg2: Internal.Lifecycle): Internal.DataResult<R_>;
        error(): Internal.Optional<Internal.DataResult$PartialResult<R>>;
        static error<R_>(arg0: string): Internal.DataResult<R_>;
        static error<R_>(arg0: string, arg1: Internal.Lifecycle): Internal.DataResult<R_>;
        static error<R_>(arg0: string, arg1: R_): Internal.DataResult<R_>;
        notify(): void;
        promotePartial(arg0: (arg0: string) => void): Internal.DataResult<R>;
        lifecycle(): Internal.Lifecycle;
        result(): Internal.Optional<R>;
        setLifecycle(arg0: Internal.Lifecycle): Internal.DataResult<R>;
        hashCode(): number;
        get(): Internal.Either<R, Internal.DataResult$PartialResult<R>>;
        map<T_>(arg0: (arg0: R) => T_): Internal.DataResult<T_>;
        resultOrPartial(arg0: (arg0: string) => void): Internal.Optional<R>;
        apply2<R2_, S_>(arg0: (arg0: R, arg1: R2_) => S_, arg1: Internal.DataResult<R2_>): Internal.DataResult<S_>;
        apply3<R2_, R3_, S_>(arg0: Internal.Function3<R, R2_, R3_, S_>, arg1: Internal.DataResult<R2_>, arg2: Internal.DataResult<R3_>): Internal.DataResult<S_>;
        apply2stable<R2_, S_>(arg0: (arg0: R, arg1: R2_) => S_, arg1: Internal.DataResult<R2_>): Internal.DataResult<S_>;
        ap<R2_>(arg0: Internal.DataResult<(arg0: R) => R2_>): Internal.DataResult<R2_>;
        flatMap<R2_>(arg0: (arg0: R) => Internal.DataResult<R2_>): Internal.DataResult<R2_>;
        mapError(arg0: (arg0: any) => any): Internal.DataResult<R>;
        static success<R_>(arg0: R_, arg1: Internal.Lifecycle): Internal.DataResult<R_>;
        static success<R_>(arg0: R_): Internal.DataResult<R_>;
        static unbox<R_>(arg0: Internal.App<Internal.DataResult$Mu, R_>): Internal.DataResult<R_>;
        getOrThrow(arg0: boolean, arg1: (arg0: string) => void): R;
        equals(arg0: any): boolean;
        toString(): string;
        get class(): Internal.Class<any>;
        set partial(arg0: R);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DoubleStream extends Internal.BaseStream<number, Internal.DoubleStream> {
        average(): Internal.OptionalDouble;
        sequential(): Internal.BaseStream<any, any>;
        sequential(): Internal.DoubleStream;
        takeWhile(arg0: Internal.DoublePredicate): Internal.DoubleStream;
        distinct(): Internal.DoubleStream;
        findFirst(): Internal.OptionalDouble;
        sum(): number;
        skip(arg0: number): Internal.DoubleStream;
        allMatch(arg0: Internal.DoublePredicate): boolean;
        mapToObj<U_>(arg0: Internal.DoubleFunction<U_>): Internal.Stream<U_>;
        mapMulti(arg0: Internal.DoubleStream$DoubleMapMultiConsumer): Internal.DoubleStream;
        iterator(): Internal.PrimitiveIterator$OfDouble;
        iterator(): Internal.Iterator<any>;
        min(): Internal.OptionalDouble;
        mapToLong(arg0: Internal.DoubleToLongFunction): Internal.LongStream;
        parallel(): Internal.BaseStream<any, any>;
        parallel(): Internal.DoubleStream;
        noneMatch(arg0: Internal.DoublePredicate): boolean;
        findAny(): Internal.OptionalDouble;
        isParallel(): boolean;
        limit(arg0: number): Internal.DoubleStream;
        toArray(): number[];
        forEachOrdered(arg0: Internal.DoubleConsumer): void;
        close(): void;
        anyMatch(arg0: Internal.DoublePredicate): boolean;
        map(arg0: Internal.DoubleUnaryOperator): Internal.DoubleStream;
        unordered(): Internal.DoubleStream;
        reduce(arg0: number, arg1: Internal.DoubleBinaryOperator): number;
        reduce(arg0: Internal.DoubleBinaryOperator): Internal.OptionalDouble;
        spliterator(): Internal.Spliterator<any>;
        spliterator(): Internal.Spliterator$OfDouble;
        max(): Internal.OptionalDouble;
        forEach(arg0: Internal.DoubleConsumer): void;
        count(): number;
        dropWhile(arg0: Internal.DoublePredicate): Internal.DoubleStream;
        peek(arg0: Internal.DoubleConsumer): Internal.DoubleStream;
        flatMap(arg0: Internal.DoubleFunction<Internal.DoubleStream>): Internal.DoubleStream;
        filter(arg0: Internal.DoublePredicate): Internal.DoubleStream;
        onClose(arg0: Internal.Runnable): Internal.DoubleStream;
        sorted(): Internal.DoubleStream;
        boxed(): Internal.Stream<number>;
        summaryStatistics(): Internal.DoubleSummaryStatistics;
        mapToInt(arg0: Internal.DoubleToIntFunction): Internal.IntStream;
        collect<R_>(arg0: () => R_, arg1: Internal.ObjDoubleConsumer<R_>, arg2: (arg0: R_, arg1: R_) => void): R_;
    }
    interface TemporalAmount {
        subtractFrom(arg0: Internal.Temporal): Internal.Temporal;
        get(arg0: Internal.TemporalUnit): number;
        getUnits(): Internal.List<Internal.TemporalUnit>;
        addTo(arg0: Internal.Temporal): Internal.Temporal;
    }
    abstract class Record {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface App <F, A> {
    }
    class SimpleContainer implements Internal.Container, Internal.StackedContentsCompatible {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LevelSimulatedReader {
    }
    class PropertyMap extends Internal.ForwardingMultimap<any, any> {
        getClass(): Internal.Class<any>;
        containsEntry(arg0: any, arg1: any): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        forEach(arg0: (arg0: string, arg1: com.mojang.authlib.properties.Property) => void): void;
        asMap(): Internal.Map<string, Internal.Collection<com.mojang.authlib.properties.Property>>;
        keys(): Internal.Multiset<string>;
        containsKey(arg0: any): boolean;
        notifyAll(): void;
        values(): Internal.Collection<com.mojang.authlib.properties.Property>;
        isEmpty(): boolean;
        clear(): void;
        replaceValues(arg0: string, arg1: Internal.Iterable<com.mojang.authlib.properties.Property>): Internal.Collection<com.mojang.authlib.properties.Property>;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: string, arg1: com.mojang.authlib.properties.Property): boolean;
        remove(arg0: any, arg1: any): boolean;
        removeAll(arg0: any): Internal.Collection<com.mojang.authlib.properties.Property>;
        entries(): Internal.Collection<Internal.Map$Entry<string, com.mojang.authlib.properties.Property>>;
        size(): number;
        hashCode(): number;
        putAll(arg0: Internal.Multimap<string, com.mojang.authlib.properties.Property>): boolean;
        putAll(arg0: string, arg1: Internal.Iterable<com.mojang.authlib.properties.Property>): boolean;
        equals(arg0: any): boolean;
        get(arg0: string): Internal.Collection<com.mojang.authlib.properties.Property>;
        toString(): string;
        keySet(): Internal.Set<string>;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Matrix3fExtended {
        getA20(): number;
        rotate(arg0: Internal.Quaternion): void;
        getA21(): number;
        getA10(): number;
        getA22(): number;
        getA11(): number;
        getA00(): number;
        getA01(): number;
        getA12(): number;
        getA02(): number;
        transformVecZ(dir: Internal.Vector3f): number;
        transformVecZ(arg0: number, arg1: number, arg2: number): number;
        transformVecY(dir: Internal.Vector3f): number;
        transformVecY(arg0: number, arg1: number, arg2: number): number;
        transformVecX(arg0: number, arg1: number, arg2: number): number;
        transformVecX(dir: Internal.Vector3f): number;
        computeNormal(arg0: Internal.Direction): number;
    }
    interface ChannelInboundHandler extends Internal.ChannelHandler {
        channelInactive(arg0: Internal.ChannelHandlerContext): void;
        channelUnregistered(arg0: Internal.ChannelHandlerContext): void;
        channelReadComplete(arg0: Internal.ChannelHandlerContext): void;
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void;
        channelActive(arg0: Internal.ChannelHandlerContext): void;
        handlerAdded(arg0: Internal.ChannelHandlerContext): void;
        userEventTriggered(arg0: Internal.ChannelHandlerContext, arg1: any): void;
        channelRegistered(arg0: Internal.ChannelHandlerContext): void;
        handlerRemoved(arg0: Internal.ChannelHandlerContext): void;
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext): void;
        channelRead(arg0: Internal.ChannelHandlerContext, arg1: any): void;
    }
    interface ItemHandler extends Internal.Iterable<Internal.ItemStack> {
        getHeight(): number;
        iterator(): Internal.Iterator<Internal.ItemStack>;
        spliterator(): Internal.Spliterator<Internal.ItemStack>;
        extractItem(arg0: number, arg1: number, arg2: boolean): Internal.ItemStack;
        forEach(arg0: (arg0: Internal.ItemStack) => void): void;
        getSlotLimit(arg0: number): number;
        isItemValid(arg0: number, arg1: Internal.ItemStack): boolean;
        getStackInSlot(arg0: number): Internal.ItemStack;
        getSlots(): number;
        getWidth(): number;
        insertItem(arg0: number, arg1: Internal.ItemStack, arg2: boolean): Internal.ItemStack;
    }
    interface NonNullSupplier <T> {
        get(): T;
    }
    class Scoreboard {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IFluidHandler {
        getFluidInTank(arg0: number): net.minecraftforge.fluids.FluidStack;
        getTankCapacity(arg0: number): number;
        fill(arg0: net.minecraftforge.fluids.FluidStack, arg1: Internal.IFluidHandler$FluidAction): number;
        getTanks(): number;
        isFluidValid(arg0: number, arg1: net.minecraftforge.fluids.FluidStack): boolean;
        drain(arg0: number, arg1: Internal.IFluidHandler$FluidAction): net.minecraftforge.fluids.FluidStack;
        drain(arg0: net.minecraftforge.fluids.FluidStack, arg1: Internal.IFluidHandler$FluidAction): net.minecraftforge.fluids.FluidStack;
    }
    class EvaluatorException extends Internal.RhinoException {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLocalizedMessage(): string;
        getScriptStack(limit: number, hideFunction: string): any[];
        getScriptStack(): any[];
        notifyAll(): void;
        initColumnNumber(columnNumber: number): void;
        getCause(): Internal.Throwable;
        notify(): void;
        getScriptStackTrace(): string;
        getScriptStackTrace(limit: number, functionName: string): string;
        addSuppressed(arg0: Internal.Throwable): void;
        getStackTrace(): Internal.StackTraceElement[];
        columnNumber(): number;
        hashCode(): number;
        getSuppressed(): Internal.Throwable[];
        details(): string;
        printStackTrace(s: Internal.PrintWriter): void;
        printStackTrace(s: Internal.PrintStream): void;
        printStackTrace(): void;
        initSourceName(sourceName: string): void;
        initCause(arg0: Internal.Throwable): Internal.Throwable;
        getMessage(): string;
        initLineSource(lineSource: string): void;
        setStackTrace(arg0: Internal.StackTraceElement[]): void;
        lineSource(): string;
        equals(arg0: any): boolean;
        initLineNumber(lineNumber: number): void;
        toString(): string;
        sourceName(): string;
        lineNumber(): number;
        fillInStackTrace(): Internal.Throwable;
        get localizedMessage(): string;
        get scriptStack(): any[];
        get cause(): Internal.Throwable;
        get scriptStackTrace(): string;
        get stackTrace(): Internal.StackTraceElement[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        set stackTrace(arg0: Internal.StackTraceElement[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EffectInstanceAccess {
        getEffect(): Internal.MobEffect;
    }
    class RecordCodecBuilder <O, F> implements Internal.App<Internal.RecordCodecBuilder$Mu<O>, F> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static instance<O_>(): Internal.RecordCodecBuilder$Instance<O_>;
        static mapCodec<O_>(arg0: (arg0: Internal.RecordCodecBuilder$Instance<O_>) => Internal.App<Internal.RecordCodecBuilder$Mu<O_>, O_>): Internal.MapCodec<O_>;
        notifyAll(): void;
        static deprecated<O_, F_>(arg0: F_, arg1: number): Internal.RecordCodecBuilder<O_, F_>;
        notify(): void;
        static point<O_, F_>(arg0: F_): Internal.RecordCodecBuilder<O_, F_>;
        static point<O_, F_>(arg0: F_, arg1: Internal.Lifecycle): Internal.RecordCodecBuilder<O_, F_>;
        static build<O_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O_>, O_>): Internal.MapCodec<O_>;
        hashCode(): number;
        static stable<O_, F_>(arg0: F_): Internal.RecordCodecBuilder<O_, F_>;
        static unbox<O_, F_>(arg0: Internal.App<Internal.RecordCodecBuilder$Mu<O_>, F_>): Internal.RecordCodecBuilder<O_, F_>;
        equals(arg0: any): boolean;
        static of<O_, F_>(arg0: (arg0: O_) => F_, arg1: string, arg2: Internal.Codec<F_>): Internal.RecordCodecBuilder<O_, F_>;
        static of<O_, F_>(arg0: (arg0: O_) => F_, arg1: Internal.MapCodec<F_>): Internal.RecordCodecBuilder<O_, F_>;
        static create<O_>(arg0: (arg0: Internal.RecordCodecBuilder$Instance<O_>) => Internal.App<Internal.RecordCodecBuilder$Mu<O_>, O_>): Internal.Codec<O_>;
        toString(): string;
        dependent<E_>(arg0: (arg0: O) => E_, arg1: Internal.MapEncoder<E_>, arg2: (arg0: Internal.RecordCodecBuilder$Mu<O>) => Internal.MapDecoder<E_>): Internal.RecordCodecBuilder<O, E_>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Float2DoubleFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface PublicKey extends Internal.Key {
        getEncoded(): number[];
        getAlgorithm(): string;
        getFormat(): string;
    }
    interface FormattedCharSequence {
    }
    interface IForgeBlock {
        rotate(arg0: Internal.BlockState, arg1: Internal.LevelAccessor, arg2: BlockPos, arg3: Internal.Rotation): Internal.BlockState;
        getStateAtViewpoint(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Vec3): Internal.BlockState;
        onBlockExploded(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Explosion): void;
        getBedDirection(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): Internal.Direction;
        getExpDrop(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: number, arg4: number): number;
        isConduitFrame(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): boolean;
        getLightEmission(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): number;
        onDestroyedByPlayer(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Player, arg4: boolean, arg5: Internal.FluidState): boolean;
        getTags(): Internal.Set<ResourceLocation>;
        isBed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean;
        canHarvestBlock(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Player): boolean;
        shouldCheckWeakPower(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean;
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.BlockState): boolean;
        collisionExtendsVertically(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean;
        isLadder(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean;
        addLandingEffects(arg0: Internal.BlockState, arg1: Internal.ServerLevel, arg2: BlockPos, arg3: Internal.BlockState, arg4: Internal.LivingEntity, arg5: number): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockState, arg1: Internal.BlockAndTintGetter, arg2: BlockPos, arg3: Internal.FluidState): boolean;
        getSoundType(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): Internal.SoundType;
        canStickTo(arg0: Internal.BlockState, arg1: Internal.BlockState): boolean;
        onNeighborChange(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): void;
        addRunningEffects(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Entity): boolean;
        getWeakChanges(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): boolean;
        isBurning(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean;
        canEntityDestroy(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean;
        getCloneItemStack(arg0: Internal.BlockState, arg1: Internal.HitResult, arg2: Internal.BlockGetter, arg3: BlockPos, arg4: Internal.Player): Internal.ItemStack;
        getFriction(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): number;
        isFlammable(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean;
        isValidSpawn(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.SpawnPlacements$Type, arg4: Internal.EntityType<any>): boolean;
        isPortalFrame(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean;
        getExplosionResistance(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): number;
        canSustainPlant(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.IPlantable): boolean;
        isScaffolding(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean;
        onCaughtFire(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.LivingEntity): void;
        getEnchantPowerBonus(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): number;
        setBedOccupied(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.LivingEntity, arg4: boolean): void;
        isFireSource(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean;
        canDropFromExplosion(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): boolean;
        getRespawnPosition(arg0: Internal.BlockState, arg1: Internal.EntityType<any>, arg2: Internal.LevelReader, arg3: BlockPos, arg4: number, arg5: Internal.LivingEntity): Internal.Optional<Vec3>;
        isStickyBlock(arg0: Internal.BlockState): boolean;
        isFertile(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean;
        getAiPathNodeType(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Mob): Internal.BlockPathTypes;
        isSlimeBlock(arg0: Internal.BlockState): boolean;
        canConnectRedstone(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean;
        getFlammability(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number;
        getFireSpreadSpeed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number;
        getToolModifiedState(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Player, arg4: Internal.ItemStack, arg5: Internal.ToolAction): Internal.BlockState;
        getBeaconColorMultiplier(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): number[];
    }
    class MobSpawnSettings$SpawnerData extends Internal.WeightedEntry$IntrusiveBase {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeBakedModel {
        doesHandlePerspectives(): boolean;
        getModelData(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.BlockState, arg3: Internal.IModelData): Internal.IModelData;
        isLayered(): boolean;
        handlePerspective(arg0: Internal.ItemTransforms$TransformType, arg1: Internal.PoseStack): Internal.BakedModel;
        useAmbientOcclusion(arg0: Internal.BlockState): boolean;
        getQuads(arg0: Internal.BlockState, arg1: Internal.Direction, arg2: Internal.Random, arg3: Internal.IModelData): Internal.List<Internal.BakedQuad>;
        getLayerModels(arg0: Internal.ItemStack, arg1: boolean): Internal.List<Internal.Pair<Internal.BakedModel, Internal.RenderType>>;
        getParticleIcon(arg0: Internal.IModelData): Internal.TextureAtlasSprite;
    }
    interface Function <T, R> {
        compose<V>(arg0: (arg0: V) => T): (arg0: V) => R;
        apply(arg0: T): R;
        andThen<V>(arg0: (arg0: R) => V): (arg0: T) => V;
    }
    interface ICapabilitySerializable <T> extends Internal.ICapabilityProvider, Internal.INBTSerializable<T> {
        serializeNBT(): T;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        deserializeNBT(arg0: T): void;
    }
    class ResourceKey <T> implements Internal.Comparable<Internal.ResourceKey<any>>, Internal.SpecialEquality {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getNamespace(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getPath(): string;
        getRegistryName(): ResourceLocation;
        toString(): string;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ResourceKey<any>): number;
        notify(): void;
        specialEquals(o: any, shallow: boolean): boolean;
        get path(): string;
        get namespace(): string;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class StageCreationEvent {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.Player;
        setPlayerStages(s: Internal.Stages): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        getPlayerStages(): Internal.Stages;
        get playerStages(): Internal.Stages;
        get class(): Internal.Class<any>;
        get player(): Internal.Player;
        set playerStages(s: Internal.Stages);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ScriptFile implements Internal.Comparable<Internal.ScriptFile> {
        getError(): Internal.Throwable;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        load(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        compareTo(o: Internal.ScriptFile): number;
        compareTo(arg0: any): number;
        notify(): void;
        readonly source : Internal.ScriptSource;
        readonly pack : Internal.ScriptPack;
        readonly info : Internal.ScriptFileInfo;
        get error(): Internal.Throwable;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class JsonToken extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.JsonToken;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.JsonToken[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.JsonToken): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.JsonToken>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.JsonToken>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly NUMBER : Internal.JsonToken;
        static readonly NULL : Internal.JsonToken;
        static readonly END_DOCUMENT : Internal.JsonToken;
        static readonly BEGIN_OBJECT : Internal.JsonToken;
        static readonly END_ARRAY : Internal.JsonToken;
        static readonly STRING : Internal.JsonToken;
        static readonly END_OBJECT : Internal.JsonToken;
        static readonly BEGIN_ARRAY : Internal.JsonToken;
        static readonly BOOLEAN : Internal.JsonToken;
        static readonly NAME : Internal.JsonToken;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.JsonToken>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PlayerStatsJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayTime(): number;
        getPlayer(): Internal.PlayerJS<any>;
        getCrouchDistance(): number;
        getDamageAbsorbed(): number;
        getWalkDistance(): number;
        notifyAll(): void;
        getDamageDealt_absorbed(): number;
        getItemsPickedUp(item: Internal.Item): number;
        getFishCaught(): number;
        getDeaths(): number;
        notify(): void;
        getSwimDistance(): number;
        getItemsCrafted(item: Internal.Item): number;
        getBlocksMined(block: Internal.Block): number;
        getDamageDealt_resisted(): number;
        getPlayerKills(): number;
        hashCode(): number;
        get(id: ResourceLocation): number;
        getTimeSinceDeath(): number;
        getDamageBlocked_by_shield(): number;
        getKilled(entity: Internal.EntityType<any>): number;
        getTimeCrouchTime(): number;
        getDamageTaken(): number;
        add(id: ResourceLocation, value: number): void;
        getItemsDropped(item: Internal.Item): number;
        set(id: ResourceLocation, value: number): void;
        getJumps(): number;
        getDamageResisted(): number;
        getAnimalsBred(): number;
        getItemsBroken(item: Internal.Item): number;
        getMobKills(): number;
        equals(arg0: any): boolean;
        getSprintDistance(): number;
        getTimeSinceRest(): number;
        getKilledBy(entity: Internal.EntityType<any>): number;
        toString(): string;
        getDamageDealt(): number;
        getItemsUsed(item: Internal.Item): number;
        get playerKills(): number;
        get animalsBred(): number;
        get walkDistance(): number;
        get damageDealt_resisted(): number;
        get crouchDistance(): number;
        get damageAbsorbed(): number;
        get damageResisted(): number;
        get jumps(): number;
        get damageDealt_absorbed(): number;
        get timeSinceDeath(): number;
        get timeCrouchTime(): number;
        get damageBlocked_by_shield(): number;
        get fishCaught(): number;
        get mobKills(): number;
        get sprintDistance(): number;
        get timeSinceRest(): number;
        get swimDistance(): number;
        get playTime(): number;
        get class(): Internal.Class<any>;
        get deaths(): number;
        get damageDealt(): number;
        get player(): Internal.PlayerJS<any>;
        get damageTaken(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ConfigurableAutoFlush {
        setShouldAutoFlush(arg0: boolean): void;
    }
    class Matrix3f implements Internal.MatrixWrite, Internal.Matrix3fExtended {
        multiplyBackward(arg0: Internal.Matrix3f): void;
        getClass(): Internal.Class<any>;
        getA20(): number;
        rotate(quaternion: Internal.Quaternion): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getA21(): number;
        getA10(): number;
        getA22(): number;
        getA11(): number;
        getA00(): number;
        getA01(): number;
        getA12(): number;
        getA02(): number;
        notifyAll(): void;
        flywheel$write(arg0: Internal.VecBuffer): void;
        notify(): void;
        hashCode(): number;
        flywheel$writeUnsafe(arg0: number): void;
        equals(arg0: any): boolean;
        transformVecZ(x: number, y: number, z: number): number;
        transformVecZ(dir: Internal.Vector3f): number;
        transformVecY(x: number, y: number, z: number): number;
        transformVecY(dir: Internal.Vector3f): number;
        toString(): string;
        transformVecX(x: number, y: number, z: number): number;
        transformVecX(dir: Internal.Vector3f): number;
        computeNormal(dir: Internal.Direction): number;
        get a22(): number;
        get a11(): number;
        get a00(): number;
        get a21(): number;
        get a10(): number;
        get a02(): number;
        get a01(): number;
        get a12(): number;
        get class(): Internal.Class<any>;
        get a20(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LootItemCondition$Builder {
    }
    abstract class Either <L, R> implements Internal.App<Internal.Either$Mu<R>, L> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        swap(): Internal.Either<R, L>;
        notifyAll(): void;
        mapBoth<C_, D_>(arg0: (arg0: L) => C_, arg1: (arg0: R) => D_): Internal.Either<C_, D_>;
        ifLeft(arg0: (arg0: L) => void): Internal.Either<L, R>;
        static right<L_, R_>(arg0: R_): Internal.Either<L_, R_>;
        right(): Internal.Optional<R>;
        notify(): void;
        ifRight(arg0: (arg0: R) => void): Internal.Either<L, R>;
        orThrow(): L;
        mapRight<T_>(arg0: (arg0: R) => T_): Internal.Either<L, T_>;
        flatMap<L2_>(arg0: (arg0: L) => Internal.Either<L2_, R>): Internal.Either<L2_, R>;
        static left<L_, R_>(arg0: L_): Internal.Either<L_, R_>;
        left(): Internal.Optional<L>;
        hashCode(): number;
        static unbox<L_, R_>(arg0: Internal.App<Internal.Either$Mu<R_>, L_>): Internal.Either<L_, R_>;
        equals(arg0: any): boolean;
        mapLeft<T_>(arg0: (arg0: L) => T_): Internal.Either<T_, R>;
        toString(): string;
        map<T_>(arg0: (arg0: L) => T_, arg1: (arg0: R) => T_): T_;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Double2ByteFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface IMovedAccess {
        backpackedMoved(): boolean;
    }
    class Products$P9 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ServerResources implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LogBuilder {
        withLocation(): Internal.LogBuilder;
        withLocation(location: Internal.StackTraceElement): Internal.LogBuilder;
        log(message: string, p0: any, p1: any, p2: any, p3: any): void;
        log(message: string, p0: any, p1: any, p2: any, p3: any, p4: any): void;
        log(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): void;
        log(message: string, p0: any, p1: any, p2: any): void;
        log(message: string, p0: any, p1: any): void;
        log(message: string, p0: any): void;
        log(): void;
        log(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any, p9: any): void;
        log(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any, p8: any): void;
        log(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any, p7: any): void;
        log(message: string, p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): void;
        log(message: string, params: Internal.Supplier<any>[]): void;
        log(message: string, params: any[]): void;
        log(message: string): void;
        log(message: Internal.CharSequence): void;
        log(message: any): void;
        log(messageSupplier: Internal.Supplier<Internal.Message>): void;
        log(message: Internal.Message): void;
        withMarker(marker: Internal.Marker): Internal.LogBuilder;
        withThrowable(throwable: Internal.Throwable): Internal.LogBuilder;
    }
    interface ChannelPipeline extends Internal.ChannelInboundInvoker, Internal.ChannelOutboundInvoker, Internal.Iterable<Internal.Map$Entry<string, Internal.ChannelHandler>> {
        disconnect(): Internal.ChannelFuture;
        disconnect(arg0: Internal.ChannelPromise): Internal.ChannelFuture;
        newProgressivePromise(): Internal.ChannelProgressivePromise;
        fireChannelWritabilityChanged(): Internal.ChannelPipeline;
        fireChannelWritabilityChanged(): Internal.ChannelInboundInvoker;
        channel(): io.netty.channel.Channel;
        replace(arg0: string, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelHandler;
        replace<T_>(arg0: Internal.Class<T_>, arg1: string, arg2: Internal.ChannelHandler): T_;
        replace(arg0: Internal.ChannelHandler, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelPipeline;
        fireExceptionCaught(arg0: Internal.Throwable): Internal.ChannelPipeline;
        fireExceptionCaught(arg0: Internal.Throwable): Internal.ChannelInboundInvoker;
        fireChannelActive(): Internal.ChannelPipeline;
        fireChannelActive(): Internal.ChannelInboundInvoker;
        removeLast(): Internal.ChannelHandler;
        remove<T_>(arg0: Internal.Class<T_>): T_;
        remove(arg0: string): Internal.ChannelHandler;
        remove(arg0: Internal.ChannelHandler): Internal.ChannelPipeline;
        writeAndFlush(arg0: any): Internal.ChannelFuture;
        writeAndFlush(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        addLast(arg0: Internal.EventExecutorGroup, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelPipeline;
        addLast(arg0: string, arg1: Internal.ChannelHandler): Internal.ChannelPipeline;
        addLast(arg0: Internal.ChannelHandler[]): Internal.ChannelPipeline;
        addLast(arg0: Internal.EventExecutorGroup, arg1: Internal.ChannelHandler[]): Internal.ChannelPipeline;
        iterator(): Internal.Iterator<Internal.Map$Entry<string, Internal.ChannelHandler>>;
        addAfter(arg0: string, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelPipeline;
        addAfter(arg0: Internal.EventExecutorGroup, arg1: string, arg2: string, arg3: Internal.ChannelHandler): Internal.ChannelPipeline;
        bind(arg0: Internal.SocketAddress): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        flush(): Internal.ChannelPipeline;
        flush(): Internal.ChannelOutboundInvoker;
        removeFirst(): Internal.ChannelHandler;
        get<T_>(arg0: Internal.Class<T_>): T_;
        get(arg0: string): Internal.ChannelHandler;
        context(arg0: Internal.ChannelHandler): Internal.ChannelHandlerContext;
        context(arg0: string): Internal.ChannelHandlerContext;
        context(arg0: Internal.Class<Internal.ChannelHandler>): Internal.ChannelHandlerContext;
        close(arg0: Internal.ChannelPromise): Internal.ChannelFuture;
        close(): Internal.ChannelFuture;
        write(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        write(arg0: any): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress, arg2: Internal.ChannelPromise): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        newPromise(): Internal.ChannelPromise;
        firstContext(): Internal.ChannelHandlerContext;
        read(): Internal.ChannelOutboundInvoker;
        fireChannelInactive(): Internal.ChannelPipeline;
        fireChannelInactive(): Internal.ChannelInboundInvoker;
        fireChannelReadComplete(): Internal.ChannelPipeline;
        fireChannelReadComplete(): Internal.ChannelInboundInvoker;
        last(): Internal.ChannelHandler;
        spliterator(): Internal.Spliterator<Internal.Map$Entry<string, Internal.ChannelHandler>>;
        forEach(arg0: (arg0: Internal.Map$Entry<string, Internal.ChannelHandler>) => void): void;
        deregister(): Internal.ChannelFuture;
        deregister(arg0: Internal.ChannelPromise): Internal.ChannelFuture;
        newFailedFuture(arg0: Internal.Throwable): Internal.ChannelFuture;
        fireChannelRegistered(): Internal.ChannelPipeline;
        fireChannelRegistered(): Internal.ChannelInboundInvoker;
        addBefore(arg0: string, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelPipeline;
        addBefore(arg0: Internal.EventExecutorGroup, arg1: string, arg2: string, arg3: Internal.ChannelHandler): Internal.ChannelPipeline;
        fireChannelRead(arg0: any): Internal.ChannelPipeline;
        fireChannelRead(arg0: any): Internal.ChannelInboundInvoker;
        names(): Internal.List<string>;
        newSucceededFuture(): Internal.ChannelFuture;
        voidPromise(): Internal.ChannelPromise;
        toMap(): Internal.Map<string, Internal.ChannelHandler>;
        fireUserEventTriggered(arg0: any): Internal.ChannelPipeline;
        fireUserEventTriggered(arg0: any): Internal.ChannelInboundInvoker;
        fireChannelUnregistered(): Internal.ChannelPipeline;
        fireChannelUnregistered(): Internal.ChannelInboundInvoker;
        lastContext(): Internal.ChannelHandlerContext;
        addFirst(arg0: string, arg1: Internal.ChannelHandler): Internal.ChannelPipeline;
        addFirst(arg0: Internal.EventExecutorGroup, arg1: string, arg2: Internal.ChannelHandler): Internal.ChannelPipeline;
        addFirst(arg0: Internal.ChannelHandler[]): Internal.ChannelPipeline;
        addFirst(arg0: Internal.EventExecutorGroup, arg1: Internal.ChannelHandler[]): Internal.ChannelPipeline;
        first(): Internal.ChannelHandler;
    }
    class Event$Result extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Event$Result;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Event$Result[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Event$Result): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Event$Result>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Event$Result>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly DENY : Internal.Event$Result;
        static readonly DEFAULT : Internal.Event$Result;
        static readonly ALLOW : Internal.Event$Result;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Event$Result>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BidirectionalIterator <K> extends Internal.Iterator<K> {
        next(): K;
        previous(): K;
        hasPrevious(): boolean;
        hasNext(): boolean;
        forEachRemaining(arg0: (arg0: K) => void): void;
        remove(): void;
    }
    interface ILootHandler extends Internal.Predicate<Internal.LootContext> {
        or(arg0: (arg0: Internal.LootContext) => boolean): (arg0: Internal.LootContext) => boolean;
        test(arg0: Internal.LootContext): boolean;
        and(arg0: (arg0: Internal.LootContext) => boolean): (arg0: Internal.LootContext) => boolean;
        negate(): (arg0: Internal.LootContext) => boolean;
    }
    interface RenderTypeExtension {
        flywheel$getDrawBuffer(): Internal.DrawBuffer;
    }
    interface Comparator <T> {
        compare(arg0: T, arg1: T): number;
        thenComparingInt(arg0: Internal.ToIntFunction<T>): Internal.Comparator<T>;
        thenComparingDouble(arg0: Internal.ToDoubleFunction<T>): Internal.Comparator<T>;
        thenComparingLong(arg0: Internal.ToLongFunction<T>): Internal.Comparator<T>;
        thenComparing(arg0: Internal.Comparator<T>): Internal.Comparator<T>;
        thenComparing<U>(arg0: (arg0: T) => U, arg1: Internal.Comparator<U>): Internal.Comparator<T>;
        thenComparing<U>(arg0: (arg0: T) => U): Internal.Comparator<T>;
        equals(arg0: any): boolean;
        reversed(): Internal.Comparator<T>;
    }
    class Optional <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: () => Internal.Optional<T>): Internal.Optional<T>;
        static ofNullable<T>(arg0: T): Internal.Optional<T>;
        notifyAll(): void;
        isEmpty(): boolean;
        isPresent(): boolean;
        orElse(arg0: T): T;
        notify(): void;
        orElseThrow<X>(arg0: () => X): T;
        orElseThrow(): T;
        static empty<T>(): Internal.Optional<T>;
        flatMap<U>(arg0: (arg0: T) => Internal.Optional<U>): Internal.Optional<U>;
        filter(arg0: (arg0: T) => boolean): Internal.Optional<T>;
        orElseGet(arg0: () => T): T;
        stream(): Internal.Stream<T>;
        hashCode(): number;
        ifPresentOrElse(arg0: (arg0: T) => void, arg1: Internal.Runnable): void;
        ifPresent(arg0: (arg0: T) => void): void;
        static of<T>(arg0: T): Internal.Optional<T>;
        equals(arg0: any): boolean;
        get(): T;
        toString(): string;
        map<U>(arg0: (arg0: T) => U): Internal.Optional<U>;
        get present(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EntityKJS extends Internal.AsKJS {
        getPersistentDataKJS(): Internal.CompoundTag;
        asKJS(): any;
    }
    class DamageSourcePredicateBuilderJS implements Internal.LootItemCondition$Builder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isFire(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        anyType(arg0: string[]): Internal.DamageSourcePredicateBuilderJS;
        notifyAll(): void;
        isLightning(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        isExplosion(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        isProjectile(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        notify(): void;
        doesBypassInvulnerability(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        matchDirectEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.DamageSourcePredicateBuilderJS;
        doesBypassMagic(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        isMagic(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        matchSourceEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.DamageSourcePredicateBuilderJS;
        doesBypassArmor(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class EntityPredicateBuilderJS implements Internal.ExtendedEntityFlagsPredicate$IBuilder<Internal.EntityPredicate> {
        isBaby(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>;
        isBaby(arg0: boolean): Internal.EntityPredicateBuilderJS;
        getClass(): Internal.Class<any>;
        nbt(arg0: Internal.CompoundTag): Internal.EntityPredicateBuilderJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        anyType(arg0: string[]): Internal.EntityPredicateBuilderJS;
        isCrouching(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>;
        isCrouching(arg0: boolean): Internal.EntityPredicateBuilderJS;
        notifyAll(): void;
        isUnderWater(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>;
        isUnderWater(arg0: boolean): Internal.EntityPredicateBuilderJS;
        isSprinting(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>;
        isSprinting(arg0: boolean): Internal.EntityPredicateBuilderJS;
        matchFluid(arg0: string): Internal.EntityPredicateBuilderJS;
        notify(): void;
        hashCode(): number;
        matchBlock(arg0: string): Internal.EntityPredicateBuilderJS;
        matchBlock(arg0: string, arg1: Internal.Map<string, string>): Internal.EntityPredicateBuilderJS;
        hasEffect(arg0: Internal.MobEffect): Internal.EntityPredicateBuilderJS;
        hasEffect(arg0: Internal.MobEffect, arg1: number): Internal.EntityPredicateBuilderJS;
        isIllegarMob(arg0: boolean): Internal.EntityPredicateBuilderJS;
        isIllegarMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>;
        isSwimming(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>;
        isSwimming(arg0: boolean): Internal.EntityPredicateBuilderJS;
        isInWater(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>;
        isInWater(arg0: boolean): Internal.EntityPredicateBuilderJS;
        isWaterMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>;
        isWaterMob(arg0: boolean): Internal.EntityPredicateBuilderJS;
        catType(arg0: ResourceLocation): Internal.EntityPredicateBuilderJS;
        isUndeadMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>;
        isUndeadMob(arg0: boolean): Internal.EntityPredicateBuilderJS;
        isCreature(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>;
        isCreature(arg0: boolean): Internal.EntityPredicateBuilderJS;
        build(): Internal.EntityPredicate;
        build(): any;
        isMonster(arg0: boolean): Internal.EntityPredicateBuilderJS;
        isMonster(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>;
        equals(arg0: any): boolean;
        matchMount(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.EntityPredicateBuilderJS;
        isOnFire(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>;
        isOnFire(arg0: boolean): Internal.EntityPredicateBuilderJS;
        toString(): string;
        isOnGround(arg0: boolean): Internal.EntityPredicateBuilderJS;
        isOnGround(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>;
        isArthropodMob(arg0: boolean): Internal.EntityPredicateBuilderJS;
        isArthropodMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<any>;
        matchSlot(arg0: EquipmentSlot, arg1: Internal.IngredientJS): Internal.EntityPredicateBuilderJS;
        matchTargetedEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.EntityPredicateBuilderJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Products$P7 <F, T1, T2, T3, T4, T5, T6, T7> {
        t4(): Internal.App<F, T4>;
        getClass(): Internal.Class<any>;
        t5(): Internal.App<F, T5>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        t6(): Internal.App<F, T6>;
        t7(): Internal.App<F, T7>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function7<T1, T2, T3, T4, T5, T6, T7, R>>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function7<T1, T2, T3, T4, T5, T6, T7, R>): Internal.App<F, R>;
        notifyAll(): void;
        notify(): void;
        hashCode(): number;
        and<T8>(arg0: Internal.App<F, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Mob extends Internal.LivingEntity implements Internal.NavigatingEntity, Internal.EquipmentEntity, Internal.EquipmentEntity$EquipmentTrackingEntity {
        getClass(): Internal.Class<any>;
        backpackedMoved(): boolean;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>;
        handler$zje000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void;
        updateNavigationRegistration(): void;
        onEndimationEnd(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        canBeRiddenInWater(arg0: Internal.Entity): boolean;
        handler$zzo000$tickHead(arg0: Internal.CallbackInfo): void;
        setCitadelEntityData(arg0: Internal.CompoundTag): void;
        isEndimationPlaying(arg0: Internal.PlayableEndimation): boolean;
        isActive(): boolean;
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void;
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity;
        getCachedFeetBlockState(): Internal.BlockState;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        handler$bfj000$tryShortcutFluidPushing(tag: net.minecraft.tags.Tag<any>, speed: number, cir: Internal.CallbackInfoReturnable<any>, box: Internal.AABB, x1: number, x2: number, y1: number, y2: number, z1: number, z2: number, zero: number): void;
        getPos(): Internal.Position;
        foodEatenKJS(is: Internal.ItemStack): void;
        revive(): void;
        static getDataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(arg0: boolean): void;
        canUpdate(): boolean;
        getEndimatedState(): Internal.Endimatable$EndimatedState;
        resetEndimation(): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean;
        getRegisteredNavigation(): Internal.PathNavigation;
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number;
        reviveCaps(): void;
        lithiumOnBlockCacheDeleted(): void;
        canRiderInteract(): boolean;
        getEntries(arg0: boolean): Internal.Set<any>;
        getEffectHandler(): Internal.EndimationEffectHandler;
        onAddedToWorld(): void;
        setAnimationTick(arg0: number): void;
        isRegisteredToWorld(): boolean;
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        static getDataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        getListener(): Internal.NearbyEntityListenerMulti;
        getClassification(arg0: boolean): Internal.MobCategory;
        isNoEndimationPlaying(): boolean;
        onEndimationStart(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listenForCachedBlockChanges: boolean): void;
        shouldRiderSit(): boolean;
        getIsInsidePortal(): boolean;
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$zje000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        handler$zcg000$read(arg0: Internal.CompoundTag, arg1: Internal.CallbackInfo): void;
        getRemainingFireTicks(): number;
        lithiumOnEquipmentChanged(): void;
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void;
        notify(): void;
        getDataMap(): Internal.Map<any, any>;
        handler$zzo000$moveStep(arg0: Internal.MoverType, arg1: Vec3, arg2: Internal.CallbackInfo): void;
        getEntityChangeListener(): Internal.EntityInLevelCallback;
        endimateTick(): void;
        setDataMap(arg0: Internal.Map<any, any>): void;
        isDirty(): boolean;
        hashCode(): number;
        getLastPos(): BlockPos;
        isAddedToWorld(): boolean;
        setRegisteredToWorld(navigation: Internal.PathNavigation): void;
        getParts(): any[];
        addListener(listener: Internal.NearbyEntityListener): void;
        onRemovedFromWorld(): void;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        curePotionEffects(arg0: Internal.ItemStack): boolean;
        clean(): void;
        asKJS(): any;
        getPlayingEndimation(): Internal.PlayableEndimation;
        getDirtyEntries(): Internal.Set<any>;
        getValue(arg0: Internal.TrackedData<any>): any;
        shouldRiderFaceForward(arg0: Internal.Player): boolean;
        setPlayingEndimation(arg0: Internal.PlayableEndimation): void;
        setValue(arg0: Internal.TrackedData<any>, arg1: any): void;
        equals(arg0: any): boolean;
        getAnimationTick(): number;
        toString(): string;
        setRemainingFireTicks(arg0: number): void;
        handler$zgd001$tick(arg0: Internal.CallbackInfo): void;
        get citadelEntityData(): Internal.CompoundTag;
        get listener(): Internal.NearbyEntityListenerMulti;
        get addedToWorld(): boolean;
        get registeredNavigation(): Internal.PathNavigation;
        get animationTick(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get pos(): Internal.Position;
        get registeredToWorld(): boolean;
        get dataMap(): Internal.Map<any, any>;
        get noEndimationPlaying(): boolean;
        get class(): Internal.Class<any>;
        get dirty(): boolean;
        get dataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get entityChangeListener(): Internal.EntityInLevelCallback;
        get multipartEntity(): boolean;
        get active(): boolean;
        get playingEndimation(): Internal.PlayableEndimation;
        get effectHandler(): Internal.EndimationEffectHandler;
        get cachedFeetBlockState(): Internal.BlockState;
        get lastPos(): BlockPos;
        get dirtyEntries(): Internal.Set<any>;
        get dataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        get parts(): any[];
        get endimatedState(): Internal.Endimatable$EndimatedState;
        set animationTick(arg0: number);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set dataMap(arg0: Internal.Map<any, any>);
        set playingEndimation(arg0: Internal.PlayableEndimation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Registry <T> implements Internal.Keyable, Internal.IdMap<T>, Internal.RegistryAccess {
        getClass(): Internal.Class<any>;
        iterator(): Internal.Iterator<T>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        spliterator(): Internal.Spliterator<T>;
        forEach(arg0: (arg0: T) => void): void;
        hashCode(): number;
        static invokeRegisterSimple_$md$dd73f7$0(arg0: Internal.ResourceKey<any>, arg1: () => any)): Internal.Registry<any>;
        keys<U_>(arg0: Internal.DynamicOps<U_>): Internal.Stream<U_>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ModuleFinder {
        find(arg0: string): Internal.Optional<Internal.ModuleReference>;
        findAll(): Internal.Set<Internal.ModuleReference>;
    }
    class LunarTextComponents$NotificationType extends Internal.Enum<any> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.LunarTextComponents$NotificationType;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.LunarTextComponents$NotificationType[];
        static byName(arg0: string): Internal.LunarTextComponents$NotificationType;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.LunarTextComponents$NotificationType): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.LunarTextComponents$NotificationType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.LunarTextComponents$NotificationType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly CODEC : Internal.Codec<Internal.LunarTextComponents$NotificationType>;
        static readonly CHAT : Internal.LunarTextComponents$NotificationType;
        static readonly HOT_BAR : Internal.LunarTextComponents$NotificationType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.LunarTextComponents$NotificationType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BiomeSeedProvider {
        getBiomeSeed(): number;
    }
    class ThreadGroup implements Internal.Thread$UncaughtExceptionHandler {
        setMaxPriority(arg0: number): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        notifyAll(): void;
        notify(): void;
        hashCode(): number;
        isDaemon(): boolean;
        interrupt(): void;
        activeGroupCount(): number;
        enumerate(arg0: Internal.ThreadGroup[], arg1: boolean): number;
        enumerate(arg0: Internal.ThreadGroup[]): number;
        enumerate(arg0: Internal.Thread[]): number;
        enumerate(arg0: Internal.Thread[], arg1: boolean): number;
        suspend(): void;
        activeCount(): number;
        resume(): void;
        getParent(): Internal.ThreadGroup;
        isDestroyed(): boolean;
        destroy(): void;
        parentOf(arg0: Internal.ThreadGroup): boolean;
        list(): void;
        checkAccess(): void;
        setDaemon(arg0: boolean): void;
        allowThreadSuspension(arg0: boolean): boolean;
        getMaxPriority(): number;
        stop(): void;
        equals(arg0: any): boolean;
        uncaughtException(arg0: Internal.Thread, arg1: Internal.Throwable): void;
        toString(): string;
        get parent(): Internal.ThreadGroup;
        get destroyed(): boolean;
        get maxPriority(): number;
        get name(): string;
        get class(): Internal.Class<any>;
        get daemon(): boolean;
        set maxPriority(arg0: number);
        set daemon(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ChannelFuture extends Internal.Future<void> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>;
        getNow(): void;
        channel(): io.netty.channel.Channel;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): Internal.ChannelFuture;
        awaitUninterruptibly(): Internal.Future<void>;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>;
        isDone(): boolean;
        sync(): Internal.ChannelFuture;
        sync(): Internal.Future<void>;
        isVoid(): boolean;
        syncUninterruptibly(): Internal.ChannelFuture;
        syncUninterruptibly(): Internal.Future<void>;
        get(arg0: number, arg1: Internal.TimeUnit): void;
        get(): void;
        isCancellable(): boolean;
        await(): Internal.ChannelFuture;
        await(): Internal.Future<void>;
        await(arg0: number, arg1: Internal.TimeUnit): boolean;
        await(arg0: number): boolean;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>;
        isSuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>;
    }
    class ImmutableList$Builder <E> extends Internal.ImmutableCollection$Builder<any> {
        add(arg0: any): Internal.ImmutableCollection$Builder<any>;
        add(arg0: E): Internal.ImmutableList$Builder<E>;
        add(arg0: any[]): Internal.ImmutableCollection$Builder<any>;
        add(arg0: E[]): Internal.ImmutableList$Builder<E>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.ImmutableCollection<any>;
        build(): Internal.ImmutableList<E>;
        addAll(arg0: Internal.Iterator<E>): Internal.ImmutableList$Builder<E>;
        addAll(arg0: Internal.Iterator<any>): Internal.ImmutableCollection$Builder<any>;
        addAll(arg0: Internal.Iterable<any>): Internal.ImmutableCollection$Builder<any>;
        addAll(arg0: Internal.Iterable<E>): Internal.ImmutableList$Builder<E>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Multimap <K, V> {
        containsEntry(arg0: any, arg1: any): boolean;
        asMap(): Internal.Map<K, Internal.Collection<V>>;
        keys(): Internal.Multiset<K>;
        containsKey(arg0: any): boolean;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        values(): Internal.Collection<V>;
        isEmpty(): boolean;
        clear(): void;
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.Collection<V>;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): boolean;
        remove(arg0: any, arg1: any): boolean;
        removeAll(arg0: any): Internal.Collection<V>;
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>;
        size(): number;
        hashCode(): number;
        putAll(arg0: Internal.Multimap<K, V>): boolean;
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean;
        equals(arg0: any): boolean;
        get(arg0: K): Internal.Collection<V>;
        keySet(): Internal.Set<K>;
    }
    interface ItemAccessor {
        setCategory(arg0: Internal.CreativeModeTab): void;
        getCategory(): Internal.CreativeModeTab;
    }
    class LunarContext$LunarTimeSettings {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getDayLength(): number;
        getMinDaysBetweenLunarEvents(): number;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getYearLength(): number;
        notify(): void;
        static readonly CODEC : Internal.Codec<Internal.LunarContext$LunarTimeSettings>;
        static readonly DEFAULT : Internal.LunarContext$LunarTimeSettings;
        get dayLength(): number;
        get yearLength(): number;
        get minDaysBetweenLunarEvents(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ContextAwareComponent {
    }
    class BlockIDPredicate implements Internal.BlockPredicate {
        getBlockProperties(): Internal.List<Internal.BlockIDPredicate$PropertyObject>;
        getClass(): Internal.Class<any>;
        with(key: string, value: string): Internal.BlockIDPredicate;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        checkState(state: Internal.BlockState): boolean;
        toString(): string;
        check(b: Internal.BlockContainerJS): boolean;
        getBlockState(): Internal.BlockState;
        notify(): void;
        get blockState(): Internal.BlockState;
        get blockProperties(): Internal.List<Internal.BlockIDPredicate$PropertyObject>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ScriptPack {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        readonly manager : Internal.ScriptManager;
        scope : Internal.Scriptable;
        context : Internal.Context;
        readonly scripts : Internal.List<Internal.ScriptFile>;
        readonly info : Internal.ScriptPackInfo;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TickingBlockEntity {
    }
    interface Readable {
        read(arg0: Internal.CharBuffer): number;
    }
    class AssetJsonGenerator extends Internal.JsonGenerator {
        multipartState(id: ResourceLocation, consumer: (arg0: Internal.MultipartBlockStateGenerator) => void): void;
        getClass(): Internal.Class<any>;
        blockState(id: ResourceLocation, consumer: (arg0: Internal.VariantBlockStateGenerator) => void): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        blockModel(id: ResourceLocation, consumer: (arg0: Internal.ModelGenerator) => void): void;
        hashCode(): number;
        itemModel(id: ResourceLocation, consumer: (arg0: Internal.ModelGenerator) => void): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        json(id: ResourceLocation, json: Internal.JsonElement): void;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface RecipeManagerKJS {
        customRecipesKJS(jsonMap: Internal.Map<ResourceLocation, Internal.JsonObject>): void;
        getByNameKJS(): Internal.Map<ResourceLocation, Internal.Recipe<any>>;
        setByNameKJS(arg0: Internal.Map<ResourceLocation, Internal.Recipe<any>>): void;
        getRecipesKJS(): Internal.Map<Internal.RecipeType<any>, Internal.Map<ResourceLocation, Internal.Recipe<any>>>;
        setRecipesKJS(arg0: Internal.Map<Internal.RecipeType<any>, Internal.Map<ResourceLocation, Internal.Recipe<any>>>): void;
    }
    interface Path extends Internal.Comparable<Internal.Path>, Internal.Iterable<Internal.Path>, Internal.Watchable {
        getName(arg0: number): Internal.Path;
        resolve(arg0: string): Internal.Path;
        resolve(arg0: Internal.Path): Internal.Path;
        resolveSibling(arg0: Internal.Path): Internal.Path;
        resolveSibling(arg0: string): Internal.Path;
        subpath(arg0: number, arg1: number): Internal.Path;
        compareTo(arg0: Internal.Path): number;
        compareTo(arg0: any): number;
        iterator(): Internal.Iterator<Internal.Path>;
        hashCode(): number;
        normalize(): Internal.Path;
        relativize(arg0: Internal.Path): Internal.Path;
        getRoot(): Internal.Path;
        getFileName(): Internal.Path;
        getNameCount(): number;
        getParent(): Internal.Path;
        spliterator(): Internal.Spliterator<Internal.Path>;
        forEach(arg0: (arg0: Internal.Path) => void): void;
        toUri(): Internal.URI;
        toAbsolutePath(): Internal.Path;
        getFileSystem(): Internal.FileSystem;
        equals(arg0: any): boolean;
        toFile(): Internal.File;
        toRealPath(arg0: any[]): Internal.Path;
        endsWith(arg0: Internal.Path): boolean;
        endsWith(arg0: string): boolean;
        isAbsolute(): boolean;
        toString(): string;
        register(arg0: Internal.WatchService, arg1: Internal.WatchEvent$Kind<any>[]): Internal.WatchKey;
        register(arg0: Internal.WatchService, arg1: Internal.WatchEvent$Kind<any>[], arg2: any[]): Internal.WatchKey;
        startsWith(arg0: string): boolean;
        startsWith(arg0: Internal.Path): boolean;
    }
    interface ConditionContainer {
        survivesExplosion(): Internal.ConditionContainer;
        entityScores(entity: Internal.LootContext$EntityTarget, scores: Internal.Map<string, any>): Internal.ConditionContainer;
        killedByPlayer(): Internal.ConditionContainer;
        randomChance(chance: number): Internal.ConditionContainer;
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer;
        addCondition(arg0: Internal.JsonObject): Internal.ConditionContainer;
        entityProperties(entity: Internal.LootContext$EntityTarget, properties: Internal.JsonObject): Internal.ConditionContainer;
    }
    class OrConditionBuilder implements Internal.ConditionsContainer<Internal.OrConditionBuilder> {
        killerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): Internal.OrConditionBuilder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        survivesExplosion(): Internal.OrConditionBuilder;
        notifyAll(): void;
        addCondition(arg0: (arg0: any) => boolean): Internal.ConditionsContainer<any>;
        addCondition(arg0: (arg0: any) => boolean): Internal.OrConditionBuilder;
        addCondition(arg0: Internal.LootItemCondition$Builder): Internal.OrConditionBuilder;
        customDistanceToPlayer(arg0: (arg0: Internal.DistancePredicateBuilder) => void): Internal.OrConditionBuilder;
        matchFluid(arg0: string): Internal.OrConditionBuilder;
        notify(): void;
        not(arg0: (arg0: Internal.NotConditionBuilder) => void): Internal.OrConditionBuilder;
        directKillerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): Internal.OrConditionBuilder;
        matchEquip(arg0: EquipmentSlot, arg1: Internal.IngredientJS): Internal.OrConditionBuilder;
        and(arg0: (arg0: Internal.AndConditionBuilder) => void): Internal.OrConditionBuilder;
        hashCode(): number;
        matchLoot(arg0: Internal.IngredientJS): Internal.OrConditionBuilder;
        matchLoot(arg0: Internal.IngredientJS, arg1: boolean): Internal.OrConditionBuilder;
        anyBiome(arg0: string[]): Internal.OrConditionBuilder;
        distanceToKiller(arg0: Internal.MinMaxBounds$Doubles): Internal.OrConditionBuilder;
        entityPredicate(arg0: (arg0: Internal.EntityJS) => boolean): Internal.OrConditionBuilder;
        matchEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.OrConditionBuilder;
        anyDimension(arg0: ResourceLocation[]): Internal.OrConditionBuilder;
        killedByPlayer(): Internal.OrConditionBuilder;
        or(arg0: (arg0: Internal.OrConditionBuilder) => void): Internal.OrConditionBuilder;
        randomChance(arg0: number): Internal.OrConditionBuilder;
        timeCheck(arg0: number, arg1: number, arg2: number): Internal.OrConditionBuilder;
        timeCheck(arg0: number, arg1: number): Internal.OrConditionBuilder;
        matchOffHand(arg0: Internal.IngredientJS): Internal.OrConditionBuilder;
        playerPredicate(arg0: (arg0: Internal.PlayerJS<any>) => boolean): Internal.OrConditionBuilder;
        weatherCheck(arg0: Internal.Map<string, boolean>): Internal.OrConditionBuilder;
        matchDirectKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.OrConditionBuilder;
        matchBlockState(arg0: Internal.Block, arg1: Internal.Map<string, string>): Internal.OrConditionBuilder;
        matchMainHand(arg0: Internal.IngredientJS): Internal.OrConditionBuilder;
        matchPlayer(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.OrConditionBuilder;
        lightLevel(arg0: number, arg1: number): Internal.OrConditionBuilder;
        build(): (arg0: any) => boolean;
        biome(arg0: string[]): Internal.OrConditionBuilder;
        customCondition(arg0: Internal.JsonObject): Internal.OrConditionBuilder;
        equals(arg0: any): boolean;
        matchKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.OrConditionBuilder;
        randomChanceWithLooting(arg0: number, arg1: number): Internal.OrConditionBuilder;
        hasAnyStage(arg0: string[]): Internal.OrConditionBuilder;
        toString(): string;
        randomChanceWithEnchantment(arg0: Internal.Enchantment, arg1: number[]): Internal.OrConditionBuilder;
        matchDamageSource(arg0: (arg0: Internal.DamageSourcePredicateBuilderJS) => void): Internal.OrConditionBuilder;
        anyStructure(arg0: ResourceLocation[], arg1: boolean): Internal.OrConditionBuilder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ImmutableMultimap$Builder <K, V> {
        orderKeysBy(arg0: Internal.Comparator<K>): Internal.ImmutableMultimap$Builder<K, V>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.ImmutableMultimap<K, V>;
        hashCode(): number;
        orderValuesBy(arg0: Internal.Comparator<V>): Internal.ImmutableMultimap$Builder<K, V>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        putAll(arg0: Internal.Multimap<K, V>): Internal.ImmutableMultimap$Builder<K, V>;
        putAll(arg0: K, arg1: V[]): Internal.ImmutableMultimap$Builder<K, V>;
        putAll(arg0: K, arg1: Internal.Iterable<V>): Internal.ImmutableMultimap$Builder<K, V>;
        putAll(arg0: Internal.Iterable<Internal.Map$Entry<K, V>>): Internal.ImmutableMultimap$Builder<K, V>;
        toString(): string;
        notify(): void;
        put(arg0: Internal.Map$Entry<K, V>): Internal.ImmutableMultimap$Builder<K, V>;
        put(arg0: K, arg1: V): Internal.ImmutableMultimap$Builder<K, V>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CustomTranslationTextComponent extends Internal.TranslatableComponent {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getString(): string;
        notify(): void;
        static readonly CODEC : Internal.Codec<Internal.CustomTranslationTextComponent>;
        static readonly DEFAULT : Internal.CustomTranslationTextComponent;
        get string(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MenuType$MenuSupplier <T> {
    }
    abstract class LevelJS implements Internal.WithAttachedData {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(entity: Internal.Entity): Internal.PlayerJS<any>;
        getEntitiesWithin(aabb: Internal.AABB): Internal.EntityArrayList;
        getPlayerData(arg0: Internal.Player): Internal.PlayerDataJS<any, any>;
        spawnFireworks(x: number, y: number, z: number, f: Internal.FireworksJS): void;
        getTime(): number;
        notifyAll(): void;
        getSide(): Internal.ScriptType;
        getGameRules(): Internal.GameRulesJS;
        notify(): void;
        setRainStrength(strength: number): void;
        hashCode(): number;
        getDimension(): string;
        isDaytime(): boolean;
        createEntityList(entities: Internal.Collection<Internal.Entity>): Internal.EntityArrayList;
        getPlayers(): Internal.EntityArrayList;
        getData(): Internal.AttachedData;
        getMinecraftLevel(): net.minecraft.world.level.Level;
        getServer(): Internal.ServerJS;
        getLivingEntity(entity: Internal.Entity): Internal.LivingEntityJS;
        getBlock(x: number, y: number, z: number): Internal.BlockContainerJS;
        getBlock(pos: BlockPos): Internal.BlockContainerJS;
        getBlock(blockEntity: Internal.BlockEntity): Internal.BlockContainerJS;
        isOverworld(): boolean;
        createExplosion(x: number, y: number, z: number): Internal.ExplosionJS;
        getEntity(e: Internal.Entity): Internal.EntityJS;
        createEntity(id: ResourceLocation): Internal.EntityJS;
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean): void;
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean, player: Internal.EntityJS): void;
        getLocalTime(): number;
        equals(arg0: any): boolean;
        isThundering(): boolean;
        getEntities(): Internal.EntityArrayList;
        toString(): string;
        isRaining(): boolean;
        readonly minecraftLevel : net.minecraft.world.level.Level;
        get server(): Internal.ServerJS;
        get side(): Internal.ScriptType;
        get data(): Internal.AttachedData;
        get players(): Internal.EntityArrayList;
        get raining(): boolean;
        get thundering(): boolean;
        get overworld(): boolean;
        get gameRules(): Internal.GameRulesJS;
        get localTime(): number;
        get entities(): Internal.EntityArrayList;
        get time(): number;
        get class(): Internal.Class<any>;
        get dimension(): string;
        get daytime(): boolean;
        set rainStrength(strength: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Endimation$PartKeyframes$Builder {
        getClass(): Internal.Class<any>;
        rotate(arg0: any[]): Internal.Endimation$PartKeyframes$Builder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        offset(arg0: any[]): Internal.Endimation$PartKeyframes$Builder;
        build(): Internal.Endimation$PartKeyframes;
        pos(arg0: any[]): Internal.Endimation$PartKeyframes$Builder;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        scale(arg0: any[]): Internal.Endimation$PartKeyframes$Builder;
        toString(): string;
        static partKeyframes(): Internal.Endimation$PartKeyframes$Builder;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IBlockRenderProperties {
        getFogColor(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity, arg4: Internal.Vector3d, arg5: number): Internal.Vector3d;
        addDestroyEffects(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.ParticleEngine): boolean;
        addHitEffects(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: Internal.HitResult, arg3: Internal.ParticleEngine): boolean;
    }
    class ItemRegistryEventJS extends Internal.StartupEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        create(name: string, callback: (arg0: Internal.ItemBuilder) => void): void;
        toString(): string;
        createFood(builder: () => Internal.FoodBuilder): () => Internal.FoodBuilder;
        notify(): void;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeMenuType <T> {
        create(arg0: number, arg1: Internal.Inventory, arg2: Internal.FriendlyByteBuf): T;
    }
    interface CommandSource {
    }
    class FluidTagInput implements Internal.Predicate<net.minecraftforge.fluids.FluidStack> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: (arg0: net.minecraftforge.fluids.FluidStack) => boolean): (arg0: net.minecraftforge.fluids.FluidStack) => boolean;
        static read(arg0: Internal.FriendlyByteBuf): (arg0: any) => boolean;
        getRandomizedExampleStack(arg0: number): net.minecraftforge.fluids.FluidStack;
        test(arg0: any): boolean;
        test(arg0: net.minecraftforge.fluids.FluidStack): boolean;
        notifyAll(): void;
        extractFrom(arg0: Internal.IFluidHandler, arg1: Internal.IFluidHandler$FluidAction): boolean;
        notify(): void;
        getMatchingFluidStacks(): Internal.List<net.minecraftforge.fluids.FluidStack>;
        serialize(): Internal.JsonElement;
        and(arg0: (arg0: net.minecraftforge.fluids.FluidStack) => boolean): (arg0: net.minecraftforge.fluids.FluidStack) => boolean;
        negate(): (arg0: net.minecraftforge.fluids.FluidStack) => boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        testIgnoringAmount(arg0: net.minecraftforge.fluids.FluidStack): boolean;
        toString(): string;
        withAmount(arg0: number): (arg0: any) => boolean;
        write(arg0: Internal.FriendlyByteBuf): void;
        getAmount(): number;
        static deserialize(arg0: Internal.JsonElement): (arg0: any) => boolean;
        get amount(): number;
        get matchingFluidStacks(): Internal.List<net.minecraftforge.fluids.FluidStack>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Attribute extends Internal.ForgeRegistryEntry<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.Attribute>;
        getRegistryName(): ResourceLocation;
        toString(): string;
        setRegistryName(arg0: string, arg1: string): Internal.Attribute;
        setRegistryName(arg0: ResourceLocation): any;
        setRegistryName(arg0: ResourceLocation): Internal.Attribute;
        setRegistryName(arg0: string): Internal.Attribute;
        notify(): void;
        readonly delegate : () => Internal.Attribute;
        get registryType(): Internal.Class<Internal.Attribute>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ConditionalFunction implements Internal.FunctionContainer, Internal.ConditionContainer {
        enchantWithLevels(levels: Internal.NumberProvider, treasure: boolean): Internal.FunctionContainer;
        damage(damage: Internal.NumberProvider): Internal.FunctionContainer;
        nbt(tag: Internal.CompoundTag): Internal.FunctionContainer;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        survivesExplosion(): Internal.ConditionContainer;
        notifyAll(): void;
        addConditionalFunction(func: (arg0: Internal.ConditionalFunction) => void): Internal.FunctionContainer;
        addCondition(arg0: Internal.JsonObject): Internal.ConditionContainer;
        addCondition(o: Internal.JsonObject): Internal.ConditionalFunction;
        notify(): void;
        lootTable(table: ResourceLocation, seed: number): Internal.FunctionContainer;
        hashCode(): number;
        killedByPlayer(): Internal.ConditionContainer;
        randomChance(chance: number): Internal.ConditionContainer;
        addFunction(arg0: Internal.JsonObject): Internal.FunctionContainer;
        addFunction(o: Internal.JsonObject): Internal.ConditionalFunction;
        count(count: Internal.NumberProvider): Internal.FunctionContainer;
        lootingEnchant(count: Internal.NumberProvider, limit: number): Internal.FunctionContainer;
        entityScores(entity: Internal.LootContext$EntityTarget, scores: Internal.Map<string, any>): Internal.ConditionContainer;
        copyName(source: Internal.CopyNameFunction$NameSource): Internal.FunctionContainer;
        equals(arg0: any): boolean;
        name(name: Internal.Text, entity: Internal.LootContext$EntityTarget): Internal.FunctionContainer;
        name(name: Internal.Text): Internal.FunctionContainer;
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer;
        furnaceSmelt(): Internal.FunctionContainer;
        toString(): string;
        enchantRandomly(enchantments: ResourceLocation[]): Internal.FunctionContainer;
        entityProperties(entity: Internal.LootContext$EntityTarget, properties: Internal.JsonObject): Internal.ConditionContainer;
        function : Internal.JsonObject;
        conditions : Internal.JsonArray;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Executable extends Internal.AccessibleObject implements Internal.Member, Internal.GenericDeclaration {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        getParameterCount(): number;
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean;
        notifyAll(): void;
        isSynthetic(): boolean;
        getAnnotatedParameterTypes(): Internal.AnnotatedType[];
        getParameterTypes(): Internal.Class<any>[];
        getGenericExceptionTypes(): java_.lang.reflect.Type[];
        notify(): void;
        getAnnotatedReceiverType(): Internal.AnnotatedType;
        getDeclaredAnnotations(): Internal.Annotation[];
        getDeclaringClass(): Internal.Class<any>;
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        hashCode(): number;
        canAccess(arg0: any): boolean;
        toGenericString(): string;
        getTypeParameters(): any[];
        getModifiers(): number;
        trySetAccessible(): boolean;
        isAccessible(): boolean;
        setAccessible(arg0: boolean): void;
        static setAccessible(arg0: Internal.AccessibleObject[], arg1: boolean): void;
        isVarArgs(): boolean;
        getAnnotations(): Internal.Annotation[];
        getAnnotatedExceptionTypes(): Internal.AnnotatedType[];
        getExceptionTypes(): Internal.Class<any>[];
        getGenericParameterTypes(): java_.lang.reflect.Type[];
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        equals(arg0: any): boolean;
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        getParameters(): any[];
        toString(): string;
        getAnnotatedReturnType(): Internal.AnnotatedType;
        getParameterAnnotations(): Internal.Annotation[][];
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get declaredAnnotations(): Internal.Annotation[];
        get accessible(): boolean;
        get annotatedReturnType(): Internal.AnnotatedType;
        get parameterTypes(): Internal.Class<any>[];
        get parameterCount(): number;
        get annotations(): Internal.Annotation[];
        get modifiers(): number;
        get typeParameters(): any[];
        get declaringClass(): Internal.Class<any>;
        get varArgs(): boolean;
        get synthetic(): boolean;
        get genericParameterTypes(): java_.lang.reflect.Type[];
        get exceptionTypes(): Internal.Class<any>[];
        get name(): string;
        get annotatedReceiverType(): Internal.AnnotatedType;
        get genericExceptionTypes(): java_.lang.reflect.Type[];
        get parameterAnnotations(): Internal.Annotation[][];
        get class(): Internal.Class<any>;
        get parameters(): any[];
        get annotatedExceptionTypes(): Internal.AnnotatedType[];
        get annotatedParameterTypes(): Internal.AnnotatedType[];
        set accessible(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class IdScriptableObject extends Internal.ScriptableObject implements Internal.IdFunctionCall {
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        setParentScope(m: Internal.Scriptable): void;
        static redefineProperty(obj: Internal.Scriptable, name: string, isConst: boolean): void;
        putConst(name: string, start: Internal.Scriptable, value: any): void;
        static getTypedProperty<T_>(s: Internal.Scriptable, index: number, type: Internal.Class<T_>): T_;
        static getTypedProperty<T_>(s: Internal.Scriptable, name: string, type: Internal.Class<T_>): T_;
        getIds(): any[];
        static getArrayPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        getAllIds(): any[];
        put(key: Internal.Symbol, start: Internal.Scriptable, value: any): void;
        put(name: string, start: Internal.Scriptable, value: any): void;
        put(index: number, start: Internal.Scriptable, value: any): void;
        getDefaultValue(typeHint: Internal.Class<any>): any;
        static getDefaultValue(object: Internal.Scriptable, typeHint: Internal.Class<any>): any;
        defineOwnProperties(cx: Internal.Context, props: Internal.ScriptableObject): void;
        defineProperty(propertyName: string, clazz: Internal.Class<any>, attributes: number): void;
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method, setter: Internal.Method, attributes: number): void;
        defineProperty(propertyName: string, value: any, attributes: number): void;
        defineProperty(key: Internal.Symbol, value: any, attributes: number): void;
        static defineProperty(destination: Internal.Scriptable, propertyName: string, value: any, attributes: number): void;
        hasPrototypeMap(): boolean;
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable, isSetter: boolean): void;
        avoidObjectDetection(): boolean;
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean;
        has(name: string, start: Internal.Scriptable): boolean;
        has(index: number, start: Internal.Scriptable): boolean;
        getExternalArrayLength(): any;
        getAttributes(name: string): number;
        getAttributes(key: Internal.Symbol): number;
        getAttributes(index: number): number;
        hasInstance(instance: Internal.Scriptable): boolean;
        getAssociatedValue(key: any): any;
        execIdCall(f: Internal.IdFunctionObject, cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any;
        static getPropertyIds(obj: Internal.Scriptable): any[];
        static hasProperty(obj: Internal.Scriptable, index: number): boolean;
        static hasProperty(obj: Internal.Scriptable, name: string): boolean;
        static hasProperty(obj: Internal.Scriptable, key: Internal.Symbol): boolean;
        getExternalArrayData(): Internal.ExternalArrayData;
        size(): number;
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol, functionName: string, arity: number): Internal.IdFunctionObject;
        defineOwnProperty(cx: Internal.Context, key: any, desc: Internal.ScriptableObject): void;
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void;
        initPrototypeValue(id: number, key: Internal.Symbol, value: any, attributes: number): void;
        static getFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        preventExtensions(): void;
        setExternalArrayData(array: Internal.ExternalArrayData): void;
        static callMethod(obj: Internal.Scriptable, methodName: string, args: any[]): any;
        static callMethod(cx: Internal.Context, obj: Internal.Scriptable, methodName: string, args: any[]): any;
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        getTypeOf(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getTopScopeValue(scope: Internal.Scriptable, key: any): any;
        initPrototypeConstructor(f: Internal.IdFunctionObject): void;
        notifyAll(): void;
        sealObject(): void;
        setAttributes(name: string, attributes: number): void;
        setAttributes(index: number, attributes: number): void;
        setAttributes(key: Internal.Symbol, attributes: number): void;
        static putProperty(obj: Internal.Scriptable, index: number, value: any): void;
        static putProperty(obj: Internal.Scriptable, key: Internal.Symbol, value: any): void;
        static putProperty(obj: Internal.Scriptable, name: string, value: any): void;
        delete(key: Internal.Symbol): void;
        delete(name: string): void;
        delete(index: number): void;
        notify(): void;
        associateValue(key: any, value: any): any;
        static deleteProperty(obj: Internal.Scriptable, name: string): boolean;
        static deleteProperty(obj: Internal.Scriptable, index: number): boolean;
        getPrototype(): Internal.Scriptable;
        static getObjectPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        isExtensible(): boolean;
        hashCode(): number;
        isConst(name: string): boolean;
        get(name: string, start: Internal.Scriptable): any;
        get(key: Internal.Symbol, start: Internal.Scriptable): any;
        get(index: number, start: Internal.Scriptable): any;
        get(key: any): any;
        static putConstProperty(obj: Internal.Scriptable, name: string, value: any): void;
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any;
        static getTopLevelScope(obj: Internal.Scriptable): Internal.Scriptable;
        static getProperty(obj: Internal.Scriptable, name: string): any;
        static getProperty(obj: Internal.Scriptable, key: Internal.Symbol): any;
        static getProperty(obj: Internal.Scriptable, index: number): any;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean): void;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>): void;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean, mapInheritance: boolean): string;
        activatePrototypeMap(maxPrototypeId: number): void;
        isEmpty(): boolean;
        defineFunctionProperties(names: string[], clazz: Internal.Class<any>, attributes: number): void;
        static getClassPrototype(scope: Internal.Scriptable, className: string): Internal.Scriptable;
        setPrototype(m: Internal.Scriptable): void;
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable, sealed: boolean): Internal.IdFunctionObject;
        defineConst(name: string, start: Internal.Scriptable): void;
        equals(arg0: any): boolean;
        static defineConstProperty(destination: Internal.Scriptable, propertyName: string): void;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get className(): string;
        get externalArrayLength(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get prototype(): Internal.Scriptable;
        get extensible(): boolean;
        get typeOf(): string;
        get empty(): boolean;
        set externalArrayData(array: Internal.ExternalArrayData);
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Screen extends Internal.AbstractContainerEventHandler implements Internal.Widget, Internal.ScreenAccessor, Internal.AccessScreen {
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.ItemStack): void;
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.Font): void;
        renderComponentTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedText>, arg2: number, arg3: number, arg4: Internal.Font, arg5: Internal.ItemStack): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.ItemStack): void;
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.Font): void;
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.FormattedCharSequence>, arg2: number, arg3: number, arg4: Internal.Font): void;
        renderTooltip(arg0: Internal.PoseStack, arg1: Internal.List<Internal.Component>, arg2: Internal.Optional<Internal.TooltipComponent>, arg3: number, arg4: number, arg5: Internal.Font, arg6: Internal.ItemStack): void;
        notifyAll(): void;
        getRenderables(): Internal.List<any>;
        getMinecraft(): Internal.Minecraft;
        notify(): void;
        balm_getNarratables(): Internal.List<any>;
        balm_getChildren(): Internal.List<any>;
        balm_getRenderables(): Internal.List<any>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        tooltipStack : Internal.ItemStack;
        get minecraft(): Internal.Minecraft;
        get renderables(): Internal.List<any>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class FileStore {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getUsableSpace(): number;
        notifyAll(): void;
        type(): string;
        notify(): void;
        getTotalSpace(): number;
        getAttribute(arg0: string): any;
        isReadOnly(): boolean;
        getBlockSize(): number;
        hashCode(): number;
        supportsFileAttributeView(arg0: Internal.Class<Internal.FileAttributeView>): boolean;
        supportsFileAttributeView(arg0: string): boolean;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        getUnallocatedSpace(): number;
        getFileStoreAttributeView<V>(arg0: Internal.Class<V>): V;
        get unallocatedSpace(): number;
        get readOnly(): boolean;
        get usableSpace(): number;
        get totalSpace(): number;
        get class(): Internal.Class<any>;
        get blockSize(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class SectionedEntityMovementTracker <E, S> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        unRegister(world: Internal.ServerLevel): void;
        hashCode(): number;
        notifyAll(): void;
        equals(obj: any): boolean;
        onSectionLeftRange(section: Internal.EntityTrackerSection): void;
        toString(): string;
        onSectionEnteredRange(section: Internal.EntityTrackerSection): void;
        isUnchangedSince(lastCheckedTime: number): boolean;
        notify(): void;
        register(world: Internal.ServerLevel): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LazyOptional <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        resolve(): Internal.Optional<T>;
        notifyAll(): void;
        isPresent(): boolean;
        invalidate(): void;
        orElse(arg0: T): T;
        notify(): void;
        orElseThrow<X>(arg0: Internal.NonNullSupplier<X>): T;
        static empty<T>(): Internal.LazyOptional<T>;
        filter(arg0: Internal.NonNullPredicate<T>): Internal.Optional<T>;
        cast<X>(): Internal.LazyOptional<X>;
        orElseGet(arg0: Internal.NonNullSupplier<T>): T;
        hashCode(): number;
        equals(arg0: any): boolean;
        ifPresent(arg0: Internal.NonNullConsumer<T>): void;
        static of<T>(arg0: Internal.NonNullSupplier<T>): Internal.LazyOptional<T>;
        toString(): string;
        map<U>(arg0: Internal.NonNullFunction<T, U>): Internal.Optional<U>;
        lazyMap<U>(arg0: Internal.NonNullFunction<T, U>): Internal.LazyOptional<U>;
        addListener(arg0: Internal.NonNullConsumer<Internal.LazyOptional<T>>): void;
        get present(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Int2FloatFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface StyleAccess {
    }
    interface Reference2ObjectFunction <K, V> extends it.unimi.dsi.fastutil.Function<K, V> {
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: K) => V_;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        defaultReturnValue(): V;
        defaultReturnValue(arg0: V): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        get(arg0: any): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: K): V;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface LootItemCondition extends Internal.LootContextUser, Internal.Predicate<Internal.LootContext>, Internal.ILootHandler, Internal.LootItemConditionMixin {
        or(arg0: (arg0: Internal.LootContext) => boolean): (arg0: Internal.LootContext) => boolean;
        test(arg0: Internal.LootContext): boolean;
        and(arg0: (arg0: Internal.LootContext) => boolean): (arg0: Internal.LootContext) => boolean;
        negate(): (arg0: Internal.LootContext) => boolean;
    }
    interface Spliterator <T> {
        trySplit(): Internal.Spliterator<T>;
        tryAdvance(arg0: (arg0: T) => void): boolean;
        characteristics(): number;
        getComparator(): Internal.Comparator<T>;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: (arg0: T) => void): void;
    }
    interface DefaultedListAccessor <T> {
        getDelegate(): Internal.List<T>;
    }
    interface BlockCachingEntity {
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void;
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listening: boolean): void;
        getCachedFeetBlockState(): Internal.BlockState;
        lithiumOnBlockCacheDeleted(): void;
    }
    class Range6Int extends Internal.Record {
        positiveY(): number;
        getClass(): Internal.Class<any>;
        positiveZ(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(o: any): boolean;
        negativeX(): number;
        toString(): string;
        notify(): void;
        negativeY(): number;
        positiveX(): number;
        negativeZ(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ServerEventJS extends Internal.EventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ResolverStyle extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ResolverStyle;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ResolverStyle[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ResolverStyle): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ResolverStyle>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ResolverStyle>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly STRICT : Internal.ResolverStyle;
        static readonly LENIENT : Internal.ResolverStyle;
        static readonly SMART : Internal.ResolverStyle;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ResolverStyle>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ImmutableMap <K, V> implements Internal.Map<K, V>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: V): V;
        static ofEntries<K_, V_>(arg0: Internal.Map$Entry<K_, V_>[]): Internal.ImmutableMap<K_, V_>;
        notifyAll(): void;
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V;
        values(): Internal.Collection<any>;
        values(): Internal.ImmutableCollection<V>;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replace(arg0: K, arg1: V): V;
        replaceAll(arg0: (arg0: K, arg1: V) => V): void;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        remove(arg0: any, arg1: any): boolean;
        remove(arg0: any): V;
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        static toImmutableMap<T_, K_, V_>(arg0: (arg0: T_) => K_, arg1: (arg0: T_) => V_): Internal.Collector<T_, any, Internal.ImmutableMap<K_, V_>>;
        static toImmutableMap<T_, K_, V_>(arg0: (arg0: T_) => K_, arg1: (arg0: T_) => V_, arg2: (arg0: any, arg1: any) => any): Internal.Collector<T_, any, Internal.ImmutableMap<K_, V_>>;
        hashCode(): number;
        putAll(arg0: Internal.Map<K, V>): void;
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_, arg10: K_, arg11: V_, arg12: K_, arg13: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_, arg10: K_, arg11: V_, arg12: K_, arg13: V_, arg14: K_, arg15: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_, arg10: K_, arg11: V_, arg12: K_, arg13: V_, arg14: K_, arg15: V_, arg16: K_, arg17: V_, arg18: K_, arg19: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_, arg10: K_, arg11: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_, arg10: K_, arg11: V_, arg12: K_, arg13: V_, arg14: K_, arg15: V_, arg16: K_, arg17: V_): Internal.ImmutableMap<K_, V_>;
        get(arg0: any): V;
        static builder<K_, V_>(): Internal.ImmutableMap$Builder<K_, V_>;
        keySet(): Internal.ImmutableSet<K>;
        keySet(): Internal.Set<any>;
        entrySet(): Internal.Set<any>;
        entrySet(): Internal.ImmutableSet<Internal.Map$Entry<K, V>>;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        containsKey(arg0: any): boolean;
        isEmpty(): boolean;
        clear(): void;
        static copyOf<K_, V_>(arg0: Internal.Iterable<Internal.Map$Entry<K_, V_>>): Internal.ImmutableMap<K_, V_>;
        static copyOf<K_, V_>(arg0: Internal.Map<K_, V_>): Internal.ImmutableMap<K_, V_>;
        static builderWithExpectedSize<K_, V_>(arg0: number): Internal.ImmutableMap$Builder<K_, V_>;
        asMultimap(): Internal.ImmutableSetMultimap<K, V>;
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        size(): number;
        equals(arg0: any): boolean;
        toString(): string;
        putIfAbsent(arg0: K, arg1: V): V;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Float2LongFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleToLongFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsLong(arg0: number): number;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    abstract class AbstractInt2IntMap extends Internal.AbstractInt2IntFunction implements Internal.Int2IntMap, Internal.Serializable {
        getClass(): Internal.Class<any>;
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        replace(arg0: number, arg1: number, arg2: number): boolean;
        replace(arg0: number, arg1: number, arg2: number): boolean;
        replace(arg0: number, arg1: number): number;
        replace(arg0: number, arg1: number): number;
        replace(arg0: any, arg1: any): any;
        replace(arg0: any, arg1: any, arg2: any): boolean;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        put(arg0: number, arg1: number): number;
        containsValue(arg0: number): boolean;
        containsValue(arg0: any): boolean;
        mergeInt(arg0: number, arg1: number, arg2: (arg0: any, arg1: any) => any): number;
        mergeInt(arg0: number, arg1: number, arg2: Internal.IntBinaryOperator): number;
        compute(arg0: any, arg1: (arg0: any, arg1: any) => any): any;
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number;
        compute(arg0: number, arg1: (arg0: number, arg1: number) => number): number;
        defaultReturnValue(arg0: number): void;
        defaultReturnValue(): number;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        merge(arg0: any, arg1: any, arg2: (arg0: any, arg1: any) => any): any;
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number;
        merge(arg0: number, arg1: number, arg2: (arg0: number, arg1: number) => number): number;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, number>>;
        entrySet(): Internal.Set<any>;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        computeIfAbsent(arg0: number, arg1: Internal.IntUnaryOperator): number;
        computeIfAbsent(arg0: any, arg1: (arg0: any) => any): any;
        computeIfAbsent(arg0: number, arg1: (arg0: number) => number): number;
        computeIfAbsent(arg0: number, arg1: (arg0: any) => any): number;
        notifyAll(): void;
        values(): Internal.Collection<any>;
        values(): Internal.IntCollection;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        computeIfAbsentPartial(arg0: number, arg1: (arg0: any) => any): number;
        replaceAll(arg0: (arg0: number, arg1: number) => number): void;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        remove(arg0: number): number;
        remove(arg0: any): any;
        remove(arg0: any): number;
        remove(arg0: number, arg1: number): boolean;
        remove(arg0: any, arg1: any): boolean;
        notify(): void;
        int2IntEntrySet(): Internal.ObjectSet<Internal.Int2IntMap$Entry>;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        hashCode(): number;
        get(arg0: any): any;
        get(arg0: any): number;
        get(arg0: number): number;
        putAll(arg0: Internal.Map<number, number>): void;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        keySet(): Internal.Set<any>;
        keySet(): Internal.IntSet;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        computeIfAbsentNullable(arg0: number, arg1: Internal.IntFunction<number>): number;
        apply(arg0: number): number;
        forEach(arg0: (arg0: number, arg1: number) => void): void;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        isEmpty(): boolean;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number;
        computeIfPresent(arg0: any, arg1: (arg0: any, arg1: any) => any): any;
        computeIfPresent(arg0: number, arg1: (arg0: number, arg1: number) => number): number;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        toString(): string;
        putIfAbsent(arg0: any, arg1: any): any;
        putIfAbsent(arg0: number, arg1: number): number;
        putIfAbsent(arg0: number, arg1: number): number;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Byte2ReferenceFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: number, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        put(arg0: number, arg1: V): V;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: V): V;
        remove(arg0: number): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): V;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class LinkedHashMap <K, V> extends Internal.HashMap<any, any> implements Internal.Map<K, V> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: V): V;
        notifyAll(): void;
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V;
        values(): Internal.Collection<V>;
        replace(arg0: K, arg1: V): V;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replaceAll(arg0: (arg0: K, arg1: V) => V): void;
        notify(): void;
        put(arg0: K, arg1: V): V;
        remove(arg0: any, arg1: any): boolean;
        remove(arg0: any): V;
        containsValue(arg0: any): boolean;
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        hashCode(): number;
        putAll(arg0: Internal.Map<K, V>): void;
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V;
        get(arg0: any): V;
        keySet(): Internal.Set<K>;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        containsKey(arg0: any): boolean;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        isEmpty(): boolean;
        clear(): void;
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        size(): number;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        putIfAbsent(arg0: K, arg1: V): V;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Object2ObjectMap$FastEntrySet <K, V> extends Internal.ObjectSet<Internal.Object2ObjectMap$Entry<K, V>> {
        add(arg0: Internal.Object2ObjectMap$Entry<K, V>): boolean;
        spliterator(): Internal.Spliterator<any>;
        spliterator(): Internal.ObjectSpliterator<Internal.Object2ObjectMap$Entry<Internal.Object2ObjectMap$Entry<K, V>, V>>;
        forEach(arg0: (arg0: Internal.Object2ObjectMap$Entry<K, V>) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        fastIterator(): Internal.ObjectIterator<Internal.Object2ObjectMap$Entry<Internal.Object2ObjectMap$Entry<Internal.Object2ObjectMap$Entry<K, V>, V>, V>>;
        remove(arg0: any): boolean;
        removeIf(arg0: (arg0: Internal.Object2ObjectMap$Entry<K, V>) => boolean): boolean;
        fastForEach(arg0: (arg0: Internal.Object2ObjectMap$Entry<Internal.Object2ObjectMap$Entry<Internal.Object2ObjectMap$Entry<K, V>, V>, V>) => void): void;
        removeAll(arg0: Internal.Collection<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.Iterator<any>;
        iterator(): Internal.ObjectIterator<Internal.Object2ObjectMap$Entry<Internal.Object2ObjectMap$Entry<K, V>, V>>;
        size(): number;
        addAll(arg0: Internal.Collection<Internal.Object2ObjectMap$Entry<K, V>>): boolean;
        stream(): Internal.Stream<Internal.Object2ObjectMap$Entry<K, V>>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<Internal.Object2ObjectMap$Entry<K, V>>;
        retainAll(arg0: Internal.Collection<any>): boolean;
    }
    abstract class AbstractStringBuilder implements Internal.Appendable, Internal.CharSequence {
        deleteCharAt(arg0: number): Internal.AbstractStringBuilder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        codePointAt(arg0: number): number;
        notifyAll(): void;
        setCharAt(arg0: number, arg1: string): void;
        replace(arg0: number, arg1: number, arg2: string): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: Internal.CharSequence): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string[]): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: any): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: boolean): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: Internal.CharSequence, arg2: number, arg3: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder;
        delete(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        notify(): void;
        substring(arg0: number): string;
        substring(arg0: number, arg1: number): string;
        capacity(): number;
        appendCodePoint(arg0: number): Internal.AbstractStringBuilder;
        hashCode(): number;
        codePointBefore(arg0: number): number;
        indexOf(arg0: string): number;
        indexOf(arg0: string, arg1: number): number;
        codePointCount(arg0: number, arg1: number): number;
        codePoints(): Internal.IntStream;
        trimToSize(): void;
        getChars(arg0: number, arg1: number, arg2: string[], arg3: number): void;
        isEmpty(): boolean;
        length(): number;
        subSequence(arg0: number, arg1: number): Internal.CharSequence;
        reverse(): Internal.AbstractStringBuilder;
        lastIndexOf(arg0: string): number;
        lastIndexOf(arg0: string, arg1: number): number;
        setLength(arg0: number): void;
        equals(arg0: any): boolean;
        toString(): string;
        ensureCapacity(arg0: number): void;
        chars(): Internal.IntStream;
        offsetByCodePoints(arg0: number, arg1: number): number;
        charAt(arg0: number): string;
        append(arg0: Internal.CharSequence): Internal.AbstractStringBuilder;
        append(arg0: Internal.CharSequence): Internal.Appendable;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.AbstractStringBuilder;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable;
        append(arg0: string[]): Internal.AbstractStringBuilder;
        append(arg0: any): Internal.AbstractStringBuilder;
        append(arg0: Internal.StringBuffer): Internal.AbstractStringBuilder;
        append(arg0: string): Internal.AbstractStringBuilder;
        append(arg0: number): Internal.AbstractStringBuilder;
        append(arg0: number): Internal.AbstractStringBuilder;
        append(arg0: number): Internal.AbstractStringBuilder;
        append(arg0: number): Internal.AbstractStringBuilder;
        append(arg0: string): Internal.AbstractStringBuilder;
        append(arg0: string): Internal.Appendable;
        append(arg0: boolean): Internal.AbstractStringBuilder;
        append(arg0: string[], arg1: number, arg2: number): Internal.AbstractStringBuilder;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class RoundingMode extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.RoundingMode;
        static valueOf(arg0: number): Internal.RoundingMode;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.RoundingMode[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.RoundingMode): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.RoundingMode>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.RoundingMode>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly DOWN : Internal.RoundingMode;
        static readonly FLOOR : Internal.RoundingMode;
        static readonly UNNECESSARY : Internal.RoundingMode;
        static readonly CEILING : Internal.RoundingMode;
        static readonly HALF_EVEN : Internal.RoundingMode;
        static readonly UP : Internal.RoundingMode;
        static readonly HALF_UP : Internal.RoundingMode;
        static readonly HALF_DOWN : Internal.RoundingMode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.RoundingMode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockEntityPredicate implements Internal.BlockPredicate {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        data(cd: Internal.BlockEntityPredicateDataCheck): Internal.BlockEntityPredicate;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        check(block: Internal.BlockContainerJS): boolean;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Float2IntFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface GatheringByteChannel extends Internal.WritableByteChannel {
        isOpen(): boolean;
        close(): void;
        write(arg0: Internal.ByteBuffer[], arg1: number, arg2: number): number;
        write(arg0: Internal.ByteBuffer[]): number;
        write(arg0: Internal.ByteBuffer): number;
    }
    abstract class ClassLoader {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getResource(arg0: string): Internal.URL;
        getName(): string;
        notifyAll(): void;
        setDefaultAssertionStatus(arg0: boolean): void;
        setPackageAssertionStatus(arg0: string, arg1: boolean): void;
        notify(): void;
        setClassAssertionStatus(arg0: string, arg1: boolean): void;
        getDefinedPackage(arg0: string): Internal.Package;
        clearAssertionStatus(): void;
        isRegisteredAsParallelCapable(): boolean;
        getResources(arg0: string): Internal.Enumeration<Internal.URL>;
        hashCode(): number;
        getDefinedPackages(): Internal.Package[];
        getUnnamedModule(): Internal.Module;
        static getSystemResources(arg0: string): Internal.Enumeration<Internal.URL>;
        getParent(): Internal.ClassLoader;
        static getPlatformClassLoader(): Internal.ClassLoader;
        getResourceAsStream(arg0: string): Internal.InputStream;
        resources(arg0: string): Internal.Stream<Internal.URL>;
        static getSystemClassLoader(): Internal.ClassLoader;
        static getSystemResource(arg0: string): Internal.URL;
        static getSystemResourceAsStream(arg0: string): Internal.InputStream;
        equals(arg0: any): boolean;
        loadClass(arg0: string): Internal.Class<any>;
        toString(): string;
        get parent(): Internal.ClassLoader;
        get systemClassLoader(): Internal.ClassLoader;
        get unnamedModule(): Internal.Module;
        get name(): string;
        get registeredAsParallelCapable(): boolean;
        get platformClassLoader(): Internal.ClassLoader;
        get definedPackages(): Internal.Package[];
        get class(): Internal.Class<any>;
        set defaultAssertionStatus(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class RuntimeException extends Internal.Exception {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        printStackTrace(): void;
        printStackTrace(arg0: Internal.PrintStream): void;
        printStackTrace(arg0: Internal.PrintWriter): void;
        getLocalizedMessage(): string;
        notifyAll(): void;
        initCause(arg0: Internal.Throwable): Internal.Throwable;
        getMessage(): string;
        getCause(): Internal.Throwable;
        notify(): void;
        addSuppressed(arg0: Internal.Throwable): void;
        setStackTrace(arg0: Internal.StackTraceElement[]): void;
        getStackTrace(): Internal.StackTraceElement[];
        hashCode(): number;
        equals(arg0: any): boolean;
        getSuppressed(): Internal.Throwable[];
        toString(): string;
        fillInStackTrace(): Internal.Throwable;
        get localizedMessage(): string;
        get cause(): Internal.Throwable;
        get stackTrace(): Internal.StackTraceElement[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        set stackTrace(arg0: Internal.StackTraceElement[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MetricsRecorder {
    }
    interface SortedMap <K, V> extends Internal.Map<K, V> {
        getOrDefault(arg0: any, arg1: V): V;
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V;
        values(): Internal.Collection<V>;
        replace(arg0: K, arg1: V): V;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replaceAll(arg0: (arg0: K, arg1: V) => V): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: any, arg1: any): boolean;
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        hashCode(): number;
        putAll(arg0: Internal.Map<K, V>): void;
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V;
        get(arg0: any): V;
        lastKey(): K;
        keySet(): Internal.Set<K>;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        containsKey(arg0: any): boolean;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        subMap(arg0: K, arg1: K): Internal.SortedMap<K, V>;
        isEmpty(): boolean;
        clear(): void;
        comparator(): Internal.Comparator<K>;
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        size(): number;
        firstKey(): K;
        equals(arg0: any): boolean;
        headMap(arg0: K): Internal.SortedMap<K, V>;
        putIfAbsent(arg0: K, arg1: V): V;
        tailMap(arg0: K): Internal.SortedMap<K, V>;
    }
    interface EntityInstancingController <T> {
        createInstance(arg0: Internal.MaterialManager, arg1: T): Internal.EntityInstance<T>;
        shouldSkipRender(arg0: T): boolean;
    }
    interface LevelAccessor extends Internal.CommonLevelAccessor, Internal.LevelTimeAccess {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean;
    }
    interface TemporalAccessor {
        getLong(arg0: Internal.TemporalField): number;
        query<R>(arg0: Internal.TemporalQuery<R>): R;
        get(arg0: Internal.TemporalField): number;
        range(arg0: Internal.TemporalField): Internal.ValueRange;
        isSupported(arg0: Internal.TemporalField): boolean;
    }
    interface ExtendedWorld {
        getChunkAtImmediately(arg0: number, arg1: number): Internal.LevelChunk;
        getAnyChunkImmediately(arg0: number, arg1: number): Internal.ChunkAccess;
    }
    interface AsynchronousChannel extends Internal.Channel {
        isOpen(): boolean;
        close(): void;
    }
    interface ExclusionStrategy {
        shouldSkipClass(arg0: Internal.Class<any>): boolean;
        shouldSkipField(arg0: Internal.FieldAttributes): boolean;
    }
    interface Tier {
        getTag(): net.minecraft.tags.Tag<Internal.Block>;
    }
    class MobEffect extends Internal.ForgeRegistryEntry<any> implements Internal.IForgeMobEffect {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: string, arg1: string): Internal.MobEffect;
        setRegistryName(arg0: ResourceLocation): any;
        setRegistryName(arg0: ResourceLocation): Internal.MobEffect;
        setRegistryName(arg0: string): Internal.MobEffect;
        getTags(): Internal.Set<ResourceLocation>;
        is(arg0: net.minecraft.tags.Tag<Internal.MobEffect>): boolean;
        getSortOrder(arg0: Internal.MobEffectInstance): number;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.MobEffect>;
        toString(): string;
        initializeClient(arg0: (arg0: Internal.EffectRenderer) => void): void;
        getCurativeItems(): Internal.List<Internal.ItemStack>;
        getEffectRendererInternal(): any;
        readonly delegate : () => Internal.MobEffect;
        get registryType(): Internal.Class<Internal.MobEffect>;
        get curativeItems(): Internal.List<Internal.ItemStack>;
        get effectRendererInternal(): any;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Spliterator$OfLong extends Internal.Spliterator$OfPrimitive<number, Internal.LongConsumer, Internal.Spliterator$OfLong> {
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>;
        trySplit(): Internal.Spliterator<any>;
        trySplit(): Internal.Spliterator$OfLong;
        characteristics(): number;
        tryAdvance(arg0: Internal.LongConsumer): boolean;
        tryAdvance(arg0: (arg0: number) => void): boolean;
        tryAdvance(arg0: any): boolean;
        getComparator(): Internal.Comparator<number>;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: any): void;
        forEachRemaining(arg0: Internal.LongConsumer): void;
        forEachRemaining(arg0: (arg0: number) => void): void;
    }
    class ModuleDescriptor$Version implements Internal.Comparable<Internal.ModuleDescriptor$Version> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        static parse(arg0: string): Internal.ModuleDescriptor$Version;
        compareTo(arg0: Internal.ModuleDescriptor$Version): number;
        compareTo(arg0: any): number;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface CompletionHandler <V, A> {
        failed(arg0: Internal.Throwable, arg1: A): void;
        completed(arg0: V, arg1: A): void;
    }
    abstract class ShortBuffer extends Internal.Buffer implements Internal.Comparable<Internal.ShortBuffer> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        compact(): Internal.ShortBuffer;
        notifyAll(): void;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ShortBuffer): number;
        notify(): void;
        asReadOnlyBuffer(): Internal.ShortBuffer;
        put(arg0: number[]): Internal.ShortBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ShortBuffer;
        put(arg0: number, arg1: number[]): Internal.ShortBuffer;
        put(arg0: number[], arg1: number, arg2: number): Internal.ShortBuffer;
        put(arg0: number, arg1: Internal.ShortBuffer, arg2: number, arg3: number): Internal.ShortBuffer;
        put(arg0: Internal.ShortBuffer): Internal.ShortBuffer;
        put(arg0: number, arg1: number): Internal.ShortBuffer;
        put(arg0: number): Internal.ShortBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        slice(): Internal.Buffer;
        slice(): Internal.ShortBuffer;
        slice(arg0: number, arg1: number): Internal.Buffer;
        slice(arg0: number, arg1: number): Internal.ShortBuffer;
        array(): number[];
        array(): any;
        hashCode(): number;
        get(): number;
        get(arg0: number, arg1: number[]): Internal.ShortBuffer;
        get(arg0: number): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ShortBuffer;
        get(arg0: number[], arg1: number, arg2: number): Internal.ShortBuffer;
        get(arg0: number[]): Internal.ShortBuffer;
        limit(arg0: number): Internal.ShortBuffer;
        limit(arg0: number): Internal.Buffer;
        limit(): number;
        arrayOffset(): number;
        flip(): Internal.Buffer;
        flip(): Internal.ShortBuffer;
        order(): Internal.ByteOrder;
        hasArray(): boolean;
        hasRemaining(): boolean;
        clear(): Internal.Buffer;
        clear(): Internal.ShortBuffer;
        duplicate(): Internal.ShortBuffer;
        duplicate(): Internal.Buffer;
        remaining(): number;
        static allocate(arg0: number): Internal.ShortBuffer;
        rewind(): Internal.Buffer;
        rewind(): Internal.ShortBuffer;
        mismatch(arg0: Internal.ShortBuffer): number;
        equals(arg0: any): boolean;
        reset(): Internal.Buffer;
        reset(): Internal.ShortBuffer;
        toString(): string;
        position(arg0: number): Internal.ShortBuffer;
        position(arg0: number): Internal.Buffer;
        position(): number;
        isDirect(): boolean;
        static wrap(arg0: number[]): Internal.ShortBuffer;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.ShortBuffer;
        mark(): Internal.Buffer;
        mark(): Internal.ShortBuffer;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface UnbakedModel {
    }
    class LithiumStackList extends Internal.NonNullList<any> implements Internal.LithiumDefaultedList {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        clearSignalStrengthOverride(): void;
        hasSignalStrengthOverride(): boolean;
        getDelegate(): Internal.List<any>;
        beforeSlotCountChange(slot: number, newCount: number): void;
        changedInteractionConditions(): void;
        replaceAll(arg0: (arg0: any) => any): void;
        notify(): void;
        remove(arg0: number): any;
        remove(index: number): Internal.ItemStack;
        remove(arg0: any): boolean;
        runComparatorUpdatePatternOnFailedExtract(masterStackList: Internal.LithiumStackList, inventory: Internal.Container): void;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.Iterator<Internal.ItemStack>;
        setUnstableInteractionConditions(): void;
        stream(): Internal.Stream<Internal.ItemStack>;
        changedALot(): void;
        hashCode(): number;
        get(arg0: number): Internal.ItemStack;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<Internal.ItemStack>;
        indexOf(arg0: any): number;
        add(slot: number, element: Internal.ItemStack): void;
        add(arg0: number, arg1: any): void;
        add(arg0: Internal.ItemStack): boolean;
        subList(arg0: number, arg1: number): Internal.List<Internal.ItemStack>;
        set(arg0: number, arg1: any): any;
        set(index: number, element: Internal.ItemStack): Internal.ItemStack;
        spliterator(): Internal.Spliterator<Internal.ItemStack>;
        forEach(arg0: (arg0: Internal.ItemStack) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator<Internal.ItemStack>): void;
        removeIf(arg0: (arg0: Internal.ItemStack) => boolean): boolean;
        getOccupiedSlots(): number;
        lastIndexOf(arg0: any): number;
        setReducedSignalStrengthOverride(): void;
        contains(arg0: any): boolean;
        size(): number;
        getModCount(): number;
        addAll(arg0: number, arg1: Internal.Collection<Internal.ItemStack>): boolean;
        addAll(arg0: Internal.Collection<Internal.ItemStack>): boolean;
        equals(arg0: any): boolean;
        getSignalStrength(inventory: Internal.Container): number;
        listIterator(): Internal.ListIterator<Internal.ItemStack>;
        listIterator(arg0: number): Internal.ListIterator<Internal.ItemStack>;
        toString(): string;
        getFullSlots(): number;
        retainAll(arg0: Internal.Collection<any>): boolean;
        changed(): void;
        get delegate(): Internal.List<any>;
        get modCount(): number;
        get fullSlots(): number;
        get occupiedSlots(): number;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class DynamicConstantDesc <T> implements Internal.ConstantDesc {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static ofCanonical<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: string, arg2: Internal.ClassDesc, arg3: Internal.ConstantDesc[]): Internal.ConstantDesc;
        bootstrapMethod(): Internal.DirectMethodHandleDesc;
        constantName(): string;
        notifyAll(): void;
        bootstrapArgsList(): Internal.List<Internal.ConstantDesc>;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): T;
        notify(): void;
        constantType(): Internal.ClassDesc;
        hashCode(): number;
        bootstrapArgs(): Internal.ConstantDesc[];
        static of<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: Internal.ConstantDesc[]): Internal.DynamicConstantDesc<T_>;
        static of<T_>(arg0: Internal.DirectMethodHandleDesc): Internal.DynamicConstantDesc<T_>;
        equals(arg0: any): boolean;
        static ofNamed<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: string, arg2: Internal.ClassDesc, arg3: Internal.ConstantDesc[]): Internal.DynamicConstantDesc<T_>;
        toString(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IEventHandler {
        onEvent(arg0: Internal.EventJS): void;
    }
    abstract class Stages {
        add(stage: string): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAll(): Internal.Collection<string>;
        set(stage: string, enabled: boolean): boolean;
        static added(event: (arg0: Internal.StageChangeEvent) => void): void;
        notifyAll(): void;
        static invokeAdded(stages: Internal.Stages, stage: string): void;
        replace(stages: Internal.Collection<string>): void;
        clear(): boolean;
        toggle(stage: string): boolean;
        addNoUpdate(arg0: string): boolean;
        sync(): void;
        notify(): void;
        remove(stage: string): boolean;
        static removed(event: (arg0: Internal.StageChangeEvent) => void): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        static get(player: Internal.Player): Internal.Stages;
        toString(): string;
        static invokeRemoved(stages: Internal.Stages, stage: string): void;
        static overrideCreation(event: (arg0: Internal.StageCreationEvent) => void): void;
        has(stage: string): boolean;
        removeNoUpdate(arg0: string): boolean;
        readonly player : Internal.Player;
        get all(): Internal.Collection<string>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class BlockType {
        getClass(): Internal.Class<any>;
        applyDefaults(builder: Internal.BlockBuilder): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        generateBlockModels(builder: Internal.BlockBuilder): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        createBlock(arg0: Internal.BlockBuilder): Internal.Block;
        generateData(builder: Internal.BlockBuilder, generator: Internal.DataJsonGenerator): void;
        toString(): string;
        generateAssets(b: Internal.BlockBuilder, generator: Internal.AssetJsonGenerator): void;
        notify(): void;
        readonly name : string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BinaryOperator <T> extends Internal.BiFunction<T, T, T> {
        apply(arg0: T, arg1: T): T;
        andThen<V_>(arg0: (arg0: T) => V_): (arg0: T, arg1: T) => V_;
    }
    class ModuleDescriptor$Opens$Modifier extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ModuleDescriptor$Opens$Modifier;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ModuleDescriptor$Opens$Modifier[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ModuleDescriptor$Opens$Modifier): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ModuleDescriptor$Opens$Modifier>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ModuleDescriptor$Opens$Modifier>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Opens$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Opens$Modifier;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ModuleDescriptor$Opens$Modifier>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FoodBuilder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        removeEffect(mobEffect: Internal.MobEffect): Internal.FoodBuilder;
        notifyAll(): void;
        alwaysEdible(): Internal.FoodBuilder;
        alwaysEdible(flag: boolean): Internal.FoodBuilder;
        fastToEat(flag: boolean): Internal.FoodBuilder;
        fastToEat(): Internal.FoodBuilder;
        notify(): void;
        hunger(h: number): Internal.FoodBuilder;
        saturation(s: number): Internal.FoodBuilder;
        build(): Internal.FoodProperties;
        hashCode(): number;
        equals(arg0: any): boolean;
        effect(mobEffectId: ResourceLocation, duration: number, amplifier: number, probability: number): Internal.FoodBuilder;
        meat(flag: boolean): Internal.FoodBuilder;
        meat(): Internal.FoodBuilder;
        toString(): string;
        eaten(e: (arg0: Internal.ItemFoodEatenEventJS) => void): Internal.FoodBuilder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FireworkRocketEntity extends Internal.Projectile implements Internal.ItemSupplier, Internal.FireworkRocketEntityKJS {
        getClass(): Internal.Class<any>;
        backpackedMoved(): boolean;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>;
        handler$zje000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void;
        onEndimationEnd(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        canBeRiddenInWater(arg0: Internal.Entity): boolean;
        handler$zzo000$tickHead(arg0: Internal.CallbackInfo): void;
        setLifetimeKJS(arg0: number): void;
        isEndimationPlaying(arg0: Internal.PlayableEndimation): boolean;
        isActive(): boolean;
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity;
        getCachedFeetBlockState(): Internal.BlockState;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        handler$bfj000$tryShortcutFluidPushing(tag: net.minecraft.tags.Tag<any>, speed: number, cir: Internal.CallbackInfoReturnable<any>, box: Internal.AABB, x1: number, x2: number, y1: number, y2: number, z1: number, z2: number, zero: number): void;
        getPos(): Internal.Position;
        revive(): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(arg0: boolean): void;
        canUpdate(): boolean;
        getEndimatedState(): Internal.Endimatable$EndimatedState;
        resetEndimation(): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean;
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number;
        reviveCaps(): void;
        lithiumOnBlockCacheDeleted(): void;
        canRiderInteract(): boolean;
        getEntries(arg0: boolean): Internal.Set<any>;
        getEffectHandler(): Internal.EndimationEffectHandler;
        onAddedToWorld(): void;
        setAnimationTick(arg0: number): void;
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean;
        getListener(): Internal.NearbyEntityListenerMulti;
        getClassification(arg0: boolean): Internal.MobCategory;
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listening: boolean): void;
        isNoEndimationPlaying(): boolean;
        onEndimationStart(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        shouldRiderSit(): boolean;
        getIsInsidePortal(): boolean;
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$zje000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        handler$zcg000$read(arg0: Internal.CompoundTag, arg1: Internal.CallbackInfo): void;
        getRemainingFireTicks(): number;
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void;
        notify(): void;
        getDataMap(): Internal.Map<any, any>;
        handler$zzo000$moveStep(arg0: Internal.MoverType, arg1: Vec3, arg2: Internal.CallbackInfo): void;
        getEntityChangeListener(): Internal.EntityInLevelCallback;
        endimateTick(): void;
        setDataMap(arg0: Internal.Map<any, any>): void;
        isDirty(): boolean;
        hashCode(): number;
        isAddedToWorld(): boolean;
        getParts(): any[];
        addListener(listener: Internal.NearbyEntityListener): void;
        onRemovedFromWorld(): void;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        clean(): void;
        asKJS(): any;
        getPlayingEndimation(): Internal.PlayableEndimation;
        getDirtyEntries(): Internal.Set<any>;
        getValue(arg0: Internal.TrackedData<any>): any;
        setPlayingEndimation(arg0: Internal.PlayableEndimation): void;
        setValue(arg0: Internal.TrackedData<any>, arg1: any): void;
        equals(arg0: any): boolean;
        getAnimationTick(): number;
        toString(): string;
        setRemainingFireTicks(arg0: number): void;
        handler$zgd001$tick(arg0: Internal.CallbackInfo): void;
        get dirty(): boolean;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get entityChangeListener(): Internal.EntityInLevelCallback;
        get listener(): Internal.NearbyEntityListenerMulti;
        get multipartEntity(): boolean;
        get active(): boolean;
        get addedToWorld(): boolean;
        get playingEndimation(): Internal.PlayableEndimation;
        get effectHandler(): Internal.EndimationEffectHandler;
        get cachedFeetBlockState(): Internal.BlockState;
        get dirtyEntries(): Internal.Set<any>;
        get animationTick(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get pos(): Internal.Position;
        get dataMap(): Internal.Map<any, any>;
        get noEndimationPlaying(): boolean;
        get parts(): any[];
        get endimatedState(): Internal.Endimatable$EndimatedState;
        get class(): Internal.Class<any>;
        set animationTick(arg0: number);
        set remainingFireTicks(arg0: number);
        set dataMap(arg0: Internal.Map<any, any>);
        set playingEndimation(arg0: Internal.PlayableEndimation);
        set lifetimeKJS(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface HeadedModel {
    }
    class NonNullList <E> extends Internal.AbstractList<any> implements Internal.DefaultedListAccessor<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getDelegate(): Internal.List<any>;
        replaceAll(arg0: (arg0: any) => any): void;
        notify(): void;
        remove(arg0: number): E;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.Iterator<E>;
        stream(): Internal.Stream<E>;
        hashCode(): number;
        get(arg0: number): E;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: E): void;
        add(arg0: E): boolean;
        subList(arg0: number, arg1: number): Internal.List<E>;
        set(arg0: number, arg1: E): E;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: (arg0: E) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator<E>): void;
        removeIf(arg0: (arg0: E) => boolean): boolean;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean;
        addAll(arg0: Internal.Collection<E>): boolean;
        equals(arg0: any): boolean;
        listIterator(): Internal.ListIterator<E>;
        listIterator(arg0: number): Internal.ListIterator<E>;
        toString(): string;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get delegate(): Internal.List<any>;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class IDataManager$DataEntry <T> {
        getClass(): Internal.Class<any>;
        readValue(arg0: Internal.CompoundTag, arg1: boolean): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static read(arg0: Internal.FriendlyByteBuf): Internal.IDataManager$DataEntry<any>;
        markDirty(): void;
        notifyAll(): void;
        clean(): void;
        notify(): void;
        getValue(): T;
        isDirty(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        setValue(arg0: T, arg1: boolean): void;
        toString(): string;
        writeValue(): Internal.CompoundTag;
        getTrackedData(): Internal.TrackedData<T>;
        write(arg0: Internal.FriendlyByteBuf): void;
        get dirty(): boolean;
        get trackedData(): Internal.TrackedData<T>;
        get class(): Internal.Class<any>;
        get value(): T;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ColorAccess {
        getColorRaw(): number;
    }
    abstract class JsonElement {
        getAsFloat(): number;
        getClass(): Internal.Class<any>;
        getAsByte(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAsBigDecimal(): Internal.BigDecimal;
        notifyAll(): void;
        getAsNumber(): Internal.Number;
        getAsCharacter(): string;
        getAsString(): string;
        isJsonArray(): boolean;
        notify(): void;
        getAsInt(): number;
        isJsonPrimitive(): boolean;
        getAsLong(): number;
        hashCode(): number;
        isJsonObject(): boolean;
        getAsBigInteger(): Internal.BigInteger;
        getAsJsonObject(): Internal.JsonObject;
        getAsJsonNull(): Internal.JsonNull;
        isJsonNull(): boolean;
        getAsDouble(): number;
        deepCopy(): Internal.JsonElement;
        getAsJsonArray(): Internal.JsonArray;
        getAsJsonPrimitive(): Internal.JsonPrimitive;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getAsShort(): number;
        get asByte(): number;
        get asBigInteger(): Internal.BigInteger;
        get asJsonObject(): Internal.JsonObject;
        get asCharacter(): string;
        get jsonPrimitive(): boolean;
        get asNumber(): Internal.Number;
        get asBigDecimal(): Internal.BigDecimal;
        get jsonNull(): boolean;
        get asFloat(): number;
        get asLong(): number;
        get asInt(): number;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get asJsonNull(): Internal.JsonNull;
        get asShort(): number;
        get asDouble(): number;
        get asJsonArray(): Internal.JsonArray;
        get asString(): string;
        get jsonObject(): boolean;
        get class(): Internal.Class<any>;
        get jsonArray(): boolean;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Vector4f {
        setW(arg0: number): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setY(arg0: number): void;
        setX(arg0: number): void;
        set(arg0: number[]): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        setZ(arg0: number): void;
        notify(): void;
        get class(): Internal.Class<any>;
        set w(arg0: number);
        set x(arg0: number);
        set y(arg0: number);
        set z(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AttributeView {
        name(): string;
    }
    interface Keyable {
        keys<T>(arg0: Internal.DynamicOps<T>): Internal.Stream<T>;
    }
    abstract class FluidStackJS implements Internal.WrappedJS, Internal.Copyable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getNbt(): Internal.CompoundTag;
        getChance(): number;
        notifyAll(): void;
        getTags(): Internal.Collection<ResourceLocation>;
        getId(): string;
        notify(): void;
        toNBT(): Internal.CompoundTag;
        setChance(c: number): void;
        hashCode(): number;
        static of(o: any, amount: number, nbt: Internal.CompoundTag): Internal.FluidStackJS;
        static of(o: any): Internal.FluidStackJS;
        withAmount(amount: number): Internal.FluidStackJS;
        withChance(c: number): Internal.FluidStackJS;
        copy(): Internal.FluidStackJS;
        copy(): Internal.Copyable;
        setAmount(arg0: number): void;
        withNBT(nbt: Internal.CompoundTag): Internal.FluidStackJS;
        getAmount(): number;
        hasTag(tag: ResourceLocation): boolean;
        isEmpty(): boolean;
        hasChance(): boolean;
        strongEquals(o: any): boolean;
        getFluidStack(): Internal.FluidStack;
        toJson(): Internal.JsonObject;
        equals(o: any): boolean;
        getFluid(): Internal.Fluid;
        static fromJson(e: Internal.JsonElement): Internal.FluidStackJS;
        toString(): string;
        removeChance(): void;
        setNbt(arg0: Internal.CompoundTag): void;
        get nbt(): Internal.CompoundTag;
        get amount(): number;
        get chance(): number;
        get fluidStack(): Internal.FluidStack;
        get fluid(): Internal.Fluid;
        get id(): string;
        get class(): Internal.Class<any>;
        get tags(): Internal.Collection<ResourceLocation>;
        get empty(): boolean;
        set nbt(arg0: Internal.CompoundTag);
        set amount(arg0: number);
        set chance(c: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ListBuilder <T> {
        withErrorsFrom(arg0: Internal.DataResult<any>): Internal.ListBuilder<T>;
        add(arg0: Internal.DataResult<T>): Internal.ListBuilder<T>;
        add(arg0: T): Internal.ListBuilder<T>;
        add<E>(arg0: E, arg1: Internal.Encoder<E>): Internal.ListBuilder<T>;
        mapError(arg0: (arg0: any) => any): Internal.ListBuilder<T>;
        ops(): Internal.DynamicOps<T>;
        build(arg0: T): Internal.DataResult<T>;
        build(arg0: Internal.DataResult<T>): Internal.DataResult<T>;
        addAll<E>(arg0: Internal.Iterable<E>, arg1: Internal.Encoder<E>): Internal.ListBuilder<T>;
    }
    class ModuleDescriptor$Modifier extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ModuleDescriptor$Modifier;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ModuleDescriptor$Modifier[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ModuleDescriptor$Modifier): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ModuleDescriptor$Modifier>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ModuleDescriptor$Modifier>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly AUTOMATIC : Internal.ModuleDescriptor$Modifier;
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Modifier;
        static readonly OPEN : Internal.ModuleDescriptor$Modifier;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ModuleDescriptor$Modifier>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ServerLevelJS extends Internal.LevelJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(entity: Internal.Entity): Internal.PlayerJS<any>;
        getEntitiesWithin(aabb: Internal.AABB): Internal.EntityArrayList;
        getPlayerData(arg0: Internal.Player): Internal.PlayerDataJS<any, any>;
        getPlayerData(player: Internal.Player): Internal.ServerPlayerDataJS;
        spawnFireworks(x: number, y: number, z: number, f: Internal.FireworksJS): void;
        getTime(): number;
        notifyAll(): void;
        getSide(): Internal.ScriptType;
        getGameRules(): Internal.GameRulesJS;
        notify(): void;
        setRainStrength(strength: number): void;
        hashCode(): number;
        getDimension(): string;
        isDaytime(): boolean;
        createEntityList(entities: Internal.Collection<Internal.Entity>): Internal.EntityArrayList;
        getPlayers(): Internal.EntityArrayList;
        getData(): Internal.AttachedData;
        getMinecraftLevel(): Internal.ServerLevel;
        getMinecraftLevel(): net.minecraft.world.level.Level;
        setTime(time: number): void;
        getServer(): Internal.ServerJS;
        getLivingEntity(entity: Internal.Entity): Internal.LivingEntityJS;
        getBlock(x: number, y: number, z: number): Internal.BlockContainerJS;
        getBlock(pos: BlockPos): Internal.BlockContainerJS;
        getBlock(blockEntity: Internal.BlockEntity): Internal.BlockContainerJS;
        getSeed(): number;
        isOverworld(): boolean;
        createExplosion(x: number, y: number, z: number): Internal.ExplosionJS;
        getEntity(e: Internal.Entity): Internal.EntityJS;
        createEntity(id: ResourceLocation): Internal.EntityJS;
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean): void;
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean, player: Internal.EntityJS): void;
        getLocalTime(): number;
        equals(arg0: any): boolean;
        isThundering(): boolean;
        getEntities(): Internal.EntityArrayList;
        getEntities(filter: string): Internal.EntityArrayList;
        toString(): string;
        isRaining(): boolean;
        setLocalTime(time: number): void;
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftLevel : net.minecraft.world.level.Level;
        get server(): Internal.ServerJS;
        get side(): Internal.ScriptType;
        get data(): Internal.AttachedData;
        get seed(): number;
        get players(): Internal.EntityArrayList;
        get raining(): boolean;
        get thundering(): boolean;
        get overworld(): boolean;
        get gameRules(): Internal.GameRulesJS;
        get localTime(): number;
        get entities(): Internal.EntityArrayList;
        get time(): number;
        get class(): Internal.Class<any>;
        get dimension(): string;
        get daytime(): boolean;
        set localTime(time: number);
        set time(time: number);
        set rainStrength(strength: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ByteChannel extends Internal.ReadableByteChannel, Internal.WritableByteChannel {
        isOpen(): boolean;
        read(arg0: Internal.ByteBuffer): number;
        write(arg0: Internal.ByteBuffer): number;
        close(): void;
    }
    class Throwable implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        printStackTrace(): void;
        printStackTrace(arg0: Internal.PrintStream): void;
        printStackTrace(arg0: Internal.PrintWriter): void;
        getLocalizedMessage(): string;
        notifyAll(): void;
        initCause(arg0: Internal.Throwable): Internal.Throwable;
        getMessage(): string;
        getCause(): Internal.Throwable;
        notify(): void;
        addSuppressed(arg0: Internal.Throwable): void;
        setStackTrace(arg0: Internal.StackTraceElement[]): void;
        getStackTrace(): Internal.StackTraceElement[];
        hashCode(): number;
        equals(arg0: any): boolean;
        getSuppressed(): Internal.Throwable[];
        toString(): string;
        fillInStackTrace(): Internal.Throwable;
        get localizedMessage(): string;
        get cause(): Internal.Throwable;
        get stackTrace(): Internal.StackTraceElement[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        set stackTrace(arg0: Internal.StackTraceElement[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BiomeManager$NoiseBiomeSource {
    }
    class EventsJS$ScriptEventHandler {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface SlotAccessor {
        setY(arg0: number): void;
        setX(arg0: number): void;
    }
    interface Annotation {
        hashCode(): number;
        equals(arg0: any): boolean;
        annotationType(): Internal.Class<Internal.Annotation>;
        toString(): string;
    }
    class MathContext implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRoundingMode(): Internal.RoundingMode;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        getPrecision(): number;
        static readonly DECIMAL128 : Internal.MathContext;
        static readonly DECIMAL64 : Internal.MathContext;
        static readonly DECIMAL32 : Internal.MathContext;
        static readonly UNLIMITED : Internal.MathContext;
        get roundingMode(): Internal.RoundingMode;
        get precision(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FileFilter {
        accept(arg0: Internal.File): boolean;
    }
    interface Function16 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, Internal.Function4<T13, T14, T15, T16, R>>;
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function7<T10, T11, T12, T13, T14, T15, T16, R>>;
        curry13(): Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, Internal.Function3<T14, T15, T16, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13, arg13: T14, arg14: T15, arg15: T16): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function9<T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry14(): Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, (arg0: T15, arg1: T16) => R>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function8<T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry15(): Internal.Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, (arg0: T16) => R>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function6<T11, T12, T13, T14, T15, T16, R>>;
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function5<T12, T13, T14, T15, T16, R>>;
        curry(): (arg0: T1) => Internal.Function15<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function11<T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function10<T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function13<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function12<T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry2(): (arg0: T1, arg1: T2) => Internal.Function14<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>;
    }
    class Endimatable$EndimatedState {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        animationTick : number;
        endimation : Internal.PlayableEndimation;
        readonly effectHandler : Internal.EndimationEffectHandler;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EventListener {
    }
    class Block extends Internal.BlockBehaviour implements Internal.ItemLike, Internal.IForgeBlock, Internal.BlockPathingBehavior {
        rotate(arg0: Internal.BlockState, arg1: Internal.LevelAccessor, arg2: BlockPos, arg3: Internal.Rotation): Internal.BlockState;
        getClass(): Internal.Class<any>;
        getStateAtViewpoint(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Vec3): Internal.BlockState;
        onBlockExploded(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Explosion): void;
        getBedDirection(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): Internal.Direction;
        getTags(): Internal.Set<ResourceLocation>;
        isBed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean;
        canHarvestBlock(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Player): boolean;
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.BlockState): boolean;
        setMaterialKJS(arg0: net.minecraft.world.level.material.Material): void;
        isLadder(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockState, arg1: Internal.BlockAndTintGetter, arg2: BlockPos, arg3: Internal.FluidState): boolean;
        canStickTo(arg0: Internal.BlockState, arg1: Internal.BlockState): boolean;
        onNeighborChange(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): void;
        getWeakChanges(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): boolean;
        isBurning(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean;
        canEntityDestroy(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean;
        getFriction(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): number;
        isValidSpawn(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.SpawnPlacements$Type, arg4: Internal.EntityType<any>): boolean;
        isPortalFrame(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean;
        getExplosionResistance(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): number;
        getPathNodeType(state: Internal.BlockState): Internal.BlockPathTypes;
        isScaffolding(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.LivingEntity): boolean;
        setExplosionResistanceKJS(arg0: number): void;
        canSustainPlant(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.IPlantable): boolean;
        setJumpFactorKJS(arg0: number): void;
        canDropFromExplosion(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): boolean;
        getMaterial(): net.minecraft.world.level.material.Material;
        isStickyBlock(arg0: Internal.BlockState): boolean;
        setSoundTypeKJS(arg0: Internal.SoundType): void;
        isFertile(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): boolean;
        getAiPathNodeType(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Mob): Internal.BlockPathTypes;
        getBlockBuilderKJS(): Internal.BlockBuilder;
        isSlimeBlock(arg0: Internal.BlockState): boolean;
        getRegistryType(): Internal.Class<Internal.Block>;
        getFireSpreadSpeed(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number;
        getToolModifiedState(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Player, arg4: Internal.ItemStack, arg5: Internal.ToolAction): Internal.BlockState;
        getBeaconColorMultiplier(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): number[];
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getExpDrop(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: number, arg4: number): number;
        isConduitFrame(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: BlockPos): boolean;
        notifyAll(): void;
        getPathNodeTypeAsNeighbor(state: Internal.BlockState): Internal.BlockPathTypes;
        getLightEmission(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos): number;
        onDestroyedByPlayer(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Player, arg4: boolean, arg5: Internal.FluidState): boolean;
        getId(): string;
        shouldCheckWeakPower(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean;
        collisionExtendsVertically(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Entity): boolean;
        notify(): void;
        addLandingEffects(arg0: Internal.BlockState, arg1: Internal.ServerLevel, arg2: BlockPos, arg3: Internal.BlockState, arg4: Internal.LivingEntity, arg5: number): boolean;
        getRenderPropertiesInternal(): any;
        getSoundType(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity): Internal.SoundType;
        hashCode(): number;
        addRunningEffects(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Entity): boolean;
        initializeClient(arg0: (arg0: Internal.IBlockRenderProperties) => void): void;
        getCloneItemStack(arg0: Internal.BlockState, arg1: Internal.HitResult, arg2: Internal.BlockGetter, arg3: BlockPos, arg4: Internal.Player): Internal.ItemStack;
        setFrictionKJS(arg0: number): void;
        setHasCollisionKJS(arg0: boolean): void;
        getBlockStatesKJS(): Internal.List<Internal.BlockState>;
        isFlammable(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean;
        onCaughtFire(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.Direction, arg4: Internal.LivingEntity): void;
        getEnchantPowerBonus(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos): number;
        getRegistryName(): ResourceLocation;
        setBedOccupied(arg0: Internal.BlockState, arg1: net.minecraft.world.level.Level, arg2: BlockPos, arg3: Internal.LivingEntity, arg4: boolean): void;
        setRegistryName(arg0: string, arg1: string): Internal.Block;
        setRegistryName(arg0: ResourceLocation): any;
        setRegistryName(arg0: ResourceLocation): Internal.Block;
        setRegistryName(arg0: string): Internal.Block;
        isFireSource(arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Direction): boolean;
        setIsRandomlyTickingKJS(arg0: boolean): void;
        getRespawnPosition(arg0: Internal.BlockState, arg1: Internal.EntityType<any>, arg2: Internal.LevelReader, arg3: BlockPos, arg4: number, arg5: Internal.LivingEntity): Internal.Optional<Vec3>;
        equals(arg0: any): boolean;
        canConnectRedstone(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): boolean;
        setSpeedFactorKJS(arg0: number): void;
        setBlockBuilderKJS(b: Internal.BlockBuilder): void;
        toString(): string;
        getFlammability(arg0: Internal.BlockState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Direction): number;
        readonly delegate : () => Internal.Block;
        get registryType(): Internal.Class<Internal.Block>;
        get blockBuilderKJS(): Internal.BlockBuilder;
        get material(): net.minecraft.world.level.material.Material;
        get renderPropertiesInternal(): any;
        get blockStatesKJS(): Internal.List<Internal.BlockState>;
        get id(): string;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        set jumpFactorKJS(arg0: number);
        set isRandomlyTickingKJS(arg0: boolean);
        set blockBuilderKJS(b: Internal.BlockBuilder);
        set frictionKJS(arg0: number);
        set hasCollisionKJS(arg0: boolean);
        set materialKJS(arg0: net.minecraft.world.level.material.Material);
        set speedFactorKJS(arg0: number);
        set soundTypeKJS(arg0: Internal.SoundType);
        set explosionResistanceKJS(arg0: number);
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FormattedText {
        getString(): string;
    }
    interface TemporalUnit {
        isDurationEstimated(): boolean;
        getDuration(): Internal.Duration;
        isTimeBased(): boolean;
        addTo<R>(arg0: R, arg1: number): R;
        toString(): string;
        isDateBased(): boolean;
        between(arg0: Internal.Temporal, arg1: Internal.Temporal): number;
        isSupportedBy(arg0: Internal.Temporal): boolean;
    }
    abstract class Number implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        intValue(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        floatValue(): number;
        toString(): string;
        shortValue(): number;
        doubleValue(): number;
        notify(): void;
        longValue(): number;
        byteValue(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Map$Entry <K, V> {
        getKey(): K;
        getValue(): V;
        hashCode(): number;
        setValue(arg0: V): V;
        equals(arg0: any): boolean;
    }
    class BigInteger extends Internal.Number implements Internal.Comparable<Internal.BigInteger> {
        bitLength(): number;
        getClass(): Internal.Class<any>;
        getLowestSetBit(): number;
        mod(arg0: Internal.BigInteger): Internal.BigInteger;
        byteValueExact(): number;
        gcd(arg0: Internal.BigInteger): Internal.BigInteger;
        compareTo(arg0: Internal.BigInteger): number;
        compareTo(arg0: any): number;
        sqrtAndRemainder(): Internal.BigInteger[];
        shiftLeft(arg0: number): Internal.BigInteger;
        sqrt(): Internal.BigInteger;
        shortValue(): number;
        clearBit(arg0: number): Internal.BigInteger;
        signum(): number;
        add(arg0: Internal.BigInteger): Internal.BigInteger;
        subtract(arg0: Internal.BigInteger): Internal.BigInteger;
        floatValue(): number;
        isProbablePrime(arg0: number): boolean;
        doubleValue(): number;
        nextProbablePrime(): Internal.BigInteger;
        testBit(arg0: number): boolean;
        shiftRight(arg0: number): Internal.BigInteger;
        divideAndRemainder(arg0: Internal.BigInteger): Internal.BigInteger[];
        modPow(arg0: Internal.BigInteger, arg1: Internal.BigInteger): Internal.BigInteger;
        intValueExact(): number;
        andNot(arg0: Internal.BigInteger): Internal.BigInteger;
        modInverse(arg0: Internal.BigInteger): Internal.BigInteger;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        longValueExact(): number;
        notifyAll(): void;
        setBit(arg0: number): Internal.BigInteger;
        shortValueExact(): number;
        notify(): void;
        longValue(): number;
        not(): Internal.BigInteger;
        min(arg0: Internal.BigInteger): Internal.BigInteger;
        and(arg0: Internal.BigInteger): Internal.BigInteger;
        hashCode(): number;
        pow(arg0: number): Internal.BigInteger;
        xor(arg0: Internal.BigInteger): Internal.BigInteger;
        divide(arg0: Internal.BigInteger): Internal.BigInteger;
        multiply(arg0: Internal.BigInteger): Internal.BigInteger;
        flipBit(arg0: number): Internal.BigInteger;
        or(arg0: Internal.BigInteger): Internal.BigInteger;
        max(arg0: Internal.BigInteger): Internal.BigInteger;
        static valueOf(arg0: number): Internal.BigInteger;
        intValue(): number;
        abs(): Internal.BigInteger;
        negate(): Internal.BigInteger;
        toByteArray(): number[];
        equals(arg0: any): boolean;
        toString(arg0: number): string;
        toString(): string;
        bitCount(): number;
        static probablePrime(arg0: number, arg1: Internal.Random): Internal.BigInteger;
        remainder(arg0: Internal.BigInteger): Internal.BigInteger;
        byteValue(): number;
        static readonly ZERO : Internal.BigInteger;
        static readonly ONE : Internal.BigInteger;
        static readonly TEN : Internal.BigInteger;
        static readonly TWO : Internal.BigInteger;
        get lowestSetBit(): number;
        get class(): Internal.Class<any>;
        set bit(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockItemBuilder extends Internal.ItemBuilder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        maxStackSize(v: number): Internal.ItemBuilder;
        translationKey(key: string): Internal.BuilderBase;
        color(index: number, c: number): Internal.ItemBuilder;
        getBuilderType(): string;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase;
        notifyAll(): void;
        maxDamage(v: number): Internal.ItemBuilder;
        tooltip(text: Internal.Component): Internal.ItemBuilder;
        containerItem(id: string): Internal.ItemBuilder;
        type(t: Internal.ItemType): Internal.ItemBuilder;
        notify(): void;
        subtypes(fn: (arg0: Internal.ItemStackJS) => Internal.Collection<Internal.ItemStackJS>): Internal.ItemBuilder;
        tier(t: string): Internal.ItemBuilder;
        hashCode(): number;
        getAttackSpeed(): number;
        burnTime(v: number): Internal.ItemBuilder;
        tag(tag: ResourceLocation): Internal.BuilderBase;
        parentModel(m: string): Internal.ItemBuilder;
        attackDamage(f: number): Internal.ItemBuilder;
        group(g: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        getMiningSpeed(): number;
        miningSpeed(f: number): Internal.ItemBuilder;
        food(b: (arg0: Internal.FoodBuilder) => void): Internal.ItemBuilder;
        unstackable(): Internal.ItemBuilder;
        getAttackDamage(): number;
        equals(arg0: any): boolean;
        attackSpeed(f: number): Internal.ItemBuilder;
        toString(): string;
        glow(v: boolean): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        rarity(v: Rarity): Internal.ItemBuilder;
        toolTier : Internal.Tier;
        foodBuilder : Internal.FoodBuilder;
        defaultTags : Internal.Set<ResourceLocation>;
        armorTier : Internal.ArmorMaterial;
        modelJson : Internal.JsonObject;
        static readonly ARMOR_TIERS : Internal.Map<string, Internal.ArmorMaterial>;
        readonly id : ResourceLocation;
        item : Internal.Item;
        attackSpeedBaseline : number;
        static readonly TOOL_TIERS : Internal.Map<string, Internal.Tier>;
        blockBuilder : Internal.BlockBuilder;
        attackDamageBaseline : number;
        blockItem : Internal.BlockItem;
        get builderType(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Translate <Self> {
        translateZ(arg0: number): Self;
        translateAll(arg0: number): Self;
        translateY(arg0: number): Self;
        translateX(arg0: number): Self;
        centre(): Self;
        unCentre(): Self;
        translate(arg0: number, arg1: number, arg2: number): Self;
        translate(arg0: Internal.Vector3f): Self;
        translate(arg0: Vec3): Self;
        translate(arg0: Vec3i): Self;
        translateBack(arg0: Vec3i): Self;
        translateBack(arg0: number, arg1: number, arg2: number): Self;
        translateBack(arg0: Vec3): Self;
        nudge(arg0: number): Self;
    }
    interface Decoder$Terminal <A> {
        decoder(): Internal.Decoder<A>;
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<A>;
    }
    class SawmillRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        energy(e: number): Internal.IERecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        time(t: number): Internal.IERecipeJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        hasStripped : boolean;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        stripping : Internal.List<boolean>;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<net.minecraftforge.fluids.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ServerSettings {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        static exportData(): void;
        logInvalidRecipeHandlers : boolean;
        useOriginalRecipeForFilters : boolean;
        dataPackOutput : boolean;
        logSkippedRecipes : boolean;
        static instance : Internal.ServerSettings;
        logOverrides : boolean;
        logErroringRecipes : boolean;
        static source : Internal.CommandSourceStack;
        logAddedRecipes : boolean;
        logRemovedRecipes : boolean;
        static dataExport : Internal.JsonObject;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClassInstanceMultiMap <T> extends Internal.AbstractCollection<any> implements Internal.ClassGroupFilterableList<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        notify(): void;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.Iterator<T>;
        stream(): Internal.Stream<T>;
        hashCode(): number;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<T>;
        add(arg0: T): boolean;
        spliterator(): Internal.Spliterator<T>;
        forEach(arg0: (arg0: T) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        getAllOfGroupType(type: Internal.EntityClassGroup): Internal.Collection<any>;
        removeIf(arg0: (arg0: T) => boolean): boolean;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.Collection<T>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        localvar$bem000$remove(o: any): any;
        localvar$bem000$add(entity: any): any;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BackpackedInventoryAccess {
        getBackpackedInventory(): Internal.BackpackInventory;
    }
    class Explosion$BlockInteraction extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Explosion$BlockInteraction;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Explosion$BlockInteraction[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Explosion$BlockInteraction): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Explosion$BlockInteraction>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Explosion$BlockInteraction>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly DESTROY : Internal.Explosion$BlockInteraction;
        static readonly BREAK : Internal.Explosion$BlockInteraction;
        static readonly NONE : Internal.Explosion$BlockInteraction;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Explosion$BlockInteraction>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Thread$UncaughtExceptionHandler {
        uncaughtException(arg0: Internal.Thread, arg1: Internal.Throwable): void;
    }
    abstract class BlockBehaviour$BlockStateBase extends Internal.StateHolder<any, any> implements Internal.BlockStateKJS, Internal.BlockStatePathingCache, Internal.BlockStateFlagHolder, Internal.ExtendedAbstractBlockState {
        getNeighborTable(): Internal.Table<any, any, any>;
        getStateIndex(): number;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$zhp000$cacheStateTail(ci: Internal.CallbackInfo): void;
        notifyAll(): void;
        getOpacityIfCached(): number;
        setRequiresToolKJS(arg0: boolean): void;
        notify(): void;
        setMaterialKJS(arg0: net.minecraft.world.level.material.Material): void;
        replacePropertyMap(newMap: Internal.ImmutableMap<any, any>): void;
        handler$zkf000$onBlockCollision(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Entity, arg3: Internal.CallbackInfo): void;
        hashCode(): number;
        setStateIndex(newValue: number): void;
        getVanillaPropertyMap(): Internal.ImmutableMap<any, any>;
        handler$bmk000$initLightAccessState(arg0: Internal.CallbackInfo): void;
        setDestroySpeedKJS(arg0: number): void;
        getNeighborPathNodeType(): Internal.BlockPathTypes;
        setLightEmissionKJS(arg0: number): void;
        getPathNodeType(): Internal.BlockPathTypes;
        redirect$zhl000$getNeighborFromFastMap(ignore: Internal.Table<any, any, any>, rowKey: any, columnKey: any): any;
        setNeighborTable(table: Internal.Table<any, any, any>): void;
        setStateMap(newValue: Internal.FastMap<any>): void;
        getStateMap(): Internal.FastMap<any>;
        isConditionallyFullOpaque(): boolean;
        equals(arg0: any): boolean;
        getAllFlags(): number;
        toString(): string;
        handler$zhp000$cacheStateHead(ci: Internal.CallbackInfo): void;
        get conditionallyFullOpaque(): boolean;
        get opacityIfCached(): number;
        get stateIndex(): number;
        get neighborTable(): Internal.Table<any, any, any>;
        get stateMap(): Internal.FastMap<any>;
        get neighborPathNodeType(): Internal.BlockPathTypes;
        get class(): Internal.Class<any>;
        get allFlags(): number;
        get pathNodeType(): Internal.BlockPathTypes;
        get vanillaPropertyMap(): Internal.ImmutableMap<any, any>;
        set materialKJS(arg0: net.minecraft.world.level.material.Material);
        set requiresToolKJS(arg0: boolean);
        set stateIndex(newValue: number);
        set stateMap(newValue: Internal.FastMap<any>);
        set neighborTable(table: Internal.Table<any, any, any>);
        set destroySpeedKJS(arg0: number);
        set lightEmissionKJS(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface NBTSerializable {
        toNBT(): Internal.Tag;
    }
    abstract class ImmutableList <E> extends Internal.ImmutableCollection<any> implements Internal.List<E>, Internal.RandomAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        replaceAll(arg0: (arg0: any) => any): void;
        notify(): void;
        asList(): Internal.ImmutableList<E>;
        remove(arg0: number): E;
        remove(arg0: any): boolean;
        static sortedCopyOf<E_>(arg0: Internal.Iterable<E_>): Internal.ImmutableList<E_>;
        static sortedCopyOf<E_>(arg0: Internal.Comparator<E_>, arg1: Internal.Iterable<E_>): Internal.ImmutableList<E_>;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.UnmodifiableIterator<E>;
        iterator(): Internal.Iterator<any>;
        stream(): Internal.Stream<E>;
        hashCode(): number;
        get(arg0: number): E;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_): Internal.ImmutableList<E_>;
        static of<E_>(): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_, arg7: E_, arg8: E_, arg9: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_, arg7: E_, arg8: E_, arg9: E_, arg10: E_, arg11: E_, arg12: E_[]): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_, arg7: E_, arg8: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_, arg7: E_, arg8: E_, arg9: E_, arg10: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_, arg7: E_): Internal.ImmutableList<E_>;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        static builder<E_>(): Internal.ImmutableList$Builder<E_>;
        parallelStream(): Internal.Stream<E>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: E): void;
        add(arg0: E): boolean;
        subList(arg0: number, arg1: number): Internal.ImmutableList<E>;
        subList(arg0: number, arg1: number): Internal.List<any>;
        set(arg0: number, arg1: E): E;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: (arg0: E) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator<E>): void;
        reverse(): Internal.ImmutableList<E>;
        static copyOf<E_>(arg0: E_[]): Internal.ImmutableList<E_>;
        static copyOf<E_>(arg0: Internal.Iterator<E_>): Internal.ImmutableList<E_>;
        static copyOf<E_>(arg0: Internal.Collection<E_>): Internal.ImmutableList<E_>;
        static copyOf<E_>(arg0: Internal.Iterable<E_>): Internal.ImmutableList<E_>;
        removeIf(arg0: (arg0: E) => boolean): boolean;
        static builderWithExpectedSize<E_>(arg0: number): Internal.ImmutableList$Builder<E_>;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean;
        addAll(arg0: Internal.Collection<E>): boolean;
        equals(arg0: any): boolean;
        static toImmutableList<E_>(): Internal.Collector<E_, any, Internal.ImmutableList<E_>>;
        listIterator(arg0: number): Internal.ListIterator<any>;
        listIterator(arg0: number): Internal.UnmodifiableListIterator<E>;
        listIterator(): Internal.ListIterator<any>;
        listIterator(): Internal.UnmodifiableListIterator<E>;
        toString(): string;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Closeable extends Internal.AutoCloseable {
        close(): void;
    }
    class Minecraft extends Internal.ReentrantBlockableEventLoop<any> implements Internal.WindowEventHandler, Internal.IForgeMinecraft, Internal.PausedPartialTickAccessor, Internal.MinecraftAccess, Internal.MinecraftClientAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRecorder(): Internal.MetricsRecorder;
        notifyAll(): void;
        handler$cam000$createLevel(arg0: string, arg1: Internal.LevelSettings, arg2: Internal.RegistryAccess$RegistryHolder, arg3: Internal.WorldGenSettings, arg4: Internal.CallbackInfo): void;
        popGuiLayer(): void;
        execute(arg0: Internal.Runnable): void;
        notify(): void;
        pushGuiLayer(arg0: Internal.Screen): void;
        setRecorder(recorder: Internal.MetricsRecorder): void;
        getSearchTreeManager(): Internal.SearchRegistry;
        hashCode(): number;
        equals(arg0: any): boolean;
        getFontManager(): Internal.FontManager;
        flywheel$getPartialTicksPaused(): number;
        toString(): string;
        getItemColors(): Internal.ItemColors;
        close(): void;
        get itemColors(): Internal.ItemColors;
        get recorder(): Internal.MetricsRecorder;
        get fontManager(): Internal.FontManager;
        get searchTreeManager(): Internal.SearchRegistry;
        get class(): Internal.Class<any>;
        set recorder(recorder: Internal.MetricsRecorder);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LootContextUser {
    }
    class LootActionsBuilderJS implements Internal.ConditionsContainer<Internal.LootActionsBuilderJS> {
        killerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): Internal.LootActionsBuilderJS;
        getClass(): Internal.Class<any>;
        thenRemove(arg0: Internal.IngredientJS): Internal.LootActionsBuilderJS;
        addCondition(arg0: (arg0: any) => boolean): Internal.ConditionsContainer<any>;
        addCondition(arg0: (arg0: any) => boolean): Internal.LootActionsBuilderJS;
        addCondition(arg0: Internal.LootItemCondition$Builder): Internal.LootActionsBuilderJS;
        getLogName(arg0: string): string;
        directKillerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): Internal.LootActionsBuilderJS;
        thenAddWeighted(arg0: Internal.MinMaxBounds$Ints, arg1: boolean, arg2: Internal.ItemStackJS[]): Internal.LootActionsBuilderJS;
        thenAddWeighted(arg0: Internal.ItemStackJS[]): Internal.LootActionsBuilderJS;
        thenAddWeighted(arg0: Internal.MinMaxBounds$Ints, arg1: Internal.ItemStackJS[]): Internal.LootActionsBuilderJS;
        matchLoot(arg0: Internal.IngredientJS): Internal.LootActionsBuilderJS;
        matchLoot(arg0: Internal.IngredientJS, arg1: boolean): Internal.LootActionsBuilderJS;
        anyBiome(arg0: string[]): Internal.LootActionsBuilderJS;
        entityPredicate(arg0: (arg0: Internal.EntityJS) => boolean): Internal.LootActionsBuilderJS;
        thenApply(arg0: (arg0: Internal.LootContextJS) => void): Internal.LootActionsBuilderJS;
        anyDimension(arg0: ResourceLocation[]): Internal.LootActionsBuilderJS;
        killedByPlayer(): Internal.LootActionsBuilderJS;
        randomChance(arg0: number): Internal.LootActionsBuilderJS;
        timeCheck(arg0: number, arg1: number, arg2: number): Internal.LootActionsBuilderJS;
        timeCheck(arg0: number, arg1: number): Internal.LootActionsBuilderJS;
        matchOffHand(arg0: Internal.IngredientJS): Internal.LootActionsBuilderJS;
        weatherCheck(arg0: Internal.Map<string, boolean>): Internal.LootActionsBuilderJS;
        matchDirectKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.LootActionsBuilderJS;
        logName(arg0: string): Internal.LootActionsBuilderJS;
        biome(arg0: string[]): Internal.LootActionsBuilderJS;
        customCondition(arg0: Internal.JsonObject): Internal.LootActionsBuilderJS;
        randomChanceWithLooting(arg0: number, arg1: number): Internal.LootActionsBuilderJS;
        thenLightningStrike(arg0: boolean): Internal.LootActionsBuilderJS;
        matchDamageSource(arg0: (arg0: Internal.DamageSourcePredicateBuilderJS) => void): Internal.LootActionsBuilderJS;
        anyStructure(arg0: ResourceLocation[], arg1: boolean): Internal.LootActionsBuilderJS;
        thenModify(arg0: Internal.IngredientJS, arg1: (arg0: Internal.ItemStackJS) => Internal.ItemStackJS): Internal.LootActionsBuilderJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        survivesExplosion(): Internal.LootActionsBuilderJS;
        notifyAll(): void;
        thenAdd(arg0: Internal.ItemStackJS[]): Internal.LootActionsBuilderJS;
        customDistanceToPlayer(arg0: (arg0: Internal.DistancePredicateBuilder) => void): Internal.LootActionsBuilderJS;
        matchFluid(arg0: string): Internal.LootActionsBuilderJS;
        notify(): void;
        not(arg0: (arg0: Internal.NotConditionBuilder) => void): Internal.LootActionsBuilderJS;
        matchEquip(arg0: EquipmentSlot, arg1: Internal.IngredientJS): Internal.LootActionsBuilderJS;
        and(arg0: (arg0: Internal.AndConditionBuilder) => void): Internal.LootActionsBuilderJS;
        hashCode(): number;
        thenRollPool(arg0: Internal.MinMaxBounds$Ints, arg1: (arg0: Internal.LootActionsBuilderJS) => void): Internal.LootActionsBuilderJS;
        thenRollPool(arg0: (arg0: Internal.LootActionsBuilderJS) => void): Internal.LootActionsBuilderJS;
        distanceToKiller(arg0: Internal.MinMaxBounds$Doubles): Internal.LootActionsBuilderJS;
        matchEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.LootActionsBuilderJS;
        or(arg0: (arg0: Internal.OrConditionBuilder) => void): Internal.LootActionsBuilderJS;
        playerPredicate(arg0: (arg0: Internal.PlayerJS<any>) => boolean): Internal.LootActionsBuilderJS;
        thenExplode(arg0: number, arg1: boolean, arg2: boolean): Internal.LootActionsBuilderJS;
        matchBlockState(arg0: Internal.Block, arg1: Internal.Map<string, string>): Internal.LootActionsBuilderJS;
        matchMainHand(arg0: Internal.IngredientJS): Internal.LootActionsBuilderJS;
        matchPlayer(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.LootActionsBuilderJS;
        lightLevel(arg0: number, arg1: number): Internal.LootActionsBuilderJS;
        equals(arg0: any): boolean;
        matchKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.LootActionsBuilderJS;
        hasAnyStage(arg0: string[]): Internal.LootActionsBuilderJS;
        toString(): string;
        thenReplace(arg0: Internal.IngredientJS, arg1: Internal.ItemStackJS): Internal.LootActionsBuilderJS;
        randomChanceWithEnchantment(arg0: Internal.Enchantment, arg1: number[]): Internal.LootActionsBuilderJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface VertexDrain {
        createSink<T>(arg0: Internal.VertexType<T>): T;
    }
    class FieldAttributes {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        notifyAll(): void;
        getDeclaredClass(): Internal.Class<any>;
        getAnnotations(): Internal.Collection<Internal.Annotation>;
        notify(): void;
        getDeclaringClass(): Internal.Class<any>;
        hasModifier(arg0: number): boolean;
        getAnnotation<T>(arg0: Internal.Class<T>): T;
        hashCode(): number;
        equals(arg0: any): boolean;
        getDeclaredType(): java_.lang.reflect.Type;
        toString(): string;
        get name(): string;
        get annotations(): Internal.Collection<Internal.Annotation>;
        get declaredType(): java_.lang.reflect.Type;
        get declaredClass(): Internal.Class<any>;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ShapelessRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        parseResultItem(o: any): Internal.ItemStackJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class RecipeTypeJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(obj: any): boolean;
        isCustom(): boolean;
        getId(): string;
        toString(): string;
        getIdRL(): ResourceLocation;
        notify(): void;
        readonly factory : () => Internal.RecipeJS;
        readonly serializer : Internal.RecipeSerializer<any>;
        get mod(): string;
        get idRL(): ResourceLocation;
        get custom(): boolean;
        get id(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ExecutorService extends Internal.Executor {
        submit(arg0: Internal.Runnable): java_.util.concurrent.Future<any>;
        submit<T_>(arg0: Internal.Runnable, arg1: T_): java_.util.concurrent.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): java_.util.concurrent.Future<T_>;
        isTerminated(): boolean;
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<java_.util.concurrent.Future<T_>>;
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): Internal.List<java_.util.concurrent.Future<T_>>;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean;
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): T_;
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): T_;
        shutdownNow(): Internal.List<Internal.Runnable>;
        execute(arg0: Internal.Runnable): void;
        shutdown(): void;
        isShutdown(): boolean;
    }
    interface FilenameFilter {
        accept(arg0: Internal.File, arg1: string): boolean;
    }
    interface VertexBufferView {
        ensureBufferCapacity(arg0: number): boolean;
        flush(arg0: number, arg1: Internal.BufferVertexFormat): void;
        getWriterPosition(): number;
        getVertexFormat(): Internal.BufferVertexFormat;
        getDirectBuffer(): Internal.ByteBuffer;
    }
    interface ItemEntityAccess {
        setAge(arg0: number): void;
    }
    class ClientPlayerJS extends Internal.PlayerJS<any> {
        getXpLevel(): number;
        getLastAttackedEntity(): Internal.LivingEntityJS;
        sendData(channel: string, data: Internal.CompoundTag): void;
        setY(y: number): void;
        setX(x: number): void;
        isOnScoreboardTeam(teamID: string): boolean;
        isLiving(): boolean;
        isSprinting(): boolean;
        getItem(): Internal.ItemStackJS;
        getRevengeTarget(): Internal.LivingEntityJS;
        paint(tag: Internal.CompoundTag): void;
        getTags(): Internal.Set<string>;
        getOffHandItem(): Internal.ItemStackJS;
        setGlowing(glowing: boolean): void;
        setZ(z: number): void;
        setXpLevel(l: number): void;
        getHasCustomName(): boolean;
        setInvisible(invisible: boolean): void;
        runCommandSilent(command: string): number;
        getIdleTime(): number;
        getMovementSpeed(): number;
        setSelectedSlot(index: number): void;
        getDistanceSq(x: number, y: number, z: number): number;
        getDistanceSq(pos: BlockPos): number;
        isBoss(): boolean;
        isGlowing(): boolean;
        getHorizontalFacing(): Internal.Direction;
        addFood(f: number, m: number): void;
        setLegsArmorItem(item: Internal.ItemStackJS): void;
        getHealth(): number;
        getServer(): Internal.ServerJS;
        setFeetArmorItem(item: Internal.ItemStackJS): void;
        give(item: Internal.ItemStackJS): void;
        setMaxHealth(hp: number): void;
        setMotion(x: number, y: number, z: number): void;
        getProfile(): Internal.GameProfile;
        setRotation(yaw: number, pitch: number): void;
        isMiningBlock(): boolean;
        isSpectator(): boolean;
        setAbsorptionAmount(amount: number): void;
        isOnSameTeam(e: Internal.EntityJS): boolean;
        isAnimal(): boolean;
        getDisplayName(): Internal.Text;
        getType(): string;
        getXp(): number;
        addExhaustion(exhaustion: number): void;
        setCustomNameAlwaysVisible(b: boolean): void;
        setOffHandItem(item: Internal.ItemStackJS): void;
        getFoodLevel(): number;
        addMotion(x: number, y: number, z: number): void;
        isFake(): boolean;
        isSelf(): boolean;
        isInvisible(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMaxHealth(): number;
        isUnderWater(): boolean;
        getHeldItem(hand: Hand): Internal.ItemStackJS;
        getEyeHeight(): number;
        getEquipment(slot: EquipmentSlot): Internal.ItemStackJS;
        notify(): void;
        getFallDistance(): number;
        damageHeldItem(hand: Hand, amount: number): void;
        damageHeldItem(hand: Hand, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void;
        damageHeldItem(): void;
        setAirSupply(air: number): void;
        setOnFire(seconds: number): void;
        removePassengers(): void;
        attack(hp: number): void;
        attack(source: string, hp: number): void;
        isUndead(): boolean;
        isOnLadder(): boolean;
        playSound(id: Internal.SoundEvent): void;
        playSound(id: Internal.SoundEvent, volume: number, pitch: number): void;
        getInventory(): Internal.InventoryJS;
        boostElytraFlight(): void;
        getData(): Internal.AttachedData;
        getDistance(x: number, y: number, z: number): number;
        getDistance(pos: BlockPos): number;
        getLastDamageSource(): Internal.DamageSourceJS;
        setStatusMessage(message: Internal.Component): void;
        isSwimming(): boolean;
        getReachDistance(): number;
        getCustomName(): Internal.Text;
        getStepHeight(): number;
        mergeFullNBT(tag: Internal.CompoundTag): Internal.EntityJS;
        kill(): void;
        getRidingEntity(): Internal.EntityJS;
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void;
        getLevel(): Internal.LevelJS;
        getPitch(): number;
        getPassengers(): Internal.EntityArrayList;
        getLastAttackedEntityTime(): number;
        isMonster(): boolean;
        equals(arg0: any): boolean;
        addItemCooldown(item: Internal.Item, ticks: number): void;
        setPitch(pitch: number): void;
        isOnGround(): boolean;
        getFacing(): Internal.Direction;
        toString(): string;
        isSilent(): boolean;
        isPassenger(e: Internal.EntityJS): boolean;
        setXp(xp: number): void;
        getMaxAirSupply(): number;
        getClass(): Internal.Class<any>;
        getNbt(): Internal.CompoundTag;
        getRecursivePassengers(): Internal.EntityArrayList;
        setFallDistance(fallDistance: number): void;
        getName(): Internal.Text;
        getFeetArmorItem(): Internal.ItemStackJS;
        sendInventoryUpdate(): void;
        setCustomName(name: Internal.Component): void;
        setMainHandItem(item: Internal.ItemStackJS): void;
        setStepHeight(stepHeight: number): void;
        tell(message: Internal.Component): void;
        getTeamId(): string;
        isWaterCreature(): boolean;
        setNoClip(noClip: boolean): void;
        setPosition(x: number, y: number, z: number): void;
        setPosition(block: Internal.BlockContainerJS): void;
        closeInventory(): void;
        extinguish(): void;
        setInvulnerable(invulnerable: boolean): void;
        setRevengeTarget(target: Internal.LivingEntityJS): void;
        setMovementSpeed(speed: number): void;
        isChild(): boolean;
        setEquipment(slot: EquipmentSlot, item: Internal.ItemStackJS): void;
        giveInHand(item: Internal.ItemStackJS): void;
        getAirSupply(): number;
        getLegsArmorItem(): Internal.ItemStackJS;
        setFullNBT(nbt: Internal.CompoundTag): void;
        getAttackingEntity(): Internal.LivingEntityJS;
        isHoldingInAnyHand(ingredient: any): boolean;
        isCreativeMode(): boolean;
        getFullNBT(): Internal.CompoundTag;
        getNoClip(): boolean;
        setYaw(yaw: number): void;
        damageEquipment(slot: EquipmentSlot, amount: number): void;
        damageEquipment(slot: EquipmentSlot): void;
        damageEquipment(slot: EquipmentSlot, amount: number, onBroken: (arg0: Internal.ItemStackJS) => void): void;
        getYaw(): number;
        isAlive(): boolean;
        getHeadArmorItem(): Internal.ItemStackJS;
        setNoGravity(noGravity: boolean): void;
        setMouseItem(item: Internal.ItemStackJS): void;
        setHeldItem(hand: Hand, item: Internal.ItemStackJS): void;
        isPlayer(): boolean;
        getRevengeTimer(): number;
        getStats(): Internal.PlayerStatsJS;
        getAbsorptionAmount(): number;
        isCrouching(): boolean;
        notifyAll(): void;
        getId(): Internal.UUID;
        addXPLevels(l: number): void;
        getTicksExisted(): number;
        getOpenInventory(): Internal.AbstractContainerMenu;
        getStages(): Internal.Stages;
        setSilent(isSilent: boolean): void;
        hashCode(): number;
        getChestArmorItem(): Internal.ItemStackJS;
        isFrame(): boolean;
        heal(hp: number): void;
        startRiding(e: Internal.EntityJS, force: boolean): boolean;
        runCommand(command: string): number;
        setChestArmorItem(item: Internal.ItemStackJS): void;
        getCustomNameAlwaysVisible(): boolean;
        addXP(xp: number): void;
        getMainHandItem(): Internal.ItemStackJS;
        setHealth(hp: number): void;
        setMotionZ(z: number): void;
        setMotionY(y: number): void;
        getBlock(): Internal.BlockContainerJS;
        setMotionX(x: number): void;
        isElytraFlying(): boolean;
        isInWater(): boolean;
        dismountRidingEntity(): void;
        isSleeping(): boolean;
        isAmbientCreature(): boolean;
        swingArm(hand: Hand): void;
        getPotionEffects(): Internal.EntityPotionEffectsJS;
        rayTrace(distance: number): Internal.RayTraceResultJS;
        rayTrace(): Internal.RayTraceResultJS;
        isInvulnerable(): boolean;
        setHeadArmorItem(item: Internal.ItemStackJS): void;
        getSelectedSlot(): number;
        canEntityBeSeen(entity: Internal.LivingEntityJS): boolean;
        getX(): number;
        getY(): number;
        spawn(): void;
        getZ(): number;
        isPeacefulCreature(): boolean;
        getMouseItem(): Internal.ItemStackJS;
        setFoodLevel(foodLevel: number): void;
        getMotionZ(): number;
        getMotionX(): number;
        getMotionY(): number;
        getNoGravity(): boolean;
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftPlayer : Internal.Player;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        get xpLevel(): number;
        get invisible(): boolean;
        get creativeMode(): boolean;
        get customNameAlwaysVisible(): boolean;
        get movementSpeed(): number;
        get type(): string;
        get stats(): Internal.PlayerStatsJS;
        get revengeTarget(): Internal.LivingEntityJS;
        get hasCustomName(): boolean;
        get maxHealth(): number;
        get block(): Internal.BlockContainerJS;
        get pitch(): number;
        get id(): Internal.UUID;
        get item(): Internal.ItemStackJS;
        get passengers(): Internal.EntityArrayList;
        get profile(): Internal.GameProfile;
        get onLadder(): boolean;
        get offHandItem(): Internal.ItemStackJS;
        get customName(): Internal.Text;
        get lastAttackedEntityTime(): number;
        get tags(): Internal.Set<string>;
        get crouching(): boolean;
        get animal(): boolean;
        get lastDamageSource(): Internal.DamageSourceJS;
        get stepHeight(): number;
        get noClip(): boolean;
        get server(): Internal.ServerJS;
        get nbt(): Internal.CompoundTag;
        get boss(): boolean;
        get alive(): boolean;
        get displayName(): Internal.Text;
        get revengeTimer(): number;
        get mainHandItem(): Internal.ItemStackJS;
        get facing(): Internal.Direction;
        get ambientCreature(): boolean;
        get swimming(): boolean;
        get selectedSlot(): number;
        get eyeHeight(): number;
        get underWater(): boolean;
        get openInventory(): Internal.AbstractContainerMenu;
        get motionZ(): number;
        get silent(): boolean;
        get motionY(): number;
        get motionX(): number;
        get health(): number;
        get chestArmorItem(): Internal.ItemStackJS;
        get yaw(): number;
        get monster(): boolean;
        get glowing(): boolean;
        get onGround(): boolean;
        get spectator(): boolean;
        get x(): number;
        get self(): boolean;
        get y(): number;
        get fake(): boolean;
        get z(): number;
        get foodLevel(): number;
        get data(): Internal.AttachedData;
        get idleTime(): number;
        get legsArmorItem(): Internal.ItemStackJS;
        get maxAirSupply(): number;
        get undead(): boolean;
        get lastAttackedEntity(): Internal.LivingEntityJS;
        get potionEffects(): Internal.EntityPotionEffectsJS;
        get level(): Internal.LevelJS;
        get feetArmorItem(): Internal.ItemStackJS;
        get horizontalFacing(): Internal.Direction;
        get sprinting(): boolean;
        get mouseItem(): Internal.ItemStackJS;
        get noGravity(): boolean;
        get fullNBT(): Internal.CompoundTag;
        get name(): Internal.Text;
        get peacefulCreature(): boolean;
        get child(): boolean;
        get frame(): boolean;
        get ticksExisted(): number;
        get fallDistance(): number;
        get elytraFlying(): boolean;
        get inventory(): Internal.InventoryJS;
        get airSupply(): number;
        get sleeping(): boolean;
        get waterCreature(): boolean;
        get invulnerable(): boolean;
        get miningBlock(): boolean;
        get headArmorItem(): Internal.ItemStackJS;
        get class(): Internal.Class<any>;
        get reachDistance(): number;
        get player(): boolean;
        get absorptionAmount(): number;
        get living(): boolean;
        get ridingEntity(): Internal.EntityJS;
        get inWater(): boolean;
        get recursivePassengers(): Internal.EntityArrayList;
        get attackingEntity(): Internal.LivingEntityJS;
        get teamId(): string;
        get xp(): number;
        get stages(): Internal.Stages;
        set noClip(noClip: boolean);
        set xpLevel(l: number);
        set fallDistance(fallDistance: number);
        set mainHandItem(item: Internal.ItemStackJS);
        set invisible(invisible: boolean);
        set customNameAlwaysVisible(b: boolean);
        set movementSpeed(speed: number);
        set airSupply(air: number);
        set invulnerable(invulnerable: boolean);
        set legsArmorItem(item: Internal.ItemStackJS);
        set selectedSlot(index: number);
        set revengeTarget(target: Internal.LivingEntityJS);
        set maxHealth(hp: number);
        set headArmorItem(item: Internal.ItemStackJS);
        set pitch(pitch: number);
        set motionZ(z: number);
        set absorptionAmount(amount: number);
        set silent(isSilent: boolean);
        set motionY(y: number);
        set motionX(x: number);
        set health(hp: number);
        set feetArmorItem(item: Internal.ItemStackJS);
        set offHandItem(item: Internal.ItemStackJS);
        set chestArmorItem(item: Internal.ItemStackJS);
        set onFire(seconds: number);
        set yaw(yaw: number);
        set statusMessage(message: Internal.Component);
        set glowing(glowing: boolean);
        set mouseItem(item: Internal.ItemStackJS);
        set noGravity(noGravity: boolean);
        set fullNBT(nbt: Internal.CompoundTag);
        set xp(xp: number);
        set x(x: number);
        set y(y: number);
        set z(z: number);
        set foodLevel(foodLevel: number);
        set position(block: Internal.BlockContainerJS);
        set stepHeight(stepHeight: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface SymbolScriptable {
        get(arg0: Internal.Symbol, arg1: Internal.Scriptable): any;
        has(arg0: Internal.Symbol, arg1: Internal.Scriptable): boolean;
        delete(arg0: Internal.Symbol): void;
        put(arg0: Internal.Symbol, arg1: Internal.Scriptable, arg2: any): void;
    }
    interface PrivilegedAction <T> {
        run(): T;
    }
    interface AnnotatedElement {
        getAnnotationsByType<T>(arg0: Internal.Class<T>): T[];
        getDeclaredAnnotationsByType<T>(arg0: Internal.Class<T>): T[];
        getAnnotation<T>(arg0: Internal.Class<T>): T;
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean;
        getDeclaredAnnotation<T>(arg0: Internal.Class<T>): T;
        getAnnotations(): Internal.Annotation[];
        getDeclaredAnnotations(): Internal.Annotation[];
    }
    class EntityClassGroup {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        contains(entityClass: Internal.Class<any>): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        clear(): void;
        toString(): string;
        notify(): void;
        static readonly MINECART_BOAT_LIKE_COLLISION : Internal.EntityClassGroup;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Packet <T> {
    }
    class VariantBlockStateGenerator {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toJson(): Internal.JsonObject;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        variant(key: string, model: string): void;
        variant(key: string, consumer: (arg0: Internal.VariantBlockStateGenerator$Variant) => void): void;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LunarMobSpawnInfo {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isForceSurfaceSpawning(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        useBiomeSpawnSettings(): boolean;
        toString(): string;
        notify(): void;
        getSpawnInfo(): Internal.MobSpawnSettings;
        static readonly CODEC : Internal.Codec<Internal.LunarMobSpawnInfo>;
        get spawnInfo(): Internal.MobSpawnSettings;
        get forceSurfaceSpawning(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MethodHandleDesc extends Internal.ConstantDesc {
        invocationType(): Internal.MethodTypeDesc;
        equals(arg0: any): boolean;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): any;
        asType(arg0: Internal.MethodTypeDesc): Internal.MethodHandleDesc;
    }
    abstract class BaseComponent implements Internal.MutableComponent {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getString(): string;
        notify(): void;
        get string(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ExtendedChunk {
        setSkyNibbles(arg0: any[]): void;
        getSkyEmptinessMap(): boolean[];
        getSkyNibbles(): any[];
        getBlockNibbles(): any[];
        setSkyEmptinessMap(arg0: boolean[]): void;
        setBlockEmptinessMap(arg0: boolean[]): void;
        getBlockEmptinessMap(): boolean[];
        setBlockNibbles(arg0: any[]): void;
    }
    interface Key extends Internal.Serializable {
        getEncoded(): number[];
        getAlgorithm(): string;
        getFormat(): string;
    }
    interface ChannelPromise extends Internal.ChannelFuture, Internal.Promise<void> {
        cancel(arg0: boolean): boolean;
        unvoid(): Internal.ChannelPromise;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelPromise;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Promise<void>;
        getNow(): void;
        channel(): io.netty.channel.Channel;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): Internal.ChannelPromise;
        awaitUninterruptibly(): Internal.ChannelFuture;
        awaitUninterruptibly(): Internal.Future<void>;
        awaitUninterruptibly(): Internal.Promise<void>;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelPromise;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Promise<void>;
        tryFailure(arg0: Internal.Throwable): boolean;
        isDone(): boolean;
        sync(): Internal.ChannelPromise;
        sync(): Internal.ChannelFuture;
        sync(): Internal.Future<void>;
        sync(): Internal.Promise<void>;
        setSuccess(): Internal.ChannelPromise;
        setSuccess(arg0: void): Internal.ChannelPromise;
        setSuccess(arg0: void): Internal.Promise<void>;
        setFailure(arg0: Internal.Throwable): Internal.ChannelPromise;
        setFailure(arg0: Internal.Throwable): Internal.Promise<void>;
        isVoid(): boolean;
        trySuccess(): boolean;
        trySuccess(arg0: void): boolean;
        syncUninterruptibly(): Internal.ChannelPromise;
        syncUninterruptibly(): Internal.ChannelFuture;
        syncUninterruptibly(): Internal.Future<void>;
        syncUninterruptibly(): Internal.Promise<void>;
        get(arg0: number, arg1: Internal.TimeUnit): void;
        get(): void;
        isCancellable(): boolean;
        await(): Internal.ChannelPromise;
        await(): Internal.ChannelFuture;
        await(): Internal.Future<void>;
        await(): Internal.Promise<void>;
        await(arg0: number, arg1: Internal.TimeUnit): boolean;
        await(arg0: number): boolean;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelPromise;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Promise<void>;
        setUncancellable(): boolean;
        isSuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelPromise;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Promise<void>;
    }
    class ByteOrder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static nativeOrder(): Internal.ByteOrder;
        toString(): string;
        notify(): void;
        static readonly BIG_ENDIAN : Internal.ByteOrder;
        static readonly LITTLE_ENDIAN : Internal.ByteOrder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Class <T> implements Internal.Serializable, Internal.GenericDeclaration, java_.lang.reflect.Type, Internal.AnnotatedElement, Internal.TypeDescriptor$OfField<Internal.Class<any>>, Internal.Constable {
        getModule(): Internal.Module;
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        getResource(arg0: string): Internal.URL;
        getName(): string;
        isLocalClass(): boolean;
        isSynthetic(): boolean;
        getCanonicalName(): string;
        getMethod(arg0: string, arg1: Internal.Class<any>[]): Internal.Method;
        describeConstable(): Internal.Optional<Internal.ClassDesc>;
        getDeclaredFields(): Internal.Field[];
        isMemberClass(): boolean;
        cast(arg0: any): T;
        isInstance(arg0: any): boolean;
        getEnclosingMethod(): Internal.Method;
        getPermittedSubclasses(): Internal.Class<any>[];
        getSigners(): any[];
        getTypeParameters(): any[];
        isInterface(): boolean;
        getPackage(): Internal.Package;
        arrayType(): Internal.TypeDescriptor$OfField<any>;
        arrayType(): Internal.Class<any>;
        getNestHost(): Internal.Class<any>;
        asSubclass<U_>(arg0: Internal.Class<U_>): Internal.Class<U_>;
        getField(arg0: string): Internal.Field;
        descriptorString(): string;
        getInterfaces(): Internal.Class<any>[];
        getAnnotatedInterfaces(): Internal.AnnotatedType[];
        newInstance(): T;
        getFields(): Internal.Field[];
        getAnnotation<A_>(arg0: Internal.Class<A_>): A_;
        getRecordComponents(): any[];
        getComponentType(): Internal.Class<any>;
        getDeclaredAnnotation<A_>(arg0: Internal.Class<A_>): A_;
        getSimpleName(): string;
        isArray(): boolean;
        getPackageName(): string;
        getMethods(): Internal.Method[];
        isPrimitive(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isAnnotation(): boolean;
        getProtectionDomain(): Internal.ProtectionDomain;
        getDeclaredConstructors(): Internal.Constructor<any>[];
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean;
        notifyAll(): void;
        desiredAssertionStatus(): boolean;
        getNestMembers(): Internal.Class<any>[];
        getGenericInterfaces(): java_.lang.reflect.Type[];
        getClassLoader(): Internal.ClassLoader;
        isAssignableFrom(arg0: Internal.Class<any>): boolean;
        notify(): void;
        getDeclaredAnnotations(): Internal.Annotation[];
        getDeclaredMethods(): Internal.Method[];
        getDeclaringClass(): Internal.Class<any>;
        getAnnotationsByType<A_>(arg0: Internal.Class<A_>): A_[];
        getConstructors(): Internal.Constructor<any>[];
        hashCode(): number;
        getAnnotatedSuperclass(): Internal.AnnotatedType;
        toGenericString(): string;
        getModifiers(): number;
        getTypeName(): string;
        getEnclosingConstructor(): Internal.Constructor<any>;
        isNestmateOf(arg0: Internal.Class<any>): boolean;
        getClasses(): Internal.Class<any>[];
        getSuperclass(): Internal.Class<T>;
        getDeclaredField(arg0: string): Internal.Field;
        componentType(): Internal.TypeDescriptor$OfField<any>;
        componentType(): Internal.Class<any>;
        static forName(arg0: string, arg1: boolean, arg2: Internal.ClassLoader): Internal.Class<any>;
        static forName(arg0: string): Internal.Class<any>;
        static forName(arg0: Internal.Module, arg1: string): Internal.Class<any>;
        getResourceAsStream(arg0: string): Internal.InputStream;
        isRecord(): boolean;
        getDeclaredMethod(arg0: string, arg1: Internal.Class<any>[]): Internal.Method;
        isEnum(): boolean;
        getDeclaredConstructor(arg0: Internal.Class<any>[]): Internal.Constructor<T>;
        getAnnotations(): Internal.Annotation[];
        getConstructor(arg0: Internal.Class<any>[]): Internal.Constructor<T>;
        getEnumConstants(): T[];
        isHidden(): boolean;
        getDeclaredAnnotationsByType<A_>(arg0: Internal.Class<A_>): A_[];
        getDeclaredClasses(): Internal.Class<any>[];
        equals(arg0: any): boolean;
        isAnonymousClass(): boolean;
        getEnclosingClass(): Internal.Class<any>;
        toString(): string;
        getGenericSuperclass(): java_.lang.reflect.Type;
        get enclosingConstructor(): Internal.Constructor<any>;
        get annotations(): Internal.Annotation[];
        get memberClass(): boolean;
        get declaredConstructors(): Internal.Constructor<any>[];
        get declaredFields(): Internal.Field[];
        get superclass(): Internal.Class<T>;
        get record(): boolean;
        get canonicalName(): string;
        get package(): Internal.Package;
        get protectionDomain(): Internal.ProtectionDomain;
        get sealed(): boolean;
        get module(): Internal.Module;
        get enclosingMethod(): Internal.Method;
        get enum(): boolean;
        get declaringClass(): Internal.Class<any>;
        get synthetic(): boolean;
        get constructors(): Internal.Constructor<any>[];
        get declaredClasses(): Internal.Class<any>[];
        get name(): string;
        get fields(): Internal.Field[];
        get classLoader(): Internal.ClassLoader;
        get primitive(): boolean;
        get hidden(): boolean;
        get methods(): Internal.Method[];
        get classes(): Internal.Class<any>[];
        get typeName(): string;
        get declaredMethods(): Internal.Method[];
        get interface(): boolean;
        get genericInterfaces(): java_.lang.reflect.Type[];
        get modifiers(): number;
        get typeParameters(): any[];
        get annotatedSuperclass(): Internal.AnnotatedType;
        get permittedSubclasses(): Internal.Class<any>[];
        get array(): boolean;
        get enumConstants(): T[];
        get annotatedInterfaces(): Internal.AnnotatedType[];
        get packageName(): string;
        get class(): Internal.Class<any>;
        get annotation(): boolean;
        get declaredAnnotations(): Internal.Annotation[];
        get interfaces(): Internal.Class<any>[];
        get genericSuperclass(): java_.lang.reflect.Type;
        get localClass(): boolean;
        get enclosingClass(): Internal.Class<any>;
        get nestMembers(): Internal.Class<any>[];
        get signers(): any[];
        get recordComponents(): any[];
        get simpleName(): string;
        get nestHost(): Internal.Class<any>;
        get anonymousClass(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MenuAccess <T> {
    }
    interface Int2DoubleFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class ChannelMetadata {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hasDisconnect(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        defaultMaxMessagesPerRead(): number;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Cancellable {
        cancel(): void;
        isCancelled(): boolean;
        isCancellable(): boolean;
    }
    interface Endimatable extends Internal.EndimationEffectSource {
        getEndimatedState(): Internal.Endimatable$EndimatedState;
        resetEndimation(): void;
        onEndimationEnd(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        isActive(): boolean;
        isEndimationPlaying(arg0: Internal.PlayableEndimation): boolean;
        getPlayingEndimation(): Internal.PlayableEndimation;
        endimateTick(): void;
        setPlayingEndimation(arg0: Internal.PlayableEndimation): void;
        getPos(): Internal.Position;
        getEffectHandler(): Internal.EndimationEffectHandler;
        setAnimationTick(arg0: number): void;
        getAnimationTick(): number;
        isNoEndimationPlaying(): boolean;
        onEndimationStart(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
    }
    interface LongStream extends Internal.BaseStream<number, Internal.LongStream> {
        average(): Internal.OptionalDouble;
        sequential(): Internal.BaseStream<any, any>;
        sequential(): Internal.LongStream;
        takeWhile(arg0: Internal.LongPredicate): Internal.LongStream;
        distinct(): Internal.LongStream;
        findFirst(): Internal.OptionalLong;
        sum(): number;
        skip(arg0: number): Internal.LongStream;
        allMatch(arg0: Internal.LongPredicate): boolean;
        mapToObj<U_>(arg0: Internal.LongFunction<U_>): Internal.Stream<U_>;
        mapMulti(arg0: Internal.LongStream$LongMapMultiConsumer): Internal.LongStream;
        iterator(): Internal.Iterator<any>;
        iterator(): Internal.PrimitiveIterator$OfLong;
        asDoubleStream(): Internal.DoubleStream;
        min(): Internal.OptionalLong;
        parallel(): Internal.LongStream;
        parallel(): Internal.BaseStream<any, any>;
        noneMatch(arg0: Internal.LongPredicate): boolean;
        findAny(): Internal.OptionalLong;
        isParallel(): boolean;
        limit(arg0: number): Internal.LongStream;
        toArray(): number[];
        forEachOrdered(arg0: Internal.LongConsumer): void;
        close(): void;
        anyMatch(arg0: Internal.LongPredicate): boolean;
        map(arg0: Internal.LongUnaryOperator): Internal.LongStream;
        mapToDouble(arg0: Internal.LongToDoubleFunction): Internal.DoubleStream;
        unordered(): Internal.LongStream;
        reduce(arg0: Internal.LongBinaryOperator): Internal.OptionalLong;
        reduce(arg0: number, arg1: Internal.LongBinaryOperator): number;
        spliterator(): Internal.Spliterator$OfLong;
        spliterator(): Internal.Spliterator<any>;
        max(): Internal.OptionalLong;
        forEach(arg0: Internal.LongConsumer): void;
        count(): number;
        dropWhile(arg0: Internal.LongPredicate): Internal.LongStream;
        peek(arg0: Internal.LongConsumer): Internal.LongStream;
        flatMap(arg0: Internal.LongFunction<Internal.LongStream>): Internal.LongStream;
        filter(arg0: Internal.LongPredicate): Internal.LongStream;
        onClose(arg0: Internal.Runnable): Internal.LongStream;
        sorted(): Internal.LongStream;
        boxed(): Internal.Stream<number>;
        summaryStatistics(): Internal.LongSummaryStatistics;
        mapToInt(arg0: Internal.LongToIntFunction): Internal.IntStream;
        collect<R_>(arg0: () => R_, arg1: Internal.ObjLongConsumer<R_>, arg2: (arg0: R_, arg1: R_) => void): R_;
    }
    abstract class ImmutableSet <E> extends Internal.ImmutableCollection<any> implements Internal.Set<E> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        notify(): void;
        asList(): Internal.ImmutableList<E>;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.Iterator<any>;
        iterator(): Internal.UnmodifiableIterator<E>;
        stream(): Internal.Stream<E>;
        hashCode(): number;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_): Internal.ImmutableSet<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_): Internal.ImmutableSet<E_>;
        static of<E_>(): Internal.ImmutableSet<E_>;
        static of<E_>(arg0: E_): Internal.ImmutableSet<E_>;
        static of<E_>(arg0: E_, arg1: E_): Internal.ImmutableSet<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_[]): Internal.ImmutableSet<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_): Internal.ImmutableSet<E_>;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        static builder<E_>(): Internal.ImmutableSet$Builder<E_>;
        parallelStream(): Internal.Stream<E>;
        static toImmutableSet<E_>(): Internal.Collector<E_, any, Internal.ImmutableSet<E_>>;
        add(arg0: E): boolean;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: (arg0: E) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        static copyOf<E_>(arg0: E_[]): Internal.ImmutableSet<E_>;
        static copyOf<E_>(arg0: Internal.Iterable<E_>): Internal.ImmutableSet<E_>;
        static copyOf<E_>(arg0: Internal.Collection<E_>): Internal.ImmutableSet<E_>;
        static copyOf<E_>(arg0: Internal.Iterator<E_>): Internal.ImmutableSet<E_>;
        removeIf(arg0: (arg0: E) => boolean): boolean;
        static builderWithExpectedSize<E_>(arg0: number): Internal.ImmutableSet$Builder<E_>;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.Collection<E>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PrimitiveCodec <A> extends Internal.Codec<A> {
        encode<T_>(arg0: A, arg1: Internal.DynamicOps<T_>, arg2: T_): Internal.DataResult<T_>;
        flatComapMap<S_>(arg0: (arg0: A) => S_, arg1: (arg0: S_) => Internal.DataResult<A>): Internal.Codec<S_>;
        dispatch<E_>(arg0: (arg0: E_) => A, arg1: (arg0: A) => Internal.Codec<E_>): Internal.Codec<E_>;
        dispatch<E_>(arg0: string, arg1: (arg0: E_) => A, arg2: (arg0: A) => Internal.Codec<E_>): Internal.Codec<E_>;
        deprecated(arg0: number): Internal.Codec<A>;
        simple(): Internal.Decoder$Simple<A>;
        dispatchMap<E_>(arg0: string, arg1: (arg0: E_) => A, arg2: (arg0: A) => Internal.Codec<E_>): Internal.MapCodec<E_>;
        dispatchMap<E_>(arg0: (arg0: E_) => A, arg1: (arg0: A) => Internal.Codec<E_>): Internal.MapCodec<E_>;
        comapFlatMap<S_>(arg0: (arg0: A) => Internal.DataResult<S_>, arg1: (arg0: S_) => A): Internal.Codec<S_>;
        decode<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<Internal.Pair<A, T_>>;
        decode<T_>(arg0: Internal.Dynamic<T_>): Internal.DataResult<Internal.Pair<A, T_>>;
        promotePartial(arg0: (arg0: any) => void): Internal.Decoder<any>;
        promotePartial(arg0: (arg0: string) => void): Internal.Codec<A>;
        flatXmap<S_>(arg0: (arg0: A) => Internal.DataResult<S_>, arg1: (arg0: S_) => Internal.DataResult<A>): Internal.Codec<S_>;
        comap<B_>(arg0: (arg0: B_) => A): Internal.Encoder<B_>;
        fieldOf(arg0: string): Internal.MapCodec<A>;
        fieldOf(arg0: string): Internal.MapDecoder<any>;
        fieldOf(arg0: string): Internal.MapEncoder<any>;
        xmap<S_>(arg0: (arg0: A) => S_, arg1: (arg0: S_) => A): Internal.Codec<S_>;
        listOf(): Internal.Codec<Internal.List<A>>;
        map<B_>(arg0: (arg0: A) => B_): Internal.Decoder<B_>;
        write<T_>(arg0: Internal.DynamicOps<T_>, arg1: A): T_;
        encodeStart<T_>(arg0: Internal.DynamicOps<T_>, arg1: A): Internal.DataResult<T_>;
        optionalFieldOf(arg0: string, arg1: A, arg2: Internal.Lifecycle): Internal.MapCodec<A>;
        optionalFieldOf(arg0: string): Internal.MapCodec<Internal.Optional<A>>;
        optionalFieldOf(arg0: string, arg1: A): Internal.MapCodec<A>;
        optionalFieldOf(arg0: string, arg1: Internal.Lifecycle, arg2: A, arg3: Internal.Lifecycle): Internal.MapCodec<A>;
        flatComap<B_>(arg0: (arg0: B_) => Internal.DataResult<A>): Internal.Encoder<B_>;
        read<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<A>;
        partialDispatch<E_>(arg0: string, arg1: (arg0: E_) => Internal.DataResult<A>, arg2: (arg0: A) => Internal.DataResult<Internal.Codec<E_>>): Internal.Codec<E_>;
        terminal(): Internal.Decoder$Terminal<A>;
        parse<T_>(arg0: Internal.Dynamic<T_>): Internal.DataResult<A>;
        parse<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<A>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.Codec<A>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.Decoder<any>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.Encoder<any>;
        orElse(arg0: A): Internal.Codec<A>;
        orElse(arg0: (arg0: string) => void, arg1: A): Internal.Codec<A>;
        orElse(arg0: (arg0: any) => any, arg1: A): Internal.Codec<A>;
        flatMap<B_>(arg0: (arg0: A) => Internal.DataResult<B_>): Internal.Decoder<B_>;
        boxed(): Internal.Decoder$Boxed<A>;
        dispatchStable<E_>(arg0: (arg0: E_) => A, arg1: (arg0: A) => Internal.Codec<E_>): Internal.Codec<E_>;
        orElseGet(arg0: (arg0: string) => void, arg1: () => A): Internal.Codec<A>;
        orElseGet(arg0: () => A): Internal.Codec<A>;
        orElseGet(arg0: (arg0: any) => any, arg1: () => A): Internal.Codec<A>;
        stable(): Internal.Codec<A>;
        mapResult(arg0: Internal.Codec$ResultFunction<A>): Internal.Codec<A>;
    }
    interface Set <E> extends Internal.Collection<E> {
        add(arg0: E): boolean;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: (arg0: E) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        remove(arg0: any): boolean;
        removeIf(arg0: (arg0: E) => boolean): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.Iterator<E>;
        size(): number;
        stream(): Internal.Stream<E>;
        addAll(arg0: Internal.Collection<E>): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray(): any[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        retainAll(arg0: Internal.Collection<any>): boolean;
    }
    class ValueRange implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getMaximum(): number;
        getSmallestMaximum(): number;
        notify(): void;
        isIntValue(): boolean;
        getLargestMinimum(): number;
        isValidValue(arg0: number): boolean;
        hashCode(): number;
        static of(arg0: number, arg1: number): Internal.ValueRange;
        static of(arg0: number, arg1: number, arg2: number, arg3: number): Internal.ValueRange;
        static of(arg0: number, arg1: number, arg2: number): Internal.ValueRange;
        equals(arg0: any): boolean;
        getMinimum(): number;
        checkValidIntValue(arg0: number, arg1: Internal.TemporalField): number;
        checkValidValue(arg0: number, arg1: Internal.TemporalField): number;
        toString(): string;
        isFixed(): boolean;
        isValidIntValue(arg0: number): boolean;
        get largestMinimum(): number;
        get smallestMaximum(): number;
        get intValue(): boolean;
        get maximum(): number;
        get fixed(): boolean;
        get class(): Internal.Class<any>;
        get minimum(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Byte2LongFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsLong(arg0: number): number;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class InetAddress implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isMCOrgLocal(): boolean;
        notifyAll(): void;
        notify(): void;
        isMCLinkLocal(): boolean;
        isLoopbackAddress(): boolean;
        isSiteLocalAddress(): boolean;
        isMulticastAddress(): boolean;
        hashCode(): number;
        static getByName(arg0: string): Internal.InetAddress;
        static getLoopbackAddress(): Internal.InetAddress;
        getAddress(): number[];
        getHostAddress(): string;
        isMCNodeLocal(): boolean;
        isMCSiteLocal(): boolean;
        isReachable(arg0: number): boolean;
        isReachable(arg0: Internal.NetworkInterface, arg1: number, arg2: number): boolean;
        isMCGlobal(): boolean;
        static getAllByName(arg0: string): Internal.InetAddress[];
        getHostName(): string;
        getCanonicalHostName(): string;
        isAnyLocalAddress(): boolean;
        isLinkLocalAddress(): boolean;
        static getLocalHost(): Internal.InetAddress;
        equals(arg0: any): boolean;
        static getByAddress(arg0: number[]): Internal.InetAddress;
        static getByAddress(arg0: string, arg1: number[]): Internal.InetAddress;
        toString(): string;
        get linkLocalAddress(): boolean;
        get loopbackAddress(): Internal.InetAddress;
        get hostName(): string;
        get address(): number[];
        get canonicalHostName(): string;
        get mCOrgLocal(): boolean;
        get siteLocalAddress(): boolean;
        get mCNodeLocal(): boolean;
        get mCGlobal(): boolean;
        get mCLinkLocal(): boolean;
        get multicastAddress(): boolean;
        get localHost(): Internal.InetAddress;
        get hostAddress(): string;
        get class(): Internal.Class<any>;
        get mCSiteLocal(): boolean;
        get anyLocalAddress(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Reader implements Internal.Readable, Internal.Closeable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        read(arg0: string[]): number;
        read(arg0: string[], arg1: number, arg2: number): number;
        read(arg0: Internal.CharBuffer): number;
        read(): number;
        markSupported(): boolean;
        notifyAll(): void;
        skip(arg0: number): number;
        transferTo(arg0: Internal.Writer): number;
        notify(): void;
        static nullReader(): Internal.Reader;
        hashCode(): number;
        ready(): boolean;
        equals(arg0: any): boolean;
        reset(): void;
        toString(): string;
        close(): void;
        mark(arg0: number): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class StonecuttingRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        parseResultItem(o: any): Internal.ItemStackJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DataResult$Instance extends Internal.Enum<any> implements Internal.Applicative<Internal.DataResult$Mu, any> {
        getClass(): Internal.Class<any>;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.DataResult$Instance): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.DataResult$Instance>>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>, arg9: Internal.App<Internal.DataResult$Mu, T10_>, arg10: Internal.App<Internal.DataResult$Mu, T11_>): Internal.Products$P11<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>, arg9: Internal.App<Internal.DataResult$Mu, T10_>): Internal.Products$P10<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>): Internal.Products$P9<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>, arg9: Internal.App<Internal.DataResult$Mu, T10_>, arg10: Internal.App<Internal.DataResult$Mu, T11_>, arg11: Internal.App<Internal.DataResult$Mu, T12_>, arg12: Internal.App<Internal.DataResult$Mu, T13_>, arg13: Internal.App<Internal.DataResult$Mu, T14_>, arg14: Internal.App<Internal.DataResult$Mu, T15_>, arg15: Internal.App<Internal.DataResult$Mu, T16_>): Internal.Products$P16<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>, arg9: Internal.App<Internal.DataResult$Mu, T10_>, arg10: Internal.App<Internal.DataResult$Mu, T11_>, arg11: Internal.App<Internal.DataResult$Mu, T12_>, arg12: Internal.App<Internal.DataResult$Mu, T13_>, arg13: Internal.App<Internal.DataResult$Mu, T14_>, arg14: Internal.App<Internal.DataResult$Mu, T15_>): Internal.Products$P15<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>, arg9: Internal.App<Internal.DataResult$Mu, T10_>, arg10: Internal.App<Internal.DataResult$Mu, T11_>, arg11: Internal.App<Internal.DataResult$Mu, T12_>, arg12: Internal.App<Internal.DataResult$Mu, T13_>, arg13: Internal.App<Internal.DataResult$Mu, T14_>): Internal.Products$P14<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>, arg9: Internal.App<Internal.DataResult$Mu, T10_>, arg10: Internal.App<Internal.DataResult$Mu, T11_>, arg11: Internal.App<Internal.DataResult$Mu, T12_>, arg12: Internal.App<Internal.DataResult$Mu, T13_>): Internal.Products$P13<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>, arg8: Internal.App<Internal.DataResult$Mu, T9_>, arg9: Internal.App<Internal.DataResult$Mu, T10_>, arg10: Internal.App<Internal.DataResult$Mu, T11_>, arg11: Internal.App<Internal.DataResult$Mu, T12_>): Internal.Products$P12<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>;
        group<T1_, T2_, T3_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>): Internal.Products$P3<Internal.DataResult$Mu, T1_, T2_, T3_>;
        group<T1_, T2_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>): Internal.Products$P2<Internal.DataResult$Mu, T1_, T2_>;
        group<T1_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>): Internal.Products$P1<Internal.DataResult$Mu, T1_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>, arg7: Internal.App<Internal.DataResult$Mu, T8_>): Internal.Products$P8<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>, arg6: Internal.App<Internal.DataResult$Mu, T7_>): Internal.Products$P7<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>, arg5: Internal.App<Internal.DataResult$Mu, T6_>): Internal.Products$P6<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_>;
        group<T1_, T2_, T3_, T4_, T5_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>, arg4: Internal.App<Internal.DataResult$Mu, T5_>): Internal.Products$P5<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_>;
        group<T1_, T2_, T3_, T4_>(arg0: Internal.App<Internal.DataResult$Mu, T1_>, arg1: Internal.App<Internal.DataResult$Mu, T2_>, arg2: Internal.App<Internal.DataResult$Mu, T3_>, arg3: Internal.App<Internal.DataResult$Mu, T4_>): Internal.Products$P4<Internal.DataResult$Mu, T1_, T2_, T3_, T4_>;
        ap11<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function11<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>, arg10: Internal.App<Internal.DataResult$Mu, T10_>, arg11: Internal.App<Internal.DataResult$Mu, T11_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap10<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function10<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>, arg10: Internal.App<Internal.DataResult$Mu, T10_>): Internal.App<Internal.DataResult$Mu, R_>;
        lift2<A_, B_, R_>(arg0: Internal.App<Internal.DataResult$Mu, (arg0: A_, arg1: B_) => R_>): (arg0: Internal.App<Internal.DataResult$Mu, A_>, arg1: Internal.App<Internal.DataResult$Mu, B_>) => Internal.App<Internal.DataResult$Mu, R_>;
        lift1<A_, R_>(arg0: Internal.App<Internal.DataResult$Mu, (arg0: A_) => R_>): (arg0: Internal.App<Internal.DataResult$Mu, A_>) => Internal.App<Internal.DataResult$Mu, R_>;
        lift6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>>): Internal.Function6<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, T5_>, Internal.App<Internal.DataResult$Mu, T6_>, Internal.App<Internal.DataResult$Mu, R_>>;
        lift5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>>): Internal.Function5<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, T5_>, Internal.App<Internal.DataResult$Mu, R_>>;
        lift4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function4<T1_, T2_, T3_, T4_, R_>>): Internal.Function4<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, R_>>;
        lift3<T1_, T2_, T3_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function3<T1_, T2_, T3_, R_>>): Internal.Function3<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, R_>>;
        lift9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>): Internal.Function9<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, T5_>, Internal.App<Internal.DataResult$Mu, T6_>, Internal.App<Internal.DataResult$Mu, T7_>, Internal.App<Internal.DataResult$Mu, T8_>, Internal.App<Internal.DataResult$Mu, T9_>, Internal.App<Internal.DataResult$Mu, R_>>;
        lift8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>): Internal.Function8<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, T5_>, Internal.App<Internal.DataResult$Mu, T6_>, Internal.App<Internal.DataResult$Mu, T7_>, Internal.App<Internal.DataResult$Mu, T8_>, Internal.App<Internal.DataResult$Mu, R_>>;
        lift7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>): Internal.Function7<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, T5_>, Internal.App<Internal.DataResult$Mu, T6_>, Internal.App<Internal.DataResult$Mu, T7_>, Internal.App<Internal.DataResult$Mu, R_>>;
        ap<A_, R_>(arg0: Internal.App<Internal.DataResult$Mu, (arg0: A_) => R_>, arg1: Internal.App<Internal.DataResult$Mu, A_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap<A_, R_>(arg0: (arg0: A_) => R_, arg1: Internal.App<Internal.DataResult$Mu, A_>): Internal.App<Internal.DataResult$Mu, R_>;
        name(): string;
        ap16<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function16<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>, arg10: Internal.App<Internal.DataResult$Mu, T10_>, arg11: Internal.App<Internal.DataResult$Mu, T11_>, arg12: Internal.App<Internal.DataResult$Mu, T12_>, arg13: Internal.App<Internal.DataResult$Mu, T13_>, arg14: Internal.App<Internal.DataResult$Mu, T14_>, arg15: Internal.App<Internal.DataResult$Mu, T15_>, arg16: Internal.App<Internal.DataResult$Mu, T16_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap13<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function13<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>, arg10: Internal.App<Internal.DataResult$Mu, T10_>, arg11: Internal.App<Internal.DataResult$Mu, T11_>, arg12: Internal.App<Internal.DataResult$Mu, T12_>, arg13: Internal.App<Internal.DataResult$Mu, T13_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap12<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function12<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>, arg10: Internal.App<Internal.DataResult$Mu, T10_>, arg11: Internal.App<Internal.DataResult$Mu, T11_>, arg12: Internal.App<Internal.DataResult$Mu, T12_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap15<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function15<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>, arg10: Internal.App<Internal.DataResult$Mu, T10_>, arg11: Internal.App<Internal.DataResult$Mu, T11_>, arg12: Internal.App<Internal.DataResult$Mu, T12_>, arg13: Internal.App<Internal.DataResult$Mu, T13_>, arg14: Internal.App<Internal.DataResult$Mu, T14_>, arg15: Internal.App<Internal.DataResult$Mu, T15_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap14<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function14<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>, arg10: Internal.App<Internal.DataResult$Mu, T10_>, arg11: Internal.App<Internal.DataResult$Mu, T11_>, arg12: Internal.App<Internal.DataResult$Mu, T12_>, arg13: Internal.App<Internal.DataResult$Mu, T13_>, arg14: Internal.App<Internal.DataResult$Mu, T14_>): Internal.App<Internal.DataResult$Mu, R_>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        static values(): Internal.DataResult$Instance[];
        notify(): void;
        point<A_>(arg0: A_): Internal.App<Internal.DataResult$Mu, A_>;
        getDeclaringClass(): Internal.Class<Internal.DataResult$Instance>;
        hashCode(): number;
        map<T_, R_>(arg0: (arg0: T_) => R_, arg1: Internal.App<Internal.DataResult$Mu, T_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply2<A_, B_, R_>(arg0: (arg0: A_, arg1: B_) => R_, arg1: Internal.App<Internal.DataResult$Mu, A_>, arg2: Internal.App<Internal.DataResult$Mu, B_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply3<T1_, T2_, T3_, R_>(arg0: Internal.Function3<T1_, T2_, T3_, R_>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.Function4<T1_, T2_, T3_, T4_, R_>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap2<A_, B_, R_>(arg0: Internal.App<Internal.DataResult$Mu, (arg0: A_, arg1: B_) => R_>, arg1: Internal.App<Internal.DataResult$Mu, A_>, arg2: Internal.App<Internal.DataResult$Mu, B_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function4<T1_, T2_, T3_, T4_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap3<T1_, T2_, T3_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function3<T1_, T2_, T3_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>): Internal.App<Internal.DataResult$Mu, R_>;
        static valueOf(arg0: string): Internal.DataResult$Instance;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        ap5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App<Internal.DataResult$Mu, Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>, arg1: Internal.App<Internal.DataResult$Mu, T1_>, arg2: Internal.App<Internal.DataResult$Mu, T2_>, arg3: Internal.App<Internal.DataResult$Mu, T3_>, arg4: Internal.App<Internal.DataResult$Mu, T4_>, arg5: Internal.App<Internal.DataResult$Mu, T5_>, arg6: Internal.App<Internal.DataResult$Mu, T6_>, arg7: Internal.App<Internal.DataResult$Mu, T7_>, arg8: Internal.App<Internal.DataResult$Mu, T8_>, arg9: Internal.App<Internal.DataResult$Mu, T9_>): Internal.App<Internal.DataResult$Mu, R_>;
        equals(arg0: any): boolean;
        toString(): string;
        ordinal(): number;
        static readonly INSTANCE : Internal.DataResult$Instance;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.DataResult$Instance>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface OpenOption {
    }
    class AttributeKey <T> extends Internal.AbstractConstant<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        static valueOf<T_>(arg0: string): Internal.AttributeKey<T_>;
        static valueOf<T_>(arg0: Internal.Class<any>, arg1: string): Internal.AttributeKey<T_>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        name(): string;
        static exists(arg0: string): boolean;
        toString(): string;
        static newInstance<T_>(arg0: string): Internal.AttributeKey<T_>;
        id(): number;
        compareTo(arg0: Internal.AttributeKey<Internal.AttributeKey<T>>): number;
        compareTo(arg0: any): number;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class VoxelShape implements Internal.VoxelShapeAccess, Internal.OffsetVoxelShapeCache {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setFaces(arg0: Internal.VoxelShape[]): void;
        hashCode(): number;
        getOffsetSimplifiedShape(offset: number, direction: Internal.Direction): Internal.VoxelShape;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getFaces(): Internal.VoxelShape[];
        getShape(): Internal.DiscreteVoxelShape;
        toString(): string;
        notify(): void;
        setShape(offset: number, direction: Internal.Direction, offsetShape: Internal.VoxelShape): void;
        setShape(arg0: Internal.DiscreteVoxelShape): void;
        get shape(): Internal.DiscreteVoxelShape;
        get faces(): Internal.VoxelShape[];
        get class(): Internal.Class<any>;
        set shape(arg0: Internal.DiscreteVoxelShape);
        set faces(arg0: Internal.VoxelShape[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Object2LongEntry implements Internal.Comparable<Internal.Object2LongEntry> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        compareTo(arg0: any): number;
        compareTo(o: Internal.Object2LongEntry): number;
        notify(): void;
        readonly value : number;
        readonly key : any;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClickEvent {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ItemStack extends Internal.CapabilityProvider<any> implements Internal.IForgeItemStack, Internal.ItemStackKJS, Internal.StorableItemStack {
        getClass(): Internal.Class<any>;
        canElytraFly(arg0: Internal.LivingEntity): boolean;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        canPerformAction(arg0: Internal.ToolAction): boolean;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack): boolean;
        getItemEnchantability(): number;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        getXpRepairRatio(): number;
        readShareTag(arg0: Internal.CompoundTag): void;
        localvar$bed000$updateInventory(count: number): number;
        onEntityItemUpdate(arg0: Internal.ItemEntity): boolean;
        registerToInventory(itemStacks: Internal.LithiumStackList, mySlot: number): void;
        isBookEnchantable(arg0: Internal.ItemStack): boolean;
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: Internal.LivingEntity): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.ItemStack>): boolean;
        onUsingTick(arg0: Internal.LivingEntity, arg1: number): void;
        isPiglinCurrency(): boolean;
        getSweepHitBox(arg0: Internal.Player, arg1: Internal.Entity): Internal.AABB;
        reviveCaps(): void;
        isRepairable(): boolean;
        getShareTag(): Internal.CompoundTag;
        getBurnTime(arg0: Internal.RecipeType<any>): number;
        onDroppedByPlayer(arg0: Internal.Player): boolean;
        onEntitySwing(arg0: Internal.LivingEntity): boolean;
        elytraFlightTick(arg0: Internal.LivingEntity, arg1: number): boolean;
        areShareTagsEqual(arg0: Internal.ItemStack): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        canEquip(arg0: EquipmentSlot, arg1: Internal.Entity): boolean;
        notifyAll(): void;
        notify(): void;
        onBlockStartBreak(arg0: BlockPos, arg1: Internal.Player): boolean;
        onHorseArmorTick(arg0: net.minecraft.world.level.Level, arg1: Internal.Mob): void;
        getEntityLifespan(arg0: net.minecraft.world.level.Level): number;
        hashCode(): number;
        getHighlightTip(arg0: Internal.Component): Internal.Component;
        removeTagKJS(): void;
        onArmorTick(arg0: net.minecraft.world.level.Level, arg1: Internal.Player): void;
        unregisterFromInventory(myInventoryList: Internal.LithiumStackList): void;
        hasContainerItem(): boolean;
        doesSneakBypassUse(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Player): boolean;
        onItemUseFirst(arg0: Internal.UseOnContext): Internal.InteractionResult;
        getContainerItem(): Internal.ItemStack;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        asKJS(): any;
        onDestroyed(arg0: Internal.ItemEntity, arg1: Internal.DamageSource): void;
        getEquipmentSlot(): EquipmentSlot;
        equals(arg0: any): boolean;
        equals(arg0: Internal.ItemStack, arg1: boolean): boolean;
        makesPiglinsNeutral(arg0: Internal.LivingEntity): boolean;
        toString(): string;
        isEnderMask(arg0: Internal.Player, arg1: Internal.EnderMan): boolean;
        canApplyAtEnchantingTable(arg0: Internal.Enchantment): boolean;
        get shareTag(): Internal.CompoundTag;
        get repairable(): boolean;
        get itemEnchantability(): number;
        get equipmentSlot(): EquipmentSlot;
        get piglinCurrency(): boolean;
        get containerItem(): Internal.ItemStack;
        get class(): Internal.Class<any>;
        get xpRepairRatio(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Long2LongFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.LongUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.LongUnaryOperator): Internal.LongUnaryOperator;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsLong(arg0: number): number;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.LongUnaryOperator): Internal.LongUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface ItemColorsExtended {
        getColorProvider(arg0: Internal.ItemStack): Internal.ItemColor;
    }
    interface ErrorReporter {
        runtimeError(arg0: string, arg1: string, arg2: number, arg3: string, arg4: number): Internal.EvaluatorException;
        warning(arg0: string, arg1: string, arg2: number, arg3: string, arg4: number): void;
        error(arg0: string, arg1: string, arg2: number, arg3: string, arg4: number): void;
    }
    interface ConstProperties {
        defineConst(arg0: string, arg1: Internal.Scriptable): void;
        isConst(arg0: string): boolean;
        putConst(arg0: string, arg1: Internal.Scriptable, arg2: any): void;
    }
    interface Comparable <T> {
        compareTo(arg0: T): number;
    }
    abstract class PlayerEventJS extends Internal.LivingEntityEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        addGameStage(stage: string): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getPlayer(): Internal.PlayerJS<any>;
        notifyAll(): void;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.LevelJS;
        getMinecraftPlayer(): Internal.Player;
        post(id: string, sub: string): boolean;
        post(id: string): boolean;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        hasGameStage(stage: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        removeGameStage(stage: string): void;
        toString(): string;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get minecraftPlayer(): Internal.Player;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FastMap <Value> {
        getClass(): Internal.Class<any>;
        getKey(keyIndex: number): Internal.FastMapKey<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        numProperties(): number;
        notifyAll(): void;
        isSingleState(): boolean;
        notify(): void;
        with<T>(oldIndex: number, prop: Internal.Property<T>, value: T): Value;
        getValue(stateIndex: number, key: any): Internal.Comparable<any>;
        getValue<T>(stateIndex: number, property: Internal.Property<T>): T;
        getIndexOf(state: Internal.Map<Internal.Property<any>, Internal.Comparable<any>>): number;
        hashCode(): number;
        getPropertySet(): Internal.ImmutableSet<Internal.Property<any>>;
        equals(arg0: any): boolean;
        withUnsafe<T>(globalTableIndex: number, property: Internal.Property<T>, newValue: any): Value;
        toString(): string;
        getEntry(propertyIndex: number, stateIndex: number): Internal.Map$Entry<Internal.Property<any>, Internal.Comparable<any>>;
        get propertySet(): Internal.ImmutableSet<Internal.Property<any>>;
        get singleState(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractContainerMenu implements Internal.ContainerAccess, Internal.AbstractContainerMenuInvoker, Internal.AbstractContainerMenuAccessor {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMenuType(): Internal.MenuType<any>;
        getRemoteSlots(): Internal.NonNullList<any>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getLastSlots(): Internal.NonNullList<any>;
        handler$zjc000$doClick(arg0: number, arg1: number, arg2: Internal.ClickType, arg3: Internal.Player, arg4: Internal.CallbackInfo): void;
        toString(): string;
        notify(): void;
        _moveItemStackTo(arg0: Internal.ItemStack, arg1: number, arg2: number, arg3: boolean): boolean;
        get remoteSlots(): Internal.NonNullList<any>;
        get menuType(): Internal.MenuType<any>;
        get lastSlots(): Internal.NonNullList<any>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Tags$IOptionalNamedTag <T> extends Internal.Tag$Named<T> {
        isDefaulted(): boolean;
    }
    class ImmutableSetMultimap <K, V> extends Internal.ImmutableMultimap<any, any> implements Internal.SetMultimap<K, V> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        asMap(): Internal.Map<any, any>;
        asMap(): Internal.ImmutableMap<K, Internal.Collection<V>>;
        keys(): Internal.ImmutableMultiset<K>;
        keys(): Internal.Multiset<any>;
        notifyAll(): void;
        values(): Internal.ImmutableCollection<V>;
        values(): Internal.Collection<any>;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): boolean;
        remove(arg0: any, arg1: any): boolean;
        static flatteningToImmutableSetMultimap<T_, K_, V_>(arg0: (arg0: T_) => K_, arg1: (arg0: T_) => Internal.Stream<V_>): Internal.Collector<T_, any, Internal.ImmutableSetMultimap<K_, V_>>;
        removeAll(arg0: any): Internal.ImmutableCollection<any>;
        removeAll(arg0: any): Internal.Set<any>;
        removeAll(arg0: any): Internal.ImmutableSet<V>;
        removeAll(arg0: any): Internal.Collection<any>;
        hashCode(): number;
        putAll(arg0: Internal.Multimap<K, V>): boolean;
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean;
        static of<K_, V_>(arg0: K_, arg1: V_): Internal.ImmutableSetMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_): Internal.ImmutableSetMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_): Internal.ImmutableSetMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(): Internal.ImmutableSetMultimap<K_, V_>;
        static of<K_, V_>(): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_): Internal.ImmutableSetMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_): Internal.ImmutableSetMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_): Internal.ImmutableMultimap<K_, V_>;
        get(arg0: any): Internal.Collection<any>;
        get(arg0: K): Internal.ImmutableSet<V>;
        get(arg0: any): Internal.ImmutableCollection<any>;
        get(arg0: any): Internal.Set<any>;
        static builder<K_, V_>(): Internal.ImmutableSetMultimap$Builder<K_, V_>;
        static builder<K_, V_>(): Internal.ImmutableMultimap$Builder<K_, V_>;
        keySet(): Internal.ImmutableSet<K>;
        keySet(): Internal.Set<any>;
        containsEntry(arg0: any, arg1: any): boolean;
        inverse(): Internal.ImmutableSetMultimap<V, K>;
        inverse(): Internal.ImmutableMultimap<any, any>;
        containsKey(arg0: any): boolean;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        isEmpty(): boolean;
        clear(): void;
        static copyOf<K_, V_>(arg0: Internal.Multimap<K_, V_>): Internal.ImmutableSetMultimap<K_, V_>;
        static copyOf<K_, V_>(arg0: Internal.Multimap<K_, V_>): Internal.ImmutableMultimap<K_, V_>;
        static copyOf<K_, V_>(arg0: Internal.Iterable<Internal.Map$Entry<K_, V_>>): Internal.ImmutableSetMultimap<K_, V_>;
        static copyOf<K_, V_>(arg0: Internal.Iterable<Internal.Map$Entry<K_, V_>>): Internal.ImmutableMultimap<K_, V_>;
        replaceValues(arg0: any, arg1: Internal.Iterable<any>): Internal.Collection<any>;
        replaceValues(arg0: any, arg1: Internal.Iterable<any>): Internal.ImmutableCollection<any>;
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.ImmutableSet<V>;
        replaceValues(arg0: any, arg1: Internal.Iterable<any>): Internal.Set<any>;
        static toImmutableSetMultimap<T_, K_, V_>(arg0: (arg0: T_) => K_, arg1: (arg0: T_) => V_): Internal.Collector<T_, any, Internal.ImmutableSetMultimap<K_, V_>>;
        entries(): Internal.Collection<any>;
        entries(): Internal.ImmutableCollection<any>;
        entries(): Internal.Set<any>;
        entries(): Internal.ImmutableSet<Internal.Map$Entry<K, V>>;
        size(): number;
        equals(arg0: any): boolean;
        toString(): string;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class SimplePreparableReloadListener <T> implements Internal.PreparableReloadListener {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CodeSource implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLocation(): Internal.URL;
        getCodeSigners(): any[];
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getCertificates(): any[];
        toString(): string;
        implies(arg0: Internal.CodeSource): boolean;
        notify(): void;
        get codeSigners(): any[];
        get certificates(): any[];
        get location(): Internal.URL;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Reference2DoubleFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        applyAsDouble(arg0: K): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        getDouble(arg0: any): number;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_;
        put(arg0: K, arg1: number): number;
        put(arg0: K, arg1: number): number;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): any;
        remove(arg0: any): number;
        defaultReturnValue(arg0: number): void;
        defaultReturnValue(): number;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        get(arg0: any): number;
        get(arg0: any): any;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number;
        removeDouble(arg0: any): number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface FontResourceManagerAccess {
        getFontSets(): Internal.Map<ResourceLocation, Internal.FontSet>;
    }
    interface Double2ShortFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    abstract class FileChannel extends Internal.AbstractInterruptibleChannel implements Internal.SeekableByteChannel, Internal.GatheringByteChannel, Internal.ScatteringByteChannel {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        transferFrom(arg0: Internal.ReadableByteChannel, arg1: number, arg2: number): number;
        read(arg0: Internal.ByteBuffer): number;
        read(arg0: Internal.ByteBuffer, arg1: number): number;
        read(arg0: Internal.ByteBuffer[]): number;
        read(arg0: Internal.ByteBuffer[], arg1: number, arg2: number): number;
        notifyAll(): void;
        transferTo(arg0: number, arg1: number, arg2: Internal.WritableByteChannel): number;
        notify(): void;
        tryLock(arg0: number, arg1: number, arg2: boolean): Internal.FileLock;
        tryLock(): Internal.FileLock;
        isOpen(): boolean;
        truncate(arg0: number): Internal.SeekableByteChannel;
        truncate(arg0: number): Internal.FileChannel;
        size(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        lock(): Internal.FileLock;
        lock(arg0: number, arg1: number, arg2: boolean): Internal.FileLock;
        toString(): string;
        force(arg0: boolean): void;
        position(arg0: number): Internal.SeekableByteChannel;
        position(arg0: number): Internal.FileChannel;
        position(): number;
        close(): void;
        write(arg0: Internal.ByteBuffer, arg1: number): number;
        write(arg0: Internal.ByteBuffer): number;
        write(arg0: Internal.ByteBuffer[], arg1: number, arg2: number): number;
        write(arg0: Internal.ByteBuffer[]): number;
        map(arg0: Internal.FileChannel$MapMode, arg1: number, arg2: number): Internal.MappedByteBuffer;
        static open(arg0: Internal.Path, arg1: Internal.Set<Internal.OpenOption>, arg2: any[]): Internal.FileChannel;
        static open(arg0: Internal.Path, arg1: Internal.OpenOption[]): Internal.FileChannel;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Endimation$Builder$Keyframes {
        static keyframes(): Internal.Endimation$Builder$Keyframes;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): (arg0: string) => Internal.Endimation$PartKeyframes;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        part(arg0: string, arg1: Internal.Endimation$PartKeyframes$Builder): Internal.Endimation$Builder$Keyframes;
        part(arg0: string, arg1: Internal.Endimation$PartKeyframes): Internal.Endimation$Builder$Keyframes;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FluidAttributes$Builder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        density(arg0: number): Internal.FluidAttributes$Builder;
        translationKey(arg0: string): Internal.FluidAttributes$Builder;
        overlay(arg0: ResourceLocation): Internal.FluidAttributes$Builder;
        color(arg0: number): Internal.FluidAttributes$Builder;
        notifyAll(): void;
        sound(arg0: Internal.SoundEvent, arg1: Internal.SoundEvent): Internal.FluidAttributes$Builder;
        sound(arg0: Internal.SoundEvent): Internal.FluidAttributes$Builder;
        gaseous(): Internal.FluidAttributes$Builder;
        notify(): void;
        viscosity(arg0: number): Internal.FluidAttributes$Builder;
        build(arg0: Internal.Fluid): Internal.FluidAttributes;
        hashCode(): number;
        equals(arg0: any): boolean;
        temperature(arg0: number): Internal.FluidAttributes$Builder;
        luminosity(arg0: number): Internal.FluidAttributes$Builder;
        toString(): string;
        rarity(arg0: Internal.Rarity): Internal.FluidAttributes$Builder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FireworksJS$Explosion {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        trail : boolean;
        readonly fadeColors : Internal.IntOpenHashSet;
        shape : Internal.FireworksJS$Shape;
        flicker : boolean;
        readonly colors : Internal.IntOpenHashSet;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class SearchRegistry implements Internal.ResourceManagerReloadListener {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Object2ByteFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        getByte(arg0: any): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_;
        put(arg0: K, arg1: number): number;
        put(arg0: K, arg1: number): number;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): any;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        get(arg0: any): number;
        get(arg0: any): any;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        removeByte(arg0: any): number;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: K): number;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface CommonLevelAccessor extends Internal.EntityGetter, Internal.LevelReader, Internal.LevelSimulatedRW {
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean;
    }
    interface Int2ReferenceFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: number, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        put(arg0: number, arg1: V): V;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: V): V;
        remove(arg0: number): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): V;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class AlloyRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        energy(e: number): Internal.IERecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        time(t: number): Internal.IERecipeJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<net.minecraftforge.fluids.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class SqueezerRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        energy(e: number): Internal.IERecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        time(t: number): Internal.IERecipeJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<net.minecraftforge.fluids.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AnnotatedType extends Internal.AnnotatedElement {
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean;
        getAnnotatedOwnerType(): Internal.AnnotatedType;
        getType(): java_.lang.reflect.Type;
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        getAnnotations(): Internal.Annotation[];
        getDeclaredAnnotations(): Internal.Annotation[];
    }
    class ItemColors implements Internal.ItemColorsExtended {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getColorProvider(stack: Internal.ItemStack): Internal.ItemColor;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FlowMessage extends Internal.Message {
        getText(): string;
        getParameters(): any[];
        getFormattedMessage(): string;
        getMessage(): Internal.Message;
        getFormat(): string;
        getThrowable(): Internal.Throwable;
    }
    interface ModelState extends Internal.IForgeModelState {
        getPartTransformation(arg0: any): Internal.Transformation;
    }
    class Capability <T> {
        getClass(): Internal.Class<any>;
        orEmpty<R>(arg0: Internal.Capability<R>, arg1: Internal.LazyOptional<T>): Internal.LazyOptional<R>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        isRegistered(): boolean;
        notify(): void;
        addListener(arg0: (arg0: Internal.Capability<T>) => void): Internal.Capability<T>;
        get name(): string;
        get registered(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LongFunction <R> {
        apply(arg0: number): R;
    }
    class BaseFunction extends Internal.IdScriptableObject implements dev.latvian.mods.rhino.Function {
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        setParentScope(m: Internal.Scriptable): void;
        static redefineProperty(obj: Internal.Scriptable, name: string, isConst: boolean): void;
        putConst(name: string, start: Internal.Scriptable, value: any): void;
        static getTypedProperty<T_>(s: Internal.Scriptable, index: number, type: Internal.Class<T_>): T_;
        static getTypedProperty<T_>(s: Internal.Scriptable, name: string, type: Internal.Class<T_>): T_;
        getIds(): any[];
        static getArrayPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        construct(cx: Internal.Context, scope: Internal.Scriptable, args: any[]): Internal.Scriptable;
        getAllIds(): any[];
        put(key: Internal.Symbol, start: Internal.Scriptable, value: any): void;
        put(name: string, start: Internal.Scriptable, value: any): void;
        put(index: number, start: Internal.Scriptable, value: any): void;
        getArity(): number;
        getDefaultValue(typeHint: Internal.Class<any>): any;
        static getDefaultValue(object: Internal.Scriptable, typeHint: Internal.Class<any>): any;
        defineOwnProperties(cx: Internal.Context, props: Internal.ScriptableObject): void;
        defineProperty(propertyName: string, clazz: Internal.Class<any>, attributes: number): void;
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method, setter: Internal.Method, attributes: number): void;
        defineProperty(propertyName: string, value: any, attributes: number): void;
        defineProperty(key: Internal.Symbol, value: any, attributes: number): void;
        static defineProperty(destination: Internal.Scriptable, propertyName: string, value: any, attributes: number): void;
        hasPrototypeMap(): boolean;
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable, isSetter: boolean): void;
        avoidObjectDetection(): boolean;
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean;
        has(name: string, start: Internal.Scriptable): boolean;
        has(index: number, start: Internal.Scriptable): boolean;
        getFunctionName(): string;
        getExternalArrayLength(): any;
        getAttributes(name: string): number;
        getAttributes(key: Internal.Symbol): number;
        getAttributes(index: number): number;
        setImmunePrototypeProperty(value: any): void;
        hasInstance(instance: Internal.Scriptable): boolean;
        getAssociatedValue(key: any): any;
        execIdCall(f: Internal.IdFunctionObject, cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any;
        static getPropertyIds(obj: Internal.Scriptable): any[];
        static hasProperty(obj: Internal.Scriptable, index: number): boolean;
        static hasProperty(obj: Internal.Scriptable, name: string): boolean;
        static hasProperty(obj: Internal.Scriptable, key: Internal.Symbol): boolean;
        getExternalArrayData(): Internal.ExternalArrayData;
        size(): number;
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol, functionName: string, arity: number): Internal.IdFunctionObject;
        defineOwnProperty(cx: Internal.Context, key: any, desc: Internal.ScriptableObject): void;
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void;
        initPrototypeValue(id: number, key: Internal.Symbol, value: any, attributes: number): void;
        static getFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        preventExtensions(): void;
        setExternalArrayData(array: Internal.ExternalArrayData): void;
        static callMethod(obj: Internal.Scriptable, methodName: string, args: any[]): any;
        static callMethod(cx: Internal.Context, obj: Internal.Scriptable, methodName: string, args: any[]): any;
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        getTypeOf(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getTopScopeValue(scope: Internal.Scriptable, key: any): any;
        initPrototypeConstructor(f: Internal.IdFunctionObject): void;
        notifyAll(): void;
        sealObject(): void;
        setAttributes(name: string, attributes: number): void;
        setAttributes(index: number, attributes: number): void;
        setAttributes(key: Internal.Symbol, attributes: number): void;
        static putProperty(obj: Internal.Scriptable, index: number, value: any): void;
        static putProperty(obj: Internal.Scriptable, key: Internal.Symbol, value: any): void;
        static putProperty(obj: Internal.Scriptable, name: string, value: any): void;
        delete(key: Internal.Symbol): void;
        delete(name: string): void;
        delete(index: number): void;
        notify(): void;
        associateValue(key: any, value: any): any;
        static deleteProperty(obj: Internal.Scriptable, name: string): boolean;
        static deleteProperty(obj: Internal.Scriptable, index: number): boolean;
        getPrototype(): Internal.Scriptable;
        static getObjectPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        isExtensible(): boolean;
        hashCode(): number;
        isConst(name: string): boolean;
        get(name: string, start: Internal.Scriptable): any;
        get(key: Internal.Symbol, start: Internal.Scriptable): any;
        get(index: number, start: Internal.Scriptable): any;
        get(key: any): any;
        static putConstProperty(obj: Internal.Scriptable, name: string, value: any): void;
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any;
        static getTopLevelScope(obj: Internal.Scriptable): Internal.Scriptable;
        static getProperty(obj: Internal.Scriptable, name: string): any;
        static getProperty(obj: Internal.Scriptable, key: Internal.Symbol): any;
        static getProperty(obj: Internal.Scriptable, index: number): any;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean): void;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>): void;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean, mapInheritance: boolean): string;
        activatePrototypeMap(maxPrototypeId: number): void;
        isEmpty(): boolean;
        defineFunctionProperties(names: string[], clazz: Internal.Class<any>, attributes: number): void;
        static getClassPrototype(scope: Internal.Scriptable, className: string): Internal.Scriptable;
        createObject(cx: Internal.Context, scope: Internal.Scriptable): Internal.Scriptable;
        setPrototype(m: Internal.Scriptable): void;
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable, sealed: boolean): Internal.IdFunctionObject;
        call(cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any;
        defineConst(name: string, start: Internal.Scriptable): void;
        equals(arg0: any): boolean;
        static defineConstProperty(destination: Internal.Scriptable, propertyName: string): void;
        getLength(): number;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get functionName(): string;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get length(): number;
        get className(): string;
        get prototype(): Internal.Scriptable;
        get empty(): boolean;
        get arity(): number;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get externalArrayLength(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get extensible(): boolean;
        get typeOf(): string;
        set immunePrototypeProperty(value: any);
        set externalArrayData(array: Internal.ExternalArrayData);
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IDataProcessor <T> {
        read(arg0: Internal.CompoundTag): T;
        write(arg0: T): Internal.CompoundTag;
    }
    class CompletableFuture <T> implements java_.util.concurrent.Future<T>, Internal.CompletionStage<T> {
        cancel(arg0: boolean): boolean;
        getClass(): Internal.Class<any>;
        obtrudeValue(arg0: T): void;
        exceptionallyAsync(arg0: (arg0: Internal.Throwable) => T, arg1: Internal.Executor): Internal.CompletableFuture<T>;
        exceptionallyAsync(arg0: (arg0: any) => any, arg1: Internal.Executor): Internal.CompletionStage<any>;
        exceptionallyAsync(arg0: (arg0: Internal.Throwable) => T): Internal.CompletableFuture<T>;
        exceptionallyAsync(arg0: (arg0: any) => any): Internal.CompletionStage<any>;
        static failedStage<U_>(arg0: Internal.Throwable): Internal.CompletionStage<U_>;
        runAfterBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletableFuture<void>;
        runAfterBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletionStage<any>;
        runAfterBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<any>;
        runAfterBothAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletableFuture<void>;
        obtrudeException(arg0: Internal.Throwable): void;
        thenAcceptBoth(arg0: Internal.CompletionStage<any>, arg1: (arg0: any, arg1: any) => void): Internal.CompletionStage<any>;
        thenAcceptBoth<U_>(arg0: Internal.CompletionStage<U_>, arg1: (arg0: T, arg1: U_) => void): Internal.CompletableFuture<void>;
        exceptionallyCompose(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>): Internal.CompletableFuture<T>;
        exceptionallyCompose(arg0: (arg0: any) => any): Internal.CompletionStage<any>;
        join(): T;
        isCompletedExceptionally(): boolean;
        applyToEither<U_>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U_): Internal.CompletableFuture<U_>;
        applyToEither(arg0: Internal.CompletionStage<any>, arg1: (arg0: any) => any): Internal.CompletionStage<any>;
        completeAsync(arg0: () => T, arg1: Internal.Executor): Internal.CompletableFuture<T>;
        completeAsync(arg0: () => T): Internal.CompletableFuture<T>;
        thenApply<U_>(arg0: (arg0: T) => U_): Internal.CompletableFuture<U_>;
        thenApply(arg0: (arg0: any) => any): Internal.CompletionStage<any>;
        thenRun(arg0: Internal.Runnable): Internal.CompletionStage<any>;
        thenRun(arg0: Internal.Runnable): Internal.CompletableFuture<void>;
        orTimeout(arg0: number, arg1: Internal.TimeUnit): Internal.CompletableFuture<T>;
        getNow(arg0: T): T;
        exceptionally(arg0: (arg0: Internal.Throwable) => T): Internal.CompletableFuture<T>;
        exceptionally(arg0: (arg0: any) => any): Internal.CompletionStage<any>;
        handle(arg0: (arg0: any, arg1: any) => any): Internal.CompletionStage<any>;
        handle<U_>(arg0: (arg0: T, arg1: Internal.Throwable) => U_): Internal.CompletableFuture<U_>;
        thenCompose<U_>(arg0: (arg0: T) => Internal.CompletionStage<U_>): Internal.CompletableFuture<U_>;
        thenCompose(arg0: (arg0: any) => any): Internal.CompletionStage<any>;
        static failedFuture<U_>(arg0: Internal.Throwable): Internal.CompletableFuture<U_>;
        thenCombineAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any, arg1: any) => any): Internal.CompletionStage<any>;
        thenCombineAsync<U_, V_>(arg0: Internal.CompletionStage<U_>, arg1: (arg0: T, arg1: U_) => V_): Internal.CompletableFuture<V_>;
        thenCombineAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any, arg1: any) => any, arg2: Internal.Executor): Internal.CompletionStage<any>;
        thenCombineAsync<U_, V_>(arg0: Internal.CompletionStage<U_>, arg1: (arg0: T, arg1: U_) => V_, arg2: Internal.Executor): Internal.CompletableFuture<V_>;
        static completedFuture<U_>(arg0: U_): Internal.CompletableFuture<U_>;
        getNumberOfDependents(): number;
        whenCompleteAsync(arg0: (arg0: T, arg1: Internal.Throwable) => void, arg1: Internal.Executor): Internal.CompletableFuture<T>;
        whenCompleteAsync(arg0: (arg0: any, arg1: any) => void, arg1: Internal.Executor): Internal.CompletionStage<any>;
        whenCompleteAsync(arg0: (arg0: T, arg1: Internal.Throwable) => void): Internal.CompletableFuture<T>;
        whenCompleteAsync(arg0: (arg0: any, arg1: any) => void): Internal.CompletionStage<any>;
        thenApplyAsync(arg0: (arg0: any) => any): Internal.CompletionStage<any>;
        thenApplyAsync<U_>(arg0: (arg0: T) => U_): Internal.CompletableFuture<U_>;
        thenApplyAsync(arg0: (arg0: any) => any, arg1: Internal.Executor): Internal.CompletionStage<any>;
        thenApplyAsync<U_>(arg0: (arg0: T) => U_, arg1: Internal.Executor): Internal.CompletableFuture<U_>;
        thenAcceptAsync(arg0: (arg0: T) => void, arg1: Internal.Executor): Internal.CompletableFuture<void>;
        thenAcceptAsync(arg0: (arg0: any) => void, arg1: Internal.Executor): Internal.CompletionStage<any>;
        thenAcceptAsync(arg0: (arg0: T) => void): Internal.CompletableFuture<void>;
        thenAcceptAsync(arg0: (arg0: any) => void): Internal.CompletionStage<any>;
        toCompletableFuture(): Internal.CompletableFuture<T>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        notify(): void;
        static runAsync(arg0: Internal.Runnable): Internal.CompletableFuture<void>;
        static runAsync(arg0: Internal.Runnable, arg1: Internal.Executor): Internal.CompletableFuture<void>;
        thenRunAsync(arg0: Internal.Runnable, arg1: Internal.Executor): Internal.CompletableFuture<void>;
        thenRunAsync(arg0: Internal.Runnable, arg1: Internal.Executor): Internal.CompletionStage<any>;
        thenRunAsync(arg0: Internal.Runnable): Internal.CompletionStage<any>;
        thenRunAsync(arg0: Internal.Runnable): Internal.CompletableFuture<void>;
        static allOf(arg0: Internal.CompletableFuture<any>[]): Internal.CompletableFuture<void>;
        applyToEitherAsync<U_>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U_, arg2: Internal.Executor): Internal.CompletableFuture<U_>;
        applyToEitherAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any) => any, arg2: Internal.Executor): Internal.CompletionStage<any>;
        applyToEitherAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any) => any): Internal.CompletionStage<any>;
        applyToEitherAsync<U_>(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => U_): Internal.CompletableFuture<U_>;
        acceptEitherAsync(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void): Internal.CompletableFuture<void>;
        acceptEitherAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any) => void): Internal.CompletionStage<any>;
        acceptEitherAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any) => void, arg2: Internal.Executor): Internal.CompletionStage<any>;
        acceptEitherAsync(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void, arg2: Internal.Executor): Internal.CompletableFuture<void>;
        runAfterEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletableFuture<void>;
        runAfterEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<any>;
        runAfterEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletionStage<any>;
        runAfterEitherAsync(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable, arg2: Internal.Executor): Internal.CompletableFuture<void>;
        newIncompleteFuture<U_>(): Internal.CompletableFuture<U_>;
        hashCode(): number;
        acceptEither(arg0: Internal.CompletionStage<T>, arg1: (arg0: T) => void): Internal.CompletableFuture<void>;
        acceptEither(arg0: Internal.CompletionStage<any>, arg1: (arg0: any) => void): Internal.CompletionStage<any>;
        get(arg0: number, arg1: Internal.TimeUnit): T;
        get(): T;
        copy(): Internal.CompletableFuture<T>;
        runAfterEither(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletableFuture<void>;
        runAfterEither(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<any>;
        thenComposeAsync(arg0: (arg0: any) => any, arg1: Internal.Executor): Internal.CompletionStage<any>;
        thenComposeAsync<U_>(arg0: (arg0: T) => Internal.CompletionStage<U_>, arg1: Internal.Executor): Internal.CompletableFuture<U_>;
        thenComposeAsync<U_>(arg0: (arg0: T) => Internal.CompletionStage<U_>): Internal.CompletableFuture<U_>;
        thenComposeAsync(arg0: (arg0: any) => any): Internal.CompletionStage<any>;
        thenAccept(arg0: (arg0: any) => void): Internal.CompletionStage<any>;
        thenAccept(arg0: (arg0: T) => void): Internal.CompletableFuture<void>;
        isCancelled(): boolean;
        runAfterBoth(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletionStage<any>;
        runAfterBoth(arg0: Internal.CompletionStage<any>, arg1: Internal.Runnable): Internal.CompletableFuture<void>;
        static anyOf(arg0: Internal.CompletableFuture<any>[]): Internal.CompletableFuture<any>;
        completeOnTimeout(arg0: T, arg1: number, arg2: Internal.TimeUnit): Internal.CompletableFuture<T>;
        handleAsync(arg0: (arg0: any, arg1: any) => any): Internal.CompletionStage<any>;
        handleAsync<U_>(arg0: (arg0: T, arg1: Internal.Throwable) => U_): Internal.CompletableFuture<U_>;
        handleAsync(arg0: (arg0: any, arg1: any) => any, arg1: Internal.Executor): Internal.CompletionStage<any>;
        handleAsync<U_>(arg0: (arg0: T, arg1: Internal.Throwable) => U_, arg1: Internal.Executor): Internal.CompletableFuture<U_>;
        defaultExecutor(): Internal.Executor;
        static supplyAsync<U_>(arg0: () => U_, arg1: Internal.Executor): Internal.CompletableFuture<U_>;
        static supplyAsync<U_>(arg0: () => U_): Internal.CompletableFuture<U_>;
        completeExceptionally(arg0: Internal.Throwable): boolean;
        isDone(): boolean;
        whenComplete(arg0: (arg0: any, arg1: any) => void): Internal.CompletionStage<any>;
        whenComplete(arg0: (arg0: T, arg1: Internal.Throwable) => void): Internal.CompletableFuture<T>;
        thenAcceptBothAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any, arg1: any) => void): Internal.CompletionStage<any>;
        thenAcceptBothAsync<U_>(arg0: Internal.CompletionStage<U_>, arg1: (arg0: T, arg1: U_) => void): Internal.CompletableFuture<void>;
        thenAcceptBothAsync<U_>(arg0: Internal.CompletionStage<U_>, arg1: (arg0: T, arg1: U_) => void, arg2: Internal.Executor): Internal.CompletableFuture<void>;
        thenAcceptBothAsync(arg0: Internal.CompletionStage<any>, arg1: (arg0: any, arg1: any) => void, arg2: Internal.Executor): Internal.CompletionStage<any>;
        static delayedExecutor(arg0: number, arg1: Internal.TimeUnit): Internal.Executor;
        static delayedExecutor(arg0: number, arg1: Internal.TimeUnit, arg2: Internal.Executor): Internal.Executor;
        exceptionallyComposeAsync(arg0: (arg0: any) => any): Internal.CompletionStage<any>;
        exceptionallyComposeAsync(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>): Internal.CompletableFuture<T>;
        exceptionallyComposeAsync(arg0: (arg0: Internal.Throwable) => Internal.CompletionStage<T>, arg1: Internal.Executor): Internal.CompletableFuture<T>;
        exceptionallyComposeAsync(arg0: (arg0: any) => any, arg1: Internal.Executor): Internal.CompletionStage<any>;
        thenCombine(arg0: Internal.CompletionStage<any>, arg1: (arg0: any, arg1: any) => any): Internal.CompletionStage<any>;
        thenCombine<U_, V_>(arg0: Internal.CompletionStage<U_>, arg1: (arg0: T, arg1: U_) => V_): Internal.CompletableFuture<V_>;
        equals(arg0: any): boolean;
        toString(): string;
        minimalCompletionStage(): Internal.CompletionStage<T>;
        complete(arg0: T): boolean;
        static completedStage<U_>(arg0: U_): Internal.CompletionStage<U_>;
        get numberOfDependents(): number;
        get cancelled(): boolean;
        get completedExceptionally(): boolean;
        get class(): Internal.Class<any>;
        get done(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TickContainerAccess <T> extends Internal.TickAccess<T> {
    }
    class FileChannel$MapMode {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        static readonly READ_ONLY : Internal.FileChannel$MapMode;
        static readonly READ_WRITE : Internal.FileChannel$MapMode;
        static readonly PRIVATE : Internal.FileChannel$MapMode;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ScriptPackInfo {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        readonly displayName : Internal.Component;
        readonly namespace : string;
        readonly pathStart : string;
        readonly scripts : Internal.List<Internal.ScriptFileInfo>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Stream$Builder <T> extends Internal.Consumer<T> {
        add(arg0: T): (arg0: T) => void;
        build(): Internal.Stream<T>;
        andThen(arg0: (arg0: T) => void): (arg0: T) => void;
        accept(arg0: T): void;
    }
    interface Iterator <E> {
        next(): E;
        hasNext(): boolean;
        forEachRemaining(arg0: (arg0: E) => void): void;
        remove(): void;
    }
    interface MessageSupplier {
        get(): Internal.Message;
    }
    class TranslatableComponent extends Internal.BaseComponent implements Internal.ContextAwareComponent {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getString(): string;
        notify(): void;
        get string(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ParticleProvider <T> {
    }
    class AttributeModifier {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjectIterator <K> extends Internal.Iterator<K> {
        next(): K;
        hasNext(): boolean;
        skip(arg0: number): number;
        forEachRemaining(arg0: (arg0: K) => void): void;
        remove(): void;
    }
    interface TooltipComponent {
    }
    abstract class Buffer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hasArray(): boolean;
        notifyAll(): void;
        hasRemaining(): boolean;
        clear(): Internal.Buffer;
        duplicate(): Internal.Buffer;
        notify(): void;
        remaining(): number;
        capacity(): number;
        isReadOnly(): boolean;
        rewind(): Internal.Buffer;
        slice(arg0: number, arg1: number): Internal.Buffer;
        slice(): Internal.Buffer;
        array(): any;
        hashCode(): number;
        equals(arg0: any): boolean;
        limit(arg0: number): Internal.Buffer;
        limit(): number;
        reset(): Internal.Buffer;
        arrayOffset(): number;
        toString(): string;
        position(): number;
        position(arg0: number): Internal.Buffer;
        flip(): Internal.Buffer;
        isDirect(): boolean;
        mark(): Internal.Buffer;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CommandSourceStack implements Internal.SharedSuggestionProvider, Internal.IForgeCommandSourceStack {
        getAdvancement(arg0: ResourceLocation): Internal.Advancement;
        getRecipeManager(): Internal.RecipeManager;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getUnsidedLevel(): net.minecraft.world.level.Level;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getScoreboard(): Internal.Scoreboard;
        toString(): string;
        notify(): void;
        get unsidedLevel(): net.minecraft.world.level.Level;
        get recipeManager(): Internal.RecipeManager;
        get scoreboard(): Internal.Scoreboard;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class BuilderBase {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        translationKey(key: string): Internal.BuilderBase;
        getBuilderType(): string;
        hashCode(): number;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        tag(tag: ResourceLocation): Internal.BuilderBase;
        notify(): void;
        readonly id : ResourceLocation;
        defaultTags : Internal.Set<ResourceLocation>;
        get builderType(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AttachedData extends Internal.HashMap<any, any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: any): any;
        notifyAll(): void;
        computeIfAbsent(arg0: string, arg1: (arg0: string) => any): any;
        values(): Internal.Collection<any>;
        replace(arg0: string, arg1: any): any;
        replace(arg0: string, arg1: any, arg2: any): boolean;
        replaceAll(arg0: (arg0: string, arg1: any) => any): void;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: string, arg1: any): any;
        remove(arg0: any, arg1: any): boolean;
        remove(arg0: any): any;
        compute(arg0: string, arg1: (arg0: string, arg1: any) => any): any;
        hashCode(): number;
        putAll(arg0: Internal.Map<string, any>): void;
        merge(arg0: string, arg1: any, arg2: (arg0: any, arg1: any) => any): any;
        get(arg0: any): any;
        keySet(): Internal.Set<string>;
        getParent(): any;
        entrySet(): Internal.Set<Internal.Map$Entry<string, any>>;
        containsKey(arg0: any): boolean;
        forEach(arg0: (arg0: string, arg1: any) => void): void;
        isEmpty(): boolean;
        clear(): void;
        computeIfPresent(arg0: string, arg1: (arg0: string, arg1: any) => any): any;
        size(): number;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        putIfAbsent(arg0: string, arg1: any): any;
        get parent(): any;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Long2ReferenceFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.LongFunction<V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: number, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        put(arg0: number, arg1: V): V;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: V): V;
        remove(arg0: number): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): V;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class ModuleDescriptor$Exports implements Internal.Comparable<Internal.ModuleDescriptor$Exports> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        isQualified(): boolean;
        toString(): string;
        source(): string;
        compareTo(arg0: Internal.ModuleDescriptor$Exports): number;
        compareTo(arg0: any): number;
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Exports$Modifier>;
        targets(): Internal.Set<string>;
        notify(): void;
        get qualified(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Codec <A> extends Internal.Encoder<A>, Internal.Decoder<A> {
        encode<T_>(arg0: A, arg1: Internal.DynamicOps<T_>, arg2: T_): Internal.DataResult<T_>;
        flatComapMap<S_>(arg0: (arg0: A) => S_, arg1: (arg0: S_) => Internal.DataResult<A>): Internal.Codec<S_>;
        dispatch<E_>(arg0: (arg0: E_) => A, arg1: (arg0: A) => Internal.Codec<E_>): Internal.Codec<E_>;
        dispatch<E_>(arg0: string, arg1: (arg0: E_) => A, arg2: (arg0: A) => Internal.Codec<E_>): Internal.Codec<E_>;
        deprecated(arg0: number): Internal.Codec<A>;
        simple(): Internal.Decoder$Simple<A>;
        dispatchMap<E_>(arg0: string, arg1: (arg0: E_) => A, arg2: (arg0: A) => Internal.Codec<E_>): Internal.MapCodec<E_>;
        dispatchMap<E_>(arg0: (arg0: E_) => A, arg1: (arg0: A) => Internal.Codec<E_>): Internal.MapCodec<E_>;
        decode<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<Internal.Pair<A, T_>>;
        decode<T_>(arg0: Internal.Dynamic<T_>): Internal.DataResult<Internal.Pair<A, T_>>;
        comapFlatMap<S_>(arg0: (arg0: A) => Internal.DataResult<S_>, arg1: (arg0: S_) => A): Internal.Codec<S_>;
        promotePartial(arg0: (arg0: any) => void): Internal.Decoder<any>;
        promotePartial(arg0: (arg0: string) => void): Internal.Codec<A>;
        flatXmap<S_>(arg0: (arg0: A) => Internal.DataResult<S_>, arg1: (arg0: S_) => Internal.DataResult<A>): Internal.Codec<S_>;
        comap<B_>(arg0: (arg0: B_) => A): Internal.Encoder<B_>;
        fieldOf(arg0: string): Internal.MapCodec<A>;
        fieldOf(arg0: string): Internal.MapDecoder<any>;
        fieldOf(arg0: string): Internal.MapEncoder<any>;
        xmap<S_>(arg0: (arg0: A) => S_, arg1: (arg0: S_) => A): Internal.Codec<S_>;
        listOf(): Internal.Codec<Internal.List<A>>;
        map<B_>(arg0: (arg0: A) => B_): Internal.Decoder<B_>;
        encodeStart<T_>(arg0: Internal.DynamicOps<T_>, arg1: A): Internal.DataResult<T_>;
        optionalFieldOf(arg0: string, arg1: A, arg2: Internal.Lifecycle): Internal.MapCodec<A>;
        optionalFieldOf(arg0: string): Internal.MapCodec<Internal.Optional<A>>;
        optionalFieldOf(arg0: string, arg1: A): Internal.MapCodec<A>;
        optionalFieldOf(arg0: string, arg1: Internal.Lifecycle, arg2: A, arg3: Internal.Lifecycle): Internal.MapCodec<A>;
        flatComap<B_>(arg0: (arg0: B_) => Internal.DataResult<A>): Internal.Encoder<B_>;
        partialDispatch<E_>(arg0: string, arg1: (arg0: E_) => Internal.DataResult<A>, arg2: (arg0: A) => Internal.DataResult<Internal.Codec<E_>>): Internal.Codec<E_>;
        terminal(): Internal.Decoder$Terminal<A>;
        parse<T_>(arg0: Internal.Dynamic<T_>): Internal.DataResult<A>;
        parse<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<A>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.Codec<A>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.Decoder<any>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.Encoder<any>;
        orElse(arg0: A): Internal.Codec<A>;
        orElse(arg0: (arg0: string) => void, arg1: A): Internal.Codec<A>;
        orElse(arg0: (arg0: any) => any, arg1: A): Internal.Codec<A>;
        flatMap<B_>(arg0: (arg0: A) => Internal.DataResult<B_>): Internal.Decoder<B_>;
        boxed(): Internal.Decoder$Boxed<A>;
        dispatchStable<E_>(arg0: (arg0: E_) => A, arg1: (arg0: A) => Internal.Codec<E_>): Internal.Codec<E_>;
        orElseGet(arg0: (arg0: string) => void, arg1: () => A): Internal.Codec<A>;
        orElseGet(arg0: () => A): Internal.Codec<A>;
        orElseGet(arg0: (arg0: any) => any, arg1: () => A): Internal.Codec<A>;
        stable(): Internal.Codec<A>;
        mapResult(arg0: Internal.Codec$ResultFunction<A>): Internal.Codec<A>;
    }
    interface IForgeFluid {
        getAttributes(): Internal.FluidAttributes;
        getExplosionResistance(arg0: Internal.FluidState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): number;
        getTags(): Internal.Set<ResourceLocation>;
        isAABBInsideMaterial(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.AABB, arg4: net.minecraft.world.level.material.Material): boolean;
        isEntityInside(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity, arg4: number, arg5: Internal.SetTag<Internal.Fluid>, arg6: boolean): boolean;
        isAABBInsideLiquid(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.AABB): boolean;
    }
    interface IForgePackResources {
        isHidden(): boolean;
    }
    abstract class ForgeRegistryEntry <V> implements Internal.IForgeRegistryEntry<V> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<V>;
        getRegistryName(): ResourceLocation;
        toString(): string;
        setRegistryName(arg0: string, arg1: string): V;
        setRegistryName(arg0: ResourceLocation): any;
        setRegistryName(arg0: ResourceLocation): V;
        setRegistryName(arg0: string): V;
        notify(): void;
        readonly delegate : () => V;
        get registryType(): Internal.Class<V>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PlantType {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static get(arg0: string): Internal.PlantType;
        toString(): string;
        notify(): void;
        static readonly BEACH : Internal.PlantType;
        static readonly CAVE : Internal.PlantType;
        static readonly NETHER : Internal.PlantType;
        static readonly PLAINS : Internal.PlantType;
        static readonly DESERT : Internal.PlantType;
        static readonly WATER : Internal.PlantType;
        static readonly CROP : Internal.PlantType;
        get name(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BaseStream <T, S> extends Internal.AutoCloseable {
        unordered(): S;
        onClose(arg0: Internal.Runnable): S;
        iterator(): Internal.Iterator<T>;
        parallel(): S;
        spliterator(): Internal.Spliterator<T>;
        sequential(): S;
        isParallel(): boolean;
        close(): void;
    }
    class LootBuilderPool implements Internal.FunctionContainer, Internal.ConditionContainer {
        enchantWithLevels(levels: Internal.NumberProvider, treasure: boolean): Internal.FunctionContainer;
        damage(damage: Internal.NumberProvider): Internal.FunctionContainer;
        nbt(tag: Internal.CompoundTag): Internal.FunctionContainer;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        survivesExplosion(): Internal.ConditionContainer;
        notifyAll(): void;
        addEmpty(weight: number): Internal.LootTableEntry;
        addConditionalFunction(func: (arg0: Internal.ConditionalFunction) => void): Internal.FunctionContainer;
        addCondition(o: Internal.JsonObject): Internal.LootBuilderPool;
        addCondition(arg0: Internal.JsonObject): Internal.ConditionContainer;
        addTag(tag: string, expand: boolean): Internal.LootTableEntry;
        notify(): void;
        addItem(item: Internal.ItemStack): Internal.LootTableEntry;
        addItem(item: Internal.ItemStack, weight: number, count: Internal.NumberProvider): Internal.LootTableEntry;
        addItem(item: Internal.ItemStack, weight: number): Internal.LootTableEntry;
        lootTable(table: ResourceLocation, seed: number): Internal.FunctionContainer;
        setBinomialRolls(n: number, p: number): void;
        hashCode(): number;
        killedByPlayer(): Internal.ConditionContainer;
        randomChance(chance: number): Internal.ConditionContainer;
        addFunction(arg0: Internal.JsonObject): Internal.FunctionContainer;
        addFunction(o: Internal.JsonObject): Internal.LootBuilderPool;
        count(count: Internal.NumberProvider): Internal.FunctionContainer;
        lootingEnchant(count: Internal.NumberProvider, limit: number): Internal.FunctionContainer;
        setUniformRolls(min: number, max: number): void;
        toJson(): Internal.JsonObject;
        entityScores(entity: Internal.LootContext$EntityTarget, scores: Internal.Map<string, any>): Internal.ConditionContainer;
        copyName(source: Internal.CopyNameFunction$NameSource): Internal.FunctionContainer;
        addEntry(json: Internal.JsonObject): Internal.LootTableEntry;
        equals(arg0: any): boolean;
        name(name: Internal.Text, entity: Internal.LootContext$EntityTarget): Internal.FunctionContainer;
        name(name: Internal.Text): Internal.FunctionContainer;
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer;
        furnaceSmelt(): Internal.FunctionContainer;
        addLootTable(table: ResourceLocation): Internal.LootTableEntry;
        toString(): string;
        enchantRandomly(enchantments: ResourceLocation[]): Internal.FunctionContainer;
        entityProperties(entity: Internal.LootContext$EntityTarget, properties: Internal.JsonObject): Internal.ConditionContainer;
        readonly entries : Internal.JsonArray;
        readonly functions : Internal.JsonArray;
        rolls : Internal.NumberProvider;
        readonly conditions : Internal.JsonArray;
        bonusRolls : Internal.NumberProvider;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface JsonReloadListenerAccess {
        getGson(): Internal.Gson;
    }
    class BlockSnapshot {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        restore(arg0: boolean): boolean;
        restore(): boolean;
        restore(arg0: boolean, arg1: boolean): boolean;
        getBlockEntity(): Internal.BlockEntity;
        notifyAll(): void;
        restoreToLocation(arg0: Internal.LevelAccessor, arg1: BlockPos, arg2: boolean, arg3: boolean): boolean;
        getTag(): Internal.CompoundTag;
        getReplacedBlock(): Internal.BlockState;
        notify(): void;
        getCurrentBlock(): Internal.BlockState;
        getLevel(): Internal.LevelAccessor;
        getPos(): BlockPos;
        hashCode(): number;
        equals(arg0: any): boolean;
        static create(arg0: Internal.ResourceKey<net.minecraft.world.level.Level>, arg1: Internal.LevelAccessor, arg2: BlockPos): Internal.BlockSnapshot;
        static create(arg0: Internal.ResourceKey<net.minecraft.world.level.Level>, arg1: Internal.LevelAccessor, arg2: BlockPos, arg3: number): Internal.BlockSnapshot;
        toString(): string;
        getFlag(): number;
        get flag(): number;
        get currentBlock(): Internal.BlockState;
        get level(): Internal.LevelAccessor;
        get pos(): BlockPos;
        get blockEntity(): Internal.BlockEntity;
        get replacedBlock(): Internal.BlockState;
        get tag(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Enum$EnumDesc <E> extends Internal.DynamicConstantDesc<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static ofCanonical<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: string, arg2: Internal.ClassDesc, arg3: Internal.ConstantDesc[]): Internal.ConstantDesc;
        bootstrapMethod(): Internal.DirectMethodHandleDesc;
        constantName(): string;
        notifyAll(): void;
        bootstrapArgsList(): Internal.List<Internal.ConstantDesc>;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): any;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): E;
        notify(): void;
        constantType(): Internal.ClassDesc;
        hashCode(): number;
        bootstrapArgs(): Internal.ConstantDesc[];
        equals(arg0: any): boolean;
        static of<E_>(arg0: Internal.ClassDesc, arg1: string): Internal.Enum$EnumDesc<E_>;
        static of<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: Internal.ConstantDesc[]): Internal.DynamicConstantDesc<T_>;
        static of<T_>(arg0: Internal.DirectMethodHandleDesc): Internal.DynamicConstantDesc<T_>;
        static ofNamed<T_>(arg0: Internal.DirectMethodHandleDesc, arg1: string, arg2: Internal.ClassDesc, arg3: Internal.ConstantDesc[]): Internal.DynamicConstantDesc<T_>;
        toString(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class JsonObject extends Internal.JsonElement {
        getAsFloat(): number;
        getClass(): Internal.Class<any>;
        getAsByte(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAsBigDecimal(): Internal.BigDecimal;
        notifyAll(): void;
        getAsNumber(): Internal.Number;
        getAsCharacter(): string;
        getAsString(): string;
        isJsonArray(): boolean;
        notify(): void;
        getAsInt(): number;
        remove(arg0: string): Internal.JsonElement;
        isJsonPrimitive(): boolean;
        getAsLong(): number;
        isJsonObject(): boolean;
        hashCode(): number;
        get(arg0: string): Internal.JsonElement;
        has(arg0: string): boolean;
        keySet(): Internal.Set<string>;
        getAsBigInteger(): Internal.BigInteger;
        add(arg0: string, arg1: Internal.JsonElement): void;
        getAsJsonObject(arg0: string): Internal.JsonObject;
        getAsJsonObject(): Internal.JsonObject;
        getAsJsonNull(): Internal.JsonNull;
        entrySet(): Internal.Set<Internal.Map$Entry<string, Internal.JsonElement>>;
        isJsonNull(): boolean;
        getAsDouble(): number;
        addProperty(arg0: string, arg1: string): void;
        addProperty(arg0: string, arg1: boolean): void;
        addProperty(arg0: string, arg1: string): void;
        addProperty(arg0: string, arg1: Internal.Number): void;
        deepCopy(): Internal.JsonObject;
        deepCopy(): Internal.JsonElement;
        getAsJsonArray(arg0: string): Internal.JsonArray;
        getAsJsonArray(): Internal.JsonArray;
        size(): number;
        getAsBoolean(): boolean;
        getAsJsonPrimitive(arg0: string): Internal.JsonPrimitive;
        getAsJsonPrimitive(): Internal.JsonPrimitive;
        equals(arg0: any): boolean;
        toString(): string;
        getAsShort(): number;
        get asByte(): number;
        get asBigInteger(): Internal.BigInteger;
        get asJsonObject(): Internal.JsonObject;
        get asCharacter(): string;
        get jsonPrimitive(): boolean;
        get asNumber(): Internal.Number;
        get asBigDecimal(): Internal.BigDecimal;
        get jsonNull(): boolean;
        get asFloat(): number;
        get asLong(): number;
        get asInt(): number;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get asJsonNull(): Internal.JsonNull;
        get asShort(): number;
        get asDouble(): number;
        get asJsonArray(): Internal.JsonArray;
        get asString(): string;
        get jsonObject(): boolean;
        get class(): Internal.Class<any>;
        get jsonArray(): boolean;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlastFurnaceRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        energy(e: number): Internal.IERecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        time(t: number): Internal.IERecipeJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<net.minecraftforge.fluids.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LevelChunkTicks <T> implements Internal.SerializableTickContainer<T>, Internal.TickContainerAccess<T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Pattern implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        splitAsStream(arg0: Internal.CharSequence): Internal.Stream<string>;
        pattern(): string;
        flags(): number;
        asMatchPredicate(): (arg0: string) => boolean;
        matcher(arg0: Internal.CharSequence): Internal.Matcher;
        static matches(arg0: string, arg1: Internal.CharSequence): boolean;
        notify(): void;
        static quote(arg0: string): string;
        split(arg0: Internal.CharSequence, arg1: number): string[];
        split(arg0: Internal.CharSequence): string[];
        static compile(arg0: string): Internal.Pattern;
        static compile(arg0: string, arg1: number): Internal.Pattern;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        asPredicate(): (arg0: string) => boolean;
        static readonly DOTALL : 32;
        static readonly UNICODE_CASE : 64;
        static readonly LITERAL : 16;
        static readonly UNICODE_CHARACTER_CLASS : 256;
        static readonly CASE_INSENSITIVE : 2;
        static readonly CANON_EQ : 128;
        static readonly COMMENTS : 4;
        static readonly UNIX_LINES : 1;
        static readonly MULTILINE : 8;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class RuleTest {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TagEventJS$TagWrapper <T> {
        add(ids: any): Internal.TagEventJS$TagWrapper<T>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        removeAll(): Internal.TagEventJS$TagWrapper<T>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        sort(): boolean;
        notify(): void;
        setPriorityList(o: any): void;
        remove(ids: any): Internal.TagEventJS$TagWrapper<T>;
        get class(): Internal.Class<any>;
        set priorityList(o: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class SimpleChannelInboundHandler <I> extends Internal.ChannelInboundHandlerAdapter {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        channelReadComplete(arg0: Internal.ChannelHandlerContext): void;
        notifyAll(): void;
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void;
        channelActive(arg0: Internal.ChannelHandlerContext): void;
        handlerAdded(arg0: Internal.ChannelHandlerContext): void;
        isSharable(): boolean;
        notify(): void;
        handlerRemoved(arg0: Internal.ChannelHandlerContext): void;
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext): void;
        channelRead(arg0: Internal.ChannelHandlerContext, arg1: any): void;
        channelInactive(arg0: Internal.ChannelHandlerContext): void;
        channelUnregistered(arg0: Internal.ChannelHandlerContext): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        userEventTriggered(arg0: Internal.ChannelHandlerContext, arg1: any): void;
        channelRegistered(arg0: Internal.ChannelHandlerContext): void;
        acceptInboundMessage(arg0: any): boolean;
        get sharable(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DataResult$PartialResult <R> {
        flatMap<R2>(arg0: (arg0: R) => Internal.DataResult$PartialResult<R2>): Internal.DataResult$PartialResult<R2>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        message(): string;
        map<R2>(arg0: (arg0: R) => R2): Internal.DataResult$PartialResult<R2>;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DiscreteVSAccess {
        getZSize(): number;
        getYSize(): number;
        getXSize(): number;
    }
    interface CharSequence {
        isEmpty(): boolean;
        length(): number;
        toString(): string;
        subSequence(arg0: number, arg1: number): Internal.CharSequence;
        chars(): Internal.IntStream;
        charAt(arg0: number): string;
        codePoints(): Internal.IntStream;
    }
    interface IModelData {
        setData<T>(arg0: (arg0: T) => boolean, arg1: T): T;
        hasProperty(arg0: (arg0: any) => boolean): boolean;
        getData<T>(arg0: (arg0: T) => boolean): T;
    }
    interface TypeWrapperFactory <T> {
        wrap(arg0: any): T;
    }
    interface ProgressivePromise <V> extends Internal.Promise<V>, Internal.ProgressiveFuture<V> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.ProgressivePromise<V>;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Promise<V>;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.ProgressiveFuture<V>;
        getNow(): V;
        setProgress(arg0: number, arg1: number): Internal.ProgressivePromise<V>;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): Internal.ProgressivePromise<V>;
        awaitUninterruptibly(): Internal.Promise<V>;
        awaitUninterruptibly(): Internal.Future<V>;
        awaitUninterruptibly(): Internal.ProgressiveFuture<V>;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.ProgressivePromise<V>;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Promise<V>;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.ProgressiveFuture<V>;
        tryFailure(arg0: Internal.Throwable): boolean;
        isDone(): boolean;
        sync(): Internal.ProgressivePromise<V>;
        sync(): Internal.Promise<V>;
        sync(): Internal.Future<V>;
        sync(): Internal.ProgressiveFuture<V>;
        setSuccess(arg0: V): Internal.ProgressivePromise<V>;
        setSuccess(arg0: V): Internal.Promise<V>;
        setFailure(arg0: Internal.Throwable): Internal.ProgressivePromise<V>;
        setFailure(arg0: Internal.Throwable): Internal.Promise<V>;
        trySuccess(arg0: V): boolean;
        tryProgress(arg0: number, arg1: number): boolean;
        syncUninterruptibly(): Internal.ProgressivePromise<V>;
        syncUninterruptibly(): Internal.Promise<V>;
        syncUninterruptibly(): Internal.Future<V>;
        syncUninterruptibly(): Internal.ProgressiveFuture<V>;
        get(arg0: number, arg1: Internal.TimeUnit): V;
        get(): V;
        isCancellable(): boolean;
        await(): Internal.ProgressivePromise<V>;
        await(): Internal.Promise<V>;
        await(): Internal.Future<V>;
        await(): Internal.ProgressiveFuture<V>;
        await(arg0: number, arg1: Internal.TimeUnit): boolean;
        await(arg0: number): boolean;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.ProgressivePromise<V>;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Promise<V>;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.Future<V>;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<V>>[]): Internal.ProgressiveFuture<V>;
        isSuccess(): boolean;
        setUncancellable(): boolean;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.ProgressivePromise<V>;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Promise<V>;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.Future<V>;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<V>>): Internal.ProgressiveFuture<V>;
    }
    interface PropertyChangeListener extends Internal.EventListener {
        propertyChange(arg0: Internal.PropertyChangeEvent): void;
    }
    class InteractionResult extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.InteractionResult;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.InteractionResult[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.InteractionResult): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.InteractionResult>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.InteractionResult>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SUCCESS : Internal.InteractionResult;
        static readonly PASS : Internal.InteractionResult;
        static readonly CONSUME_PARTIAL : Internal.InteractionResult;
        static readonly CONSUME : Internal.InteractionResult;
        static readonly FAIL : Internal.InteractionResult;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.InteractionResult>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class RegistryAccess$RegistryHolder extends net.minecraft.core.RegistryAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClickType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ClickType;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ClickType[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ClickType): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ClickType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ClickType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly QUICK_MOVE : Internal.ClickType;
        static readonly SWAP : Internal.ClickType;
        static readonly PICKUP_ALL : Internal.ClickType;
        static readonly THROW : Internal.ClickType;
        static readonly QUICK_CRAFT : Internal.ClickType;
        static readonly PICKUP : Internal.ClickType;
        static readonly CLONE : Internal.ClickType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ClickType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class RenderLayer extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getLayer(arg0: Internal.RenderType): Internal.RenderLayer;
        static valueOf(arg0: string): Internal.RenderLayer;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.RenderLayer[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.RenderLayer): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.RenderLayer>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.RenderLayer>;
        static getPrimaryLayer(arg0: Internal.RenderType): Internal.RenderLayer;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly CUTOUT : Internal.RenderLayer;
        static readonly SOLID : Internal.RenderLayer;
        static readonly TRANSPARENT : Internal.RenderLayer;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.RenderLayer>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class StackTraceElement implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMethodName(): string;
        notifyAll(): void;
        getModuleName(): string;
        notify(): void;
        getModuleVersion(): string;
        getLineNumber(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getClassName(): string;
        getClassLoaderName(): string;
        getFileName(): string;
        isNativeMethod(): boolean;
        get fileName(): string;
        get moduleVersion(): string;
        get moduleName(): string;
        get nativeMethod(): boolean;
        get methodName(): string;
        get className(): string;
        get lineNumber(): number;
        get class(): Internal.Class<any>;
        get classLoaderName(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Object2ObjectMap$Entry <K, V> extends Internal.Map$Entry<K, V> {
        getKey(): K;
        getValue(): V;
        hashCode(): number;
        setValue(arg0: V): V;
        equals(arg0: any): boolean;
    }
    abstract class BlockEntity extends Internal.CapabilityProvider<any> implements Internal.IForgeBlockEntity, Internal.RemovableBlockEntity {
        requestModelDataUpdate(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        increaseRemoveCounter(): void;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        getTileData(): Internal.CompoundTag;
        notifyAll(): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.BlockEntity>): boolean;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        notify(): void;
        reviveCaps(): void;
        getRemovedCountLithium(): number;
        getModelData(): Internal.IModelData;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        getRenderBoundingBox(): Internal.AABB;
        hashCode(): number;
        onChunkUnloaded(): void;
        equals(arg0: any): boolean;
        onDataPacket(arg0: Internal.Connection, arg1: Internal.ClientboundBlockEntityDataPacket): void;
        onLoad(): void;
        toString(): string;
        handleUpdateTag(arg0: Internal.CompoundTag): void;
        static readonly INFINITE_EXTENT_AABB : Internal.AABB;
        get modelData(): Internal.IModelData;
        get removedCountLithium(): number;
        get renderBoundingBox(): Internal.AABB;
        get tileData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ItemSupplier {
    }
    abstract class LongSerializationPolicy extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.LongSerializationPolicy;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.LongSerializationPolicy[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.LongSerializationPolicy): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.LongSerializationPolicy>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.LongSerializationPolicy>;
        serialize(arg0: number): Internal.JsonElement;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly STRING : Internal.LongSerializationPolicy;
        static readonly DEFAULT : Internal.LongSerializationPolicy;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.LongSerializationPolicy>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FluidStack {
        getClass(): Internal.Class<any>;
        getRawFluidSupplier(): () => Internal.Fluid;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRawFluid(): Internal.Fluid;
        getName(): Internal.Component;
        notifyAll(): void;
        getOrCreateChildTag(childName: string): Internal.CompoundTag;
        notify(): void;
        static empty(): Internal.FluidStack;
        getChildTag(childName: string): Internal.CompoundTag;
        hashCode(): number;
        static create(fluid: Internal.Fluid, amount: number, tag: Internal.CompoundTag): Internal.FluidStack;
        static create(fluid: () => Internal.Fluid, amount: number, tag: Internal.CompoundTag): Internal.FluidStack;
        static create(fluid: () => Internal.Fluid, amount: number): Internal.FluidStack;
        static create(stack: Internal.FluidStack, amount: number): Internal.FluidStack;
        static create(fluid: Internal.Fluid, amount: number): Internal.FluidStack;
        setTag(tag: Internal.CompoundTag): void;
        copy(): Internal.FluidStack;
        setAmount(amount: number): void;
        write(buf: Internal.FriendlyByteBuf): void;
        write(tag: Internal.CompoundTag): Internal.CompoundTag;
        getAmount(): number;
        removeChildTag(childName: string): void;
        grow(amount: number): void;
        static read(buf: Internal.FriendlyByteBuf): Internal.FluidStack;
        static read(tag: Internal.CompoundTag): Internal.FluidStack;
        hasTag(): boolean;
        shrink(amount: number): void;
        getTranslationKey(): string;
        isEmpty(): boolean;
        getTag(): Internal.CompoundTag;
        isFluidStackEqual(other: Internal.FluidStack): boolean;
        static bucketAmount(): number;
        getOrCreateTag(): Internal.CompoundTag;
        equals(o: any): boolean;
        getFluid(): Internal.Fluid;
        toString(): string;
        get orCreateTag(): Internal.CompoundTag;
        get rawFluid(): Internal.Fluid;
        get amount(): number;
        get rawFluidSupplier(): () => Internal.Fluid;
        get translationKey(): string;
        get name(): Internal.Component;
        get fluid(): Internal.Fluid;
        get tag(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set amount(amount: number);
        set tag(tag: Internal.CompoundTag);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class EffectRenderer {
        renderInventoryEffect(arg0: Internal.MobEffectInstance, arg1: Internal.EffectRenderingInventoryScreen<any>, arg2: Internal.PoseStack, arg3: number, arg4: number, arg5: number): void;
        getClass(): Internal.Class<any>;
        shouldRenderHUD(arg0: Internal.MobEffectInstance): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        shouldRenderInvText(arg0: Internal.MobEffectInstance): boolean;
        shouldRender(arg0: Internal.MobEffectInstance): boolean;
        notify(): void;
        renderHUDEffect(arg0: Internal.MobEffectInstance, arg1: Internal.GuiComponent, arg2: Internal.PoseStack, arg3: number, arg4: number, arg5: number, arg6: number): void;
        static readonly DUMMY : Internal.EffectRenderer;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Direction extends Internal.Enum<any> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getIndex(): number;
        static valueOf(arg0: string): Internal.Direction;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Direction[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Direction): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Direction>>;
        notify(): void;
        getClockWise(): Internal.Direction;
        getDeclaringClass(): Internal.Class<Internal.Direction>;
        getYaw(): number;
        getX(): number;
        getHorizontalIndex(): number;
        getY(): number;
        getPitch(): number;
        getZ(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        getCounterClockWise(): Internal.Direction;
        getOpposite(): Internal.Direction;
        toString(): string;
        ordinal(): number;
        static readonly DOWN : Internal.Direction;
        static readonly NORTH : Internal.Direction;
        static readonly WEST : Internal.Direction;
        static readonly UP : Internal.Direction;
        static readonly SOUTH : Internal.Direction;
        static readonly EAST : Internal.Direction;
        get clockWise(): Internal.Direction;
        get horizontalIndex(): number;
        get x(): number;
        get index(): number;
        get y(): number;
        get z(): number;
        get counterClockWise(): Internal.Direction;
        get opposite(): Internal.Direction;
        get pitch(): number;
        get class(): Internal.Class<any>;
        get yaw(): number;
        get declaringClass(): Internal.Class<Internal.Direction>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class DiscreteVoxelShape implements Internal.DiscreteVSAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getZSize(): number;
        toString(): string;
        getYSize(): number;
        getXSize(): number;
        notify(): void;
        get zSize(): number;
        get ySize(): number;
        get xSize(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Widget {
    }
    class JsonWriter implements Internal.Closeable, Internal.Flushable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setSerializeNulls(arg0: boolean): void;
        setHtmlSafe(arg0: boolean): void;
        jsonValue(arg0: string): Internal.JsonWriter;
        isLenient(): boolean;
        notifyAll(): void;
        endArray(): Internal.JsonWriter;
        nullValue(): Internal.JsonWriter;
        setLenient(arg0: boolean): void;
        notify(): void;
        endObject(): Internal.JsonWriter;
        beginArray(): Internal.JsonWriter;
        flush(): void;
        beginObject(): Internal.JsonWriter;
        hashCode(): number;
        equals(arg0: any): boolean;
        getSerializeNulls(): boolean;
        setIndent(arg0: string): void;
        name(arg0: string): Internal.JsonWriter;
        toString(): string;
        isHtmlSafe(): boolean;
        close(): void;
        value(arg0: boolean): Internal.JsonWriter;
        value(arg0: number): Internal.JsonWriter;
        value(arg0: number): Internal.JsonWriter;
        value(arg0: boolean): Internal.JsonWriter;
        value(arg0: string): Internal.JsonWriter;
        value(arg0: Internal.Number): Internal.JsonWriter;
        get serializeNulls(): boolean;
        get class(): Internal.Class<any>;
        get lenient(): boolean;
        get htmlSafe(): boolean;
        set serializeNulls(arg0: boolean);
        set indent(arg0: string);
        set lenient(arg0: boolean);
        set htmlSafe(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IntFunction <R> {
        apply(arg0: number): R;
    }
    interface ClassGroupFilterableList <T> {
        getAllOfGroupType(arg0: Internal.EntityClassGroup): Internal.Collection<T>;
    }
    class Proxy {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        address(): Internal.SocketAddress;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        type(): Internal.Proxy$Type;
        notify(): void;
        static readonly NO_PROXY : Internal.Proxy;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class SocketAddress implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Function4 <T1, T2, T3, T4, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4): R;
        curry3(): Internal.Function3<T1, T2, T3, (arg0: T4) => R>;
        curry2(): (arg0: T1, arg1: T2) => (arg0: T3, arg1: T4) => R;
        curry(): (arg0: T1) => Internal.Function3<T2, T3, T4, R>;
    }
    class BlockBehaviour$Properties {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        lootFrom(arg0: () => Internal.Block): Internal.BlockBehaviour$Properties;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjectIterable <K> extends Internal.Iterable<K> {
        iterator(): Internal.Iterator<any>;
        iterator(): Internal.ObjectIterator<K>;
        spliterator(): Internal.ObjectSpliterator<K>;
        spliterator(): Internal.Spliterator<any>;
        forEach(arg0: (arg0: K) => void): void;
    }
    class DirectVertexConsumer implements Internal.VertexConsumer {
        getClass(): Internal.Class<any>;
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        memSetZero(): void;
        notifyAll(): void;
        notify(): void;
        hasOverlay(): boolean;
        createSink(factory: Internal.VertexType<any>): Internal.VertexSink;
        split(arg0: number): Internal.DirectVertexConsumer;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        applyBakedNormals(arg0: Internal.Vector3f, arg1: Internal.ByteBuffer, arg2: Internal.Matrix3f): void;
        readonly format : Internal.VertexFormat;
        readonly startPos : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ItemColor {
    }
    interface ChangeListener <T> {
        onChanged(arg0: T): void;
    }
    interface FastMapStateHolder <S> {
        getNeighborTable(): Internal.Table<Internal.Property<any>, Internal.Comparable<any>, S>;
        getStateIndex(): number;
        setNeighborTable(arg0: Internal.Table<Internal.Property<any>, Internal.Comparable<any>, S>): void;
        setStateIndex(arg0: number): void;
        setStateMap(arg0: Internal.FastMap<S>): void;
        getStateMap(): Internal.FastMap<S>;
        getVanillaPropertyMap(): Internal.ImmutableMap<Internal.Property<any>, Internal.Comparable<any>>;
        replacePropertyMap(arg0: Internal.ImmutableMap<Internal.Property<any>, Internal.Comparable<any>>): void;
    }
    class EntityDataAccessor <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModuleDescriptor$Opens implements Internal.Comparable<Internal.ModuleDescriptor$Opens> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        isQualified(): boolean;
        toString(): string;
        source(): string;
        compareTo(arg0: Internal.ModuleDescriptor$Opens): number;
        compareTo(arg0: any): number;
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Opens$Modifier>;
        targets(): Internal.Set<string>;
        notify(): void;
        get qualified(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Table <R, C, V> {
        cellSet(): Internal.Set<Internal.Table$Cell<R, C, V>>;
        values(): Internal.Collection<V>;
        column(arg0: C): Internal.Map<R, V>;
        isEmpty(): boolean;
        clear(): void;
        containsValue(arg0: any): boolean;
        put(arg0: R, arg1: C, arg2: V): V;
        remove(arg0: any, arg1: any): V;
        columnMap(): Internal.Map<C, Internal.Map<R, V>>;
        contains(arg0: any, arg1: any): boolean;
        containsColumn(arg0: any): boolean;
        size(): number;
        columnKeySet(): Internal.Set<C>;
        hashCode(): number;
        putAll(arg0: Internal.Table<R, C, V>): void;
        equals(arg0: any): boolean;
        get(arg0: any, arg1: any): V;
        rowKeySet(): Internal.Set<R>;
        rowMap(): Internal.Map<R, Internal.Map<C, V>>;
        row(arg0: R): Internal.Map<C, V>;
        containsRow(arg0: any): boolean;
    }
    abstract class UserPrincipalLookupService {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        lookupPrincipalByGroupName(arg0: string): Internal.GroupPrincipal;
        lookupPrincipalByName(arg0: string): Internal.UserPrincipal;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Endimation$PartKeyframes {
        getPosFrames(): any[];
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOffsetFrames(): any[];
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRotationFrames(): any[];
        getScaleFrames(): any[];
        toString(): string;
        notify(): void;
        static readonly CODEC : Internal.Codec<Internal.Endimation$PartKeyframes>;
        get scaleFrames(): any[];
        get posFrames(): any[];
        get class(): Internal.Class<any>;
        get offsetFrames(): any[];
        get rotationFrames(): any[];
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Iterable <T> {
        iterator(): Internal.Iterator<T>;
        spliterator(): Internal.Spliterator<T>;
        forEach(arg0: (arg0: T) => void): void;
    }
    interface Long2ShortFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.LongToIntFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface SharedSuggestionProvider {
    }
    interface Double2ObjectFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: number, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        put(arg0: number, arg1: V): V;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: V): V;
        remove(arg0: number): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): V;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    abstract class FileLock implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        release(): void;
        notifyAll(): void;
        isValid(): boolean;
        channel(): Internal.FileChannel;
        notify(): void;
        acquiredBy(): Internal.Channel;
        size(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        overlaps(arg0: number, arg1: number): boolean;
        toString(): string;
        position(): number;
        close(): void;
        isShared(): boolean;
        get valid(): boolean;
        get shared(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TypeAdapterFactory {
        create<T>(arg0: Internal.Gson, arg1: Internal.TypeToken<T>): Internal.TypeAdapter<T>;
    }
    class VarHandle$AccessMode extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.VarHandle$AccessMode;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.VarHandle$AccessMode[];
        methodName(): string;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.VarHandle$AccessMode): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.VarHandle$AccessMode>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.VarHandle$AccessMode>;
        hashCode(): number;
        equals(arg0: any): boolean;
        static valueFromMethodName(arg0: string): Internal.VarHandle$AccessMode;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly WEAK_COMPARE_AND_SET : Internal.VarHandle$AccessMode;
        static readonly GET_VOLATILE : Internal.VarHandle$AccessMode;
        static readonly SET : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_OR_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_ADD : Internal.VarHandle$AccessMode;
        static readonly GET_AND_SET : Internal.VarHandle$AccessMode;
        static readonly GET_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_ADD_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_AND_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_XOR_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_ADD_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_OR_RELEASE : Internal.VarHandle$AccessMode;
        static readonly SET_OPAQUE : Internal.VarHandle$AccessMode;
        static readonly WEAK_COMPARE_AND_SET_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_SET : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_EXCHANGE_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_AND : Internal.VarHandle$AccessMode;
        static readonly SET_VOLATILE : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_EXCHANGE_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_XOR : Internal.VarHandle$AccessMode;
        static readonly WEAK_COMPARE_AND_SET_PLAIN : Internal.VarHandle$AccessMode;
        static readonly SET_RELEASE : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_EXCHANGE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_OR : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_AND_RELEASE : Internal.VarHandle$AccessMode;
        static readonly WEAK_COMPARE_AND_SET_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_SET_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET : Internal.VarHandle$AccessMode;
        static readonly GET_AND_SET_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_XOR_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_OPAQUE : Internal.VarHandle$AccessMode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.VarHandle$AccessMode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ParticleEngineAccessor {
        create$getProviders(): Internal.Map<ResourceLocation, Internal.ParticleProvider<any>>;
    }
    interface CustomProperty {
        get(): any;
    }
    interface BlockEntityPredicateDataCheck {
        checkData(arg0: Internal.CompoundTag): boolean;
    }
    class LogicalSide extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isServer(): boolean;
        static valueOf(arg0: string): Internal.LogicalSide;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.LogicalSide[];
        isClient(): boolean;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.LogicalSide): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.LogicalSide>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.LogicalSide>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SERVER : Internal.LogicalSide;
        static readonly CLIENT : Internal.LogicalSide;
        get server(): boolean;
        get client(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.LogicalSide>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Frustum implements Internal.FrustumAdapter {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$bjc000$init(modelViewMatrix: Internal.Matrix4f, projectionMatrix: Internal.Matrix4f, ci: Internal.CallbackInfo): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        sodium$createFrustum(): me.jellysquid.mods.sodium.client.util.frustum.Frustum;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface WatchEvent$Kind <T> {
        name(): string;
        type(): Internal.Class<T>;
    }
    class EntityPredicate {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface StringBuilderAppendable {
        appendString(arg0: Internal.StringBuilder): void;
    }
    class ChannelInboundHandlerAdapter extends Internal.ChannelHandlerAdapter implements Internal.ChannelInboundHandler {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        channelReadComplete(arg0: Internal.ChannelHandlerContext): void;
        notifyAll(): void;
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void;
        channelActive(arg0: Internal.ChannelHandlerContext): void;
        handlerAdded(arg0: Internal.ChannelHandlerContext): void;
        isSharable(): boolean;
        notify(): void;
        handlerRemoved(arg0: Internal.ChannelHandlerContext): void;
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext): void;
        channelRead(arg0: Internal.ChannelHandlerContext, arg1: any): void;
        channelInactive(arg0: Internal.ChannelHandlerContext): void;
        channelUnregistered(arg0: Internal.ChannelHandlerContext): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        userEventTriggered(arg0: Internal.ChannelHandlerContext, arg1: any): void;
        channelRegistered(arg0: Internal.ChannelHandlerContext): void;
        get sharable(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class SpawnPlacements$Type extends Internal.Enum<any> implements Internal.IExtensibleEnum {
        init(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.SpawnPlacements$Type;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.SpawnPlacements$Type[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.SpawnPlacements$Type): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.SpawnPlacements$Type>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.SpawnPlacements$Type>;
        hashCode(): number;
        canSpawnAt(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.EntityType<any>): boolean;
        equals(arg0: any): boolean;
        name(): string;
        static create(arg0: string, arg1: Internal.TriPredicate<Internal.LevelReader, BlockPos, Internal.EntityType<Internal.Mob>>): Internal.SpawnPlacements$Type;
        toString(): string;
        ordinal(): number;
        static readonly IN_LAVA : Internal.SpawnPlacements$Type;
        static readonly IN_WATER : Internal.SpawnPlacements$Type;
        static readonly ON_GROUND : Internal.SpawnPlacements$Type;
        static readonly NO_RESTRICTIONS : Internal.SpawnPlacements$Type;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.SpawnPlacements$Type>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AbstractContainerMenuAccessor {
        getMenuType(): Internal.MenuType<any>;
    }
    class ImmutableSetMultimap$Builder <K, V> extends Internal.ImmutableMultimap$Builder<any, any> {
        orderKeysBy(arg0: Internal.Comparator<K>): Internal.ImmutableSetMultimap$Builder<K, V>;
        orderKeysBy(arg0: Internal.Comparator<any>): Internal.ImmutableMultimap$Builder<any, any>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.ImmutableMultimap<any, any>;
        build(): Internal.ImmutableSetMultimap<K, V>;
        hashCode(): number;
        orderValuesBy(arg0: Internal.Comparator<any>): Internal.ImmutableMultimap$Builder<any, any>;
        orderValuesBy(arg0: Internal.Comparator<V>): Internal.ImmutableSetMultimap$Builder<K, V>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        putAll(arg0: Internal.Iterable<any>): Internal.ImmutableMultimap$Builder<any, any>;
        putAll(arg0: Internal.Iterable<Internal.Map$Entry<K, V>>): Internal.ImmutableSetMultimap$Builder<K, V>;
        putAll(arg0: any, arg1: Internal.Iterable<any>): Internal.ImmutableMultimap$Builder<any, any>;
        putAll(arg0: K, arg1: Internal.Iterable<V>): Internal.ImmutableSetMultimap$Builder<K, V>;
        putAll(arg0: any, arg1: any[]): Internal.ImmutableMultimap$Builder<any, any>;
        putAll(arg0: K, arg1: V[]): Internal.ImmutableSetMultimap$Builder<K, V>;
        putAll(arg0: Internal.Multimap<any, any>): Internal.ImmutableMultimap$Builder<any, any>;
        putAll(arg0: Internal.Multimap<K, V>): Internal.ImmutableSetMultimap$Builder<K, V>;
        toString(): string;
        notify(): void;
        put(arg0: Internal.Map$Entry<K, V>): Internal.ImmutableSetMultimap$Builder<K, V>;
        put(arg0: Internal.Map$Entry<any, any>): Internal.ImmutableMultimap$Builder<any, any>;
        put(arg0: any, arg1: any): Internal.ImmutableMultimap$Builder<any, any>;
        put(arg0: K, arg1: V): Internal.ImmutableSetMultimap$Builder<K, V>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Instancer <D> {
        notifyRemoval(): void;
        createInstance(): D;
        createInstances(arg0: D[]): void;
        notifyDirty(): void;
        stealInstance(arg0: D): void;
    }
    abstract class AbstractObject2ObjectFunction <K, V> implements Internal.Object2ObjectFunction<K, V>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: V): V;
        notifyAll(): void;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: K) => V_;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        notify(): void;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        hashCode(): number;
        get(arg0: any): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: K): V;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        toString(): string;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ContextFactory {
        enterContext(cx: Internal.Context): Internal.Context;
        enterContext(): Internal.Context;
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        seal(): void;
        getApplicationClassLoader(): Internal.ClassLoader;
        removeListener(listener: Internal.ContextFactory$Listener): void;
        notify(): void;
        call<T>(action: Internal.ContextAction<T>): T;
        hashCode(): number;
        equals(arg0: any): boolean;
        static getGlobal(): Internal.ContextFactory;
        toString(): string;
        addListener(listener: Internal.ContextFactory$Listener): void;
        get sealed(): boolean;
        get applicationClassLoader(): Internal.ClassLoader;
        get global(): Internal.ContextFactory;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class RhinoException extends Internal.RuntimeException {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLocalizedMessage(): string;
        getScriptStack(limit: number, hideFunction: string): any[];
        getScriptStack(): any[];
        notifyAll(): void;
        initColumnNumber(columnNumber: number): void;
        getCause(): Internal.Throwable;
        notify(): void;
        getScriptStackTrace(): string;
        getScriptStackTrace(limit: number, functionName: string): string;
        addSuppressed(arg0: Internal.Throwable): void;
        getStackTrace(): Internal.StackTraceElement[];
        columnNumber(): number;
        hashCode(): number;
        getSuppressed(): Internal.Throwable[];
        details(): string;
        printStackTrace(s: Internal.PrintWriter): void;
        printStackTrace(s: Internal.PrintStream): void;
        printStackTrace(): void;
        initSourceName(sourceName: string): void;
        initCause(arg0: Internal.Throwable): Internal.Throwable;
        getMessage(): string;
        initLineSource(lineSource: string): void;
        setStackTrace(arg0: Internal.StackTraceElement[]): void;
        lineSource(): string;
        equals(arg0: any): boolean;
        initLineNumber(lineNumber: number): void;
        toString(): string;
        sourceName(): string;
        lineNumber(): number;
        fillInStackTrace(): Internal.Throwable;
        get localizedMessage(): string;
        get scriptStack(): any[];
        get cause(): Internal.Throwable;
        get scriptStackTrace(): string;
        get stackTrace(): Internal.StackTraceElement[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        set stackTrace(arg0: Internal.StackTraceElement[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class StringBuilder extends Internal.AbstractStringBuilder implements Internal.Serializable, Internal.Comparable<Internal.StringBuilder>, Internal.CharSequence {
        deleteCharAt(arg0: number): Internal.AbstractStringBuilder;
        deleteCharAt(arg0: number): Internal.StringBuilder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        codePointAt(arg0: number): number;
        notifyAll(): void;
        setCharAt(arg0: number, arg1: string): void;
        replace(arg0: number, arg1: number, arg2: string): Internal.AbstractStringBuilder;
        replace(arg0: number, arg1: number, arg2: string): Internal.StringBuilder;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: number): Internal.StringBuilder;
        insert(arg0: number, arg1: number): Internal.StringBuilder;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: number): Internal.StringBuilder;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string): Internal.StringBuilder;
        insert(arg0: number, arg1: any): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: any): Internal.StringBuilder;
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.StringBuilder;
        insert(arg0: number, arg1: Internal.CharSequence, arg2: number, arg3: number): Internal.StringBuilder;
        insert(arg0: number, arg1: Internal.CharSequence, arg2: number, arg3: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: Internal.CharSequence): Internal.StringBuilder;
        insert(arg0: number, arg1: Internal.CharSequence): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string[]): Internal.StringBuilder;
        insert(arg0: number, arg1: string[]): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: boolean): Internal.StringBuilder;
        insert(arg0: number, arg1: boolean): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string): Internal.StringBuilder;
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: number): Internal.StringBuilder;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.StringBuilder): number;
        delete(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        delete(arg0: number, arg1: number): Internal.StringBuilder;
        notify(): void;
        substring(arg0: number, arg1: number): string;
        substring(arg0: number): string;
        capacity(): number;
        appendCodePoint(arg0: number): Internal.StringBuilder;
        appendCodePoint(arg0: number): Internal.AbstractStringBuilder;
        hashCode(): number;
        codePointBefore(arg0: number): number;
        indexOf(arg0: string): number;
        indexOf(arg0: string, arg1: number): number;
        codePointCount(arg0: number, arg1: number): number;
        codePoints(): Internal.IntStream;
        trimToSize(): void;
        getChars(arg0: number, arg1: number, arg2: string[], arg3: number): void;
        isEmpty(): boolean;
        length(): number;
        subSequence(arg0: number, arg1: number): Internal.CharSequence;
        reverse(): Internal.StringBuilder;
        reverse(): Internal.AbstractStringBuilder;
        lastIndexOf(arg0: string, arg1: number): number;
        lastIndexOf(arg0: string): number;
        setLength(arg0: number): void;
        equals(arg0: any): boolean;
        toString(): string;
        ensureCapacity(arg0: number): void;
        chars(): Internal.IntStream;
        offsetByCodePoints(arg0: number, arg1: number): number;
        charAt(arg0: number): string;
        append(arg0: Internal.StringBuffer): Internal.AbstractStringBuilder;
        append(arg0: Internal.StringBuffer): Internal.StringBuilder;
        append(arg0: Internal.CharSequence): Internal.AbstractStringBuilder;
        append(arg0: Internal.CharSequence): Internal.Appendable;
        append(arg0: Internal.CharSequence): Internal.StringBuilder;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.AbstractStringBuilder;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.StringBuilder;
        append(arg0: string[]): Internal.AbstractStringBuilder;
        append(arg0: string[]): Internal.StringBuilder;
        append(arg0: any): Internal.AbstractStringBuilder;
        append(arg0: any): Internal.StringBuilder;
        append(arg0: string): Internal.AbstractStringBuilder;
        append(arg0: string): Internal.StringBuilder;
        append(arg0: number): Internal.AbstractStringBuilder;
        append(arg0: number): Internal.StringBuilder;
        append(arg0: number): Internal.AbstractStringBuilder;
        append(arg0: number): Internal.StringBuilder;
        append(arg0: number): Internal.AbstractStringBuilder;
        append(arg0: number): Internal.StringBuilder;
        append(arg0: number): Internal.AbstractStringBuilder;
        append(arg0: number): Internal.StringBuilder;
        append(arg0: string): Internal.AbstractStringBuilder;
        append(arg0: string): Internal.Appendable;
        append(arg0: string): Internal.StringBuilder;
        append(arg0: boolean): Internal.AbstractStringBuilder;
        append(arg0: boolean): Internal.StringBuilder;
        append(arg0: string[], arg1: number, arg2: number): Internal.AbstractStringBuilder;
        append(arg0: string[], arg1: number, arg2: number): Internal.StringBuilder;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Scriptable extends Internal.IdEnumerationIterator {
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        hasInstance(arg0: Internal.Scriptable): boolean;
        setParentScope(arg0: Internal.Scriptable): void;
        getIds(): any[];
        getAllIds(): any[];
        delete(arg0: string): void;
        delete(arg0: number): void;
        put(arg0: number, arg1: Internal.Scriptable, arg2: any): void;
        put(arg0: string, arg1: Internal.Scriptable, arg2: any): void;
        getDefaultValue(arg0: Internal.Class<any>): any;
        setPrototype(arg0: Internal.Scriptable): void;
        getPrototype(): Internal.Scriptable;
        get(arg0: number, arg1: Internal.Scriptable): any;
        get(arg0: string, arg1: Internal.Scriptable): any;
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        has(arg0: number, arg1: Internal.Scriptable): boolean;
        has(arg0: string, arg1: Internal.Scriptable): boolean;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
    }
    interface ChannelInboundInvoker {
        fireChannelRead(arg0: any): Internal.ChannelInboundInvoker;
        fireChannelInactive(): Internal.ChannelInboundInvoker;
        fireChannelReadComplete(): Internal.ChannelInboundInvoker;
        fireChannelWritabilityChanged(): Internal.ChannelInboundInvoker;
        fireExceptionCaught(arg0: Internal.Throwable): Internal.ChannelInboundInvoker;
        fireUserEventTriggered(arg0: any): Internal.ChannelInboundInvoker;
        fireChannelActive(): Internal.ChannelInboundInvoker;
        fireChannelRegistered(): Internal.ChannelInboundInvoker;
        fireChannelUnregistered(): Internal.ChannelInboundInvoker;
    }
    interface K1 {
    }
    class CompositeByteBuf extends Internal.AbstractReferenceCountedByteBuf implements Internal.Iterable<Internal.ByteBuf> {
        asReadOnly(): Internal.ByteBuf;
        markReaderIndex(): Internal.ByteBuf;
        markReaderIndex(): Internal.CompositeByteBuf;
        getByte(arg0: number): number;
        release(): boolean;
        release(arg0: number): boolean;
        readDoubleLE(): number;
        writeZero(arg0: number): Internal.CompositeByteBuf;
        writeZero(arg0: number): Internal.ByteBuf;
        addComponent(arg0: Internal.ByteBuf): Internal.CompositeByteBuf;
        addComponent(arg0: boolean, arg1: number, arg2: Internal.ByteBuf): Internal.CompositeByteBuf;
        addComponent(arg0: number, arg1: Internal.ByteBuf): Internal.CompositeByteBuf;
        addComponent(arg0: boolean, arg1: Internal.ByteBuf): Internal.CompositeByteBuf;
        resetReaderIndex(): Internal.ByteBuf;
        resetReaderIndex(): Internal.CompositeByteBuf;
        writeFloat(arg0: number): Internal.CompositeByteBuf;
        writeFloat(arg0: number): Internal.ByteBuf;
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf;
        addComponents(arg0: number, arg1: Internal.Iterable<Internal.ByteBuf>): Internal.CompositeByteBuf;
        addComponents(arg0: boolean, arg1: Internal.Iterable<Internal.ByteBuf>): Internal.CompositeByteBuf;
        addComponents(arg0: Internal.ByteBuf[]): Internal.CompositeByteBuf;
        addComponents(arg0: Internal.Iterable<Internal.ByteBuf>): Internal.CompositeByteBuf;
        addComponents(arg0: number, arg1: Internal.ByteBuf[]): Internal.CompositeByteBuf;
        addComponents(arg0: boolean, arg1: Internal.ByteBuf[]): Internal.CompositeByteBuf;
        iterator(): Internal.Iterator<Internal.ByteBuf>;
        readRetainedSlice(arg0: number): Internal.ByteBuf;
        slice(): Internal.ByteBuf;
        slice(arg0: number, arg1: number): Internal.ByteBuf;
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf;
        getMediumLE(arg0: number): number;
        readUnsignedIntLE(): number;
        writeFloatLE(arg0: number): Internal.ByteBuf;
        readInt(): number;
        toByteIndex(arg0: number): number;
        order(): Internal.ByteOrder;
        order(arg0: Internal.ByteOrder): Internal.ByteBuf;
        writeMedium(arg0: number): Internal.ByteBuf;
        writeMedium(arg0: number): Internal.CompositeByteBuf;
        resetWriterIndex(): Internal.CompositeByteBuf;
        resetWriterIndex(): Internal.ByteBuf;
        spliterator(): Internal.Spliterator<Internal.ByteBuf>;
        writableBytes(): number;
        maxCapacity(): number;
        getUnsignedShort(arg0: number): number;
        internalComponentAtOffset(arg0: number): Internal.ByteBuf;
        bytesBefore(arg0: number): number;
        bytesBefore(arg0: number, arg1: number): number;
        bytesBefore(arg0: number, arg1: number, arg2: number): number;
        nioBufferCount(): number;
        discardReadComponents(): Internal.CompositeByteBuf;
        setInt(arg0: number, arg1: number): Internal.ByteBuf;
        setInt(arg0: number, arg1: number): Internal.CompositeByteBuf;
        getInt(arg0: number): number;
        markWriterIndex(): Internal.ByteBuf;
        markWriterIndex(): Internal.CompositeByteBuf;
        isReadable(arg0: number): boolean;
        isReadable(): boolean;
        writeBoolean(arg0: boolean): Internal.ByteBuf;
        writeBoolean(arg0: boolean): Internal.CompositeByteBuf;
        numComponents(): number;
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        writeLongLE(arg0: number): Internal.ByteBuf;
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf;
        retain(arg0: number): Internal.ReferenceCounted;
        retain(arg0: number): Internal.CompositeByteBuf;
        retain(arg0: number): Internal.ByteBuf;
        retain(): Internal.CompositeByteBuf;
        retain(): Internal.ByteBuf;
        retain(): Internal.ReferenceCounted;
        isWritable(arg0: number): boolean;
        isWritable(): boolean;
        notify(): void;
        readChar(): string;
        hasMemoryAddress(): boolean;
        capacity(arg0: number): Internal.CompositeByteBuf;
        capacity(arg0: number): Internal.ByteBuf;
        capacity(): number;
        readCharSequence(arg0: number, arg1: Internal.Charset): Internal.CharSequence;
        isReadOnly(): boolean;
        readUnsignedShortLE(): number;
        readDouble(): number;
        readFloat(): number;
        internalComponent(arg0: number): Internal.ByteBuf;
        getLongLE(arg0: number): number;
        getBoolean(arg0: number): boolean;
        copy(arg0: number, arg1: number): Internal.ByteBuf;
        copy(): Internal.ByteBuf;
        readShortLE(): number;
        readUnsignedMedium(): number;
        ensureWritable(arg0: number): Internal.CompositeByteBuf;
        ensureWritable(arg0: number): Internal.ByteBuf;
        ensureWritable(arg0: number, arg1: boolean): number;
        writeInt(arg0: number): Internal.ByteBuf;
        writeInt(arg0: number): Internal.CompositeByteBuf;
        readFloatLE(): number;
        getDoubleLE(arg0: number): number;
        hasArray(): boolean;
        memoryAddress(): number;
        maxFastWritableBytes(): number;
        consolidate(): Internal.CompositeByteBuf;
        consolidate(arg0: number, arg1: number): Internal.CompositeByteBuf;
        readableBytes(): number;
        readSlice(arg0: number): Internal.ByteBuf;
        getIntLE(arg0: number): number;
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number;
        forEachByteDesc(arg0: Internal.ByteProcessor): number;
        nioBuffers(): Internal.ByteBuffer[];
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        skipBytes(arg0: number): Internal.CompositeByteBuf;
        skipBytes(arg0: number): Internal.ByteBuf;
        getLong(arg0: number): number;
        component(arg0: number): Internal.ByteBuf;
        readLong(): number;
        readShort(): number;
        equals(arg0: any): boolean;
        getUnsignedMedium(arg0: number): number;
        setZero(arg0: number, arg1: number): Internal.ByteBuf;
        setZero(arg0: number, arg1: number): Internal.CompositeByteBuf;
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf, arg1: number): Internal.CompositeByteBuf;
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.CompositeByteBuf;
        readBytes(arg0: Internal.OutputStream, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.CompositeByteBuf;
        readBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuffer): Internal.CompositeByteBuf;
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.CompositeByteBuf;
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: number[]): Internal.CompositeByteBuf;
        readBytes(arg0: number[]): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf): Internal.CompositeByteBuf;
        readBytes(arg0: Internal.ByteBuf): Internal.ByteBuf;
        readBytes(arg0: number): Internal.ByteBuf;
        readBytes(arg0: Internal.GatheringByteChannel, arg1: number): number;
        readBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number;
        readBoolean(): boolean;
        toString(): string;
        toString(arg0: Internal.Charset): string;
        toString(arg0: number, arg1: number, arg2: Internal.Charset): string;
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf;
        retainedSlice(): Internal.ByteBuf;
        readMediumLE(): number;
        setMedium(arg0: number, arg1: number): Internal.CompositeByteBuf;
        setMedium(arg0: number, arg1: number): Internal.ByteBuf;
        isDirect(): boolean;
        setBoolean(arg0: number, arg1: boolean): Internal.CompositeByteBuf;
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf;
        getClass(): Internal.Class<any>;
        getFloatLE(arg0: number): number;
        readerIndex(arg0: number): Internal.ByteBuf;
        readerIndex(arg0: number): Internal.CompositeByteBuf;
        readerIndex(): number;
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset): Internal.CharSequence;
        compareTo(arg0: Internal.ByteBuf): number;
        compareTo(arg0: any): number;
        setShort(arg0: number, arg1: number): Internal.ByteBuf;
        setShort(arg0: number, arg1: number): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: Internal.OutputStream, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: number[]): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf;
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel, arg2: number): number;
        getBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number;
        unwrap(): Internal.ByteBuf;
        setDouble(arg0: number, arg1: number): Internal.CompositeByteBuf;
        setDouble(arg0: number, arg1: number): Internal.ByteBuf;
        setChar(arg0: number, arg1: number): Internal.CompositeByteBuf;
        setChar(arg0: number, arg1: number): Internal.ByteBuf;
        refCnt(): number;
        getUnsignedIntLE(arg0: number): number;
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf;
        getUnsignedInt(arg0: number): number;
        indexOf(arg0: number, arg1: number, arg2: number): number;
        writeByte(arg0: number): Internal.CompositeByteBuf;
        writeByte(arg0: number): Internal.ByteBuf;
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        nioBuffer(): Internal.ByteBuffer;
        discardSomeReadBytes(): Internal.ByteBuf;
        discardSomeReadBytes(): Internal.CompositeByteBuf;
        touch(arg0: any): Internal.ByteBuf;
        touch(arg0: any): Internal.ReferenceCounted;
        touch(arg0: any): Internal.CompositeByteBuf;
        touch(): Internal.ReferenceCounted;
        touch(): Internal.ByteBuf;
        touch(): Internal.CompositeByteBuf;
        duplicate(): Internal.ByteBuf;
        writerIndex(arg0: number): Internal.CompositeByteBuf;
        writerIndex(arg0: number): Internal.ByteBuf;
        writerIndex(): number;
        getUnsignedShortLE(arg0: number): number;
        writeCharSequence(arg0: Internal.CharSequence, arg1: Internal.Charset): number;
        readUnsignedInt(): number;
        retainedDuplicate(): Internal.ByteBuf;
        getChar(arg0: number): string;
        removeComponent(arg0: number): Internal.CompositeByteBuf;
        setLong(arg0: number, arg1: number): Internal.ByteBuf;
        setLong(arg0: number, arg1: number): Internal.CompositeByteBuf;
        readMedium(): number;
        componentAtOffset(arg0: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuffer): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuffer): Internal.CompositeByteBuf;
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf, arg1: number): Internal.CompositeByteBuf;
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf, arg1: number, arg2: number): Internal.CompositeByteBuf;
        writeBytes(arg0: Internal.ByteBuf): Internal.CompositeByteBuf;
        writeBytes(arg0: Internal.ByteBuf): Internal.ByteBuf;
        writeBytes(arg0: number[]): Internal.CompositeByteBuf;
        writeBytes(arg0: number[]): Internal.ByteBuf;
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.CompositeByteBuf;
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.ScatteringByteChannel, arg1: number): number;
        writeBytes(arg0: Internal.InputStream, arg1: number): number;
        writeBytes(arg0: Internal.FileChannel, arg1: number, arg2: number): number;
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor): number;
        forEachByte(arg0: Internal.ByteProcessor): number;
        setIndex(arg0: number, arg1: number): Internal.CompositeByteBuf;
        setIndex(arg0: number, arg1: number): Internal.ByteBuf;
        writeShort(arg0: number): Internal.CompositeByteBuf;
        writeShort(arg0: number): Internal.ByteBuf;
        getShortLE(arg0: number): number;
        alloc(): Internal.ByteBufAllocator;
        removeComponents(arg0: number, arg1: number): Internal.CompositeByteBuf;
        getMedium(arg0: number): number;
        readUnsignedShort(): number;
        addFlattenedComponents(arg0: boolean, arg1: Internal.ByteBuf): Internal.CompositeByteBuf;
        setByte(arg0: number, arg1: number): Internal.CompositeByteBuf;
        setByte(arg0: number, arg1: number): Internal.ByteBuf;
        maxWritableBytes(): number;
        writeShortLE(arg0: number): Internal.ByteBuf;
        notifyAll(): void;
        toComponentIndex(arg0: number): number;
        decompose(arg0: number, arg1: number): Internal.List<Internal.ByteBuf>;
        getDouble(arg0: number): number;
        getFloat(arg0: number): number;
        writeLong(arg0: number): Internal.CompositeByteBuf;
        writeLong(arg0: number): Internal.ByteBuf;
        writeIntLE(arg0: number): Internal.ByteBuf;
        array(): number[];
        setCharSequence(arg0: number, arg1: Internal.CharSequence, arg2: Internal.Charset): number;
        hashCode(): number;
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        arrayOffset(): number;
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf;
        readIntLE(): number;
        readUnsignedByte(): number;
        readLongLE(): number;
        readUnsignedMediumLE(): number;
        writeDouble(arg0: number): Internal.CompositeByteBuf;
        writeDouble(arg0: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel, arg2: number): number;
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf): Internal.CompositeByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number): Internal.CompositeByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.CompositeByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf, arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.InputStream, arg2: number): number;
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[]): Internal.CompositeByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.CompositeByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuffer): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.CompositeByteBuf;
        setBytes(arg0: number, arg1: Internal.FileChannel, arg2: number, arg3: number): number;
        maxNumComponents(): number;
        setFloat(arg0: number, arg1: number): Internal.ByteBuf;
        setFloat(arg0: number, arg1: number): Internal.CompositeByteBuf;
        getShort(arg0: number): number;
        forEach(arg0: (arg0: Internal.ByteBuf) => void): void;
        writeMediumLE(arg0: number): Internal.ByteBuf;
        clear(): Internal.CompositeByteBuf;
        clear(): Internal.ByteBuf;
        getUnsignedByte(arg0: number): number;
        discardReadBytes(): Internal.CompositeByteBuf;
        discardReadBytes(): Internal.ByteBuf;
        writeChar(arg0: number): Internal.CompositeByteBuf;
        writeChar(arg0: number): Internal.ByteBuf;
        writeDoubleLE(arg0: number): Internal.ByteBuf;
        isContiguous(): boolean;
        getUnsignedMediumLE(arg0: number): number;
        readByte(): number;
        get readable(): boolean;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get contiguous(): boolean;
        get writable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PacketFlow extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.PacketFlow;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.PacketFlow[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.PacketFlow): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.PacketFlow>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.PacketFlow>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly CLIENTBOUND : Internal.PacketFlow;
        static readonly SERVERBOUND : Internal.PacketFlow;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.PacketFlow>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface CameraInvokerMixin {
        callMove(arg0: number, arg1: number, arg2: number): void;
    }
    class ModelGenerator {
        getClass(): Internal.Class<any>;
        parent(s: string): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toJson(): Internal.JsonObject;
        textures(json: Internal.JsonObject): void;
        hashCode(): number;
        texture(name: string, texture: string): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        element(consumer: (arg0: Internal.ModelGenerator$Element) => void): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LevelKJS extends Internal.AsKJS {
        asKJS(): any;
    }
    interface Applicative <F, Mu> extends Internal.Functor<F, Mu> {
        point<A_>(arg0: A_): Internal.App<Mu, A_>;
        map<T_, R_>(arg0: (arg0: T_) => R_, arg1: Internal.App<Mu, T_>): Internal.App<Mu, R_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>): Internal.Products$P11<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>): Internal.Products$P10<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>): Internal.Products$P9<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>, arg14: Internal.App<Mu, T15_>, arg15: Internal.App<Mu, T16_>): Internal.Products$P16<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>, arg14: Internal.App<Mu, T15_>): Internal.Products$P15<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>, arg13: Internal.App<Mu, T14_>): Internal.Products$P14<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>, arg12: Internal.App<Mu, T13_>): Internal.Products$P13<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>, arg8: Internal.App<Mu, T9_>, arg9: Internal.App<Mu, T10_>, arg10: Internal.App<Mu, T11_>, arg11: Internal.App<Mu, T12_>): Internal.Products$P12<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>;
        group<T1_, T2_, T3_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>): Internal.Products$P3<Mu, T1_, T2_, T3_>;
        group<T1_, T2_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>): Internal.Products$P2<Mu, T1_, T2_>;
        group<T1_>(arg0: Internal.App<Mu, T1_>): Internal.Products$P1<Mu, T1_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>, arg7: Internal.App<Mu, T8_>): Internal.Products$P8<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>, arg6: Internal.App<Mu, T7_>): Internal.Products$P7<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>, arg5: Internal.App<Mu, T6_>): Internal.Products$P6<Mu, T1_, T2_, T3_, T4_, T5_, T6_>;
        group<T1_, T2_, T3_, T4_, T5_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>, arg4: Internal.App<Mu, T5_>): Internal.Products$P5<Mu, T1_, T2_, T3_, T4_, T5_>;
        group<T1_, T2_, T3_, T4_>(arg0: Internal.App<Mu, T1_>, arg1: Internal.App<Mu, T2_>, arg2: Internal.App<Mu, T3_>, arg3: Internal.App<Mu, T4_>): Internal.Products$P4<Mu, T1_, T2_, T3_, T4_>;
        apply2<A_, B_, R_>(arg0: (arg0: A_, arg1: B_) => R_, arg1: Internal.App<Mu, A_>, arg2: Internal.App<Mu, B_>): Internal.App<Mu, R_>;
        apply3<T1_, T2_, T3_, R_>(arg0: Internal.Function3<T1_, T2_, T3_, R_>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>): Internal.App<Mu, R_>;
        ap2<A_, B_, R_>(arg0: Internal.App<Mu, (arg0: A_, arg1: B_) => R_>, arg1: Internal.App<Mu, A_>, arg2: Internal.App<Mu, B_>): Internal.App<Mu, R_>;
        apply4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.Function4<T1_, T2_, T3_, T4_, R_>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>): Internal.App<Mu, R_>;
        ap11<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>(arg0: Internal.App<Mu, Internal.Function11<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>, arg10: Internal.App<Mu, T10_>, arg11: Internal.App<Mu, T11_>): Internal.App<Mu, R_>;
        apply5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>): Internal.App<Mu, R_>;
        ap10<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>(arg0: Internal.App<Mu, Internal.Function10<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>, arg10: Internal.App<Mu, T10_>): Internal.App<Mu, R_>;
        ap4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App<Mu, Internal.Function4<T1_, T2_, T3_, T4_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>): Internal.App<Mu, R_>;
        lift2<A_, B_, R_>(arg0: Internal.App<Mu, (arg0: A_, arg1: B_) => R_>): (arg0: Internal.App<Mu, A_>, arg1: Internal.App<Mu, B_>) => Internal.App<Mu, R_>;
        ap3<T1_, T2_, T3_, R_>(arg0: Internal.App<Mu, Internal.Function3<T1_, T2_, T3_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>): Internal.App<Mu, R_>;
        lift1<A_, R_>(arg0: Internal.App<Mu, (arg0: A_) => R_>): (arg0: Internal.App<Mu, A_>) => Internal.App<Mu, R_>;
        ap6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App<Mu, Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>): Internal.App<Mu, R_>;
        ap5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App<Mu, Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>): Internal.App<Mu, R_>;
        ap8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App<Mu, Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>): Internal.App<Mu, R_>;
        lift6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App<Mu, Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>>): Internal.Function6<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, T5_>, Internal.App<Mu, T6_>, Internal.App<Mu, R_>>;
        ap7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App<Mu, Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>): Internal.App<Mu, R_>;
        lift5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App<Mu, Internal.Function5<T1_, T2_, T3_, T4_, T5_, R_>>): Internal.Function5<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, T5_>, Internal.App<Mu, R_>>;
        lift4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App<Mu, Internal.Function4<T1_, T2_, T3_, T4_, R_>>): Internal.Function4<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, R_>>;
        ap9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App<Mu, Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>): Internal.App<Mu, R_>;
        lift3<T1_, T2_, T3_, R_>(arg0: Internal.App<Mu, Internal.Function3<T1_, T2_, T3_, R_>>): Internal.Function3<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, R_>>;
        apply6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.Function6<T1_, T2_, T3_, T4_, T5_, T6_, R_>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>): Internal.App<Mu, R_>;
        apply7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>): Internal.App<Mu, R_>;
        lift9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App<Mu, Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>): Internal.Function9<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, T5_>, Internal.App<Mu, T6_>, Internal.App<Mu, T7_>, Internal.App<Mu, T8_>, Internal.App<Mu, T9_>, Internal.App<Mu, R_>>;
        apply8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>): Internal.App<Mu, R_>;
        lift8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App<Mu, Internal.Function8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>): Internal.Function8<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, T5_>, Internal.App<Mu, T6_>, Internal.App<Mu, T7_>, Internal.App<Mu, T8_>, Internal.App<Mu, R_>>;
        apply9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.Function9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>): Internal.App<Mu, R_>;
        lift7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App<Mu, Internal.Function7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>): Internal.Function7<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, T5_>, Internal.App<Mu, T6_>, Internal.App<Mu, T7_>, Internal.App<Mu, R_>>;
        ap<A_, R_>(arg0: Internal.App<Mu, (arg0: A_) => R_>, arg1: Internal.App<Mu, A_>): Internal.App<Mu, R_>;
        ap<A_, R_>(arg0: (arg0: A_) => R_, arg1: Internal.App<Mu, A_>): Internal.App<Mu, R_>;
        ap16<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>(arg0: Internal.App<Mu, Internal.Function16<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>, arg10: Internal.App<Mu, T10_>, arg11: Internal.App<Mu, T11_>, arg12: Internal.App<Mu, T12_>, arg13: Internal.App<Mu, T13_>, arg14: Internal.App<Mu, T14_>, arg15: Internal.App<Mu, T15_>, arg16: Internal.App<Mu, T16_>): Internal.App<Mu, R_>;
        ap13<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>(arg0: Internal.App<Mu, Internal.Function13<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>, arg10: Internal.App<Mu, T10_>, arg11: Internal.App<Mu, T11_>, arg12: Internal.App<Mu, T12_>, arg13: Internal.App<Mu, T13_>): Internal.App<Mu, R_>;
        ap12<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>(arg0: Internal.App<Mu, Internal.Function12<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>, arg10: Internal.App<Mu, T10_>, arg11: Internal.App<Mu, T11_>, arg12: Internal.App<Mu, T12_>): Internal.App<Mu, R_>;
        ap15<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>(arg0: Internal.App<Mu, Internal.Function15<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>, arg10: Internal.App<Mu, T10_>, arg11: Internal.App<Mu, T11_>, arg12: Internal.App<Mu, T12_>, arg13: Internal.App<Mu, T13_>, arg14: Internal.App<Mu, T14_>, arg15: Internal.App<Mu, T15_>): Internal.App<Mu, R_>;
        ap14<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>(arg0: Internal.App<Mu, Internal.Function14<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>>, arg1: Internal.App<Mu, T1_>, arg2: Internal.App<Mu, T2_>, arg3: Internal.App<Mu, T3_>, arg4: Internal.App<Mu, T4_>, arg5: Internal.App<Mu, T5_>, arg6: Internal.App<Mu, T6_>, arg7: Internal.App<Mu, T7_>, arg8: Internal.App<Mu, T8_>, arg9: Internal.App<Mu, T9_>, arg10: Internal.App<Mu, T10_>, arg11: Internal.App<Mu, T11_>, arg12: Internal.App<Mu, T12_>, arg13: Internal.App<Mu, T13_>, arg14: Internal.App<Mu, T14_>): Internal.App<Mu, R_>;
    }
    class Locale$Category extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Locale$Category;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Locale$Category[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Locale$Category): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Locale$Category>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Locale$Category>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly DISPLAY : Internal.Locale$Category;
        static readonly FORMAT : Internal.Locale$Category;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Locale$Category>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ChannelConfig {
        setMessageSizeEstimator(arg0: Internal.MessageSizeEstimator): Internal.ChannelConfig;
        setWriteBufferLowWaterMark(arg0: number): Internal.ChannelConfig;
        getWriteBufferLowWaterMark(): number;
        getMessageSizeEstimator(): Internal.MessageSizeEstimator;
        setRecvByteBufAllocator(arg0: Internal.RecvByteBufAllocator): Internal.ChannelConfig;
        getOption<T>(arg0: Internal.ChannelOption<T>): T;
        isAutoClose(): boolean;
        getRecvByteBufAllocator<T>(): T;
        setAllocator(arg0: Internal.ByteBufAllocator): Internal.ChannelConfig;
        getAllocator(): Internal.ByteBufAllocator;
        isAutoRead(): boolean;
        setOptions(arg0: Internal.Map<Internal.ChannelOption<any>, any>): boolean;
        setConnectTimeoutMillis(arg0: number): Internal.ChannelConfig;
        setWriteBufferWaterMark(arg0: Internal.WriteBufferWaterMark): Internal.ChannelConfig;
        setOption<T>(arg0: Internal.ChannelOption<T>, arg1: T): boolean;
        getConnectTimeoutMillis(): number;
        setWriteSpinCount(arg0: number): Internal.ChannelConfig;
        setWriteBufferHighWaterMark(arg0: number): Internal.ChannelConfig;
        getMaxMessagesPerRead(): number;
        getWriteBufferHighWaterMark(): number;
        setAutoRead(arg0: boolean): Internal.ChannelConfig;
        getWriteSpinCount(): number;
        setMaxMessagesPerRead(arg0: number): Internal.ChannelConfig;
        getOptions(): Internal.Map<Internal.ChannelOption<any>, any>;
        getWriteBufferWaterMark(): Internal.WriteBufferWaterMark;
        setAutoClose(arg0: boolean): Internal.ChannelConfig;
    }
    class MinMaxBounds$Ints extends Internal.MinMaxBounds<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ParticleOptions {
    }
    class Heightmap$Types extends Internal.Enum<any> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Heightmap$Types;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Heightmap$Types[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Heightmap$Types): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Heightmap$Types>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Heightmap$Types>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly OCEAN_FLOOR : Internal.Heightmap$Types;
        static readonly MOTION_BLOCKING_NO_LEAVES : Internal.Heightmap$Types;
        static readonly MOTION_BLOCKING : Internal.Heightmap$Types;
        static readonly WORLD_SURFACE : Internal.Heightmap$Types;
        static readonly OCEAN_FLOOR_WG : Internal.Heightmap$Types;
        static readonly WORLD_SURFACE_WG : Internal.Heightmap$Types;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Heightmap$Types>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModelProperty <T> implements Internal.Predicate<T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean;
        test(arg0: T): boolean;
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean;
        negate(): (arg0: T) => boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BufferVertexFormat {
        getStride(): number;
    }
    class ModuleLayer$Controller {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        addReads(arg0: Internal.Module, arg1: Internal.Module): Internal.ModuleLayer$Controller;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        addExports(arg0: Internal.Module, arg1: string, arg2: Internal.Module): Internal.ModuleLayer$Controller;
        toString(): string;
        addOpens(arg0: Internal.Module, arg1: string, arg2: Internal.Module): Internal.ModuleLayer$Controller;
        notify(): void;
        layer(): Internal.ModuleLayer;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Context {
        getClass(): Internal.Class<any>;
        static throwAsScriptRuntimeEx(e: Internal.Throwable): Internal.RuntimeException;
        isSealed(): boolean;
        callFunctionWithContinuations(function_: Internal.Callable, scope: Internal.Scriptable, args: any[]): any;
        executeScriptWithContinuations(script: Internal.Script, scope: Internal.Scriptable): any;
        getClassShutterSetter(): Internal.Context$ClassShutterSetter;
        createClassLoader(parent: Internal.ClassLoader): Internal.GeneratedClassLoader;
        getApplicationClassLoader(): Internal.ClassLoader;
        evaluateReader(scope: Internal.Scriptable, in_: Internal.Reader, sourceName: string, lineno: number, securityDomain: any): any;
        getTypeWrappers(): Internal.TypeWrappers;
        compileReader(in_: Internal.Reader, sourceName: string, lineno: number, securityDomain: any): Internal.Script;
        static javaToJS(value: any, scope: Internal.Scriptable): any;
        static toBoolean(value: any): boolean;
        resumeContinuation(continuation: any, scope: Internal.Scriptable, functionResult: any): any;
        captureContinuation(): Internal.ContinuationPending;
        static enter(): Internal.Context;
        static reportRuntimeError0(messageId: string): Internal.EvaluatorException;
        static reportRuntimeError1(messageId: string, arg1: any): Internal.EvaluatorException;
        static reportRuntimeError2(messageId: string, arg1: any, arg2: any): Internal.EvaluatorException;
        static reportRuntimeError3(messageId: string, arg1: any, arg2: any, arg3: any): Internal.EvaluatorException;
        hasTypeWrappers(): boolean;
        getInstructionObserverThreshold(): number;
        static reportRuntimeError(message: string, sourceName: string, lineno: number, lineSource: string, lineOffset: number): Internal.EvaluatorException;
        static reportRuntimeError(message: string): Internal.EvaluatorException;
        getThreadLocal(key: any): any;
        removePropertyChangeListener(l: Internal.PropertyChangeListener): void;
        static getUndefinedValue(): any;
        putThreadLocal(key: any, value: any): void;
        setClassShutter(shutter: Internal.ClassShutter): void;
        static exit(): void;
        setInstructionObserverThreshold(threshold: number): void;
        getElements(object: Internal.Scriptable): any[];
        static reportRuntimeError4(messageId: string, arg1: any, arg2: any, arg3: any, arg4: any): Internal.EvaluatorException;
        hasFeature(featureIndex: number): boolean;
        initSafeStandardObjects(): Internal.ScriptableObject;
        initSafeStandardObjects(scope: Internal.ScriptableObject, sealed: boolean): Internal.ScriptableObject;
        initSafeStandardObjects(scope: Internal.ScriptableObject): Internal.Scriptable;
        static toNumber(value: any): number;
        setLocale(loc: Internal.Locale): Internal.Locale;
        initStandardObjects(): Internal.ScriptableObject;
        initStandardObjects(scope: Internal.ScriptableObject, sealed: boolean): Internal.ScriptableObject;
        initStandardObjects(scope: Internal.ScriptableObject): Internal.Scriptable;
        isStrictMode(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setApplicationClassLoader(loader: Internal.ClassLoader): void;
        getWrapFactory(): Internal.WrapFactory;
        notifyAll(): void;
        setGenerateObserverCount(generateObserverCount: boolean): void;
        seal(sealKey: any): void;
        setWrapFactory(wrapFactory: Internal.WrapFactory): void;
        evaluateString(scope: Internal.Scriptable, source: string, sourceName: string, lineno: number, securityDomain: any): any;
        notify(): void;
        compileFunction(scope: Internal.Scriptable, source: string, sourceName: string, lineno: number, securityDomain: any): dev.latvian.mods.rhino.Function;
        getClassShutter(): Internal.ClassShutter;
        setErrorReporter(reporter: Internal.ErrorReporter): Internal.ErrorReporter;
        hashCode(): number;
        newObject(scope: Internal.Scriptable): Internal.Scriptable;
        newObject(scope: Internal.Scriptable, constructorName: string, args: any[]): Internal.Scriptable;
        newObject(scope: Internal.Scriptable, constructorName: string): Internal.Scriptable;
        static jsToJava(value: any, desiredType: Internal.Class<any>): any;
        static toObject(value: any, scope: Internal.Scriptable): Internal.Scriptable;
        static getSourcePositionFromStack(linep: number[]): string;
        addPropertyChangeListener(l: Internal.PropertyChangeListener): void;
        static reportWarning(message: string, sourceName: string, lineno: number, lineSource: string, lineOffset: number): void;
        static reportWarning(message: string): void;
        static reportWarning(message: string, t: Internal.Throwable): void;
        setLanguageVersion(version: number): void;
        stringIsCompilableUnit(source: string): boolean;
        removeThreadLocal(key: any): void;
        static getCurrentContext(): Internal.Context;
        newArray(scope: Internal.Scriptable, length: number): Internal.Scriptable;
        newArray(scope: Internal.Scriptable, elements: any[]): Internal.Scriptable;
        static reportError(message: string, sourceName: string, lineno: number, lineSource: string, lineOffset: number): void;
        static reportError(message: string): void;
        getFactory(): Internal.ContextFactory;
        getErrorReporter(): Internal.ErrorReporter;
        static call(factory: Internal.ContextFactory, callable: Internal.Callable, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any;
        getMaximumInterpreterStackDepth(): number;
        setMaximumInterpreterStackDepth(max: number): void;
        equals(arg0: any): boolean;
        compileString(source: string, sourceName: string, lineno: number, securityDomain: any): Internal.Script;
        static toString(value: any): string;
        toString(): string;
        unseal(sealKey: any): void;
        getLocale(): Internal.Locale;
        static getContext(): Internal.Context;
        static enterWithNewFactory(): Internal.Context;
        getImplementationVersion(): string;
        static readonly FEATURE_INTEGER_WITHOUT_DECIMAL_PLACE : 18;
        static readonly FEATURE_ENHANCED_JAVA_ACCESS : 13;
        static readonly FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER : 3;
        static readonly FEATURE_DYNAMIC_SCOPE : 7;
        static readonly FEATURE_LITTLE_ENDIAN : 19;
        static readonly FEATURE_THREAD_SAFE_OBJECTS : 17;
        generateObserverCount : boolean;
        static readonly FEATURE_STRICT_MODE : 11;
        static readonly FEATURE_WARNING_AS_ERROR : 12;
        static readonly FEATURE_STRICT_EVAL : 9;
        static readonly FEATURE_LOCATION_INFORMATION_IN_ERROR : 10;
        static readonly errorReporterProperty : "error reporter";
        static readonly FEATURE_V8_EXTENSIONS : 14;
        static readonly FEATURE_STRICT_VARS : 8;
        static readonly FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME : 2;
        static readonly FEATURE_PARENT_PROTO_PROPERTIES : 5;
        static readonly languageVersionProperty : "language version";
        static readonly emptyArgs : any[];
        get factory(): Internal.ContextFactory;
        get undefinedValue(): any;
        get implementationVersion(): string;
        get currentContext(): Internal.Context;
        get sealed(): boolean;
        get strictMode(): boolean;
        get maximumInterpreterStackDepth(): number;
        get locale(): Internal.Locale;
        get typeWrappers(): Internal.TypeWrappers;
        get classShutterSetter(): Internal.Context$ClassShutterSetter;
        get errorReporter(): Internal.ErrorReporter;
        get applicationClassLoader(): Internal.ClassLoader;
        get wrapFactory(): Internal.WrapFactory;
        get context(): Internal.Context;
        get class(): Internal.Class<any>;
        get instructionObserverThreshold(): number;
        get classShutter(): Internal.ClassShutter;
        set errorReporter(reporter: Internal.ErrorReporter);
        set languageVersion(version: number);
        set applicationClassLoader(loader: Internal.ClassLoader);
        set wrapFactory(wrapFactory: Internal.WrapFactory);
        set maximumInterpreterStackDepth(max: number);
        set locale(loc: Internal.Locale);
        set instructionObserverThreshold(threshold: number);
        set classShutter(shutter: Internal.ClassShutter);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Monster extends Internal.PathfinderMob implements Internal.Enemy {
        getClass(): Internal.Class<any>;
        backpackedMoved(): boolean;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>;
        handler$zje000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void;
        updateNavigationRegistration(): void;
        onEndimationEnd(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        canBeRiddenInWater(arg0: Internal.Entity): boolean;
        handler$zzo000$tickHead(arg0: Internal.CallbackInfo): void;
        setCitadelEntityData(arg0: Internal.CompoundTag): void;
        isEndimationPlaying(arg0: Internal.PlayableEndimation): boolean;
        isActive(): boolean;
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void;
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity;
        getCachedFeetBlockState(): Internal.BlockState;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        handler$bfj000$tryShortcutFluidPushing(tag: net.minecraft.tags.Tag<any>, speed: number, cir: Internal.CallbackInfoReturnable<any>, box: Internal.AABB, x1: number, x2: number, y1: number, y2: number, z1: number, z2: number, zero: number): void;
        getPos(): Internal.Position;
        foodEatenKJS(is: Internal.ItemStack): void;
        revive(): void;
        static getDataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(arg0: boolean): void;
        canUpdate(): boolean;
        getEndimatedState(): Internal.Endimatable$EndimatedState;
        resetEndimation(): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean;
        getRegisteredNavigation(): Internal.PathNavigation;
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number;
        reviveCaps(): void;
        lithiumOnBlockCacheDeleted(): void;
        canRiderInteract(): boolean;
        getEntries(arg0: boolean): Internal.Set<any>;
        getEffectHandler(): Internal.EndimationEffectHandler;
        onAddedToWorld(): void;
        setAnimationTick(arg0: number): void;
        isRegisteredToWorld(): boolean;
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        static getDataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        getListener(): Internal.NearbyEntityListenerMulti;
        getClassification(arg0: boolean): Internal.MobCategory;
        isNoEndimationPlaying(): boolean;
        onEndimationStart(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listenForCachedBlockChanges: boolean): void;
        shouldRiderSit(): boolean;
        getIsInsidePortal(): boolean;
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$zje000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        handler$zcg000$read(arg0: Internal.CompoundTag, arg1: Internal.CallbackInfo): void;
        getRemainingFireTicks(): number;
        lithiumOnEquipmentChanged(): void;
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void;
        notify(): void;
        getDataMap(): Internal.Map<any, any>;
        handler$zzo000$moveStep(arg0: Internal.MoverType, arg1: Vec3, arg2: Internal.CallbackInfo): void;
        getEntityChangeListener(): Internal.EntityInLevelCallback;
        endimateTick(): void;
        setDataMap(arg0: Internal.Map<any, any>): void;
        isDirty(): boolean;
        hashCode(): number;
        getLastPos(): BlockPos;
        isAddedToWorld(): boolean;
        setRegisteredToWorld(navigation: Internal.PathNavigation): void;
        getParts(): any[];
        addListener(listener: Internal.NearbyEntityListener): void;
        onRemovedFromWorld(): void;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        curePotionEffects(arg0: Internal.ItemStack): boolean;
        clean(): void;
        asKJS(): any;
        getPlayingEndimation(): Internal.PlayableEndimation;
        getDirtyEntries(): Internal.Set<any>;
        getValue(arg0: Internal.TrackedData<any>): any;
        shouldRiderFaceForward(arg0: Internal.Player): boolean;
        setPlayingEndimation(arg0: Internal.PlayableEndimation): void;
        setValue(arg0: Internal.TrackedData<any>, arg1: any): void;
        equals(arg0: any): boolean;
        getAnimationTick(): number;
        toString(): string;
        setRemainingFireTicks(arg0: number): void;
        handler$zgd001$tick(arg0: Internal.CallbackInfo): void;
        get citadelEntityData(): Internal.CompoundTag;
        get listener(): Internal.NearbyEntityListenerMulti;
        get addedToWorld(): boolean;
        get registeredNavigation(): Internal.PathNavigation;
        get animationTick(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get pos(): Internal.Position;
        get registeredToWorld(): boolean;
        get dataMap(): Internal.Map<any, any>;
        get noEndimationPlaying(): boolean;
        get class(): Internal.Class<any>;
        get dirty(): boolean;
        get dataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get entityChangeListener(): Internal.EntityInLevelCallback;
        get multipartEntity(): boolean;
        get active(): boolean;
        get playingEndimation(): Internal.PlayableEndimation;
        get effectHandler(): Internal.EndimationEffectHandler;
        get cachedFeetBlockState(): Internal.BlockState;
        get lastPos(): BlockPos;
        get dirtyEntries(): Internal.Set<any>;
        get dataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        get parts(): any[];
        get endimatedState(): Internal.Endimatable$EndimatedState;
        set animationTick(arg0: number);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set dataMap(arg0: Internal.Map<any, any>);
        set playingEndimation(arg0: Internal.PlayableEndimation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ChannelProgressiveFuture extends Internal.ChannelFuture, Internal.ProgressiveFuture<void> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelProgressiveFuture;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ProgressiveFuture<void>;
        getNow(): void;
        channel(): io.netty.channel.Channel;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): Internal.ChannelProgressiveFuture;
        awaitUninterruptibly(): Internal.ChannelFuture;
        awaitUninterruptibly(): Internal.Future<void>;
        awaitUninterruptibly(): Internal.ProgressiveFuture<void>;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelProgressiveFuture;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ProgressiveFuture<void>;
        isDone(): boolean;
        sync(): Internal.ChannelProgressiveFuture;
        sync(): Internal.ChannelFuture;
        sync(): Internal.Future<void>;
        sync(): Internal.ProgressiveFuture<void>;
        isVoid(): boolean;
        syncUninterruptibly(): Internal.ChannelProgressiveFuture;
        syncUninterruptibly(): Internal.ChannelFuture;
        syncUninterruptibly(): Internal.Future<void>;
        syncUninterruptibly(): Internal.ProgressiveFuture<void>;
        get(arg0: number, arg1: Internal.TimeUnit): void;
        get(): void;
        isCancellable(): boolean;
        await(): Internal.ChannelProgressiveFuture;
        await(): Internal.ChannelFuture;
        await(): Internal.Future<void>;
        await(): Internal.ProgressiveFuture<void>;
        await(arg0: number, arg1: Internal.TimeUnit): boolean;
        await(arg0: number): boolean;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelProgressiveFuture;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ProgressiveFuture<void>;
        isSuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelProgressiveFuture;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ProgressiveFuture<void>;
    }
    interface DoubleStream$Builder extends Internal.DoubleConsumer {
        add(arg0: number): Internal.DoubleStream$Builder;
        build(): Internal.DoubleStream;
        andThen(arg0: Internal.DoubleConsumer): Internal.DoubleConsumer;
        accept(arg0: number): void;
    }
    class IngredientWithCustomPredicateJS implements Internal.IngredientJS {
        anyStackMatches(ingredient: Internal.IngredientJS): boolean;
        getItemIds(): Internal.Set<string>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getStacks(): Internal.Set<Internal.ItemStackJS>;
        getVanillaItems(): Internal.Set<Internal.Item>;
        notifyAll(): void;
        isInvalidRecipeIngredient(): boolean;
        notify(): void;
        not(): Internal.IngredientJS;
        hashCode(): number;
        getFirst(): Internal.ItemStackJS;
        copy(): Internal.IngredientJS;
        copy(): Internal.Copyable;
        getCount(): number;
        testVanillaItem(i: Internal.Item): boolean;
        test(stack: Internal.ItemStackJS): boolean;
        isEmpty(): boolean;
        asIngredientStack(): Internal.IngredientStackJS;
        getVanillaPredicate(): (arg0: Internal.ItemStack) => boolean;
        filter(filter: Internal.IngredientJS): Internal.IngredientJS;
        createVanillaIngredient(): (arg0: any) => boolean;
        toJson(): Internal.JsonElement;
        withCount(count: number): Internal.IngredientJS;
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>;
        equals(arg0: any): boolean;
        testVanilla(stack: Internal.ItemStack): boolean;
        x(c: number): Internal.IngredientJS;
        toString(): string;
        readonly predicate : (arg0: Internal.ItemStack) => boolean;
        readonly ingredient : Internal.IngredientJS;
        readonly uuid : Internal.UUID;
        get invalidRecipeIngredient(): boolean;
        get stacks(): Internal.Set<Internal.ItemStackJS>;
        get itemIds(): Internal.Set<string>;
        get count(): number;
        get class(): Internal.Class<any>;
        get vanillaItems(): Internal.Set<Internal.Item>;
        get first(): Internal.ItemStackJS;
        get empty(): boolean;
        get vanillaPredicate(): (arg0: Internal.ItemStack) => boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IntIterator extends Internal.PrimitiveIterator$OfInt {
        next(): any;
        next(): number;
        hasNext(): boolean;
        skip(arg0: number): number;
        nextInt(): number;
        forEachRemaining(arg0: (arg0: number) => void): void;
        forEachRemaining(arg0: (arg0: any) => void): void;
        forEachRemaining(arg0: any): void;
        forEachRemaining(arg0: java_.util.function_.IntConsumer): void;
        remove(): void;
    }
    class UnboundedMapCodec <K, V> implements Internal.BaseMapCodec<K, V>, Internal.Codec<Internal.Map<K, V>> {
        encode(arg0: any, arg1: Internal.DynamicOps<any>, arg2: any): Internal.DataResult<any>;
        encode<T_>(arg0: Internal.Map<K, V>, arg1: Internal.DynamicOps<T_>, arg2: T_): Internal.DataResult<T_>;
        encode<T_>(arg0: Internal.Map<K, V>, arg1: Internal.DynamicOps<T_>, arg2: Internal.RecordBuilder<T_>): Internal.RecordBuilder<T_>;
        getClass(): Internal.Class<any>;
        flatComapMap<S_>(arg0: (arg0: Internal.Map<K, V>) => S_, arg1: (arg0: S_) => Internal.DataResult<Internal.Map<K, V>>): Internal.Codec<S_>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        dispatch<E_>(arg0: (arg0: E_) => Internal.Map<K, V>, arg1: (arg0: Internal.Map<K, V>) => Internal.Codec<E_>): Internal.Codec<E_>;
        dispatch<E_>(arg0: string, arg1: (arg0: E_) => Internal.Map<K, V>, arg2: (arg0: Internal.Map<K, V>) => Internal.Codec<E_>): Internal.Codec<E_>;
        deprecated(arg0: number): Internal.Codec<Internal.Map<K, V>>;
        notifyAll(): void;
        simple(): Internal.Decoder$Simple<Internal.Map<K, V>>;
        dispatchMap<E_>(arg0: string, arg1: (arg0: E_) => Internal.Map<K, V>, arg2: (arg0: Internal.Map<K, V>) => Internal.Codec<E_>): Internal.MapCodec<E_>;
        dispatchMap<E_>(arg0: (arg0: E_) => Internal.Map<K, V>, arg1: (arg0: Internal.Map<K, V>) => Internal.Codec<E_>): Internal.MapCodec<E_>;
        comapFlatMap<S_>(arg0: (arg0: Internal.Map<K, V>) => Internal.DataResult<S_>, arg1: (arg0: S_) => Internal.Map<K, V>): Internal.Codec<S_>;
        decode<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<Internal.Pair<Internal.Map<K, V>, T_>>;
        decode<T_>(arg0: Internal.DynamicOps<T_>, arg1: Internal.MapLike<T_>): Internal.DataResult<Internal.Map<K, V>>;
        decode<T_>(arg0: Internal.Dynamic<T_>): Internal.DataResult<Internal.Pair<Internal.Map<K, V>, T_>>;
        notify(): void;
        promotePartial(arg0: (arg0: any) => void): Internal.Decoder<any>;
        promotePartial(arg0: (arg0: string) => void): Internal.Codec<Internal.Map<K, V>>;
        flatXmap<S_>(arg0: (arg0: Internal.Map<K, V>) => Internal.DataResult<S_>, arg1: (arg0: S_) => Internal.DataResult<Internal.Map<K, V>>): Internal.Codec<S_>;
        hashCode(): number;
        comap<B_>(arg0: (arg0: B_) => Internal.Map<K, V>): Internal.Encoder<B_>;
        fieldOf(arg0: string): Internal.MapCodec<Internal.Map<K, V>>;
        fieldOf(arg0: string): Internal.MapDecoder<any>;
        fieldOf(arg0: string): Internal.MapEncoder<any>;
        xmap<S_>(arg0: (arg0: Internal.Map<K, V>) => S_, arg1: (arg0: S_) => Internal.Map<K, V>): Internal.Codec<S_>;
        listOf(): Internal.Codec<Internal.List<Internal.Map<K, V>>>;
        map<B_>(arg0: (arg0: Internal.Map<K, V>) => B_): Internal.Decoder<B_>;
        encodeStart<T_>(arg0: Internal.DynamicOps<T_>, arg1: Internal.Map<K, V>): Internal.DataResult<T_>;
        optionalFieldOf(arg0: string, arg1: Internal.Map<K, V>, arg2: Internal.Lifecycle): Internal.MapCodec<Internal.Map<K, V>>;
        optionalFieldOf(arg0: string): Internal.MapCodec<Internal.Optional<Internal.Map<K, V>>>;
        optionalFieldOf(arg0: string, arg1: Internal.Map<K, V>): Internal.MapCodec<Internal.Map<K, V>>;
        optionalFieldOf(arg0: string, arg1: Internal.Lifecycle, arg2: Internal.Map<K, V>, arg3: Internal.Lifecycle): Internal.MapCodec<Internal.Map<K, V>>;
        flatComap<B_>(arg0: (arg0: B_) => Internal.DataResult<Internal.Map<K, V>>): Internal.Encoder<B_>;
        keyCodec(): Internal.Codec<K>;
        partialDispatch<E_>(arg0: string, arg1: (arg0: E_) => Internal.DataResult<Internal.Map<K, V>>, arg2: (arg0: Internal.Map<K, V>) => Internal.DataResult<Internal.Codec<E_>>): Internal.Codec<E_>;
        terminal(): Internal.Decoder$Terminal<Internal.Map<K, V>>;
        parse<T_>(arg0: Internal.Dynamic<T_>): Internal.DataResult<Internal.Map<K, V>>;
        parse<T_>(arg0: Internal.DynamicOps<T_>, arg1: T_): Internal.DataResult<Internal.Map<K, V>>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.Codec<Internal.Map<K, V>>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.Decoder<any>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.Encoder<any>;
        orElse(arg0: Internal.Map<K, V>): Internal.Codec<Internal.Map<K, V>>;
        orElse(arg0: (arg0: string) => void, arg1: Internal.Map<K, V>): Internal.Codec<Internal.Map<K, V>>;
        orElse(arg0: (arg0: any) => any, arg1: Internal.Map<K, V>): Internal.Codec<Internal.Map<K, V>>;
        flatMap<B_>(arg0: (arg0: Internal.Map<K, V>) => Internal.DataResult<B_>): Internal.Decoder<B_>;
        elementCodec(): Internal.Codec<V>;
        boxed(): Internal.Decoder$Boxed<Internal.Map<K, V>>;
        dispatchStable<E_>(arg0: (arg0: E_) => Internal.Map<K, V>, arg1: (arg0: Internal.Map<K, V>) => Internal.Codec<E_>): Internal.Codec<E_>;
        orElseGet(arg0: (arg0: string) => void, arg1: () => Internal.Map<K, V>): Internal.Codec<Internal.Map<K, V>>;
        orElseGet(arg0: () => Internal.Map<K, V>): Internal.Codec<Internal.Map<K, V>>;
        orElseGet(arg0: (arg0: any) => any, arg1: () => Internal.Map<K, V>): Internal.Codec<Internal.Map<K, V>>;
        stable(): Internal.Codec<Internal.Map<K, V>>;
        equals(arg0: any): boolean;
        mapResult(arg0: Internal.Codec$ResultFunction<Internal.Map<K, V>>): Internal.Codec<Internal.Map<K, V>>;
        toString(): string;
        static readonly FLOAT : Internal.PrimitiveCodec<number>;
        static readonly INT : Internal.PrimitiveCodec<number>;
        static readonly SHORT : Internal.PrimitiveCodec<number>;
        static readonly PASSTHROUGH : Internal.Codec<Internal.Dynamic<any>>;
        static readonly BOOL : Internal.PrimitiveCodec<boolean>;
        static readonly BYTE_BUFFER : Internal.PrimitiveCodec<Internal.ByteBuffer>;
        static readonly INT_STREAM : Internal.PrimitiveCodec<Internal.IntStream>;
        static readonly BYTE : Internal.PrimitiveCodec<number>;
        static readonly LONG_STREAM : Internal.PrimitiveCodec<Internal.LongStream>;
        static readonly STRING : Internal.PrimitiveCodec<string>;
        static readonly DOUBLE : Internal.PrimitiveCodec<number>;
        static readonly EMPTY : Internal.MapCodec<Internal.Unit>;
        static readonly LONG : Internal.PrimitiveCodec<number>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CountingMap {
        add(key: any, value: number): number;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        set(key: any, value: number): number;
        getValues(): Internal.Collection<number>;
        forEach(forEach: (arg0: Internal.Object2LongEntry) => void): void;
        notifyAll(): void;
        clear(): void;
        getTotalCount(): number;
        getKeys(): Internal.Set<any>;
        notify(): void;
        getSize(): number;
        getEntries(): Internal.List<Internal.Object2LongEntry>;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(key: any): number;
        toString(): string;
        get entries(): Internal.List<Internal.Object2LongEntry>;
        get size(): number;
        get keys(): Internal.Set<any>;
        get values(): Internal.Collection<number>;
        get totalCount(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ResourceManager extends Internal.ResourceProvider {
    }
    interface ReadableByteChannel extends Internal.Channel {
        isOpen(): boolean;
        read(arg0: Internal.ByteBuffer): number;
        close(): void;
    }
    class LunarForecast {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getLastCheckedGameTime(): number;
        toString(): string;
        getForecast(): Internal.List<Internal.LunarEventInstance>;
        notify(): void;
        setLastCheckedGameTime(arg0: number): void;
        static readonly CODEC : Internal.Codec<Internal.LunarForecast>;
        get forecast(): Internal.List<Internal.LunarEventInstance>;
        get class(): Internal.Class<any>;
        get lastCheckedGameTime(): number;
        set lastCheckedGameTime(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class LevelEventJS extends Internal.EventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        getLevel(): Internal.LevelJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(id: string, sub: string): boolean;
        post(id: string): boolean;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class OptionalLong {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isEmpty(): boolean;
        isPresent(): boolean;
        orElse(arg0: number): number;
        notify(): void;
        orElseThrow<X>(arg0: () => X): number;
        orElseThrow(): number;
        static empty(): Internal.OptionalLong;
        getAsLong(): number;
        orElseGet(arg0: Internal.LongSupplier): number;
        stream(): Internal.LongStream;
        hashCode(): number;
        ifPresentOrElse(arg0: Internal.LongConsumer, arg1: Internal.Runnable): void;
        ifPresent(arg0: Internal.LongConsumer): void;
        static of(arg0: number): Internal.OptionalLong;
        equals(arg0: any): boolean;
        toString(): string;
        get asLong(): number;
        get present(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Advancement {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class DataJsonGenerator extends Internal.JsonGenerator {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        json(id: ResourceLocation, json: Internal.JsonElement): void;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CompoundTag implements Internal.Tag, Internal.CustomJavaObjectWrapper$AsMap {
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, staticType: Internal.Class<any>): Internal.Scriptable;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        merge(arg0: Internal.CompoundTag): Internal.CompoundTag;
        equals(arg0: any): boolean;
        toString(): string;
        wrapAsJavaMap(): Internal.Map<any, any>;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ContainerAccess {
        getRemoteSlots(): Internal.NonNullList<Internal.ItemStack>;
        getLastSlots(): Internal.NonNullList<Internal.ItemStack>;
    }
    interface IForgeVertexConsumer {
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer): number;
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose, arg1: Internal.BakedQuad, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        applyBakedNormals(arg0: Internal.Vector3f, arg1: Internal.ByteBuffer, arg2: Internal.Matrix3f): void;
    }
    interface RecvByteBufAllocator {
        newHandle(): Internal.RecvByteBufAllocator$Handle;
    }
    interface WrappedJS {
    }
    interface LongUnaryOperator {
        applyAsLong(arg0: number): number;
        compose(arg0: Internal.LongUnaryOperator): Internal.LongUnaryOperator;
        andThen(arg0: Internal.LongUnaryOperator): Internal.LongUnaryOperator;
    }
    class ModuleDescriptor implements Internal.Comparable<Internal.ModuleDescriptor> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toNameAndVersion(): string;
        mainClass(): Internal.Optional<string>;
        exports(): Internal.Set<Internal.ModuleDescriptor$Exports>;
        notifyAll(): void;
        compareTo(arg0: Internal.ModuleDescriptor): number;
        compareTo(arg0: any): number;
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Modifier>;
        notify(): void;
        provides(): Internal.Set<Internal.ModuleDescriptor$Provides>;
        hashCode(): number;
        static newOpenModule(arg0: string): Internal.ModuleDescriptor$Builder;
        static newModule(arg0: string, arg1: Internal.Set<Internal.ModuleDescriptor$Modifier>): Internal.ModuleDescriptor$Builder;
        static newModule(arg0: string): Internal.ModuleDescriptor$Builder;
        isAutomatic(): boolean;
        static read(arg0: Internal.InputStream): Internal.ModuleDescriptor;
        static read(arg0: Internal.InputStream, arg1: () => Internal.Set<string>): Internal.ModuleDescriptor;
        static read(arg0: Internal.ByteBuffer): Internal.ModuleDescriptor;
        static read(arg0: Internal.ByteBuffer, arg1: () => Internal.Set<string>): Internal.ModuleDescriptor;
        rawVersion(): Internal.Optional<string>;
        packages(): Internal.Set<string>;
        version(): Internal.Optional<Internal.ModuleDescriptor$Version>;
        static newAutomaticModule(arg0: string): Internal.ModuleDescriptor$Builder;
        isOpen(): boolean;
        equals(arg0: any): boolean;
        name(): string;
        opens(): Internal.Set<Internal.ModuleDescriptor$Opens>;
        uses(): Internal.Set<string>;
        toString(): string;
        requires(): Internal.Set<Internal.ModuleDescriptor$Requires>;
        get automatic(): boolean;
        get class(): Internal.Class<any>;
        get open(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TypeWrappers {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        removeAll(): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        getWrapperFactory(target: Internal.Class<any>, from: any): Internal.TypeWrapperFactory<any>;
        register<T>(target: Internal.Class<T>, factory: Internal.TypeWrapperFactory<T>): void;
        register<T>(target: Internal.Class<T>, validator: (arg0: any) => boolean, factory: Internal.TypeWrapperFactory<T>): void;
        register<F, T>(id: string, from: Internal.Class<F>, to: Internal.Class<T>, factory: (arg0: F) => T): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Int2ByteFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class UnitStorage {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        addFunc(name: string, func: Internal.FuncSupplier): void;
        notifyAll(): void;
        addOp(name: string, op: Internal.OpSupplier): void;
        setVariable(key: string, unit: dev.latvian.mods.rhino.util.unit.Unit): void;
        getVariableVersion(): number;
        parse(string: string): dev.latvian.mods.rhino.util.unit.Unit;
        getVariable(key: string): dev.latvian.mods.rhino.util.unit.Unit;
        notify(): void;
        clearVariables(): void;
        addConstant(name: string, val: number): void;
        hashCode(): number;
        createFunc(name: string, args: Internal.List<dev.latvian.mods.rhino.util.unit.Unit>): dev.latvian.mods.rhino.util.unit.Unit;
        equals(arg0: any): boolean;
        getConstant(name: string): Internal.ConstantUnit;
        toString(): string;
        addFunc2(name: string, func: Internal.FuncSupplier$Func2): void;
        addFunc1(name: string, func: Internal.FuncSupplier$Func1): void;
        createOp(name: string, unit: dev.latvian.mods.rhino.util.unit.Unit, with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        get variableVersion(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MobEffectInstance implements Internal.Comparable<Internal.MobEffectInstance>, Internal.IForgeMobEffectInstance, Internal.EffectInstanceAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        addCurativeItem(arg0: Internal.ItemStack): void;
        notifyAll(): void;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.MobEffectInstance): number;
        notify(): void;
        writeCurativeItems(arg0: Internal.CompoundTag): void;
        setCurativeItems(arg0: Internal.List<Internal.ItemStack>): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getEffect(): Internal.MobEffect;
        toString(): string;
        isCurativeItem(arg0: Internal.ItemStack): boolean;
        getCurativeItems(): Internal.List<Internal.ItemStack>;
        get curativeItems(): Internal.List<Internal.ItemStack>;
        get effect(): Internal.MobEffect;
        get class(): Internal.Class<any>;
        set curativeItems(arg0: Internal.List<Internal.ItemStack>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class EntityJS implements Internal.MessageSender, Internal.WrappedJS {
        setY(y: number): void;
        setX(x: number): void;
        isOnScoreboardTeam(teamID: string): boolean;
        isLiving(): boolean;
        isSprinting(): boolean;
        getItem(): Internal.ItemStackJS;
        getTags(): Internal.Set<string>;
        setGlowing(glowing: boolean): void;
        setZ(z: number): void;
        getHasCustomName(): boolean;
        setInvisible(invisible: boolean): void;
        runCommandSilent(command: string): number;
        getDistanceSq(x: number, y: number, z: number): number;
        getDistanceSq(pos: BlockPos): number;
        isBoss(): boolean;
        isGlowing(): boolean;
        getHorizontalFacing(): Internal.Direction;
        getServer(): Internal.ServerJS;
        setMotion(x: number, y: number, z: number): void;
        getProfile(): Internal.GameProfile;
        setRotation(yaw: number, pitch: number): void;
        isOnSameTeam(e: Internal.EntityJS): boolean;
        isAnimal(): boolean;
        getDisplayName(): Internal.Text;
        getType(): string;
        setCustomNameAlwaysVisible(b: boolean): void;
        addMotion(x: number, y: number, z: number): void;
        isInvisible(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isUnderWater(): boolean;
        getEyeHeight(): number;
        notify(): void;
        getFallDistance(): number;
        setOnFire(seconds: number): void;
        removePassengers(): void;
        attack(hp: number): void;
        attack(source: string, hp: number): void;
        playSound(id: Internal.SoundEvent): void;
        playSound(id: Internal.SoundEvent, volume: number, pitch: number): void;
        getDistance(x: number, y: number, z: number): number;
        getDistance(pos: BlockPos): number;
        setStatusMessage(message: Internal.Component): void;
        isSwimming(): boolean;
        getCustomName(): Internal.Text;
        getStepHeight(): number;
        mergeFullNBT(tag: Internal.CompoundTag): Internal.EntityJS;
        kill(): void;
        getRidingEntity(): Internal.EntityJS;
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void;
        getLevel(): Internal.LevelJS;
        getPitch(): number;
        getPassengers(): Internal.EntityArrayList;
        isMonster(): boolean;
        equals(arg0: any): boolean;
        setPitch(pitch: number): void;
        isOnGround(): boolean;
        getFacing(): Internal.Direction;
        toString(): string;
        isSilent(): boolean;
        isPassenger(e: Internal.EntityJS): boolean;
        getClass(): Internal.Class<any>;
        getNbt(): Internal.CompoundTag;
        getRecursivePassengers(): Internal.EntityArrayList;
        setFallDistance(fallDistance: number): void;
        getName(): Internal.Text;
        setCustomName(name: Internal.Component): void;
        setStepHeight(stepHeight: number): void;
        tell(message: Internal.Component): void;
        getTeamId(): string;
        isWaterCreature(): boolean;
        setNoClip(noClip: boolean): void;
        setPosition(x: number, y: number, z: number): void;
        setPosition(block: Internal.BlockContainerJS): void;
        extinguish(): void;
        setInvulnerable(invulnerable: boolean): void;
        setFullNBT(nbt: Internal.CompoundTag): void;
        getFullNBT(): Internal.CompoundTag;
        getNoClip(): boolean;
        setYaw(yaw: number): void;
        getYaw(): number;
        isAlive(): boolean;
        setNoGravity(noGravity: boolean): void;
        isPlayer(): boolean;
        isCrouching(): boolean;
        notifyAll(): void;
        getId(): Internal.UUID;
        getTicksExisted(): number;
        setSilent(isSilent: boolean): void;
        hashCode(): number;
        isFrame(): boolean;
        startRiding(e: Internal.EntityJS, force: boolean): boolean;
        runCommand(command: string): number;
        getCustomNameAlwaysVisible(): boolean;
        setMotionZ(z: number): void;
        setMotionY(y: number): void;
        getBlock(): Internal.BlockContainerJS;
        setMotionX(x: number): void;
        isInWater(): boolean;
        dismountRidingEntity(): void;
        isAmbientCreature(): boolean;
        rayTrace(distance: number): Internal.RayTraceResultJS;
        isInvulnerable(): boolean;
        getX(): number;
        spawn(): void;
        getY(): number;
        getZ(): number;
        isPeacefulCreature(): boolean;
        getMotionZ(): number;
        getMotionX(): number;
        getMotionY(): number;
        getNoGravity(): boolean;
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftEntity : Internal.Entity;
        get invisible(): boolean;
        get customNameAlwaysVisible(): boolean;
        get type(): string;
        get hasCustomName(): boolean;
        get block(): Internal.BlockContainerJS;
        get pitch(): number;
        get id(): Internal.UUID;
        get item(): Internal.ItemStackJS;
        get passengers(): Internal.EntityArrayList;
        get level(): Internal.LevelJS;
        get profile(): Internal.GameProfile;
        get customName(): Internal.Text;
        get horizontalFacing(): Internal.Direction;
        get tags(): Internal.Set<string>;
        get sprinting(): boolean;
        get crouching(): boolean;
        get noGravity(): boolean;
        get fullNBT(): Internal.CompoundTag;
        get name(): Internal.Text;
        get animal(): boolean;
        get peacefulCreature(): boolean;
        get stepHeight(): number;
        get frame(): boolean;
        get noClip(): boolean;
        get server(): Internal.ServerJS;
        get nbt(): Internal.CompoundTag;
        get boss(): boolean;
        get alive(): boolean;
        get ticksExisted(): number;
        get displayName(): Internal.Text;
        get fallDistance(): number;
        get facing(): Internal.Direction;
        get ambientCreature(): boolean;
        get swimming(): boolean;
        get waterCreature(): boolean;
        get invulnerable(): boolean;
        get eyeHeight(): number;
        get underWater(): boolean;
        get class(): Internal.Class<any>;
        get player(): boolean;
        get motionZ(): number;
        get silent(): boolean;
        get living(): boolean;
        get motionY(): number;
        get motionX(): number;
        get ridingEntity(): Internal.EntityJS;
        get inWater(): boolean;
        get recursivePassengers(): Internal.EntityArrayList;
        get yaw(): number;
        get monster(): boolean;
        get glowing(): boolean;
        get onGround(): boolean;
        get teamId(): string;
        get x(): number;
        get y(): number;
        get z(): number;
        set noClip(noClip: boolean);
        set motionZ(z: number);
        set silent(isSilent: boolean);
        set motionY(y: number);
        set fallDistance(fallDistance: number);
        set motionX(x: number);
        set invisible(invisible: boolean);
        set customNameAlwaysVisible(b: boolean);
        set onFire(seconds: number);
        set yaw(yaw: number);
        set statusMessage(message: Internal.Component);
        set invulnerable(invulnerable: boolean);
        set glowing(glowing: boolean);
        set noGravity(noGravity: boolean);
        set fullNBT(nbt: Internal.CompoundTag);
        set x(x: number);
        set y(y: number);
        set z(z: number);
        set position(block: Internal.BlockContainerJS);
        set pitch(pitch: number);
        set stepHeight(stepHeight: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeEntity extends Internal.ICapabilitySerializable<Internal.CompoundTag> {
        shouldRiderSit(): boolean;
        canUpdate(arg0: boolean): void;
        canUpdate(): boolean;
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        onRemovedFromWorld(): void;
        isMultipartEntity(): boolean;
        canBeRiddenInWater(arg0: Internal.Entity): boolean;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        getPersistentData(): Internal.CompoundTag;
        canRiderInteract(): boolean;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        onAddedToWorld(): void;
        revive(): void;
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean;
        isAddedToWorld(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getParts(): any[];
    }
    class JsonGenerator {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        json(id: ResourceLocation, json: Internal.JsonElement): void;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlendingData {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Char2DoubleFunction extends it.unimi.dsi.fastutil.Function<string, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: string, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: string) => T_;
        put(arg0: string, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: string, arg1: number): number;
        remove(arg0: string): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: string): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: string): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface OrderedEventExecutor extends Internal.EventExecutor {
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>;
        scheduleAtFixedRate(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        next(): Internal.EventExecutor;
        terminationFuture(): Internal.Future<any>;
        parent(): Internal.EventExecutorGroup;
        newProgressivePromise<V_>(): Internal.ProgressivePromise<V_>;
        shutdownGracefully(): Internal.Future<any>;
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit): Internal.Future<any>;
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): Internal.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable<T_>): java_.util.concurrent.Future<T_>;
        submit(arg0: Internal.Runnable): Internal.Future<any>;
        submit(arg0: Internal.Runnable): java_.util.concurrent.Future<any>;
        submit<T_>(arg0: Internal.Runnable, arg1: T_): Internal.Future<T_>;
        submit<T_>(arg0: Internal.Runnable, arg1: T_): java_.util.concurrent.Future<T_>;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        isTerminated(): boolean;
        forEach(arg0: (arg0: Internal.EventExecutor) => void): void;
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): Internal.ScheduledFuture<any>;
        scheduleWithFixedDelay(arg0: Internal.Runnable, arg1: number, arg2: number, arg3: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): Internal.List<java_.util.concurrent.Future<T_>>;
        invokeAll<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): Internal.List<java_.util.concurrent.Future<T_>>;
        newFailedFuture<V_>(arg0: Internal.Throwable): Internal.Future<V_>;
        execute(arg0: Internal.Runnable): void;
        inEventLoop(arg0: Internal.Thread): boolean;
        inEventLoop(): boolean;
        isShuttingDown(): boolean;
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<any>;
        schedule(arg0: Internal.Runnable, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<any>;
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): Internal.ScheduledFuture<V_>;
        schedule<V_>(arg0: java_.util.concurrent.Callable<V_>, arg1: number, arg2: Internal.TimeUnit): java_.util.concurrent.ScheduledFuture<V_>;
        iterator(): Internal.Iterator<Internal.EventExecutor>;
        newSucceededFuture<V_>(arg0: V_): Internal.Future<V_>;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit): boolean;
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>): T_;
        invokeAny<T_>(arg0: Internal.Collection<java_.util.concurrent.Callable<T_>>, arg1: number, arg2: Internal.TimeUnit): T_;
        shutdownNow(): Internal.List<Internal.Runnable>;
        shutdown(): void;
        isShutdown(): boolean;
        newPromise<V_>(): Internal.Promise<V_>;
    }
    interface IForgeModelState {
        getPartTransformation(arg0: any): Internal.Transformation;
    }
    abstract class VarHandle implements Internal.Constable {
        getClass(): Internal.Class<any>;
        toMethodHandle(arg0: Internal.VarHandle$AccessMode): Internal.MethodHandle;
        getAndBitwiseXor(arg0: any[]): any;
        static storeStoreFence(): void;
        compareAndExchange(arg0: any[]): any;
        getAndSetRelease(arg0: any[]): any;
        getAndBitwiseAnd(arg0: any[]): any;
        describeConstable(): Internal.Optional<Internal.VarHandle$VarHandleDesc>;
        varType(): Internal.Class<any>;
        getAndBitwiseOrAcquire(arg0: any[]): any;
        setVolatile(arg0: any[]): void;
        static releaseFence(): void;
        getAndAdd(arg0: any[]): any;
        weakCompareAndSetRelease(arg0: any[]): boolean;
        static loadLoadFence(): void;
        getAndAddAcquire(arg0: any[]): any;
        setOpaque(arg0: any[]): void;
        isAccessModeSupported(arg0: Internal.VarHandle$AccessMode): boolean;
        compareAndExchangeRelease(arg0: any[]): any;
        compareAndSet(arg0: any[]): boolean;
        compareAndExchangeAcquire(arg0: any[]): any;
        getAndBitwiseXorRelease(arg0: any[]): any;
        withInvokeBehavior(): Internal.VarHandle;
        withInvokeExactBehavior(): Internal.VarHandle;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        coordinateTypes(): Internal.List<Internal.Class<any>>;
        weakCompareAndSetPlain(arg0: any[]): boolean;
        getVolatile(arg0: any[]): any;
        static fullFence(): void;
        notifyAll(): void;
        getAcquire(arg0: any[]): any;
        accessModeType(arg0: Internal.VarHandle$AccessMode): Internal.MethodType;
        getAndBitwiseOr(arg0: any[]): any;
        static acquireFence(): void;
        hasInvokeExactBehavior(): boolean;
        notify(): void;
        getAndBitwiseOrRelease(arg0: any[]): any;
        getAndSetAcquire(arg0: any[]): any;
        getOpaque(arg0: any[]): any;
        getAndBitwiseXorAcquire(arg0: any[]): any;
        hashCode(): number;
        getAndBitwiseAndRelease(arg0: any[]): any;
        get(arg0: any[]): any;
        getAndSet(arg0: any[]): any;
        weakCompareAndSetAcquire(arg0: any[]): boolean;
        set(arg0: any[]): void;
        weakCompareAndSet(arg0: any[]): boolean;
        getAndAddRelease(arg0: any[]): any;
        equals(arg0: any): boolean;
        setRelease(arg0: any[]): void;
        toString(): string;
        getAndBitwiseAndAcquire(arg0: any[]): any;
        get class(): Internal.Class<any>;
        set opaque(arg0: any[]);
        set release(arg0: any[]);
        set volatile(arg0: any[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ArrayList <E> extends Internal.AbstractList<any> implements Internal.List<E>, Internal.RandomAccess, Internal.Cloneable, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        replaceAll(arg0: (arg0: any) => any): void;
        notify(): void;
        remove(arg0: any): boolean;
        remove(arg0: number): E;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.Iterator<E>;
        stream(): Internal.Stream<E>;
        hashCode(): number;
        get(arg0: number): E;
        toArray<T_>(arg0: T_[]): T_[];
        toArray(): any[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        indexOf(arg0: any): number;
        add(arg0: E): boolean;
        add(arg0: number, arg1: E): void;
        subList(arg0: number, arg1: number): Internal.List<E>;
        trimToSize(): void;
        set(arg0: number, arg1: E): E;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: (arg0: E) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator<E>): void;
        removeIf(arg0: (arg0: E) => boolean): boolean;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.Collection<E>): boolean;
        addAll(arg0: number, arg1: Internal.Collection<E>): boolean;
        equals(arg0: any): boolean;
        clone(): any;
        listIterator(): Internal.ListIterator<E>;
        listIterator(arg0: number): Internal.ListIterator<E>;
        toString(): string;
        ensureCapacity(arg0: number): void;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DomainCombiner {
        combine(arg0: Internal.ProtectionDomain[], arg1: Internal.ProtectionDomain[]): Internal.ProtectionDomain[];
    }
    interface EquipmentEntity {
        lithiumOnEquipmentChanged(): void;
    }
    interface Int2ShortFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class JsonArray extends Internal.JsonElement implements Internal.Iterable<Internal.JsonElement> {
        getAsFloat(): number;
        getClass(): Internal.Class<any>;
        getAsByte(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAsBigDecimal(): Internal.BigDecimal;
        notifyAll(): void;
        getAsNumber(): Internal.Number;
        getAsCharacter(): string;
        getAsString(): string;
        isJsonArray(): boolean;
        notify(): void;
        getAsInt(): number;
        remove(arg0: number): Internal.JsonElement;
        remove(arg0: Internal.JsonElement): boolean;
        isJsonPrimitive(): boolean;
        getAsLong(): number;
        iterator(): Internal.Iterator<Internal.JsonElement>;
        isJsonObject(): boolean;
        hashCode(): number;
        get(arg0: number): Internal.JsonElement;
        getAsBigInteger(): Internal.BigInteger;
        add(arg0: string): void;
        add(arg0: Internal.Number): void;
        add(arg0: Internal.JsonElement): void;
        add(arg0: string): void;
        add(arg0: boolean): void;
        getAsJsonObject(): Internal.JsonObject;
        set(arg0: number, arg1: Internal.JsonElement): Internal.JsonElement;
        getAsJsonNull(): Internal.JsonNull;
        spliterator(): Internal.Spliterator<Internal.JsonElement>;
        forEach(arg0: (arg0: Internal.JsonElement) => void): void;
        isJsonNull(): boolean;
        isEmpty(): boolean;
        getAsDouble(): number;
        deepCopy(): Internal.JsonElement;
        deepCopy(): Internal.JsonArray;
        contains(arg0: Internal.JsonElement): boolean;
        getAsJsonArray(): Internal.JsonArray;
        size(): number;
        addAll(arg0: Internal.JsonArray): void;
        getAsJsonPrimitive(): Internal.JsonPrimitive;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getAsShort(): number;
        get asByte(): number;
        get asBigInteger(): Internal.BigInteger;
        get asJsonObject(): Internal.JsonObject;
        get asCharacter(): string;
        get jsonPrimitive(): boolean;
        get asNumber(): Internal.Number;
        get asBigDecimal(): Internal.BigDecimal;
        get jsonNull(): boolean;
        get asFloat(): number;
        get empty(): boolean;
        get asLong(): number;
        get asInt(): number;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get asJsonNull(): Internal.JsonNull;
        get asShort(): number;
        get asDouble(): number;
        get asJsonArray(): Internal.JsonArray;
        get asString(): string;
        get jsonObject(): boolean;
        get class(): Internal.Class<any>;
        get jsonArray(): boolean;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Function5 <T1, T2, T3, T4, T5, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5): R;
        curry3(): Internal.Function3<T1, T2, T3, (arg0: T4, arg1: T5) => R>;
        curry4(): Internal.Function4<T1, T2, T3, T4, (arg0: T5) => R>;
        curry2(): (arg0: T1, arg1: T2) => Internal.Function3<T3, T4, T5, R>;
        curry(): (arg0: T1) => Internal.Function4<T2, T3, T4, T5, R>;
    }
    class StartupEventJS extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IContainerFactory <T> extends Internal.MenuType$MenuSupplier<T> {
        create(arg0: number, arg1: Internal.Inventory, arg2: Internal.FriendlyByteBuf): T;
    }
    interface Function11 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R> {
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, (arg0: T10, arg1: T11) => R>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function4<T8, T9, T10, T11, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function3<T9, T10, T11, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function6<T6, T7, T8, T9, T10, T11, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function5<T7, T8, T9, T10, T11, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function8<T4, T5, T6, T7, T8, T9, T10, T11, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, (arg0: T11) => R>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function7<T5, T6, T7, T8, T9, T10, T11, R>>;
        curry2(): (arg0: T1, arg1: T2) => Internal.Function9<T3, T4, T5, T6, T7, T8, T9, T10, T11, R>;
        curry(): (arg0: T1) => Internal.Function10<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>;
    }
    class GenericLootEventJS extends Internal.LootEventJS {
        cancel(): void;
        addGeneric(id: ResourceLocation, b: (arg0: Internal.LootBuilder) => void): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        addJson(id: ResourceLocation, json: Internal.JsonObject): void;
        notify(): void;
        modify(id: ResourceLocation, b: (arg0: Internal.LootBuilder) => void): void;
        removeAll(): void;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        getType(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getDirectory(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get type(): string;
        get class(): Internal.Class<any>;
        get directory(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TimeUnit extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        static values(): Internal.TimeUnit[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.TimeUnit): number;
        convert(arg0: Internal.Duration): number;
        convert(arg0: number, arg1: Internal.TimeUnit): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.TimeUnit>>;
        notify(): void;
        toSeconds(arg0: number): number;
        sleep(arg0: number): void;
        getDeclaringClass(): Internal.Class<Internal.TimeUnit>;
        hashCode(): number;
        static of(arg0: Internal.ChronoUnit): Internal.TimeUnit;
        toMillis(arg0: number): number;
        toDays(arg0: number): number;
        toChronoUnit(): Internal.ChronoUnit;
        timedJoin(arg0: Internal.Thread, arg1: number): void;
        timedWait(arg0: any, arg1: number): void;
        static valueOf(arg0: string): Internal.TimeUnit;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        toNanos(arg0: number): number;
        toMinutes(arg0: number): number;
        toHours(arg0: number): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        toMicros(arg0: number): number;
        ordinal(): number;
        static readonly MILLISECONDS : Internal.TimeUnit;
        static readonly MICROSECONDS : Internal.TimeUnit;
        static readonly HOURS : Internal.TimeUnit;
        static readonly SECONDS : Internal.TimeUnit;
        static readonly NANOSECONDS : Internal.TimeUnit;
        static readonly DAYS : Internal.TimeUnit;
        static readonly MINUTES : Internal.TimeUnit;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.TimeUnit>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ReferenceCounted {
        refCnt(): number;
        release(arg0: number): boolean;
        release(): boolean;
        retain(): Internal.ReferenceCounted;
        retain(arg0: number): Internal.ReferenceCounted;
        touch(): Internal.ReferenceCounted;
        touch(arg0: any): Internal.ReferenceCounted;
    }
    class Event {
        setCanceled(arg0: boolean): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCanceled(): boolean;
        setResult(arg0: Internal.Event$Result): void;
        notifyAll(): void;
        hasResult(): boolean;
        notify(): void;
        getListenerList(): Internal.ListenerList;
        hashCode(): number;
        equals(arg0: any): boolean;
        getResult(): Internal.Event$Result;
        toString(): string;
        isCancelable(): boolean;
        getPhase(): Internal.EventPriority;
        setPhase(arg0: Internal.EventPriority): void;
        get result(): Internal.Event$Result;
        get phase(): Internal.EventPriority;
        get canceled(): boolean;
        get cancelable(): boolean;
        get listenerList(): Internal.ListenerList;
        get class(): Internal.Class<any>;
        set phase(arg0: Internal.EventPriority);
        set result(arg0: Internal.Event$Result);
        set canceled(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Products$P3 <F, T1, T2, T3> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function3<T1, T2, T3, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function3<T1, T2, T3, R>>): Internal.App<F, R>;
        hashCode(): number;
        and<T4, T5, T6, T7>(arg0: Internal.Products$P4<F, T4, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        and<T4, T5, T6, T7, T8>(arg0: Internal.Products$P5<F, T4, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        and<T4>(arg0: Internal.App<F, T4>): Internal.Products$P4<F, T1, T2, T3, T4>;
        and<T4, T5>(arg0: Internal.Products$P2<F, T4, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>;
        and<T4, T5, T6>(arg0: Internal.Products$P3<F, T4, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        notify(): void;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Lifecycle {
        add(arg0: Internal.Lifecycle): Internal.Lifecycle;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        static stable(): Internal.Lifecycle;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static deprecated(arg0: number): Internal.Lifecycle;
        toString(): string;
        static experimental(): Internal.Lifecycle;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FileAttributeView extends Internal.AttributeView {
        name(): string;
    }
    interface Executor {
        execute(arg0: Internal.Runnable): void;
    }
    interface DoubleUnaryOperator {
        applyAsDouble(arg0: number): number;
        compose(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator;
        andThen(arg0: Internal.DoubleUnaryOperator): Internal.DoubleUnaryOperator;
    }
    abstract class CapabilityProvider <B> implements Internal.ICapabilityProviderImpl<B> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        invalidateCaps(): void;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<B>): boolean;
        toString(): string;
        notify(): void;
        reviveCaps(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class TypeAdapter <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        read(arg0: Internal.JsonReader): T;
        notifyAll(): void;
        nullSafe(): Internal.TypeAdapter<T>;
        notify(): void;
        fromJsonTree(arg0: Internal.JsonElement): T;
        toJson(arg0: T): string;
        toJson(arg0: Internal.Writer, arg1: T): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        toJsonTree(arg0: T): Internal.JsonElement;
        fromJson(arg0: string): T;
        fromJson(arg0: Internal.Reader): T;
        toString(): string;
        write(arg0: Internal.JsonWriter, arg1: T): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class UnmodifiableIterator <E> implements Internal.Iterator<E> {
        next(): E;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        hasNext(): boolean;
        toString(): string;
        forEachRemaining(arg0: (arg0: E) => void): void;
        notify(): void;
        remove(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Function10 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> {
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, (arg0: T10) => R>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function3<T8, T9, T10, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, (arg0: T9, arg1: T10) => R>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function5<T6, T7, T8, T9, T10, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function4<T7, T8, T9, T10, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function7<T4, T5, T6, T7, T8, T9, T10, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function6<T5, T6, T7, T8, T9, T10, R>>;
        curry2(): (arg0: T1, arg1: T2) => Internal.Function8<T3, T4, T5, T6, T7, T8, T9, T10, R>;
        curry(): (arg0: T1) => Internal.Function9<T2, T3, T4, T5, T6, T7, T8, T9, T10, R>;
    }
    interface MinecraftServerAccessorMixin {
        getTickables(): Internal.List<Internal.Runnable>;
    }
    interface Int2IntMap$FastEntrySet extends Internal.ObjectSet<Internal.Int2IntMap$Entry> {
        add(arg0: Internal.Int2IntMap$Entry): boolean;
        spliterator(): Internal.Spliterator<any>;
        spliterator(): Internal.ObjectSpliterator<Internal.Int2IntMap$Entry>;
        forEach(arg0: (arg0: Internal.Int2IntMap$Entry) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        fastIterator(): Internal.ObjectIterator<Internal.Int2IntMap$Entry>;
        remove(arg0: any): boolean;
        removeIf(arg0: (arg0: Internal.Int2IntMap$Entry) => boolean): boolean;
        fastForEach(arg0: (arg0: Internal.Int2IntMap$Entry) => void): void;
        removeAll(arg0: Internal.Collection<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.Iterator<any>;
        iterator(): Internal.ObjectIterator<Internal.Int2IntMap$Entry>;
        size(): number;
        addAll(arg0: Internal.Collection<Internal.Int2IntMap$Entry>): boolean;
        stream(): Internal.Stream<Internal.Int2IntMap$Entry>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<Internal.Int2IntMap$Entry>;
        retainAll(arg0: Internal.Collection<any>): boolean;
    }
    interface BlittableVertexType <T> extends Internal.BufferVertexType<T> {
        getBufferVertexFormat(): Internal.BufferVertexFormat;
        createFallbackWriter(arg0: Internal.VertexConsumer): T;
        createBufferWriter(arg0: Internal.VertexBufferView, arg1: boolean): T;
        createBufferWriter(buffer: Internal.VertexBufferView): T;
        asBlittable(): Internal.BlittableVertexType<T>;
    }
    interface MobSpawnInfoAccess {
        getSpawners(): Internal.Map<Internal.MobCategory, Internal.List<Internal.MobSpawnSettings$SpawnerData>>;
        getMobSpawnCosts(): Internal.Map<Internal.EntityType<any>, Internal.MobSpawnSettings$MobSpawnCost>;
    }
    interface FieldNamingStrategy {
        translateName(arg0: Internal.Field): string;
    }
    interface Stack <K> {
        pop(): K;
        top(): K;
        isEmpty(): boolean;
        push(arg0: K): void;
        peek(arg0: number): K;
    }
    interface StringRepresentable {
    }
    interface DoubleConsumer {
        andThen(arg0: Internal.DoubleConsumer): Internal.DoubleConsumer;
        accept(arg0: number): void;
    }
    interface ContainerEventHandler extends Internal.GuiEventListener {
    }
    class LunarContext {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        createDefaultEventConfigs(): void;
        getCurrentEvent(): Internal.LunarEvent;
        notifyAll(): void;
        getStrength(): number;
        computeLunarForecast(arg0: Internal.ServerLevel, arg1: Internal.LunarForecast): Internal.LunarForecast;
        computeLunarForecast(arg0: Internal.ServerLevel, arg1: Internal.LunarForecast, arg2: number): Internal.LunarForecast;
        addSettingsIfMissing(): void;
        updateForecast(arg0: net.minecraft.world.level.Level, arg1: number): void;
        tick(arg0: net.minecraft.world.level.Level): void;
        getAndComputeLunarForecast(arg0: Internal.ServerLevel): Internal.LunarEventSavedData;
        notify(): void;
        getLunarForecast(): Internal.LunarForecast;
        getLastEvent(): Internal.LunarEvent;
        setStrength(arg0: number): void;
        hashCode(): number;
        getLunarEvents(): Internal.Map<string, Internal.LunarEvent>;
        setLastEvent(arg0: Internal.LunarEvent): void;
        equals(arg0: any): boolean;
        setCurrentEvent(arg0: string): void;
        toString(): string;
        handleEventConfigs(arg0: boolean): void;
        getLunarTimeSettings(): Internal.LunarContext$LunarTimeSettings;
        static readonly CONFIG_NAME : "lunar-settings.json";
        static readonly PACKET_CODEC : Internal.Codec<Internal.LunarContext>;
        get currentEvent(): Internal.LunarEvent;
        get lunarTimeSettings(): Internal.LunarContext$LunarTimeSettings;
        get strength(): number;
        get lunarForecast(): Internal.LunarForecast;
        get lastEvent(): Internal.LunarEvent;
        get lunarEvents(): Internal.Map<string, Internal.LunarEvent>;
        get class(): Internal.Class<any>;
        set strength(arg0: number);
        set lastEvent(arg0: Internal.LunarEvent);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface GroupPrincipal extends Internal.UserPrincipal {
        getName(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        implies(arg0: Internal.Subject): boolean;
    }
    interface LongToDoubleFunction {
        applyAsDouble(arg0: number): number;
    }
    class DoubleSummaryStatistics implements Internal.DoubleConsumer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMax(): number;
        notifyAll(): void;
        getAverage(): number;
        andThen(arg0: Internal.DoubleConsumer): Internal.DoubleConsumer;
        notify(): void;
        accept(arg0: number): void;
        getMin(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getSum(): number;
        getCount(): number;
        combine(arg0: Internal.DoubleSummaryStatistics): void;
        get average(): number;
        get min(): number;
        get max(): number;
        get count(): number;
        get sum(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Short2ReferenceFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: number, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        put(arg0: number, arg1: V): V;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: V): V;
        remove(arg0: number): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): V;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface NavigatingEntity {
        updateNavigationRegistration(): void;
        getRegisteredNavigation(): Internal.PathNavigation;
        isRegisteredToWorld(): boolean;
        setRegisteredToWorld(arg0: Internal.PathNavigation): void;
    }
    interface IntSpliterator extends Internal.Spliterator$OfInt {
        trySplit(): Internal.Spliterator<any>;
        trySplit(): Internal.Spliterator$OfInt;
        trySplit(): Internal.IntSpliterator;
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>;
        characteristics(): number;
        tryAdvance(arg0: (arg0: number) => void): boolean;
        tryAdvance(arg0: (arg0: any) => void): boolean;
        tryAdvance(arg0: java_.util.function_.IntConsumer): boolean;
        tryAdvance(arg0: any): boolean;
        getComparator(): Internal.Comparator<any>;
        getComparator(): Internal.IntComparator;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        skip(arg0: number): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: (arg0: number) => void): void;
        forEachRemaining(arg0: (arg0: any) => void): void;
        forEachRemaining(arg0: any): void;
        forEachRemaining(arg0: java_.util.function_.IntConsumer): void;
    }
    interface ObjIntConsumer <T> {
        accept(arg0: T, arg1: number): void;
    }
    interface Compressable extends Internal.Keyable {
        keys<T_>(arg0: Internal.DynamicOps<T_>): Internal.Stream<T_>;
        compressor<T_>(arg0: Internal.DynamicOps<T_>): Internal.KeyCompressor<T_>;
    }
    interface Char2LongFunction extends it.unimi.dsi.fastutil.Function<string, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: string, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: string) => T_;
        put(arg0: string, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: string, arg1: number): number;
        remove(arg0: string): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: string): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: string): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsLong(arg0: number): number;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class PrintWriter extends Internal.Writer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        format(arg0: string, arg1: any[]): Internal.PrintWriter;
        format(arg0: Internal.Locale, arg1: string, arg2: any[]): Internal.PrintWriter;
        checkError(): boolean;
        notify(): void;
        printf(arg0: string, arg1: any[]): Internal.PrintWriter;
        printf(arg0: Internal.Locale, arg1: string, arg2: any[]): Internal.PrintWriter;
        print(arg0: number): void;
        print(arg0: number): void;
        print(arg0: number): void;
        print(arg0: string): void;
        print(arg0: boolean): void;
        print(arg0: any): void;
        print(arg0: string): void;
        print(arg0: string[]): void;
        print(arg0: number): void;
        println(arg0: string[]): void;
        println(): void;
        println(arg0: boolean): void;
        println(arg0: string): void;
        println(arg0: any): void;
        println(arg0: number): void;
        println(arg0: number): void;
        println(arg0: number): void;
        println(arg0: number): void;
        println(arg0: string): void;
        flush(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        static nullWriter(): Internal.Writer;
        toString(): string;
        close(): void;
        write(arg0: string[], arg1: number, arg2: number): void;
        write(arg0: string): void;
        write(arg0: string, arg1: number, arg2: number): void;
        write(arg0: string[]): void;
        write(arg0: number): void;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.PrintWriter;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Writer;
        append(arg0: string): Internal.PrintWriter;
        append(arg0: string): Internal.Appendable;
        append(arg0: string): Internal.Writer;
        append(arg0: Internal.CharSequence): Internal.PrintWriter;
        append(arg0: Internal.CharSequence): Internal.Appendable;
        append(arg0: Internal.CharSequence): Internal.Writer;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class SoundEvent extends Internal.ForgeRegistryEntry<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.SoundEvent>;
        getRegistryName(): ResourceLocation;
        toString(): string;
        setRegistryName(arg0: string, arg1: string): Internal.SoundEvent;
        setRegistryName(arg0: ResourceLocation): any;
        setRegistryName(arg0: ResourceLocation): Internal.SoundEvent;
        setRegistryName(arg0: string): Internal.SoundEvent;
        notify(): void;
        readonly delegate : () => Internal.SoundEvent;
        get registryType(): Internal.Class<Internal.SoundEvent>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MapJS extends Internal.LinkedHashMap<any, any> implements Internal.StringBuilderAppendable, Internal.ChangeListener<any>, Internal.Copyable, Internal.JsonSerializable, Internal.NBTSerializable {
        getClass(): Internal.Class<any>;
        static nbt(map: any): Internal.CompoundTag;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: any): any;
        notifyAll(): void;
        computeIfAbsent(arg0: string, arg1: (arg0: string) => any): any;
        values(): Internal.Collection<any>;
        replace(arg0: string, arg1: any): any;
        replace(arg0: string, arg1: any, arg2: any): boolean;
        static isNbt(o: any): boolean;
        replaceAll(arg0: (arg0: string, arg1: any) => any): void;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(key: string, value: any): any;
        put(arg0: any, arg1: any): any;
        remove(key: any): any;
        remove(arg0: any, arg1: any): boolean;
        compute(arg0: string, arg1: (arg0: string, arg1: any) => any): any;
        toNBT(): Internal.Tag;
        toNBT(): Internal.CompoundTag;
        getOrNewList(id: string): Internal.ListJS;
        hashCode(): number;
        merge(arg0: string, arg1: any, arg2: (arg0: any, arg1: any) => any): any;
        get(arg0: any): any;
        putAll(m: Internal.Map<string, any>): void;
        static of(o: any): Internal.MapJS;
        static json(map: any): Internal.JsonObject;
        copy(): Internal.MapJS;
        copy(): Internal.Copyable;
        keySet(): Internal.Set<string>;
        appendString(builder: Internal.StringBuilder): void;
        onChanged(o: any): void;
        entrySet(): Internal.Set<Internal.Map$Entry<string, any>>;
        containsKey(arg0: any): boolean;
        forEach(arg0: (arg0: string, arg1: any) => void): void;
        containsAll(other: Internal.MapJS): boolean;
        isEmpty(): boolean;
        containsAny(other: Internal.MapJS): boolean;
        clear(): void;
        toJson(): Internal.JsonElement;
        toJson(): Internal.JsonObject;
        computeIfPresent(arg0: string, arg1: (arg0: string, arg1: any) => any): any;
        size(): number;
        getOrNewMap(id: string): Internal.MapJS;
        equals(arg0: any): boolean;
        clone(): any;
        getLength(): number;
        toString(): string;
        putIfAbsent(arg0: string, arg1: any): any;
        changeListener : Internal.ChangeListener<Internal.MapJS>;
        get length(): number;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PackResources extends Internal.AutoCloseable, Internal.IForgePackResources {
        close(): void;
        isHidden(): boolean;
    }
    interface Function12 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R> {
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function3<T10, T11, T12, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function5<T8, T9, T10, T11, T12, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function4<T9, T10, T11, T12, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function7<T6, T7, T8, T9, T10, T11, T12, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function6<T7, T8, T9, T10, T11, T12, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function9<T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, (arg0: T11, arg1: T12) => R>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function8<T5, T6, T7, T8, T9, T10, T11, T12, R>>;
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, (arg0: T12) => R>;
        curry2(): (arg0: T1, arg1: T2) => Internal.Function10<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>;
        curry(): (arg0: T1) => Internal.Function11<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>;
    }
    interface LivingEntityKJS {
        foodEatenKJS(is: Internal.ItemStack): void;
    }
    interface IDataManager {
        getDirtyEntries(): Internal.Set<Internal.IDataManager$DataEntry<any>>;
        getValue<T>(arg0: Internal.TrackedData<T>): T;
        setDataMap(arg0: Internal.Map<Internal.TrackedData<any>, Internal.IDataManager$DataEntry<any>>): void;
        isDirty(): boolean;
        getEntries(arg0: boolean): Internal.Set<Internal.IDataManager$DataEntry<any>>;
        setValue<T>(arg0: Internal.TrackedData<T>, arg1: T): void;
        clean(): void;
        getDataMap(): Internal.Map<Internal.TrackedData<any>, Internal.IDataManager$DataEntry<any>>;
    }
    abstract class LivingEntity extends Internal.Entity implements Internal.ICitadelDataEntity, net.blay09.mods.clienttweaks.mixin.LivingEntityAccessor, Internal.LivingEntityKJS, net.blay09.mods.netherportalfix.mixin.LivingEntityAccessor, Internal.BlockCachingEntity, Internal.EquipmentEntity, Internal.LivingEntityAccessor {
        getClass(): Internal.Class<any>;
        backpackedMoved(): boolean;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>;
        handler$zje000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void;
        onEndimationEnd(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        canBeRiddenInWater(arg0: Internal.Entity): boolean;
        handler$zzo000$tickHead(arg0: Internal.CallbackInfo): void;
        setCitadelEntityData(arg0: Internal.CompoundTag): void;
        isEndimationPlaying(arg0: Internal.PlayableEndimation): boolean;
        isActive(): boolean;
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void;
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity;
        getCachedFeetBlockState(): Internal.BlockState;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        handler$bfj000$tryShortcutFluidPushing(tag: net.minecraft.tags.Tag<any>, speed: number, cir: Internal.CallbackInfoReturnable<any>, box: Internal.AABB, x1: number, x2: number, y1: number, y2: number, z1: number, z2: number, zero: number): void;
        getPos(): Internal.Position;
        foodEatenKJS(is: Internal.ItemStack): void;
        revive(): void;
        static getDataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(arg0: boolean): void;
        canUpdate(): boolean;
        getEndimatedState(): Internal.Endimatable$EndimatedState;
        resetEndimation(): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean;
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number;
        reviveCaps(): void;
        lithiumOnBlockCacheDeleted(): void;
        canRiderInteract(): boolean;
        getEntries(arg0: boolean): Internal.Set<any>;
        getEffectHandler(): Internal.EndimationEffectHandler;
        onAddedToWorld(): void;
        setAnimationTick(arg0: number): void;
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        static getDataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        getListener(): Internal.NearbyEntityListenerMulti;
        getClassification(arg0: boolean): Internal.MobCategory;
        isNoEndimationPlaying(): boolean;
        onEndimationStart(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listenForCachedBlockChanges: boolean): void;
        shouldRiderSit(): boolean;
        getIsInsidePortal(): boolean;
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$zje000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        handler$zcg000$read(arg0: Internal.CompoundTag, arg1: Internal.CallbackInfo): void;
        getRemainingFireTicks(): number;
        lithiumOnEquipmentChanged(): void;
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void;
        notify(): void;
        getDataMap(): Internal.Map<any, any>;
        handler$zzo000$moveStep(arg0: Internal.MoverType, arg1: Vec3, arg2: Internal.CallbackInfo): void;
        getEntityChangeListener(): Internal.EntityInLevelCallback;
        endimateTick(): void;
        setDataMap(arg0: Internal.Map<any, any>): void;
        isDirty(): boolean;
        hashCode(): number;
        getLastPos(): BlockPos;
        isAddedToWorld(): boolean;
        getParts(): any[];
        addListener(listener: Internal.NearbyEntityListener): void;
        onRemovedFromWorld(): void;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        curePotionEffects(arg0: Internal.ItemStack): boolean;
        clean(): void;
        asKJS(): any;
        getPlayingEndimation(): Internal.PlayableEndimation;
        getDirtyEntries(): Internal.Set<any>;
        getValue(arg0: Internal.TrackedData<any>): any;
        shouldRiderFaceForward(arg0: Internal.Player): boolean;
        setPlayingEndimation(arg0: Internal.PlayableEndimation): void;
        setValue(arg0: Internal.TrackedData<any>, arg1: any): void;
        equals(arg0: any): boolean;
        getAnimationTick(): number;
        toString(): string;
        setRemainingFireTicks(arg0: number): void;
        handler$zgd001$tick(arg0: Internal.CallbackInfo): void;
        get citadelEntityData(): Internal.CompoundTag;
        get listener(): Internal.NearbyEntityListenerMulti;
        get addedToWorld(): boolean;
        get animationTick(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get pos(): Internal.Position;
        get dataMap(): Internal.Map<any, any>;
        get noEndimationPlaying(): boolean;
        get class(): Internal.Class<any>;
        get dirty(): boolean;
        get dataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get entityChangeListener(): Internal.EntityInLevelCallback;
        get multipartEntity(): boolean;
        get active(): boolean;
        get playingEndimation(): Internal.PlayableEndimation;
        get effectHandler(): Internal.EndimationEffectHandler;
        get cachedFeetBlockState(): Internal.BlockState;
        get lastPos(): BlockPos;
        get dirtyEntries(): Internal.Set<any>;
        get dataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        get parts(): any[];
        get endimatedState(): Internal.Endimatable$EndimatedState;
        set animationTick(arg0: number);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set dataMap(arg0: Internal.Map<any, any>);
        set playingEndimation(arg0: Internal.PlayableEndimation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PlayerKJS {
        setStagesKJS(arg0: Internal.Stages): void;
        getStagesRawKJS(): Internal.Stages;
        getStagesKJS(): Internal.Stages;
    }
    class ModuleDescriptor$Requires$Modifier extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ModuleDescriptor$Requires$Modifier;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ModuleDescriptor$Requires$Modifier[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ModuleDescriptor$Requires$Modifier): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ModuleDescriptor$Requires$Modifier>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ModuleDescriptor$Requires$Modifier>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly TRANSITIVE : Internal.ModuleDescriptor$Requires$Modifier;
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Requires$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Requires$Modifier;
        static readonly STATIC : Internal.ModuleDescriptor$Requires$Modifier;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ModuleDescriptor$Requires$Modifier>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface DataOutput {
        writeChar(arg0: number): void;
        writeInt(arg0: number): void;
        writeLong(arg0: number): void;
        writeByte(arg0: number): void;
        writeBytes(arg0: string): void;
        writeUTF(arg0: string): void;
        writeShort(arg0: number): void;
        writeChars(arg0: string): void;
        writeFloat(arg0: number): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        write(arg0: number[]): void;
        write(arg0: number): void;
        writeBoolean(arg0: boolean): void;
        writeDouble(arg0: number): void;
    }
    interface NonNullConsumer <T> {
        accept(arg0: T): void;
    }
    class EntityPotionEffectsJS {
        add(mobEffect: Internal.MobEffect, duration: number): void;
        add(mobEffect: Internal.MobEffect, duration: number, amplifier: number): void;
        add(mobEffect: Internal.MobEffect): void;
        add(mobEffect: Internal.MobEffect, duration: number, amplifier: number, ambient: boolean, showParticles: boolean): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isApplicable(effect: Internal.MobEffectInstance): boolean;
        clear(): void;
        isActive(mobEffect: Internal.MobEffect): boolean;
        notify(): void;
        getMap(): Internal.Map<Internal.MobEffect, Internal.MobEffectInstance>;
        getDuration(mobEffect: Internal.MobEffect): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getActive(): Internal.Collection<Internal.MobEffectInstance>;
        getActive(mobEffect: Internal.MobEffect): Internal.MobEffectInstance;
        get active(): Internal.Collection<Internal.MobEffectInstance>;
        get class(): Internal.Class<any>;
        get map(): Internal.Map<Internal.MobEffect, Internal.MobEffectInstance>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeBlockState {
        rotate(arg0: Internal.LevelAccessor, arg1: BlockPos, arg2: Internal.Rotation): Internal.BlockState;
        getStateAtViewpoint(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Vec3): Internal.BlockState;
        onBlockExploded(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Explosion): void;
        getBedDirection(arg0: Internal.LevelReader, arg1: BlockPos): Internal.Direction;
        getExpDrop(arg0: Internal.LevelReader, arg1: BlockPos, arg2: number, arg3: number): number;
        isConduitFrame(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): boolean;
        getLightEmission(arg0: Internal.BlockGetter, arg1: BlockPos): number;
        onDestroyedByPlayer(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Player, arg3: boolean, arg4: Internal.FluidState): boolean;
        isBed(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.LivingEntity): boolean;
        canHarvestBlock(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Player): boolean;
        shouldCheckWeakPower(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Direction): boolean;
        collisionExtendsVertically(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Entity): boolean;
        isLadder(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.LivingEntity): boolean;
        addLandingEffects(arg0: Internal.ServerLevel, arg1: BlockPos, arg2: Internal.BlockState, arg3: Internal.LivingEntity, arg4: number): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockAndTintGetter, arg1: BlockPos, arg2: Internal.FluidState): boolean;
        getSoundType(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity): Internal.SoundType;
        canStickTo(arg0: Internal.BlockState): boolean;
        onNeighborChange(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): void;
        addRunningEffects(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Entity): boolean;
        getWeakChanges(arg0: Internal.LevelReader, arg1: BlockPos): boolean;
        isBurning(arg0: Internal.BlockGetter, arg1: BlockPos): boolean;
        canEntityDestroy(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Entity): boolean;
        getCloneItemStack(arg0: Internal.HitResult, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Player): Internal.ItemStack;
        getFriction(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Entity): number;
        isFlammable(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): boolean;
        isValidSpawn(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.SpawnPlacements$Type, arg3: Internal.EntityType<any>): boolean;
        isPortalFrame(arg0: Internal.BlockGetter, arg1: BlockPos): boolean;
        getExplosionResistance(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): number;
        getBlockPathType(arg0: Internal.BlockGetter, arg1: BlockPos): Internal.BlockPathTypes;
        getBlockPathType(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Mob): Internal.BlockPathTypes;
        canSustainPlant(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction, arg3: Internal.IPlantable): boolean;
        isScaffolding(arg0: Internal.LivingEntity): boolean;
        onCaughtFire(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Direction, arg3: Internal.LivingEntity): void;
        getEnchantPowerBonus(arg0: Internal.LevelReader, arg1: BlockPos): number;
        setBedOccupied(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.LivingEntity, arg3: boolean): void;
        isFireSource(arg0: Internal.LevelReader, arg1: BlockPos, arg2: Internal.Direction): boolean;
        canDropFromExplosion(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Explosion): boolean;
        getRespawnPosition(arg0: Internal.EntityType<any>, arg1: Internal.LevelReader, arg2: BlockPos, arg3: number, arg4: Internal.LivingEntity): Internal.Optional<Vec3>;
        canRedstoneConnectTo(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): boolean;
        isStickyBlock(): boolean;
        isFertile(arg0: Internal.BlockGetter, arg1: BlockPos): boolean;
        isSlimeBlock(): boolean;
        getFlammability(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): number;
        getFireSpreadSpeed(arg0: Internal.BlockGetter, arg1: BlockPos, arg2: Internal.Direction): number;
        getToolModifiedState(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.Player, arg3: Internal.ItemStack, arg4: Internal.ToolAction): Internal.BlockState;
        getBeaconColorMultiplier(arg0: Internal.LevelReader, arg1: BlockPos, arg2: BlockPos): number[];
    }
    interface MessageSizeEstimator$Handle {
        size(arg0: any): number;
    }
    class PlayableEndimation$LoopType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.PlayableEndimation$LoopType;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.PlayableEndimation$LoopType[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.PlayableEndimation$LoopType): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.PlayableEndimation$LoopType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.PlayableEndimation$LoopType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly LOOP : Internal.PlayableEndimation$LoopType;
        static readonly NONE : Internal.PlayableEndimation$LoopType;
        static readonly HOLD : Internal.PlayableEndimation$LoopType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.PlayableEndimation$LoopType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class DynamicLike <T> {
        createIntList(arg0: Internal.IntStream): Internal.Dynamic<any>;
        createLong(arg0: number): Internal.Dynamic<T>;
        getClass(): Internal.Class<any>;
        getElementGeneric(arg0: T, arg1: T): T;
        getElementGeneric(arg0: T): Internal.DataResult<T>;
        createLongList(arg0: Internal.LongStream): Internal.Dynamic<any>;
        readMap<K, V>(arg0: Internal.Decoder<K>, arg1: Internal.Decoder<V>): Internal.DataResult<Internal.List<Internal.Pair<K, V>>>;
        readMap<K, V>(arg0: Internal.Decoder<K>, arg1: (arg0: K) => Internal.Decoder<V>): Internal.DataResult<Internal.List<Internal.Pair<K, V>>>;
        readMap<R>(arg0: Internal.DataResult<R>, arg1: Internal.Function3<R, Internal.Dynamic<T>, Internal.Dynamic<T>, Internal.DataResult<R>>): Internal.DataResult<R>;
        asListOpt<U>(arg0: (arg0: Internal.Dynamic<T>) => U): Internal.DataResult<Internal.List<U>>;
        createShort(arg0: number): Internal.Dynamic<T>;
        decode<A>(arg0: Internal.Decoder<A>): Internal.DataResult<Internal.Pair<A, T>>;
        asIntStreamOpt(): Internal.DataResult<Internal.IntStream>;
        asList<U>(arg0: (arg0: Internal.Dynamic<T>) => U): Internal.List<U>;
        readList<E>(arg0: (arg0: Internal.Dynamic<any>) => Internal.DataResult<E>): Internal.DataResult<Internal.List<E>>;
        readList<E>(arg0: Internal.Decoder<E>): Internal.DataResult<Internal.List<E>>;
        asString(): Internal.DataResult<string>;
        asString(arg0: string): string;
        asByte(arg0: number): number;
        createList(arg0: Internal.Stream<Internal.Dynamic<any>>): Internal.Dynamic<T>;
        asByteBufferOpt(): Internal.DataResult<Internal.ByteBuffer>;
        read<A>(arg0: Internal.Decoder<A>): Internal.DataResult<A>;
        asMapOpt<K, V>(arg0: (arg0: Internal.Dynamic<T>) => K, arg1: (arg0: Internal.Dynamic<T>) => V): Internal.DataResult<Internal.Map<K, V>>;
        asMapOpt(): Internal.DataResult<Internal.Stream<Internal.Pair<Internal.Dynamic<T>, Internal.Dynamic<T>>>>;
        getGeneric(arg0: T): Internal.DataResult<T>;
        createString(arg0: string): Internal.Dynamic<T>;
        asStream(): Internal.Stream<Internal.Dynamic<T>>;
        asLong(arg0: number): number;
        createByte(arg0: number): Internal.Dynamic<T>;
        asDouble(arg0: number): number;
        asBoolean(arg0: boolean): boolean;
        asLongStreamOpt(): Internal.DataResult<Internal.LongStream>;
        createDouble(arg0: number): Internal.Dynamic<T>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        asStreamOpt(): Internal.DataResult<Internal.Stream<Internal.Dynamic<T>>>;
        asMap<K, V>(arg0: (arg0: Internal.Dynamic<T>) => K, arg1: (arg0: Internal.Dynamic<T>) => V): Internal.Map<K, V>;
        notifyAll(): void;
        asIntStream(): Internal.IntStream;
        createByteList(arg0: Internal.ByteBuffer): Internal.Dynamic<any>;
        asByteBuffer(): Internal.ByteBuffer;
        asFloat(arg0: number): number;
        asLongStream(): Internal.LongStream;
        notify(): void;
        createBoolean(arg0: boolean): Internal.Dynamic<T>;
        asInt(arg0: number): number;
        emptyList(): Internal.Dynamic<T>;
        hashCode(): number;
        asShort(arg0: number): number;
        get(arg0: string): Internal.OptionalDynamic<T>;
        emptyMap(): Internal.Dynamic<T>;
        createNumeric(arg0: Internal.Number): Internal.Dynamic<T>;
        asNumber(arg0: Internal.Number): Internal.Number;
        asNumber(): Internal.DataResult<Internal.Number>;
        createMap(arg0: Internal.Map<Internal.Dynamic<any>, Internal.Dynamic<any>>): Internal.Dynamic<T>;
        createFloat(arg0: number): Internal.Dynamic<T>;
        getOps(): Internal.DynamicOps<T>;
        getElement(arg0: string): Internal.DataResult<T>;
        getElement(arg0: string, arg1: T): T;
        equals(arg0: any): boolean;
        createInt(arg0: number): Internal.Dynamic<T>;
        toString(): string;
        get ops(): Internal.DynamicOps<T>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IdMap <T> extends Internal.Iterable<T> {
        iterator(): Internal.Iterator<T>;
        spliterator(): Internal.Spliterator<T>;
        forEach(arg0: (arg0: T) => void): void;
    }
    class RecordCodecBuilder$Mu <O> implements Internal.K1 {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractIntSet extends Internal.AbstractIntCollection implements Internal.Cloneable, Internal.IntSet {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
        notify(): void;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        intStream(): Internal.IntStream;
        removeAll(arg0: Internal.IntCollection): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.IntIterator;
        iterator(): Internal.Iterator<any>;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toIntArray(arg0: number[]): number[];
        toIntArray(): number[];
        toArray(arg0: number[]): number[];
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        add(arg0: number): boolean;
        add(arg0: any): boolean;
        spliterator(): Internal.IntSpliterator;
        spliterator(): Internal.Spliterator<any>;
        forEach(arg0: (arg0: any) => void): void;
        forEach(arg0: (arg0: number) => void): void;
        forEach(arg0: java_.util.function_.IntConsumer): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        containsAll(arg0: Internal.IntCollection): boolean;
        isEmpty(): boolean;
        clear(): void;
        removeIf(arg0: (arg0: any) => boolean): boolean;
        removeIf(arg0: (arg0: number) => boolean): boolean;
        removeIf(arg0: Internal.IntPredicate): boolean;
        contains(arg0: number): boolean;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.IntCollection): boolean;
        addAll(arg0: Internal.Collection<number>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        intParallelStream(): Internal.IntStream;
        retainAll(arg0: Internal.Collection<any>): boolean;
        retainAll(arg0: Internal.IntCollection): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModelGenerator$Face {
        getClass(): Internal.Class<any>;
        uv(u0: number, v0: number, u1: number, v1: number): Internal.ModelGenerator$Face;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toJson(): Internal.JsonObject;
        hashCode(): number;
        tex(t: string): Internal.ModelGenerator$Face;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        cull(): Internal.ModelGenerator$Face;
        cull(d: Internal.Direction): Internal.ModelGenerator$Face;
        notify(): void;
        tintindex(i: number): Internal.ModelGenerator$Face;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Collection <E> extends Internal.Iterable<E> {
        add(arg0: E): boolean;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: (arg0: E) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        remove(arg0: any): boolean;
        removeIf(arg0: (arg0: E) => boolean): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.Iterator<E>;
        size(): number;
        addAll(arg0: Internal.Collection<E>): boolean;
        stream(): Internal.Stream<E>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<E>;
        retainAll(arg0: Internal.Collection<any>): boolean;
    }
    class LevelSettings {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class IERecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(arg0: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        energy(e: number): Internal.IERecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        serialize(): void;
        setGroup(g: string): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        time(t: number): Internal.IERecipeJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<net.minecraftforge.fluids.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MultiBufferSource$BufferSource implements Internal.MultiBufferSource {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class GlNumericType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.GlNumericType;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.GlNumericType[];
        static byName(arg0: string): Internal.GlNumericType;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.GlNumericType): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.GlNumericType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.GlNumericType>;
        getGlEnum(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        castAndBuffer(arg0: Internal.ByteBuffer, arg1: number): void;
        name(): string;
        toString(): string;
        getTypeName(): string;
        getByteWidth(): number;
        ordinal(): number;
        static readonly UBYTE : Internal.GlNumericType;
        static readonly FLOAT : Internal.GlNumericType;
        static readonly BYTE : Internal.GlNumericType;
        static readonly USHORT : Internal.GlNumericType;
        static readonly UINT : Internal.GlNumericType;
        static readonly INT : Internal.GlNumericType;
        static readonly SHORT : Internal.GlNumericType;
        get glEnum(): number;
        get byteWidth(): number;
        get typeName(): string;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.GlNumericType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Decoder <A> {
        simple(): Internal.Decoder$Simple<A>;
        terminal(): Internal.Decoder$Terminal<A>;
        parse<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<A>;
        parse<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<A>;
        withLifecycle(arg0: Internal.Lifecycle): Internal.Decoder<A>;
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: T): Internal.DataResult<Internal.Pair<A, T>>;
        decode<T>(arg0: Internal.Dynamic<T>): Internal.DataResult<Internal.Pair<A, T>>;
        promotePartial(arg0: (arg0: string) => void): Internal.Decoder<A>;
        flatMap<B>(arg0: (arg0: A) => Internal.DataResult<B>): Internal.Decoder<B>;
        boxed(): Internal.Decoder$Boxed<A>;
        fieldOf(arg0: string): Internal.MapDecoder<A>;
        map<B>(arg0: (arg0: A) => B): Internal.Decoder<B>;
    }
    abstract class Direction$Axis extends Internal.Enum<any> implements Internal.StringRepresentable, Internal.Predicate<Internal.Direction> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: (arg0: Internal.Direction) => boolean): (arg0: Internal.Direction) => boolean;
        test(arg0: Internal.Direction): boolean;
        test(arg0: any): boolean;
        static valueOf(arg0: string): (arg0: any) => boolean;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): (arg0: any) => boolean[];
        compareTo(arg0: any): number;
        compareTo(arg0: (arg0: any) => boolean): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<(arg0: any) => boolean>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<(arg0: any) => boolean>;
        and(arg0: (arg0: Internal.Direction) => boolean): (arg0: Internal.Direction) => boolean;
        negate(): (arg0: Internal.Direction) => boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly X : (arg0: any) => boolean;
        static readonly Y : (arg0: any) => boolean;
        static readonly Z : (arg0: any) => boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<(arg0: any) => boolean>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Inventory implements Internal.Container, Internal.Nameable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        handler$zbe000$removeItemTail(arg0: Internal.ItemStack, arg1: Internal.CallbackInfo): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class OptionalInt {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isEmpty(): boolean;
        isPresent(): boolean;
        orElse(arg0: number): number;
        notify(): void;
        getAsInt(): number;
        orElseThrow<X>(arg0: () => X): number;
        orElseThrow(): number;
        static empty(): Internal.OptionalInt;
        orElseGet(arg0: Internal.IntSupplier): number;
        stream(): Internal.IntStream;
        hashCode(): number;
        ifPresentOrElse(arg0: java_.util.function_.IntConsumer, arg1: Internal.Runnable): void;
        ifPresent(arg0: java_.util.function_.IntConsumer): void;
        static of(arg0: number): Internal.OptionalInt;
        equals(arg0: any): boolean;
        toString(): string;
        get asInt(): number;
        get present(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Entity extends Internal.CapabilityProvider<any> implements Internal.Nameable, Internal.EntityAccess, Internal.CommandSource, Internal.IForgeEntity, Internal.IMovedAccess, Internal.IDataManager, Internal.Endimatable, blusunrize.immersiveengineering.mixin.accessors.EntityAccess, Internal.EntityKJS, Internal.EntityAccessor, Internal.NearbyEntityListenerProvider, me.jellysquid.mods.lithium.mixin.block.hopper.EntityAccessor, Internal.BlockCachingEntity {
        getClass(): Internal.Class<any>;
        backpackedMoved(): boolean;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>;
        handler$zje000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void;
        onEndimationEnd(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        canBeRiddenInWater(arg0: Internal.Entity): boolean;
        handler$zzo000$tickHead(arg0: Internal.CallbackInfo): void;
        isEndimationPlaying(arg0: Internal.PlayableEndimation): boolean;
        isActive(): boolean;
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity;
        getCachedFeetBlockState(): Internal.BlockState;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        handler$bfj000$tryShortcutFluidPushing(tag: net.minecraft.tags.Tag<any>, speed: number, cir: Internal.CallbackInfoReturnable<any>, box: Internal.AABB, x1: number, x2: number, y1: number, y2: number, z1: number, z2: number, zero: number): void;
        getPos(): Internal.Position;
        revive(): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(arg0: boolean): void;
        canUpdate(): boolean;
        getEndimatedState(): Internal.Endimatable$EndimatedState;
        resetEndimation(): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean;
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number;
        reviveCaps(): void;
        lithiumOnBlockCacheDeleted(): void;
        canRiderInteract(): boolean;
        getEntries(arg0: boolean): Internal.Set<any>;
        getEffectHandler(): Internal.EndimationEffectHandler;
        onAddedToWorld(): void;
        setAnimationTick(arg0: number): void;
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean;
        getListener(): Internal.NearbyEntityListenerMulti;
        getClassification(arg0: boolean): Internal.MobCategory;
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listening: boolean): void;
        isNoEndimationPlaying(): boolean;
        onEndimationStart(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        shouldRiderSit(): boolean;
        getIsInsidePortal(): boolean;
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$zje000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        handler$zcg000$read(arg0: Internal.CompoundTag, arg1: Internal.CallbackInfo): void;
        getRemainingFireTicks(): number;
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void;
        notify(): void;
        getDataMap(): Internal.Map<any, any>;
        handler$zzo000$moveStep(arg0: Internal.MoverType, arg1: Vec3, arg2: Internal.CallbackInfo): void;
        getEntityChangeListener(): Internal.EntityInLevelCallback;
        endimateTick(): void;
        setDataMap(arg0: Internal.Map<any, any>): void;
        isDirty(): boolean;
        hashCode(): number;
        isAddedToWorld(): boolean;
        getParts(): any[];
        addListener(listener: Internal.NearbyEntityListener): void;
        onRemovedFromWorld(): void;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        clean(): void;
        asKJS(): any;
        getPlayingEndimation(): Internal.PlayableEndimation;
        getDirtyEntries(): Internal.Set<any>;
        getValue(arg0: Internal.TrackedData<any>): any;
        setPlayingEndimation(arg0: Internal.PlayableEndimation): void;
        setValue(arg0: Internal.TrackedData<any>, arg1: any): void;
        equals(arg0: any): boolean;
        getAnimationTick(): number;
        toString(): string;
        setRemainingFireTicks(arg0: number): void;
        handler$zgd001$tick(arg0: Internal.CallbackInfo): void;
        get dirty(): boolean;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get entityChangeListener(): Internal.EntityInLevelCallback;
        get listener(): Internal.NearbyEntityListenerMulti;
        get multipartEntity(): boolean;
        get active(): boolean;
        get addedToWorld(): boolean;
        get playingEndimation(): Internal.PlayableEndimation;
        get effectHandler(): Internal.EndimationEffectHandler;
        get cachedFeetBlockState(): Internal.BlockState;
        get dirtyEntries(): Internal.Set<any>;
        get animationTick(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get pos(): Internal.Position;
        get dataMap(): Internal.Map<any, any>;
        get noEndimationPlaying(): boolean;
        get parts(): any[];
        get endimatedState(): Internal.Endimatable$EndimatedState;
        get class(): Internal.Class<any>;
        set animationTick(arg0: number);
        set remainingFireTicks(arg0: number);
        set dataMap(arg0: Internal.Map<any, any>);
        set playingEndimation(arg0: Internal.PlayableEndimation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Matrix4f implements Internal.MatrixWrite, Internal.Matrix4fExtended {
        multiplyBackward(arg0: Internal.Matrix4f): void;
        getClass(): Internal.Class<any>;
        rotate(quaternion: Internal.Quaternion): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        setTranslation(arg0: number, arg1: number, arg2: number): void;
        flywheel$write(arg0: Internal.VecBuffer): void;
        notify(): void;
        translate(x: number, y: number, z: number): void;
        hashCode(): number;
        flywheel$writeUnsafe(arg0: number): void;
        equals(arg0: any): boolean;
        transformVecZ(x: number, y: number, z: number): number;
        transformVecY(x: number, y: number, z: number): number;
        toString(): string;
        transformVecX(x: number, y: number, z: number): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Short2DoubleFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface Int2CharFunction extends it.unimi.dsi.fastutil.Function<number, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: number, arg1: string): string;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: number, arg1: string): string;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: string): string;
        remove(arg0: number): string;
        remove(arg0: any): string;
        remove(arg0: any): any;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): string;
        get(arg0: any): any;
        get(arg0: number): string;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): string;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => string;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface MultiBufferSource {
    }
    interface IntStream$IntMapMultiConsumer {
        accept(arg0: number, arg1: java_.util.function_.IntConsumer): void;
    }
    class KeyCompressor <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        decompress(arg0: number): T;
        size(): number;
        compress(arg0: T): number;
        compress(arg0: string): number;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class VecBuffer {
        getClass(): Internal.Class<any>;
        putVec2(arg0: number, arg1: number): Internal.VecBuffer;
        putVec2(arg0: number, arg1: number): Internal.VecBuffer;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        putVec3(arg0: number, arg1: number, arg2: number): Internal.VecBuffer;
        putVec3(arg0: number, arg1: number, arg2: number): Internal.VecBuffer;
        putVec4(arg0: number, arg1: number, arg2: number, arg3: number): Internal.VecBuffer;
        putInt(arg0: number): Internal.VecBuffer;
        notifyAll(): void;
        putColor(arg0: number, arg1: number, arg2: number, arg3: number): Internal.VecBuffer;
        putColor(arg0: number, arg1: number, arg2: number, arg3: number): Internal.VecBuffer;
        notify(): void;
        put(arg0: number): Internal.VecBuffer;
        put(arg0: Internal.FloatBuffer): Internal.VecBuffer;
        put(arg0: Internal.ByteBuffer): Internal.VecBuffer;
        putByteArray(arg0: number[]): Internal.VecBuffer;
        unwrap(): Internal.ByteBuffer;
        putFloat(arg0: number): Internal.VecBuffer;
        static allocate(arg0: number): Internal.VecBuffer;
        rewind(): Internal.VecBuffer;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        position(arg0: number): Internal.VecBuffer;
        position(): number;
        putShort(arg0: number): Internal.VecBuffer;
        putFloatArray(arg0: number[]): Internal.VecBuffer;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CopyNameFunction$NameSource extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.CopyNameFunction$NameSource;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.CopyNameFunction$NameSource[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.CopyNameFunction$NameSource): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.CopyNameFunction$NameSource>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.CopyNameFunction$NameSource>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly KILLER_PLAYER : Internal.CopyNameFunction$NameSource;
        static readonly KILLER : Internal.CopyNameFunction$NameSource;
        static readonly BLOCK_ENTITY : Internal.CopyNameFunction$NameSource;
        static readonly THIS : Internal.CopyNameFunction$NameSource;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.CopyNameFunction$NameSource>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Fluid extends Internal.ForgeRegistryEntry<any> implements Internal.IForgeFluid, Internal.FluidInvokerMixin {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAttributes(): Internal.FluidAttributes;
        getExplosionResistance(arg0: Internal.FluidState, arg1: Internal.BlockGetter, arg2: BlockPos, arg3: Internal.Explosion): number;
        notifyAll(): void;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: string, arg1: string): Internal.Fluid;
        setRegistryName(arg0: ResourceLocation): any;
        setRegistryName(arg0: ResourceLocation): Internal.Fluid;
        setRegistryName(arg0: string): Internal.Fluid;
        getTags(): Internal.Set<ResourceLocation>;
        isAABBInsideMaterial(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.AABB, arg4: net.minecraft.world.level.material.Material): boolean;
        isEntityInside(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Entity, arg4: number, arg5: Internal.SetTag<Internal.Fluid>, arg6: boolean): boolean;
        notify(): void;
        isAABBInsideLiquid(arg0: Internal.FluidState, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.AABB): boolean;
        callAnimateTick(arg0: net.minecraft.world.level.Level, arg1: BlockPos, arg2: Internal.FluidState, arg3: Internal.Random): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.Fluid>;
        toString(): string;
        readonly delegate : () => Internal.Fluid;
        get registryType(): Internal.Class<Internal.Fluid>;
        get attributes(): Internal.FluidAttributes;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class PrintStream extends Internal.FilterOutputStream implements Internal.Appendable, Internal.Closeable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        format(arg0: string, arg1: any[]): Internal.PrintStream;
        format(arg0: Internal.Locale, arg1: string, arg2: any[]): Internal.PrintStream;
        checkError(): boolean;
        notify(): void;
        printf(arg0: Internal.Locale, arg1: string, arg2: any[]): Internal.PrintStream;
        printf(arg0: string, arg1: any[]): Internal.PrintStream;
        print(arg0: boolean): void;
        print(arg0: string): void;
        print(arg0: string[]): void;
        print(arg0: number): void;
        print(arg0: number): void;
        print(arg0: number): void;
        print(arg0: string): void;
        print(arg0: number): void;
        print(arg0: any): void;
        println(arg0: string): void;
        println(arg0: any): void;
        println(arg0: number): void;
        println(arg0: number): void;
        println(arg0: string[]): void;
        println(arg0: boolean): void;
        println(): void;
        println(arg0: string): void;
        println(arg0: number): void;
        println(arg0: number): void;
        writeBytes(arg0: number[]): void;
        flush(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        static nullOutputStream(): Internal.OutputStream;
        close(): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        write(arg0: number): void;
        write(arg0: number[]): void;
        append(arg0: Internal.CharSequence): Internal.Appendable;
        append(arg0: Internal.CharSequence): Internal.PrintStream;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.Appendable;
        append(arg0: Internal.CharSequence, arg1: number, arg2: number): Internal.PrintStream;
        append(arg0: string): Internal.Appendable;
        append(arg0: string): Internal.PrintStream;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AndConditionBuilder implements Internal.ConditionsContainer<Internal.AndConditionBuilder> {
        killerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): Internal.AndConditionBuilder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        survivesExplosion(): Internal.AndConditionBuilder;
        notifyAll(): void;
        addCondition(arg0: (arg0: any) => boolean): Internal.ConditionsContainer<any>;
        addCondition(arg0: (arg0: any) => boolean): Internal.AndConditionBuilder;
        addCondition(arg0: Internal.LootItemCondition$Builder): Internal.AndConditionBuilder;
        customDistanceToPlayer(arg0: (arg0: Internal.DistancePredicateBuilder) => void): Internal.AndConditionBuilder;
        matchFluid(arg0: string): Internal.AndConditionBuilder;
        notify(): void;
        not(arg0: (arg0: Internal.NotConditionBuilder) => void): Internal.AndConditionBuilder;
        directKillerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): Internal.AndConditionBuilder;
        matchEquip(arg0: EquipmentSlot, arg1: Internal.IngredientJS): Internal.AndConditionBuilder;
        and(arg0: (arg0: Internal.AndConditionBuilder) => void): Internal.AndConditionBuilder;
        hashCode(): number;
        matchLoot(arg0: Internal.IngredientJS): Internal.AndConditionBuilder;
        matchLoot(arg0: Internal.IngredientJS, arg1: boolean): Internal.AndConditionBuilder;
        anyBiome(arg0: string[]): Internal.AndConditionBuilder;
        distanceToKiller(arg0: Internal.MinMaxBounds$Doubles): Internal.AndConditionBuilder;
        entityPredicate(arg0: (arg0: Internal.EntityJS) => boolean): Internal.AndConditionBuilder;
        matchEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.AndConditionBuilder;
        anyDimension(arg0: ResourceLocation[]): Internal.AndConditionBuilder;
        killedByPlayer(): Internal.AndConditionBuilder;
        or(arg0: (arg0: Internal.OrConditionBuilder) => void): Internal.AndConditionBuilder;
        randomChance(arg0: number): Internal.AndConditionBuilder;
        timeCheck(arg0: number, arg1: number, arg2: number): Internal.AndConditionBuilder;
        timeCheck(arg0: number, arg1: number): Internal.AndConditionBuilder;
        matchOffHand(arg0: Internal.IngredientJS): Internal.AndConditionBuilder;
        playerPredicate(arg0: (arg0: Internal.PlayerJS<any>) => boolean): Internal.AndConditionBuilder;
        weatherCheck(arg0: Internal.Map<string, boolean>): Internal.AndConditionBuilder;
        matchDirectKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.AndConditionBuilder;
        matchBlockState(arg0: Internal.Block, arg1: Internal.Map<string, string>): Internal.AndConditionBuilder;
        matchMainHand(arg0: Internal.IngredientJS): Internal.AndConditionBuilder;
        matchPlayer(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.AndConditionBuilder;
        lightLevel(arg0: number, arg1: number): Internal.AndConditionBuilder;
        build(): (arg0: any) => boolean;
        biome(arg0: string[]): Internal.AndConditionBuilder;
        customCondition(arg0: Internal.JsonObject): Internal.AndConditionBuilder;
        equals(arg0: any): boolean;
        matchKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.AndConditionBuilder;
        randomChanceWithLooting(arg0: number, arg1: number): Internal.AndConditionBuilder;
        hasAnyStage(arg0: string[]): Internal.AndConditionBuilder;
        toString(): string;
        randomChanceWithEnchantment(arg0: Internal.Enchantment, arg1: number[]): Internal.AndConditionBuilder;
        matchDamageSource(arg0: (arg0: Internal.DamageSourcePredicateBuilderJS) => void): Internal.AndConditionBuilder;
        anyStructure(arg0: ResourceLocation[], arg1: boolean): Internal.AndConditionBuilder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClientboundBlockEntityDataPacket implements Internal.Packet<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ModelResourceLocation extends ResourceLocation {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        setPath(arg0: string): void;
        compareTo(arg0: any): number;
        compareTo(arg0: ResourceLocation): number;
        notify(): void;
        getNamespace(): string;
        hashCode(): number;
        compareNamespaced(arg0: ResourceLocation): number;
        equals(arg0: any): boolean;
        getPath(): string;
        toString(): string;
        setNamespace(arg0: string): void;
        specialEquals(o: any, shallow: boolean): boolean;
        get path(): string;
        get namespace(): string;
        get class(): Internal.Class<any>;
        set path(arg0: string);
        set namespace(arg0: string);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Object2ObjectArrayMap <K, V> extends Internal.AbstractObject2ObjectMap<any, any> implements Internal.Serializable, Internal.Cloneable {
        getClass(): Internal.Class<any>;
        getOrDefault(arg0: any, arg1: V): V;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replace(arg0: K, arg1: V): V;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: K) => V_;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<K, V>>;
        entrySet(): Internal.Set<any>;
        containsKey(arg0: any): boolean;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        computeObjectIfAbsentPartial(arg0: K, arg1: (arg0: K) => V): V;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        object2ObjectEntrySet(): Internal.ObjectSet<any>;
        object2ObjectEntrySet(): Internal.Object2ObjectMap$FastEntrySet<K, V>;
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V;
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V;
        notifyAll(): void;
        values(): Internal.Collection<any>;
        values(): Internal.ObjectCollection<V>;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        replaceAll(arg0: (arg0: K, arg1: V) => V): void;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        notify(): void;
        remove(arg0: any): V;
        remove(arg0: any, arg1: any): boolean;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        hashCode(): number;
        putAll(arg0: Internal.Map<K, V>): void;
        get(arg0: any): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        keySet(): Internal.ObjectSet<K>;
        keySet(): Internal.Set<any>;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: K): V;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        isEmpty(): boolean;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        clone(): any;
        clone(): (arg0: K) => V;
        toString(): string;
        putIfAbsent(arg0: K, arg1: V): V;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface GenericDeclaration extends Internal.AnnotatedElement {
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean;
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        getTypeParameters(): any[];
        getAnnotations(): Internal.Annotation[];
        getDeclaredAnnotations(): Internal.Annotation[];
    }
    interface NeutralMob {
    }
    class ItemTransforms$TransformType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ItemTransforms$TransformType;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ItemTransforms$TransformType[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ItemTransforms$TransformType): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ItemTransforms$TransformType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ItemTransforms$TransformType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly HEAD : Internal.ItemTransforms$TransformType;
        static readonly THIRD_PERSON_LEFT_HAND : Internal.ItemTransforms$TransformType;
        static readonly THIRD_PERSON_RIGHT_HAND : Internal.ItemTransforms$TransformType;
        static readonly FIRST_PERSON_RIGHT_HAND : Internal.ItemTransforms$TransformType;
        static readonly GROUND : Internal.ItemTransforms$TransformType;
        static readonly FIRST_PERSON_LEFT_HAND : Internal.ItemTransforms$TransformType;
        static readonly FIXED : Internal.ItemTransforms$TransformType;
        static readonly GUI : Internal.ItemTransforms$TransformType;
        static readonly NONE : Internal.ItemTransforms$TransformType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ItemTransforms$TransformType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IPlantable {
        getPlantType(arg0: Internal.BlockGetter, arg1: BlockPos): Internal.PlantType;
        getPlant(arg0: Internal.BlockGetter, arg1: BlockPos): Internal.BlockState;
    }
    class LootContext$EntityTarget extends Internal.Enum<any> implements Internal.EntityTargetKJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.LootContext$EntityTarget;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.LootContext$EntityTarget[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.LootContext$EntityTarget): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.LootContext$EntityTarget>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.LootContext$EntityTarget>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        getNameKJS(): string;
        ordinal(): number;
        static readonly DIRECT_KILLER : Internal.LootContext$EntityTarget;
        static readonly KILLER_PLAYER : Internal.LootContext$EntityTarget;
        static readonly KILLER : Internal.LootContext$EntityTarget;
        static readonly THIS : Internal.LootContext$EntityTarget;
        get nameKJS(): string;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.LootContext$EntityTarget>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClientLevelJS extends Internal.LevelJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(entity: Internal.Entity): Internal.PlayerJS<any>;
        getEntitiesWithin(aabb: Internal.AABB): Internal.EntityArrayList;
        getPlayerData(player: Internal.Player): Internal.ClientPlayerDataJS;
        getPlayerData(arg0: Internal.Player): Internal.PlayerDataJS<any, any>;
        spawnFireworks(x: number, y: number, z: number, f: Internal.FireworksJS): void;
        getTime(): number;
        notifyAll(): void;
        getSide(): Internal.ScriptType;
        getGameRules(): Internal.GameRulesJS;
        notify(): void;
        setRainStrength(strength: number): void;
        getMinecraftPlayer(): Internal.LocalPlayer;
        hashCode(): number;
        getDimension(): string;
        isDaytime(): boolean;
        createEntityList(entities: Internal.Collection<Internal.Entity>): Internal.EntityArrayList;
        getPlayers(): Internal.EntityArrayList;
        getData(): Internal.AttachedData;
        getMinecraftLevel(): net.minecraft.world.level.Level;
        getMinecraftLevel(): Internal.ClientLevel;
        getServer(): Internal.ServerJS;
        getLivingEntity(entity: Internal.Entity): Internal.LivingEntityJS;
        getBlock(x: number, y: number, z: number): Internal.BlockContainerJS;
        getBlock(pos: BlockPos): Internal.BlockContainerJS;
        getBlock(blockEntity: Internal.BlockEntity): Internal.BlockContainerJS;
        isOverworld(): boolean;
        createExplosion(x: number, y: number, z: number): Internal.ExplosionJS;
        getEntity(e: Internal.Entity): Internal.EntityJS;
        getMinecraft(): Internal.Minecraft;
        createEntity(id: ResourceLocation): Internal.EntityJS;
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean): void;
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean, player: Internal.EntityJS): void;
        getLocalTime(): number;
        equals(arg0: any): boolean;
        isThundering(): boolean;
        getEntities(): Internal.EntityArrayList;
        toString(): string;
        static getInstance(): Internal.ClientLevelJS;
        isRaining(): boolean;
        static setInstance(instance: Internal.ClientLevelJS): void;
        readonly clientPlayerData : Internal.ClientPlayerDataJS;
        readonly minecraftLevel : net.minecraft.world.level.Level;
        get minecraft(): Internal.Minecraft;
        get server(): Internal.ServerJS;
        get side(): Internal.ScriptType;
        get instance(): Internal.ClientLevelJS;
        get data(): Internal.AttachedData;
        get minecraftPlayer(): Internal.LocalPlayer;
        get players(): Internal.EntityArrayList;
        get raining(): boolean;
        get thundering(): boolean;
        get overworld(): boolean;
        get gameRules(): Internal.GameRulesJS;
        get localTime(): number;
        get entities(): Internal.EntityArrayList;
        get time(): number;
        get class(): Internal.Class<any>;
        get dimension(): string;
        get daytime(): boolean;
        set instance(instance: Internal.ClientLevelJS);
        set rainStrength(strength: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EntityInLevelCallback {
    }
    class FontManager implements Internal.AutoCloseable, Internal.FontResourceManagerAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getFontSets(): Internal.Map<any, any>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get fontSets(): Internal.Map<any, any>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface AbstractContainerMenuInvoker {
        _moveItemStackTo(arg0: Internal.ItemStack, arg1: number, arg2: number, arg3: boolean): boolean;
    }
    abstract class ImmutableCollection <E> extends Internal.AbstractCollection<any> implements Internal.Serializable {
        add(arg0: E): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: (arg0: E) => void): void;
        notifyAll(): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        notify(): void;
        asList(): Internal.ImmutableList<E>;
        remove(arg0: any): boolean;
        removeIf(arg0: (arg0: E) => boolean): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.UnmodifiableIterator<E>;
        iterator(): Internal.Iterator<any>;
        size(): number;
        stream(): Internal.Stream<E>;
        addAll(arg0: Internal.Collection<E>): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        toString(): string;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LunarEventInstance {
        getEvent(arg0: Internal.Map<string, Internal.LunarEvent>): Internal.LunarEvent;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        scheduledDay(): number;
        notifyAll(): void;
        active(arg0: number): boolean;
        notify(): void;
        getLunarEventKey(): string;
        hashCode(): number;
        setScheduledDay(arg0: number): void;
        equals(arg0: any): boolean;
        toString(): string;
        getDaysUntil(arg0: number): number;
        passed(arg0: number): boolean;
        static readonly CODEC : Internal.Codec<Internal.LunarEventInstance>;
        get lunarEventKey(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LithiumDefaultedList {
        setUnstableInteractionConditions(): void;
        changedInteractionConditions(): void;
    }
    interface TemporalField {
        resolve(arg0: Internal.Map<Internal.TemporalField, number>, arg1: Internal.TemporalAccessor, arg2: Internal.ResolverStyle): Internal.TemporalAccessor;
        getBaseUnit(): Internal.TemporalUnit;
        rangeRefinedBy(arg0: Internal.TemporalAccessor): Internal.ValueRange;
        getDisplayName(arg0: Internal.Locale): string;
        isTimeBased(): boolean;
        adjustInto<R>(arg0: R, arg1: number): R;
        range(): Internal.ValueRange;
        getRangeUnit(): Internal.TemporalUnit;
        toString(): string;
        isDateBased(): boolean;
        getFrom(arg0: Internal.TemporalAccessor): number;
        isSupportedBy(arg0: Internal.TemporalAccessor): boolean;
    }
    class IntSummaryStatistics implements java_.util.function_.IntConsumer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMax(): number;
        notifyAll(): void;
        getAverage(): number;
        andThen(arg0: java_.util.function_.IntConsumer): java_.util.function_.IntConsumer;
        notify(): void;
        accept(arg0: number): void;
        getMin(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getSum(): number;
        getCount(): number;
        combine(arg0: Internal.IntSummaryStatistics): void;
        get average(): number;
        get min(): number;
        get max(): number;
        get count(): number;
        get sum(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BackpackInventory extends Internal.SimpleContainer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getBackpackStack(): Internal.ItemStack;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        get backpackStack(): Internal.ItemStack;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface RecipeSerializer <T> extends Internal.IForgeRegistryEntry<Internal.RecipeSerializer<any>> {
        getRegistryType(): Internal.Class<Internal.RecipeSerializer<any>>;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation): Internal.RecipeSerializer<any>;
    }
    class DistancePredicate {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockBuilder extends Internal.BuilderBase {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase;
        getBuilderType(): string;
        newID(pre: string, post: string): ResourceLocation;
        type(t: Internal.BlockType): Internal.BlockBuilder;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation): Internal.BlockBuilder;
        tag(arg0: ResourceLocation): Internal.BuilderBase;
        tagBoth(tag: ResourceLocation): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: (arg0: Internal.BlockItemBuilder) => void): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        textureSide(direction: Internal.Direction, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        waterlogged(): Internal.BlockBuilder;
        color(index: number, c: number): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        tagBlock(tag: ResourceLocation): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: (arg0: Internal.RandomTickCallbackJS) => void): Internal.BlockBuilder;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        tagItem(tag: ResourceLocation): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        lightLevel(light: number): Internal.BlockBuilder;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        readonly textures : Internal.JsonObject;
        defaultTags : Internal.Set<ResourceLocation>;
        static current : Internal.BlockBuilder;
        lootTable : (arg0: Internal.LootBuilder) => void;
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        block : Internal.Block;
        readonly id : ResourceLocation;
        customShape : Internal.List<Internal.AABB>;
        itemBuilder : Internal.BlockItemBuilder;
        randomTickCallback : (arg0: Internal.RandomTickCallbackJS) => void;
        get builderType(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Constant <T> extends Internal.Comparable<T> {
        name(): string;
        compareTo(arg0: T): number;
        id(): number;
    }
    interface MapCodec$ResultFunction <A> {
        apply<T>(arg0: Internal.DynamicOps<T>, arg1: Internal.MapLike<T>, arg2: Internal.DataResult<A>): Internal.DataResult<A>;
        coApply<T>(arg0: Internal.DynamicOps<T>, arg1: A, arg2: Internal.RecordBuilder<T>): Internal.RecordBuilder<T>;
    }
    class UpgradeData {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Duration implements Internal.TemporalAmount, Internal.Comparable<Internal.Duration>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        negated(): Internal.Duration;
        plusHours(arg0: number): Internal.Duration;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Duration): number;
        multipliedBy(arg0: number): Internal.Duration;
        plusSeconds(arg0: number): Internal.Duration;
        toMillis(): number;
        static from(arg0: Internal.TemporalAmount): Internal.Duration;
        plusNanos(arg0: number): Internal.Duration;
        static ofMinutes(arg0: number): Internal.Duration;
        static between(arg0: Internal.Temporal, arg1: Internal.Temporal): Internal.Duration;
        static ofSeconds(arg0: number, arg1: number): Internal.Duration;
        static ofSeconds(arg0: number): Internal.Duration;
        truncatedTo(arg0: Internal.TemporalUnit): Internal.Duration;
        minusNanos(arg0: number): Internal.Duration;
        getNano(): number;
        toMillisPart(): number;
        plus(arg0: Internal.Duration): Internal.Duration;
        plus(arg0: number, arg1: Internal.TemporalUnit): Internal.Duration;
        toMinutesPart(): number;
        toNanos(): number;
        toMinutes(): number;
        toHours(): number;
        plusMillis(arg0: number): Internal.Duration;
        subtractFrom(arg0: Internal.Temporal): Internal.Temporal;
        toSecondsPart(): number;
        static ofMillis(arg0: number): Internal.Duration;
        minus(arg0: Internal.Duration): Internal.Duration;
        minus(arg0: number, arg1: Internal.TemporalUnit): Internal.Duration;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        minusHours(arg0: number): Internal.Duration;
        notifyAll(): void;
        withSeconds(arg0: number): Internal.Duration;
        minusMillis(arg0: number): Internal.Duration;
        plusMinutes(arg0: number): Internal.Duration;
        notify(): void;
        toSeconds(): number;
        dividedBy(arg0: number): Internal.Duration;
        dividedBy(arg0: Internal.Duration): number;
        minusMinutes(arg0: number): Internal.Duration;
        plusDays(arg0: number): Internal.Duration;
        hashCode(): number;
        static of(arg0: number, arg1: Internal.TemporalUnit): Internal.Duration;
        get(arg0: Internal.TemporalUnit): number;
        isZero(): boolean;
        toDays(): number;
        toNanosPart(): number;
        isNegative(): boolean;
        static ofDays(arg0: number): Internal.Duration;
        static parse(arg0: Internal.CharSequence): Internal.Duration;
        minusDays(arg0: number): Internal.Duration;
        toHoursPart(): number;
        toDaysPart(): number;
        static ofNanos(arg0: number): Internal.Duration;
        getSeconds(): number;
        abs(): Internal.Duration;
        static ofHours(arg0: number): Internal.Duration;
        withNanos(arg0: number): Internal.Duration;
        equals(arg0: any): boolean;
        getUnits(): Internal.List<Internal.TemporalUnit>;
        addTo(arg0: Internal.Temporal): Internal.Temporal;
        toString(): string;
        minusSeconds(arg0: number): Internal.Duration;
        static readonly ZERO : Internal.Duration;
        get zero(): boolean;
        get negative(): boolean;
        get seconds(): number;
        get nano(): number;
        get units(): Internal.List<Internal.TemporalUnit>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MovementTrackerCache {
        deduplicate<S>(arg0: S): S;
        remove(arg0: Internal.SectionedEntityMovementTracker<any, any>): void;
    }
    interface LongSupplier {
        getAsLong(): number;
    }
    interface AbstractContainerScreenAccessor {
        setSkipNextRelease(arg0: boolean): void;
        setIsQuickCrafting(arg0: boolean): void;
        getQuickCraftingButton(): number;
        getIsQuickCrafting(): boolean;
        invokeSlotClicked(arg0: Internal.Slot, arg1: number, arg2: number, arg3: Internal.ClickType): void;
        invokeFindSlot(arg0: number, arg1: number): Internal.Slot;
    }
    class Painter {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getObject(key: string): Internal.PainterObject;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        clear(): void;
        paint(root: Internal.CompoundTag): void;
        setVariable(key: string, variable: dev.latvian.mods.rhino.util.unit.Unit): void;
        toString(): string;
        make(type: string): Internal.PainterObject;
        notify(): void;
        readonly unitStorage : Internal.UnitStorage;
        static readonly LEFT : -1;
        static readonly RANDOM : Internal.Random;
        static readonly DRAW_INGAME : 1;
        static readonly INSTANCE : Internal.Painter;
        static readonly BOTTOM : 1;
        readonly screenHeightUnit : Internal.MutableUnit;
        static readonly DRAW_GUI : 2;
        static readonly CENTER : 0;
        readonly screenWidthUnit : Internal.MutableUnit;
        static readonly DRAW_ALWAYS : 0;
        static readonly TOP : -1;
        readonly mouseXUnit : Internal.MutableUnit;
        readonly mouseYUnit : Internal.MutableUnit;
        readonly deltaUnit : Internal.MutableUnit;
        static readonly RIGHT : 1;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class EntityModel <T> extends net.minecraft.client.model.Model {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface CollisionGetter extends Internal.BlockGetter {
    }
    interface ItemStackKJS extends Internal.AsKJS {
        removeTagKJS(): void;
        asKJS(): any;
    }
    class Vector3f {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setY(arg0: number): void;
        setX(arg0: number): void;
        set(arg0: number[]): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        setZ(arg0: number): void;
        notify(): void;
        get class(): Internal.Class<any>;
        set x(arg0: number);
        set y(arg0: number);
        set z(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Float2ObjectFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: number, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        put(arg0: number, arg1: V): V;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: V): V;
        remove(arg0: number): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): V;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    abstract class LunarEvent {
        getClass(): Internal.Class<any>;
        onBlockTick(): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getChance(): number;
        notifyAll(): void;
        getTextComponents(): Internal.LunarTextComponents;
        notify(): void;
        setClientSettings(arg0: Internal.LunarEventClientSettings): void;
        setLunarEventClient(arg0: Internal.LunarEventClient<any>, arg1: string): Internal.LunarEventClient<any>;
        hashCode(): number;
        getValidMoonPhases(): Internal.Set<number>;
        blockSleeping(): boolean;
        startNotification(): Internal.LunarTextComponents$Notification;
        setKey(arg0: string): Internal.LunarEvent;
        getKey(): string;
        onBlockItemDrop(arg0: Internal.ServerLevel, arg1: Internal.ItemStack): void;
        getClient(): Internal.LunarEventClient<any>;
        getClientSettings(): Internal.LunarEventClientSettings;
        getSpawnMultiplierForMonsterCategory(arg0: Internal.MobCategory): number;
        livingEntityTick(arg0: Internal.LivingEntity, arg1: net.minecraft.world.level.Level): void;
        codec(): Internal.Codec<Internal.LunarEvent>;
        getMinNumberOfNightsBetween(): number;
        equals(arg0: any): boolean;
        endNotification(): Internal.LunarTextComponents$Notification;
        getLunarSpawner(): Internal.LunarMobSpawnInfo;
        toString(): string;
        static readonly CODEC : Internal.Codec<Internal.LunarEvent>;
        get chance(): number;
        get validMoonPhases(): Internal.Set<number>;
        get client(): Internal.LunarEventClient<any>;
        get class(): Internal.Class<any>;
        get minNumberOfNightsBetween(): number;
        get textComponents(): Internal.LunarTextComponents;
        get key(): string;
        get lunarSpawner(): Internal.LunarMobSpawnInfo;
        get clientSettings(): Internal.LunarEventClientSettings;
        set key(arg0: string);
        set clientSettings(arg0: Internal.LunarEventClientSettings);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class LunarEventClientSettings {
        createClient(): Internal.LunarEventClient<any>;
        getClass(): Internal.Class<any>;
        codec(): Internal.Codec<Internal.LunarEventClientSettings>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMoonSize(): number;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getMoonTextureLocation(): ResourceLocation;
        getSoundTrack(): Internal.SoundEvent;
        toString(): string;
        getColorSettings(): Internal.ColorSettings;
        notify(): void;
        static readonly CODEC : Internal.Codec<Internal.LunarEventClientSettings>;
        get moonSize(): number;
        get moonTextureLocation(): ResourceLocation;
        get soundTrack(): Internal.SoundEvent;
        get colorSettings(): Internal.ColorSettings;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Products$P8 <F, T1, T2, T3, T4, T5, T6, T7, T8> {
        t4(): Internal.App<F, T4>;
        getClass(): Internal.Class<any>;
        t5(): Internal.App<F, T5>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        t6(): Internal.App<F, T6>;
        t7(): Internal.App<F, T7>;
        t8(): Internal.App<F, T8>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>>): Internal.App<F, R>;
        notifyAll(): void;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BlockPos$MutableBlockPos extends BlockPos {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getX(): number;
        getY(): number;
        getZ(): number;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        compareTo(arg0: any): number;
        compareTo(arg0: Vec3i): number;
        notify(): void;
        get x(): number;
        get y(): number;
        get z(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CoderResult {
        static malformedForLength(arg0: number): Internal.CoderResult;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isMalformed(): boolean;
        isOverflow(): boolean;
        notifyAll(): void;
        isUnmappable(): boolean;
        length(): number;
        throwException(): void;
        notify(): void;
        isError(): boolean;
        static unmappableForLength(arg0: number): Internal.CoderResult;
        hashCode(): number;
        equals(arg0: any): boolean;
        isUnderflow(): boolean;
        toString(): string;
        static readonly OVERFLOW : Internal.CoderResult;
        static readonly UNDERFLOW : Internal.CoderResult;
        get underflow(): boolean;
        get overflow(): boolean;
        get unmappable(): boolean;
        get error(): boolean;
        get class(): Internal.Class<any>;
        get malformed(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IModBusEvent {
    }
    interface Float2ByteFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class TransientEntitySectionManager <T> implements Internal.ClientEntityManagerAccessor<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getCache(): Internal.EntitySectionStorage<any>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get cache(): Internal.EntitySectionStorage<any>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ClientEntityManagerAccessor <T> {
        getCache(): Internal.EntitySectionStorage<T>;
    }
    class ListenerStatus extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        shouldRemove(): boolean;
        static valueOf(arg0: string): Internal.ListenerStatus;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ListenerStatus[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ListenerStatus): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ListenerStatus>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ListenerStatus>;
        hashCode(): number;
        equals(arg0: any): boolean;
        isOk(): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly OKAY : Internal.ListenerStatus;
        static readonly REMOVE : Internal.ListenerStatus;
        static readonly UPDATE : Internal.ListenerStatus;
        get ok(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ListenerStatus>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface TypeDescriptor {
        descriptorString(): string;
    }
    class DamageSource implements Internal.DamageSourceAccessor {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        callBypassArmor(): Internal.DamageSource;
        callBypassMagic(): Internal.DamageSource;
        toString(): string;
        static create_$md$dd73f7$0(arg0: string): Internal.DamageSource;
        notify(): void;
        callBypassInvul(): Internal.DamageSource;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface UserPrincipal extends Internal.Principal {
        getName(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        implies(arg0: Internal.Subject): boolean;
    }
    abstract class CollectionTag <T> extends Internal.AbstractList<any> implements Internal.Tag, Internal.CustomJavaObjectWrapper$AsList {
        getClass(): Internal.Class<any>;
        wrapAsJavaList(): Internal.List<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        replaceAll(arg0: (arg0: any) => any): void;
        notify(): void;
        remove(arg0: number): any;
        remove(arg0: number): T;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.Iterator<T>;
        stream(): Internal.Stream<T>;
        hashCode(): number;
        get(arg0: number): T;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<T>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: T): void;
        add(arg0: number, arg1: any): void;
        add(arg0: T): boolean;
        subList(arg0: number, arg1: number): Internal.List<T>;
        set(arg0: number, arg1: T): T;
        set(arg0: number, arg1: any): any;
        spliterator(): Internal.Spliterator<T>;
        forEach(arg0: (arg0: T) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator<T>): void;
        removeIf(arg0: (arg0: T) => boolean): boolean;
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, staticType: Internal.Class<any>): Internal.Scriptable;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: number, arg1: Internal.Collection<T>): boolean;
        addAll(arg0: Internal.Collection<T>): boolean;
        equals(arg0: any): boolean;
        listIterator(): Internal.ListIterator<T>;
        listIterator(arg0: number): Internal.ListIterator<T>;
        toString(): string;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class AbstractObject2ObjectMap <K, V> extends Internal.AbstractObject2ObjectFunction<any, any> implements Internal.Object2ObjectMap<K, V>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        getOrDefault(arg0: any, arg1: V): V;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replace(arg0: K, arg1: V): V;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: K) => V_;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        put(arg0: K, arg1: V): V;
        containsValue(arg0: any): boolean;
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<K, V>>;
        entrySet(): Internal.Set<any>;
        containsKey(arg0: any): boolean;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        computeObjectIfAbsentPartial(arg0: K, arg1: (arg0: K) => V): V;
        object2ObjectEntrySet(): Internal.ObjectSet<Internal.Object2ObjectMap$Entry<K, V>>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V;
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V;
        notifyAll(): void;
        values(): Internal.ObjectCollection<V>;
        values(): Internal.Collection<any>;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        replaceAll(arg0: (arg0: K, arg1: V) => V): void;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        remove(arg0: any): V;
        remove(arg0: any, arg1: any): boolean;
        notify(): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        hashCode(): number;
        get(arg0: any): V;
        get(arg0: any): V;
        putAll(arg0: Internal.Map<K, V>): void;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        keySet(): Internal.Set<any>;
        keySet(): Internal.ObjectSet<K>;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: K): V;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        isEmpty(): boolean;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        toString(): string;
        putIfAbsent(arg0: K, arg1: V): V;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LightListener {
        getVolume(): Internal.ImmutableBox;
        onLightUpdate(arg0: Internal.LightProvider, arg1: Internal.LightLayer, arg2: Internal.ImmutableBox): void;
        onLightPacket(arg0: Internal.LightProvider, arg1: number, arg2: number): void;
        status(): Internal.ListenerStatus;
    }
    abstract class FastMapKey <T> {
        getClass(): Internal.Class<any>;
        getValue(arg0: number): T;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getProperty(): Internal.Property<T>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        numValues(): number;
        notify(): void;
        get property(): Internal.Property<T>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Byte2ObjectFunction <V> extends it.unimi.dsi.fastutil.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: number, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: number) => V_;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        put(arg0: number, arg1: V): V;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: V): V;
        remove(arg0: number): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): V;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class ModelManager extends Internal.SimplePreparableReloadListener<any> implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getModel(arg0: ResourceLocation): Internal.BakedModel;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class Charset implements Internal.Comparable<Internal.Charset> {
        encode(arg0: string): Internal.ByteBuffer;
        encode(arg0: Internal.CharBuffer): Internal.ByteBuffer;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        aliases(): Internal.Set<string>;
        static forName(arg0: string): Internal.Charset;
        displayName(): string;
        displayName(arg0: Internal.Locale): string;
        newDecoder(): Internal.CharsetDecoder;
        notifyAll(): void;
        static defaultCharset(): Internal.Charset;
        static isSupported(arg0: string): boolean;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Charset): number;
        decode(arg0: Internal.ByteBuffer): Internal.CharBuffer;
        notify(): void;
        contains(arg0: Internal.Charset): boolean;
        hashCode(): number;
        canEncode(): boolean;
        equals(arg0: any): boolean;
        newEncoder(): Internal.CharsetEncoder;
        name(): string;
        isRegistered(): boolean;
        toString(): string;
        static availableCharsets(): Internal.SortedMap<string, Internal.Charset>;
        get registered(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ItemLike {
    }
    interface MinecraftAccess {
        getFontManager(): Internal.FontManager;
    }
    class Products$P16 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IntToLongFunction {
        applyAsLong(arg0: number): number;
    }
    class PoseStack$Pose {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface EntityGetter {
    }
    class SmithingRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        parseResultItem(o: any): Internal.ItemStackJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Products$P15 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MetalPressRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        energy(e: number): Internal.IERecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        time(t: number): Internal.IERecipeJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<net.minecraftforge.fluids.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ForwardingObject {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Short2ByteFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: number, arg1: number): number;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface IItemRenderProperties {
        getItemStackRenderer(): Internal.BlockEntityWithoutLevelRenderer;
        getBaseArmorModel(arg0: Internal.LivingEntity, arg1: Internal.ItemStack, arg2: EquipmentSlot, arg3: Internal.HumanoidModel<any>): net.minecraft.client.model.Model;
        getFont(arg0: Internal.ItemStack): Internal.Font;
        getArmorModel(arg0: Internal.LivingEntity, arg1: Internal.ItemStack, arg2: EquipmentSlot, arg3: Internal.HumanoidModel<any>): Internal.HumanoidModel<any>;
        renderHelmetOverlay(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: number, arg3: number, arg4: number): void;
    }
    class OptionalDouble {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isEmpty(): boolean;
        isPresent(): boolean;
        getAsDouble(): number;
        orElse(arg0: number): number;
        notify(): void;
        orElseThrow<X>(arg0: () => X): number;
        orElseThrow(): number;
        static empty(): Internal.OptionalDouble;
        orElseGet(arg0: Internal.DoubleSupplier): number;
        stream(): Internal.DoubleStream;
        hashCode(): number;
        ifPresentOrElse(arg0: Internal.DoubleConsumer, arg1: Internal.Runnable): void;
        ifPresent(arg0: Internal.DoubleConsumer): void;
        static of(arg0: number): Internal.OptionalDouble;
        equals(arg0: any): boolean;
        toString(): string;
        get asDouble(): number;
        get present(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LevelSimulatedRW extends Internal.LevelSimulatedReader, Internal.LevelWriter {
    }
    interface IForgeMinecraft {
        popGuiLayer(): void;
        pushGuiLayer(arg0: Internal.Screen): void;
    }
    interface Char2ObjectFunction <V> extends it.unimi.dsi.fastutil.Function<string, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: string, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: string) => V_;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        put(arg0: string, arg1: V): V;
        put(arg0: any, arg1: any): any;
        put(arg0: string, arg1: V): V;
        remove(arg0: string): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        get(arg0: any): V;
        get(arg0: string): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: number): V;
        apply(arg0: string): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: T_) => V;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface Rotate <Self> {
        rotateZRadians(arg0: number): Self;
        rotate(arg0: number, arg1: (arg0: any) => boolean): Self;
        rotate(arg0: Internal.Direction, arg1: number): Self;
        rotateYRadians(arg0: number): Self;
        rotateXRadians(arg0: number): Self;
        multiplyRadians(arg0: Internal.Vector3f, arg1: number): Self;
        multiply(arg0: Internal.Quaternion): Self;
        multiply(arg0: Internal.Vector3f, arg1: number): Self;
        rotateX(arg0: number): Self;
        rotateY(arg0: number): Self;
        rotateZ(arg0: number): Self;
        rotateToFace(arg0: Internal.Direction): Self;
    }
    class SequencedAssemblyRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        transitionalItem(item: Internal.ItemStackJS): Internal.SequencedAssemblyRecipeJS;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        loops(loops: number): Internal.SequencedAssemblyRecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        parseResultItem(o: any): Internal.ItemStackJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Stream <T> extends Internal.BaseStream<T, Internal.Stream<T>> {
        sequential(): Internal.Stream<T>;
        takeWhile(arg0: (arg0: T) => boolean): Internal.Stream<T>;
        distinct(): Internal.Stream<T>;
        findFirst(): Internal.Optional<T>;
        skip(arg0: number): Internal.Stream<T>;
        toList(): Internal.List<T>;
        allMatch(arg0: (arg0: T) => boolean): boolean;
        mapMultiToDouble(arg0: (arg0: T, arg1: Internal.DoubleConsumer) => void): Internal.DoubleStream;
        iterator(): Internal.Iterator<T>;
        mapMulti<R_>(arg0: (arg0: T, arg1: (arg0: R_) => void) => void): Internal.Stream<R_>;
        flatMapToInt(arg0: (arg0: T) => Internal.IntStream): Internal.IntStream;
        min(arg0: Internal.Comparator<T>): Internal.Optional<T>;
        flatMapToLong(arg0: (arg0: T) => Internal.LongStream): Internal.LongStream;
        parallel(): Internal.Stream<T>;
        mapToLong(arg0: Internal.ToLongFunction<T>): Internal.LongStream;
        noneMatch(arg0: (arg0: T) => boolean): boolean;
        findAny(): Internal.Optional<T>;
        isParallel(): boolean;
        limit(arg0: number): Internal.Stream<T>;
        toArray(): any[];
        toArray<A_>(arg0: Internal.IntFunction<A_[]>): A_[];
        forEachOrdered(arg0: (arg0: T) => void): void;
        close(): void;
        anyMatch(arg0: (arg0: T) => boolean): boolean;
        map<R_>(arg0: (arg0: T) => R_): Internal.Stream<R_>;
        mapToDouble(arg0: Internal.ToDoubleFunction<T>): Internal.DoubleStream;
        unordered(): Internal.Stream<T>;
        mapMultiToLong(arg0: (arg0: T, arg1: Internal.LongConsumer) => void): Internal.LongStream;
        mapMultiToInt(arg0: (arg0: T, arg1: java_.util.function_.IntConsumer) => void): Internal.IntStream;
        reduce<U_>(arg0: U_, arg1: (arg0: U_, arg1: T) => U_, arg2: (arg0: any, arg1: any) => any): U_;
        reduce(arg0: T, arg1: (arg0: any, arg1: any) => any): T;
        reduce(arg0: (arg0: any, arg1: any) => any): Internal.Optional<T>;
        spliterator(): Internal.Spliterator<T>;
        max(arg0: Internal.Comparator<T>): Internal.Optional<T>;
        forEach(arg0: (arg0: T) => void): void;
        count(): number;
        dropWhile(arg0: (arg0: T) => boolean): Internal.Stream<T>;
        flatMapToDouble(arg0: (arg0: T) => Internal.DoubleStream): Internal.DoubleStream;
        peek(arg0: (arg0: T) => void): Internal.Stream<T>;
        flatMap<R_>(arg0: (arg0: T) => Internal.Stream<R_>): Internal.Stream<R_>;
        filter(arg0: (arg0: T) => boolean): Internal.Stream<T>;
        onClose(arg0: Internal.Runnable): Internal.Stream<T>;
        sorted(arg0: Internal.Comparator<T>): Internal.Stream<T>;
        sorted(): Internal.Stream<T>;
        mapToInt(arg0: Internal.ToIntFunction<T>): Internal.IntStream;
        collect<R_>(arg0: () => R_, arg1: (arg0: R_, arg1: T) => void, arg2: (arg0: R_, arg1: R_) => void): R_;
        collect<R_, A_>(arg0: Internal.Collector<T, A_, R_>): R_;
    }
    interface Object2ObjectFunction <K, V> extends it.unimi.dsi.fastutil.Function<K, V> {
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: K) => V_;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        defaultReturnValue(): V;
        defaultReturnValue(arg0: V): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        get(arg0: any): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: K): V;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface WithAttachedData {
        getData(): Internal.AttachedData;
    }
    interface Char2CharFunction extends it.unimi.dsi.fastutil.Function<string, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: string, arg1: string): string;
        getOrDefault(arg0: any, arg1: string): string;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: string) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: any, arg1: any): any;
        put(arg0: string, arg1: string): string;
        put(arg0: string, arg1: string): string;
        remove(arg0: string): string;
        remove(arg0: any): string;
        remove(arg0: any): any;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): string;
        get(arg0: any): any;
        get(arg0: string): string;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: string): string;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => string): (arg0: T_) => string;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class NativeJavaClass extends Internal.NativeJavaObject implements dev.latvian.mods.rhino.Function {
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setParentScope(m: Internal.Scriptable): void;
        static canConvert(cx: Internal.Context, fromObj: any, to: Internal.Class<any>): boolean;
        notifyAll(): void;
        getIds(): any[];
        getClassObject(): Internal.Class<any>;
        construct(cx: Internal.Context, scope: Internal.Scriptable, args: any[]): Internal.Scriptable;
        getAllIds(): any[];
        delete(index: number): void;
        delete(key: Internal.Symbol): void;
        delete(name: string): void;
        notify(): void;
        put(name: string, start: Internal.Scriptable, value: any): void;
        put(index: number, start: Internal.Scriptable, value: any): void;
        put(symbol: Internal.Symbol, start: Internal.Scriptable, value: any): void;
        unwrap(): any;
        getDefaultValue(hint: Internal.Class<any>): any;
        getPrototype(): Internal.Scriptable;
        hashCode(): number;
        get(name: string, start: Internal.Scriptable): any;
        get(key: Internal.Symbol, start: Internal.Scriptable): any;
        get(index: number, start: Internal.Scriptable): any;
        has(name: string, start: Internal.Scriptable): boolean;
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean;
        has(index: number, start: Internal.Scriptable): boolean;
        hasInstance(value: Internal.Scriptable): boolean;
        addCustomProperty(name: string, getter: Internal.CustomProperty): void;
        setPrototype(m: Internal.Scriptable): void;
        call(cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any;
        equals(arg0: any): boolean;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        static readonly NOT_FOUND : any;
        get classObject(): Internal.Class<any>;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get className(): string;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get prototype(): Internal.Scriptable;
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ToDoubleFunction <T> {
        applyAsDouble(arg0: T): number;
    }
    interface Function7 <T1, T2, T3, T4, T5, T6, T7, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7): R;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, (arg0: T6, arg1: T7) => R>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, (arg0: T7) => R>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function4<T4, T5, T6, T7, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function3<T5, T6, T7, R>>;
        curry2(): (arg0: T1, arg1: T2) => Internal.Function5<T3, T4, T5, T6, T7, R>;
        curry(): (arg0: T1) => Internal.Function6<T2, T3, T4, T5, T6, T7, R>;
    }
    class JsonPrimitive extends Internal.JsonElement {
        getAsFloat(): number;
        getClass(): Internal.Class<any>;
        getAsByte(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAsBigDecimal(): Internal.BigDecimal;
        notifyAll(): void;
        getAsNumber(): Internal.Number;
        getAsCharacter(): string;
        getAsString(): string;
        isJsonArray(): boolean;
        notify(): void;
        getAsInt(): number;
        isJsonPrimitive(): boolean;
        isBoolean(): boolean;
        getAsLong(): number;
        isJsonObject(): boolean;
        isNumber(): boolean;
        hashCode(): number;
        isString(): boolean;
        getAsBigInteger(): Internal.BigInteger;
        getAsJsonObject(): Internal.JsonObject;
        getAsJsonNull(): Internal.JsonNull;
        isJsonNull(): boolean;
        getAsDouble(): number;
        deepCopy(): Internal.JsonElement;
        deepCopy(): Internal.JsonPrimitive;
        getAsJsonArray(): Internal.JsonArray;
        getAsJsonPrimitive(): Internal.JsonPrimitive;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getAsShort(): number;
        get asByte(): number;
        get asBigInteger(): Internal.BigInteger;
        get asJsonObject(): Internal.JsonObject;
        get asCharacter(): string;
        get jsonPrimitive(): boolean;
        get string(): boolean;
        get asNumber(): Internal.Number;
        get asBigDecimal(): Internal.BigDecimal;
        get jsonNull(): boolean;
        get asFloat(): number;
        get asLong(): number;
        get asInt(): number;
        get number(): boolean;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get boolean(): boolean;
        get asJsonNull(): Internal.JsonNull;
        get asShort(): number;
        get asDouble(): number;
        get asJsonArray(): Internal.JsonArray;
        get asString(): string;
        get jsonObject(): boolean;
        get class(): Internal.Class<any>;
        get jsonArray(): boolean;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Transform <Self> extends Internal.Translate<Self>, Internal.Rotate<Self>, Internal.Scale<Self> {
        rotate(arg0: number, arg1: (arg0: any) => boolean): Self;
        rotate(arg0: Internal.Direction, arg1: number): Self;
        translateAll(arg0: number): Self;
        rotateCentered(arg0: Internal.Direction, arg1: number): Self;
        rotateCentered(arg0: Internal.Quaternion): Self;
        scale(arg0: number, arg1: number, arg2: number): Self;
        scale(arg0: number): Self;
        centre(): Self;
        multiplyRadians(arg0: Internal.Vector3f, arg1: number): Self;
        translate(arg0: number, arg1: number, arg2: number): Self;
        translate(arg0: Internal.Vector3f): Self;
        translate(arg0: Vec3): Self;
        translate(arg0: Vec3i): Self;
        rotateZRadians(arg0: number): Self;
        translateZ(arg0: number): Self;
        mulNormal(arg0: Internal.Matrix3f): Self;
        transform(arg0: Internal.Matrix4f, arg1: Internal.Matrix3f): Self;
        transform(arg0: Internal.PoseStack): Self;
        mulPose(arg0: Internal.Matrix4f): Self;
        rotateYRadians(arg0: number): Self;
        rotateXRadians(arg0: number): Self;
        translateY(arg0: number): Self;
        translateX(arg0: number): Self;
        unCentre(): Self;
        multiply(arg0: Internal.Quaternion): Self;
        multiply(arg0: Internal.Vector3f, arg1: number): Self;
        rotateX(arg0: number): Self;
        rotateY(arg0: number): Self;
        translateBack(arg0: Vec3i): Self;
        translateBack(arg0: number, arg1: number, arg2: number): Self;
        translateBack(arg0: Vec3): Self;
        rotateZ(arg0: number): Self;
        rotateToFace(arg0: Internal.Direction): Self;
        nudge(arg0: number): Self;
    }
    class ModuleDescriptor$Builder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mainClass(arg0: string): Internal.ModuleDescriptor$Builder;
        exports(arg0: string): Internal.ModuleDescriptor$Builder;
        exports(arg0: Internal.Set<Internal.ModuleDescriptor$Exports$Modifier>, arg1: string, arg2: Internal.Set<string>): Internal.ModuleDescriptor$Builder;
        exports(arg0: string, arg1: Internal.Set<string>): Internal.ModuleDescriptor$Builder;
        exports(arg0: Internal.Set<Internal.ModuleDescriptor$Exports$Modifier>, arg1: string): Internal.ModuleDescriptor$Builder;
        exports(arg0: Internal.ModuleDescriptor$Exports): Internal.ModuleDescriptor$Builder;
        notifyAll(): void;
        packages(arg0: Internal.Set<string>): Internal.ModuleDescriptor$Builder;
        version(arg0: string): Internal.ModuleDescriptor$Builder;
        version(arg0: Internal.ModuleDescriptor$Version): Internal.ModuleDescriptor$Builder;
        notify(): void;
        build(): Internal.ModuleDescriptor;
        hashCode(): number;
        provides(arg0: Internal.ModuleDescriptor$Provides): Internal.ModuleDescriptor$Builder;
        provides(arg0: string, arg1: Internal.List<string>): Internal.ModuleDescriptor$Builder;
        equals(arg0: any): boolean;
        opens(arg0: string): Internal.ModuleDescriptor$Builder;
        opens(arg0: Internal.Set<Internal.ModuleDescriptor$Opens$Modifier>, arg1: string, arg2: Internal.Set<string>): Internal.ModuleDescriptor$Builder;
        opens(arg0: string, arg1: Internal.Set<string>): Internal.ModuleDescriptor$Builder;
        opens(arg0: Internal.ModuleDescriptor$Opens): Internal.ModuleDescriptor$Builder;
        opens(arg0: Internal.Set<Internal.ModuleDescriptor$Opens$Modifier>, arg1: string): Internal.ModuleDescriptor$Builder;
        toString(): string;
        uses(arg0: string): Internal.ModuleDescriptor$Builder;
        requires(arg0: Internal.ModuleDescriptor$Requires): Internal.ModuleDescriptor$Builder;
        requires(arg0: Internal.Set<Internal.ModuleDescriptor$Requires$Modifier>, arg1: string, arg2: Internal.ModuleDescriptor$Version): Internal.ModuleDescriptor$Builder;
        requires(arg0: string): Internal.ModuleDescriptor$Builder;
        requires(arg0: Internal.Set<Internal.ModuleDescriptor$Requires$Modifier>, arg1: string): Internal.ModuleDescriptor$Builder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface BlockAccessor {
        getMaterial(): net.minecraft.world.level.material.Material;
    }
    class NetworkEvent$PacketDispatcher {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        sendPacket(arg0: ResourceLocation, arg1: Internal.FriendlyByteBuf): void;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PrimitiveIterator$OfLong extends Internal.PrimitiveIterator<number, Internal.LongConsumer> {
        next(): any;
        next(): number;
        hasNext(): boolean;
        forEachRemaining(arg0: any): void;
        forEachRemaining(arg0: Internal.LongConsumer): void;
        forEachRemaining(arg0: (arg0: number) => void): void;
        nextLong(): number;
        remove(): void;
    }
    interface DoubleSupplier {
        getAsDouble(): number;
    }
    interface IntSupplier {
        getAsInt(): number;
    }
    interface ResourceLocationAccess {
        setPath(arg0: string): void;
        setNamespace(arg0: string): void;
    }
    class Package extends Internal.NamedPackage implements Internal.AnnotatedElement {
        getClass(): Internal.Class<any>;
        isSealed(arg0: Internal.URL): boolean;
        isSealed(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getPackage(arg0: string): Internal.Package;
        getName(): string;
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean;
        notifyAll(): void;
        getSpecificationTitle(): string;
        getImplementationTitle(): string;
        isCompatibleWith(arg0: string): boolean;
        getAnnotations(): Internal.Annotation[];
        notify(): void;
        getSpecificationVendor(): string;
        getDeclaredAnnotations(): Internal.Annotation[];
        getAnnotationsByType<A_>(arg0: Internal.Class<A_>): A_[];
        getDeclaredAnnotationsByType<A_>(arg0: Internal.Class<A_>): A_[];
        getAnnotation<A_>(arg0: Internal.Class<A_>): A_;
        hashCode(): number;
        equals(arg0: any): boolean;
        static getPackages(): Internal.Package[];
        getDeclaredAnnotation<A_>(arg0: Internal.Class<A_>): A_;
        toString(): string;
        getSpecificationVersion(): string;
        getImplementationVendor(): string;
        getImplementationVersion(): string;
        get specificationVendor(): string;
        get declaredAnnotations(): Internal.Annotation[];
        get specificationTitle(): string;
        get implementationVersion(): string;
        get sealed(): boolean;
        get name(): string;
        get implementationVendor(): string;
        get annotations(): Internal.Annotation[];
        get implementationTitle(): string;
        get packages(): Internal.Package[];
        get class(): Internal.Class<any>;
        get specificationVersion(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface NarrationSupplier {
    }
    interface ChannelProgressivePromise extends Internal.ProgressivePromise<void>, Internal.ChannelProgressiveFuture, Internal.ChannelPromise {
        cancel(arg0: boolean): boolean;
        unvoid(): Internal.ChannelProgressivePromise;
        unvoid(): Internal.ChannelPromise;
        channel(): io.netty.channel.Channel;
        setProgress(arg0: number, arg1: number): Internal.ChannelProgressivePromise;
        setProgress(arg0: number, arg1: number): Internal.ProgressivePromise<void>;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): Internal.ChannelProgressivePromise;
        awaitUninterruptibly(): Internal.ProgressivePromise<void>;
        awaitUninterruptibly(): Internal.Promise<void>;
        awaitUninterruptibly(): Internal.Future<void>;
        awaitUninterruptibly(): Internal.ProgressiveFuture<void>;
        awaitUninterruptibly(): Internal.ChannelProgressiveFuture;
        awaitUninterruptibly(): Internal.ChannelFuture;
        awaitUninterruptibly(): Internal.ChannelPromise;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        trySuccess(arg0: void): boolean;
        trySuccess(): boolean;
        tryProgress(arg0: number, arg1: number): boolean;
        syncUninterruptibly(): Internal.ChannelProgressivePromise;
        syncUninterruptibly(): Internal.ProgressivePromise<void>;
        syncUninterruptibly(): Internal.Promise<void>;
        syncUninterruptibly(): Internal.Future<void>;
        syncUninterruptibly(): Internal.ProgressiveFuture<void>;
        syncUninterruptibly(): Internal.ChannelProgressiveFuture;
        syncUninterruptibly(): Internal.ChannelFuture;
        syncUninterruptibly(): Internal.ChannelPromise;
        get(arg0: number, arg1: Internal.TimeUnit): void;
        get(): void;
        await(): Internal.ChannelProgressivePromise;
        await(): Internal.ProgressivePromise<void>;
        await(): Internal.Promise<void>;
        await(): Internal.Future<void>;
        await(): Internal.ProgressiveFuture<void>;
        await(): Internal.ChannelProgressiveFuture;
        await(): Internal.ChannelFuture;
        await(): Internal.ChannelPromise;
        await(arg0: number, arg1: Internal.TimeUnit): boolean;
        await(arg0: number): boolean;
        isSuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelProgressivePromise;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ProgressivePromise<void>;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Promise<void>;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ProgressiveFuture<void>;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelProgressiveFuture;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture;
        addListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelPromise;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelProgressivePromise;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ProgressivePromise<void>;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Promise<void>;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ProgressiveFuture<void>;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelProgressiveFuture;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture;
        removeListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelPromise;
        getNow(): void;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelProgressivePromise;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ProgressivePromise<void>;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Promise<void>;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.Future<void>;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ProgressiveFuture<void>;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelProgressiveFuture;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelFuture;
        removeListener(arg0: Internal.GenericFutureListener<Internal.Future<void>>): Internal.ChannelPromise;
        tryFailure(arg0: Internal.Throwable): boolean;
        isDone(): boolean;
        sync(): Internal.ChannelProgressivePromise;
        sync(): Internal.ProgressivePromise<void>;
        sync(): Internal.Promise<void>;
        sync(): Internal.Future<void>;
        sync(): Internal.ProgressiveFuture<void>;
        sync(): Internal.ChannelProgressiveFuture;
        sync(): Internal.ChannelFuture;
        sync(): Internal.ChannelPromise;
        setSuccess(): Internal.ChannelProgressivePromise;
        setSuccess(): Internal.ChannelPromise;
        setSuccess(arg0: void): Internal.ChannelProgressivePromise;
        setSuccess(arg0: void): Internal.ChannelPromise;
        setSuccess(arg0: void): Internal.ProgressivePromise<void>;
        setSuccess(arg0: void): Internal.Promise<void>;
        setFailure(arg0: Internal.Throwable): Internal.ChannelProgressivePromise;
        setFailure(arg0: Internal.Throwable): Internal.ProgressivePromise<void>;
        setFailure(arg0: Internal.Throwable): Internal.Promise<void>;
        setFailure(arg0: Internal.Throwable): Internal.ChannelPromise;
        isVoid(): boolean;
        isCancellable(): boolean;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelProgressivePromise;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ProgressivePromise<void>;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Promise<void>;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.Future<void>;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ProgressiveFuture<void>;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelProgressiveFuture;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelFuture;
        addListeners(arg0: Internal.GenericFutureListener<Internal.Future<void>>[]): Internal.ChannelPromise;
        setUncancellable(): boolean;
    }
    interface Predicate <T> {
        or(arg0: (arg0: T) => boolean): (arg0: T) => boolean;
        test(arg0: T): boolean;
        and(arg0: (arg0: T) => boolean): (arg0: T) => boolean;
        negate(): (arg0: T) => boolean;
    }
    abstract class BaseImmutableMultimap <K, V> extends Internal.AbstractMultimap<any, any> {
        getClass(): Internal.Class<any>;
        containsEntry(arg0: any, arg1: any): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        containsKey(arg0: any): boolean;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        asMap(): Internal.Map<K, Internal.Collection<V>>;
        keys(): Internal.Multiset<K>;
        notifyAll(): void;
        values(): Internal.Collection<V>;
        clear(): void;
        isEmpty(): boolean;
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.Collection<V>;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): boolean;
        remove(arg0: any, arg1: any): boolean;
        removeAll(arg0: any): Internal.Collection<V>;
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>;
        size(): number;
        hashCode(): number;
        get(arg0: K): Internal.Collection<V>;
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean;
        putAll(arg0: Internal.Multimap<K, V>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        keySet(): Internal.Set<K>;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ElementBuffer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        bind(): void;
        unbind(): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        readonly eboIndexType : Internal.GlNumericType;
        readonly elementCount : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class VertexFormat implements Internal.BufferVertexFormat {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getStride(): number;
        hasPosition(): boolean;
        notifyAll(): void;
        getOffset(arg0: number): number;
        getElementMapping(): Internal.ImmutableMap<string, Internal.VertexFormatElement>;
        notify(): void;
        hasColor(): boolean;
        hasNormal(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        hasUV(arg0: number): boolean;
        get elementMapping(): Internal.ImmutableMap<string, Internal.VertexFormatElement>;
        get stride(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ResourceManagerReloadListener extends Internal.PreparableReloadListener {
    }
    interface Short2ShortFunction extends it.unimi.dsi.fastutil.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: number) => T_;
        andThen(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: number): number;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any): any;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): number;
        get(arg0: any): any;
        get(arg0: number): number;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => number;
        compose(arg0: Internal.IntUnaryOperator): Internal.IntUnaryOperator;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    class ItemStackJS implements Internal.IngredientJS, Internal.NBTSerializable, Internal.ChangeListener<Internal.Tag>, Internal.SpecialEquality {
        getItemIds(): Internal.Set<string>;
        getClass(): Internal.Class<any>;
        getNbt(): Internal.CompoundTag;
        isBlock(): boolean;
        getName(): Internal.Text;
        getStacks(): Internal.Set<Internal.ItemStackJS>;
        getVanillaItems(): Internal.Set<Internal.Item>;
        static findGroup(id: string): Internal.CreativeModeTab;
        getItem(): Internal.Item;
        hasEnchantment(enchantment: Internal.Enchantment, level: number): boolean;
        getTags(): Internal.Collection<ResourceLocation>;
        getItemGroup(): string;
        setChance(c: number): void;
        static getList(): Internal.List<Internal.ItemStackJS>;
        getFirst(): Internal.ItemStackJS;
        withChance(c: number): Internal.ItemStackJS;
        withName(displayName: Internal.Component): Internal.ItemStackJS;
        getCount(): number;
        setCount(count: number): void;
        testVanillaItem(item: Internal.Item): boolean;
        hasTag(tag: ResourceLocation): boolean;
        test(other: Internal.ItemStackJS): boolean;
        hasChance(): boolean;
        asIngredientStack(): Internal.IngredientStackJS;
        static getRawItem(o: any): Internal.Item;
        getNbtString(): string;
        createVanillaIngredient(): (arg0: any) => boolean;
        isNBTEqual(other: Internal.ItemStackJS): boolean;
        isNBTEqual(other: Internal.ItemStack): boolean;
        toJson(): Internal.JsonElement;
        withCount(c: number): Internal.ItemStackJS;
        withCount(arg0: number): Internal.IngredientJS;
        static getListJS(): Internal.ListJS;
        specialEquals(o: any, shallow: boolean): boolean;
        anyStackMatches(ingredient: Internal.IngredientJS): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hasNBT(): boolean;
        areItemsEqual(other: Internal.ItemStackJS): boolean;
        areItemsEqual(other: Internal.ItemStack): boolean;
        getChance(): number;
        getMod(): string;
        notifyAll(): void;
        isInvalidRecipeIngredient(): boolean;
        getId(): string;
        notify(): void;
        weakNBT(): Internal.IngredientJS;
        static clearListCache(): void;
        not(): Internal.IngredientJS;
        toNBT(): Internal.Tag;
        toNBT(): Internal.CompoundTag;
        getHarvestSpeed(block: Internal.BlockContainerJS): number;
        getHarvestSpeed(): number;
        hashCode(): number;
        toRawResultJson(): Internal.JsonElement;
        static of(o: any): Internal.ItemStackJS;
        getItemStack(): Internal.ItemStack;
        copy(): Internal.ItemStackJS;
        copy(): Internal.Copyable;
        copy(): Internal.IngredientJS;
        withNBT(nbt: Internal.CompoundTag): Internal.ItemStackJS;
        toResultJson(): Internal.JsonElement;
        onChanged(o: Internal.Tag): void;
        onChanged(arg0: any): void;
        static getTypeList(): Internal.ListJS;
        isEmpty(): boolean;
        strongEquals(o: any): boolean;
        getVanillaPredicate(): (arg0: Internal.ItemStack) => boolean;
        filter(filter: Internal.IngredientJS): Internal.IngredientJS;
        getEnchantments(): Internal.MapJS;
        getFluidStack(): Internal.FluidStackJS;
        removeNBT(): Internal.ItemStackJS;
        static resultFromRecipeJson(json: Internal.JsonElement): Internal.ItemStackJS;
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>;
        testVanilla(other: Internal.ItemStack): boolean;
        enchant(enchantment: Internal.Enchantment, level: number): Internal.ItemStackJS;
        enchant(enchantments: Internal.MapJS): Internal.ItemStackJS;
        equals(o: any): boolean;
        x(c: number): Internal.IngredientJS;
        ignoreNBT(): Internal.IngredientJS;
        toString(): string;
        removeChance(): void;
        setNbt(tag: Internal.CompoundTag): void;
        static readonly EMPTY : Internal.ItemStackJS;
        get nbt(): Internal.CompoundTag;
        get itemStack(): Internal.ItemStack;
        get mod(): string;
        get itemIds(): Internal.Set<string>;
        get vanillaItems(): Internal.Set<Internal.Item>;
        get empty(): boolean;
        get harvestSpeed(): number;
        get typeList(): Internal.ListJS;
        get nbtString(): string;
        get block(): boolean;
        get id(): string;
        get class(): Internal.Class<any>;
        get invalidRecipeIngredient(): boolean;
        get itemGroup(): string;
        get item(): Internal.Item;
        get chance(): number;
        get stacks(): Internal.Set<Internal.ItemStackJS>;
        get count(): number;
        get list(): Internal.List<Internal.ItemStackJS>;
        get enchantments(): Internal.MapJS;
        get listJS(): Internal.ListJS;
        get tags(): Internal.Collection<ResourceLocation>;
        get name(): Internal.Text;
        get fluidStack(): Internal.FluidStackJS;
        get first(): Internal.ItemStackJS;
        get vanillaPredicate(): (arg0: Internal.ItemStack) => boolean;
        set nbt(tag: Internal.CompoundTag);
        set chance(c: number);
        set count(count: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class TextColor implements Internal.ColorAccess, Internal.Color {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRgbKJS(): number;
        getColorRaw(): number;
        notifyAll(): void;
        getSerializeKJS(): string;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        createTextColorKJS(): Internal.TextColor;
        getHexKJS(): string;
        getArgbKJS(): number;
        toString(): string;
        getFireworkColorKJS(): number;
        static create_$md$dd73f7$0(arg0: number): Internal.TextColor;
        specialEquals(o: any, shallow: boolean): boolean;
        get colorRaw(): number;
        get fireworkColorKJS(): number;
        get rgbKJS(): number;
        get argbKJS(): number;
        get serializeKJS(): string;
        get hexKJS(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AccessibleObject implements Internal.AnnotatedElement {
        trySetAccessible(): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isAccessible(): boolean;
        setAccessible(arg0: boolean): void;
        static setAccessible(arg0: Internal.AccessibleObject[], arg1: boolean): void;
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean;
        notifyAll(): void;
        getAnnotations(): Internal.Annotation[];
        notify(): void;
        getDeclaredAnnotations(): Internal.Annotation[];
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        hashCode(): number;
        equals(arg0: any): boolean;
        canAccess(arg0: any): boolean;
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        toString(): string;
        get accessible(): boolean;
        get declaredAnnotations(): Internal.Annotation[];
        get annotations(): Internal.Annotation[];
        get class(): Internal.Class<any>;
        set accessible(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class EventsJS {
        getClass(): Internal.Class<any>;
        postToHandlers(id: string, list: Internal.List<Internal.EventsJS$ScriptEventHandler>, event: Internal.EventJS): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        handlers(id: string): Internal.List<Internal.EventsJS$ScriptEventHandler>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        clear(): void;
        toString(): string;
        notify(): void;
        listen(id: string, handler: Internal.IEventHandler): void;
        readonly scriptManager : Internal.ScriptManager;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ByteBuffer extends Internal.Buffer implements Internal.Comparable<Internal.ByteBuffer> {
        asIntBuffer(): Internal.IntBuffer;
        getClass(): Internal.Class<any>;
        compact(): Internal.ByteBuffer;
        asLongBuffer(): Internal.LongBuffer;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.ByteBuffer): number;
        put(arg0: Internal.ByteBuffer): Internal.ByteBuffer;
        put(arg0: number, arg1: number): Internal.ByteBuffer;
        put(arg0: number, arg1: Internal.ByteBuffer, arg2: number, arg3: number): Internal.ByteBuffer;
        put(arg0: number[]): Internal.ByteBuffer;
        put(arg0: number, arg1: number[]): Internal.ByteBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuffer;
        put(arg0: number): Internal.ByteBuffer;
        put(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer;
        slice(): Internal.ByteBuffer;
        slice(): Internal.Buffer;
        slice(arg0: number, arg1: number): Internal.ByteBuffer;
        slice(arg0: number, arg1: number): Internal.Buffer;
        limit(arg0: number): Internal.Buffer;
        limit(arg0: number): Internal.ByteBuffer;
        limit(): number;
        order(): Internal.ByteOrder;
        order(arg0: Internal.ByteOrder): Internal.ByteBuffer;
        asFloatBuffer(): Internal.FloatBuffer;
        asCharBuffer(): Internal.CharBuffer;
        static allocateDirect(arg0: number): Internal.ByteBuffer;
        putInt(arg0: number, arg1: number): Internal.ByteBuffer;
        putInt(arg0: number): Internal.ByteBuffer;
        duplicate(): Internal.ByteBuffer;
        duplicate(): Internal.Buffer;
        remaining(): number;
        putFloat(arg0: number): Internal.ByteBuffer;
        putFloat(arg0: number, arg1: number): Internal.ByteBuffer;
        getInt(): number;
        getInt(arg0: number): number;
        getChar(): string;
        getChar(arg0: number): string;
        static allocate(arg0: number): Internal.ByteBuffer;
        reset(): Internal.ByteBuffer;
        reset(): Internal.Buffer;
        position(arg0: number): Internal.ByteBuffer;
        position(arg0: number): Internal.Buffer;
        position(): number;
        asShortBuffer(): Internal.ShortBuffer;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        putDouble(arg0: number, arg1: number): Internal.ByteBuffer;
        putDouble(arg0: number): Internal.ByteBuffer;
        getDouble(): number;
        getDouble(arg0: number): number;
        getFloat(arg0: number): number;
        getFloat(): number;
        putLong(arg0: number, arg1: number): Internal.ByteBuffer;
        putLong(arg0: number): Internal.ByteBuffer;
        notify(): void;
        asReadOnlyBuffer(): Internal.ByteBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        asDoubleBuffer(): Internal.DoubleBuffer;
        array(): number[];
        array(): any;
        hashCode(): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuffer;
        get(arg0: number): number;
        get(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer;
        get(): number;
        get(arg0: number, arg1: number[]): Internal.ByteBuffer;
        get(arg0: number[]): Internal.ByteBuffer;
        arrayOffset(): number;
        putShort(arg0: number): Internal.ByteBuffer;
        putShort(arg0: number, arg1: number): Internal.ByteBuffer;
        flip(): Internal.Buffer;
        flip(): Internal.ByteBuffer;
        hasArray(): boolean;
        getShort(arg0: number): number;
        getShort(): number;
        putChar(arg0: number, arg1: string): Internal.ByteBuffer;
        putChar(arg0: string): Internal.ByteBuffer;
        hasRemaining(): boolean;
        clear(): Internal.ByteBuffer;
        clear(): Internal.Buffer;
        getLong(arg0: number): number;
        getLong(): number;
        alignmentOffset(arg0: number, arg1: number): number;
        rewind(): Internal.Buffer;
        rewind(): Internal.ByteBuffer;
        mismatch(arg0: Internal.ByteBuffer): number;
        equals(arg0: any): boolean;
        toString(): string;
        alignedSlice(arg0: number): Internal.ByteBuffer;
        isDirect(): boolean;
        static wrap(arg0: number[]): Internal.ByteBuffer;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer;
        mark(): Internal.Buffer;
        mark(): Internal.ByteBuffer;
        get double(): number;
        get char(): string;
        get direct(): boolean;
        get short(): number;
        get readOnly(): boolean;
        get float(): number;
        get class(): Internal.Class<any>;
        get int(): number;
        get long(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ContentHandler {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getContent(arg0: Internal.URLConnection): any;
        getContent(arg0: Internal.URLConnection, arg1: Internal.Class[]): any;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class FireworksJS$Shape extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(name: string): Internal.FireworksJS$Shape;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.FireworksJS$Shape[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.FireworksJS$Shape): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.FireworksJS$Shape>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.FireworksJS$Shape>;
        hashCode(): number;
        equals(arg0: any): boolean;
        static get(name: string): Internal.FireworksJS$Shape;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SMALL_BALL : Internal.FireworksJS$Shape;
        static readonly LARGE_BALL : Internal.FireworksJS$Shape;
        static readonly STAR : Internal.FireworksJS$Shape;
        static readonly CREEPER : Internal.FireworksJS$Shape;
        static readonly BURST : Internal.FireworksJS$Shape;
        static readonly VALUES : Internal.FireworksJS$Shape[];
        readonly type : number;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.FireworksJS$Shape>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ScriptableObject implements Internal.Scriptable, Internal.SymbolScriptable, Internal.Serializable, Internal.ConstProperties {
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        setParentScope(m: Internal.Scriptable): void;
        static redefineProperty(obj: Internal.Scriptable, name: string, isConst: boolean): void;
        putConst(name: string, start: Internal.Scriptable, value: any): void;
        static getTypedProperty<T_>(s: Internal.Scriptable, index: number, type: Internal.Class<T_>): T_;
        static getTypedProperty<T_>(s: Internal.Scriptable, name: string, type: Internal.Class<T_>): T_;
        getIds(): any[];
        static getArrayPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        getAllIds(): any[];
        put(key: Internal.Symbol, start: Internal.Scriptable, value: any): void;
        put(index: number, start: Internal.Scriptable, value: any): void;
        put(name: string, start: Internal.Scriptable, value: any): void;
        getDefaultValue(typeHint: Internal.Class<any>): any;
        static getDefaultValue(object: Internal.Scriptable, typeHint: Internal.Class<any>): any;
        defineOwnProperties(cx: Internal.Context, props: Internal.ScriptableObject): void;
        defineProperty(propertyName: string, clazz: Internal.Class<any>, attributes: number): void;
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method, setter: Internal.Method, attributes: number): void;
        defineProperty(propertyName: string, value: any, attributes: number): void;
        defineProperty(key: Internal.Symbol, value: any, attributes: number): void;
        static defineProperty(destination: Internal.Scriptable, propertyName: string, value: any, attributes: number): void;
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable, isSetter: boolean): void;
        avoidObjectDetection(): boolean;
        has(index: number, start: Internal.Scriptable): boolean;
        has(name: string, start: Internal.Scriptable): boolean;
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean;
        getExternalArrayLength(): any;
        getAttributes(name: string): number;
        getAttributes(index: number): number;
        getAttributes(sym: Internal.Symbol): number;
        hasInstance(instance: Internal.Scriptable): boolean;
        getAssociatedValue(key: any): any;
        static getPropertyIds(obj: Internal.Scriptable): any[];
        static hasProperty(obj: Internal.Scriptable, index: number): boolean;
        static hasProperty(obj: Internal.Scriptable, name: string): boolean;
        static hasProperty(obj: Internal.Scriptable, key: Internal.Symbol): boolean;
        getExternalArrayData(): Internal.ExternalArrayData;
        size(): number;
        defineOwnProperty(cx: Internal.Context, id: any, desc: Internal.ScriptableObject): void;
        static getFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        preventExtensions(): void;
        setExternalArrayData(array: Internal.ExternalArrayData): void;
        static callMethod(obj: Internal.Scriptable, methodName: string, args: any[]): any;
        static callMethod(cx: Internal.Context, obj: Internal.Scriptable, methodName: string, args: any[]): any;
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        getTypeOf(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getTopScopeValue(scope: Internal.Scriptable, key: any): any;
        notifyAll(): void;
        sealObject(): void;
        setAttributes(name: string, attributes: number): void;
        setAttributes(index: number, attributes: number): void;
        setAttributes(key: Internal.Symbol, attributes: number): void;
        static putProperty(obj: Internal.Scriptable, index: number, value: any): void;
        static putProperty(obj: Internal.Scriptable, key: Internal.Symbol, value: any): void;
        static putProperty(obj: Internal.Scriptable, name: string, value: any): void;
        delete(index: number): void;
        delete(key: Internal.Symbol): void;
        delete(name: string): void;
        notify(): void;
        associateValue(key: any, value: any): any;
        static deleteProperty(obj: Internal.Scriptable, name: string): boolean;
        static deleteProperty(obj: Internal.Scriptable, index: number): boolean;
        getPrototype(): Internal.Scriptable;
        static getObjectPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        isExtensible(): boolean;
        hashCode(): number;
        isConst(name: string): boolean;
        get(index: number, start: Internal.Scriptable): any;
        get(key: Internal.Symbol, start: Internal.Scriptable): any;
        get(name: string, start: Internal.Scriptable): any;
        get(key: any): any;
        static putConstProperty(obj: Internal.Scriptable, name: string, value: any): void;
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any;
        static getTopLevelScope(obj: Internal.Scriptable): Internal.Scriptable;
        static getProperty(obj: Internal.Scriptable, name: string): any;
        static getProperty(obj: Internal.Scriptable, key: Internal.Symbol): any;
        static getProperty(obj: Internal.Scriptable, index: number): any;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean): void;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>): void;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean, mapInheritance: boolean): string;
        isEmpty(): boolean;
        defineFunctionProperties(names: string[], clazz: Internal.Class<any>, attributes: number): void;
        static getClassPrototype(scope: Internal.Scriptable, className: string): Internal.Scriptable;
        setPrototype(m: Internal.Scriptable): void;
        defineConst(name: string, start: Internal.Scriptable): void;
        equals(arg0: any): boolean;
        static defineConstProperty(destination: Internal.Scriptable, propertyName: string): void;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get className(): string;
        get externalArrayLength(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get prototype(): Internal.Scriptable;
        get extensible(): boolean;
        get typeOf(): string;
        get empty(): boolean;
        set externalArrayData(array: Internal.ExternalArrayData);
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CallbackInfoReturnable <R> extends Internal.CallbackInfo {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        setReturnValue(arg0: R): void;
        getReturnValueB(): number;
        notifyAll(): void;
        getId(): string;
        getReturnValueI(): number;
        getReturnValueJ(): number;
        getReturnValueC(): string;
        getReturnValueD(): number;
        notify(): void;
        getReturnValueF(): number;
        static getCallInfoClassName(arg0: Internal.Type): string;
        getReturnValue(): R;
        hashCode(): number;
        equals(arg0: any): boolean;
        isCancellable(): boolean;
        toString(): string;
        getReturnValueZ(): boolean;
        getReturnValueS(): number;
        get returnValueC(): string;
        get returnValueD(): number;
        get returnValueB(): number;
        get returnValue(): R;
        get returnValueF(): number;
        get returnValueI(): number;
        get returnValueJ(): number;
        get cancellable(): boolean;
        get returnValueS(): number;
        get cancelled(): boolean;
        get id(): string;
        get returnValueZ(): boolean;
        get class(): Internal.Class<any>;
        set returnValue(arg0: R);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ForgeModelBakery extends Internal.ModelBakery {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static defaultTextureGetter(): (arg0: net.minecraft.client.resources.model.Material) => Internal.TextureAtlasSprite;
        static instance(): Internal.ForgeModelBakery;
        notifyAll(): void;
        getSpecialModels(): Internal.Set<ResourceLocation>;
        notify(): void;
        isLoading(): boolean;
        static addSpecialModel(arg0: ResourceLocation): void;
        getSpriteMap(): Internal.AtlasSet;
        getModelOrLogError(arg0: ResourceLocation, arg1: string): Internal.UnbakedModel;
        static getInventoryVariant(arg0: string): Internal.ModelResourceLocation;
        hashCode(): number;
        equals(arg0: any): boolean;
        bake(arg0: ResourceLocation, arg1: Internal.ModelState, arg2: (arg0: net.minecraft.client.resources.model.Material) => Internal.TextureAtlasSprite): Internal.BakedModel;
        onPostBakeEvent(arg0: Internal.Map<ResourceLocation, Internal.BakedModel>): void;
        toString(): string;
        static defaultModelGetter(): (arg0: ResourceLocation) => Internal.UnbakedModel;
        getModelOrMissing(arg0: ResourceLocation): Internal.UnbakedModel;
        get spriteMap(): Internal.AtlasSet;
        get specialModels(): Internal.Set<ResourceLocation>;
        get loading(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class HitResult {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface PreparableReloadListener {
    }
    interface IntSet extends Internal.IntCollection, Internal.Set<number> {
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        intStream(): Internal.IntStream;
        removeAll(arg0: Internal.IntCollection): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.Iterator<any>;
        iterator(): Internal.IntIterator;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toIntArray(arg0: number[]): number[];
        toIntArray(): number[];
        toArray(arg0: number[]): number[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        add(arg0: any): boolean;
        add(arg0: number): boolean;
        spliterator(): Internal.IntSpliterator;
        spliterator(): Internal.Spliterator<any>;
        forEach(arg0: (arg0: number) => void): void;
        forEach(arg0: java_.util.function_.IntConsumer): void;
        forEach(arg0: (arg0: any) => void): void;
        containsAll(arg0: Internal.IntCollection): boolean;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        removeIf(arg0: (arg0: number) => boolean): boolean;
        removeIf(arg0: Internal.IntPredicate): boolean;
        removeIf(arg0: (arg0: any) => boolean): boolean;
        contains(arg0: any): boolean;
        contains(arg0: number): boolean;
        size(): number;
        addAll(arg0: Internal.IntCollection): boolean;
        addAll(arg0: Internal.Collection<number>): boolean;
        equals(arg0: any): boolean;
        intParallelStream(): Internal.IntStream;
        retainAll(arg0: Internal.IntCollection): boolean;
        retainAll(arg0: Internal.Collection<any>): boolean;
    }
    class HumanoidModel <T> extends Internal.AgeableListModel<any> implements Internal.ArmedModel, Internal.HeadedModel {
        getClass(): Internal.Class<any>;
        handler$bli000$poseLeftArm(arg0: Internal.LivingEntity, arg1: Internal.CallbackInfo): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        handler$zki000$rotationAngleCallback(arg0: Internal.LivingEntity, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.CallbackInfo): void;
        handler$bli000$setupAnim(arg0: Internal.LivingEntity, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.CallbackInfo): void;
        notify(): void;
        handler$bli000$poseRightArm(arg0: Internal.LivingEntity, arg1: Internal.CallbackInfo): void;
        animationType : Internal.TwoHandedAnimation;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class WeightedEntry$IntrusiveBase implements Internal.WeightedEntry {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class FileSystem implements Internal.Closeable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        supportedFileAttributeViews(): Internal.Set<string>;
        getFileStores(): Internal.Iterable<Internal.FileStore>;
        notifyAll(): void;
        newWatchService(): Internal.WatchService;
        notify(): void;
        isReadOnly(): boolean;
        isOpen(): boolean;
        provider(): Internal.FileSystemProvider;
        hashCode(): number;
        equals(arg0: any): boolean;
        getRootDirectories(): Internal.Iterable<Internal.Path>;
        getPath(arg0: string, arg1: string[]): Internal.Path;
        getSeparator(): string;
        toString(): string;
        getPathMatcher(arg0: string): Internal.PathMatcher;
        close(): void;
        getUserPrincipalLookupService(): Internal.UserPrincipalLookupService;
        get rootDirectories(): Internal.Iterable<Internal.Path>;
        get readOnly(): boolean;
        get userPrincipalLookupService(): Internal.UserPrincipalLookupService;
        get class(): Internal.Class<any>;
        get separator(): string;
        get open(): boolean;
        get fileStores(): Internal.Iterable<Internal.FileStore>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Tag {
        toString(): string;
    }
    class ToolAction {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static get(arg0: string): Internal.ToolAction;
        name(): string;
        static getActions(): Internal.Collection<Internal.ToolAction>;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        get actions(): Internal.Collection<Internal.ToolAction>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class InventoryJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getBlock(level: Internal.LevelJS): Internal.BlockContainerJS;
        countNonEmpty(ingredient: Internal.IngredientJS): number;
        countNonEmpty(): number;
        set(slot: number, item: Internal.ItemStack): void;
        markDirty(): void;
        notifyAll(): void;
        count(): number;
        count(ingredient: Internal.IngredientJS): number;
        isEmpty(): boolean;
        clear(): void;
        clear(ingredient: Internal.IngredientJS): void;
        isItemValid(slot: number, item: Internal.ItemStack): boolean;
        insert(slot: number, item: Internal.ItemStack, simulate: boolean): Internal.ItemStackJS;
        getWidth(): number;
        notify(): void;
        getHeight(): number;
        getSize(): number;
        extract(slot: number, amount: number, simulate: boolean): Internal.ItemStackJS;
        hashCode(): number;
        find(ingredient: Internal.IngredientJS): number;
        find(): number;
        equals(arg0: any): boolean;
        getSlotLimit(slot: number): number;
        get(slot: number): Internal.ItemStackJS;
        toString(): string;
        readonly minecraftInventory : Internal.ItemHandler;
        get size(): number;
        get width(): number;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        get height(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ObjectListIterator <K> extends Internal.ObjectBidirectionalIterator<K>, Internal.ListIterator<K> {
        next(): K;
        add(arg0: K): void;
        set(arg0: K): void;
        previous(): K;
        previous(): K;
        hasPrevious(): boolean;
        hasPrevious(): boolean;
        back(arg0: number): number;
        hasNext(): boolean;
        skip(arg0: number): number;
        nextIndex(): number;
        forEachRemaining(arg0: (arg0: K) => void): void;
        previousIndex(): number;
        remove(): void;
    }
    class Item extends Internal.ForgeRegistryEntry<any> implements Internal.ItemLike, Internal.IForgeItem, Internal.ItemInvokerMixin, Internal.ItemAccessor, Internal.IPlaceableItem, Internal.ItemKJS {
        getClass(): Internal.Class<any>;
        canElytraFly(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean;
        setBurnTime(i: number): void;
        getTags(): Internal.Set<ResourceLocation>;
        setDamage(arg0: Internal.ItemStack, arg1: number): void;
        canPerformAction(arg0: Internal.ItemStack, arg1: Internal.ToolAction): boolean;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean;
        getItemEnchantability(arg0: Internal.ItemStack): number;
        damageItem<T_>(arg0: Internal.ItemStack, arg1: number, arg2: T_, arg3: (arg0: T_) => void): number;
        setFireResistantKJS(arg0: boolean): void;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: boolean): boolean;
        setCategory(arg0: Internal.CreativeModeTab): void;
        getXpRepairRatio(arg0: Internal.ItemStack): number;
        readShareTag(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): void;
        onEntityItemUpdate(arg0: Internal.ItemStack, arg1: Internal.ItemEntity): boolean;
        getDamage(arg0: Internal.ItemStack): number;
        setFoodPropertiesKJS(arg0: Internal.FoodProperties): void;
        isBookEnchantable(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean;
        canDisableShield(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.LivingEntity, arg3: Internal.LivingEntity): boolean;
        getCategory(): Internal.CreativeModeTab;
        onUsingTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        createEntity(arg0: net.minecraft.world.level.Level, arg1: Internal.Entity, arg2: Internal.ItemStack): Internal.Entity;
        callAllowdedIn(arg0: Internal.CreativeModeTab): boolean;
        getSweepHitBox(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): Internal.AABB;
        handler$baf000$overrideStackedOnOther(arg0: Internal.ItemStack, arg1: Internal.Slot, arg2: Internal.ClickAction, arg3: Internal.Player, arg4: Internal.CallbackInfoReturnable<any>): void;
        isRepairable(arg0: Internal.ItemStack): boolean;
        getShareTag(arg0: Internal.ItemStack): Internal.CompoundTag;
        getBurnTime(arg0: Internal.ItemStack, arg1: Internal.RecipeType<any>): number;
        onDroppedByPlayer(arg0: Internal.ItemStack, arg1: Internal.Player): boolean;
        isDamageable(arg0: Internal.ItemStack): boolean;
        onEntitySwing(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean;
        getRegistryType(): Internal.Class<Internal.Item>;
        setItemBuilderKJS(b: Internal.ItemBuilder): void;
        elytraFlightTick(arg0: Internal.ItemStack, arg1: Internal.LivingEntity, arg2: number): boolean;
        getItemBuilderKJS(): Internal.ItemBuilder;
        getBlockItemOverride(): Internal.BlockItem;
        setMaxStackSizeKJS(arg0: number): void;
        getAttributeModifiers(arg0: EquipmentSlot, arg1: Internal.ItemStack): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        onLeftClickEntity(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.Entity): boolean;
        canEquip(arg0: Internal.ItemStack, arg1: EquipmentSlot, arg2: Internal.Entity): boolean;
        notifyAll(): void;
        getId(): string;
        notify(): void;
        onBlockStartBreak(arg0: Internal.ItemStack, arg1: BlockPos, arg2: Internal.Player): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Mob): void;
        canContinueUsing(arg0: Internal.ItemStack, arg1: Internal.ItemStack): boolean;
        getEntityLifespan(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level): number;
        getRenderPropertiesInternal(): any;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack): number;
        getArmorTexture(arg0: Internal.ItemStack, arg1: Internal.Entity, arg2: EquipmentSlot, arg3: string): string;
        hashCode(): number;
        hasCustomEntity(arg0: Internal.ItemStack): boolean;
        setCraftingRemainderKJS(arg0: Internal.Item): void;
        setMaxDamageKJS(arg0: number): void;
        getHighlightTip(arg0: Internal.ItemStack, arg1: Internal.Component): Internal.Component;
        initializeClient(arg0: (arg0: Internal.IItemRenderProperties) => void): void;
        getMaxDamage(arg0: Internal.ItemStack): number;
        getCreatorModId(arg0: Internal.ItemStack): string;
        setRarityKJS(arg0: Internal.Rarity): void;
        isDamaged(arg0: Internal.ItemStack): boolean;
        onArmorTick(arg0: Internal.ItemStack, arg1: net.minecraft.world.level.Level, arg2: Internal.Player): void;
        addPlaceable(arg0: Internal.Block): void;
        hasContainerItem(arg0: Internal.ItemStack): boolean;
        doesSneakBypassUse(arg0: Internal.ItemStack, arg1: Internal.LevelReader, arg2: BlockPos, arg3: Internal.Player): boolean;
        onItemUseFirst(arg0: Internal.ItemStack, arg1: Internal.UseOnContext): Internal.InteractionResult;
        getContainerItem(arg0: Internal.ItemStack): Internal.ItemStack;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: string, arg1: string): Internal.Item;
        setRegistryName(arg0: ResourceLocation): any;
        setRegistryName(arg0: ResourceLocation): Internal.Item;
        setRegistryName(arg0: string): Internal.Item;
        onDestroyed(arg0: Internal.ItemEntity, arg1: Internal.DamageSource): void;
        isCorrectToolForDrops(arg0: Internal.ItemStack, arg1: Internal.BlockState): boolean;
        getEquipmentSlot(arg0: Internal.ItemStack): EquipmentSlot;
        handler$zjo000$getUseDuration(arg0: Internal.ItemStack, arg1: Internal.CallbackInfoReturnable<any>): void;
        initCapabilities(arg0: Internal.ItemStack, arg1: Internal.CompoundTag): Internal.ICapabilityProvider;
        getItemStackLimit(arg0: Internal.ItemStack): number;
        equals(arg0: any): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack, arg1: Internal.LivingEntity): boolean;
        handler$baf000$overrideOtherStackedOnMe(arg0: Internal.ItemStack, arg1: Internal.ItemStack, arg2: Internal.Slot, arg3: Internal.ClickAction, arg4: Internal.Player, arg5: Internal.SlotAccess, arg6: Internal.CallbackInfoReturnable<any>): void;
        toString(): string;
        isEnderMask(arg0: Internal.ItemStack, arg1: Internal.Player, arg2: Internal.EnderMan): boolean;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack, arg1: Internal.Enchantment): boolean;
        readonly delegate : () => Internal.Item;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get category(): Internal.CreativeModeTab;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        get blockItemOverride(): Internal.BlockItem;
        set rarityKJS(arg0: Internal.Rarity);
        set maxStackSizeKJS(arg0: number);
        set itemBuilderKJS(b: Internal.ItemBuilder);
        set foodPropertiesKJS(arg0: Internal.FoodProperties);
        set burnTime(i: number);
        set fireResistantKJS(arg0: boolean);
        set registryName(arg0: ResourceLocation);
        set category(arg0: Internal.CreativeModeTab);
        set craftingRemainderKJS(arg0: Internal.Item);
        set maxDamageKJS(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface RandomAccess {
    }
    interface ExtendedAbstractBlockState {
        getOpacityIfCached(): number;
        isConditionallyFullOpaque(): boolean;
    }
    class ServerLevel extends net.minecraft.world.level.Level implements Internal.WorldGenLevel, Internal.WorldEntityByChunkAccess, me.jellysquid.mods.lithium.mixin.ai.nearby_entity_tracking.ServerWorldAccessor, Internal.ServerWorldAccessor, Internal.ServerWorldExtended, Internal.ExtendedWorld {
        setNavigationActive(mobEntity: Internal.Mob): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        getChunkAtImmediately(arg0: number, arg1: number): Internal.LevelChunk;
        notifyAll(): void;
        redirect$zoe000$onTickBlock(state: Internal.BlockState, level: Internal.ServerLevel, pos: BlockPos, random: Internal.Random): void;
        getLoadedExistingBlockEntity(pos: BlockPos): Internal.BlockEntity;
        addFreshBlockEntities(arg0: Internal.Collection<Internal.BlockEntity>): void;
        getEntityManager(): Internal.PersistentEntitySectionManager<any>;
        notify(): void;
        getEntitiesInChunk(chunkX: number, chunkZ: number): Internal.Collection<any>;
        removePlayer(arg0: Internal.ServerPlayer, arg1: boolean): void;
        markAndNotifyBlock(arg0: BlockPos, arg1: Internal.LevelChunk, arg2: Internal.BlockState, arg3: Internal.BlockState, arg4: number, arg5: number): void;
        redirect$zoe000$onTickLiquid(state: Internal.FluidState, level: net.minecraft.world.level.Level, pos: BlockPos): void;
        handler$zkg000$wireBlockCallback(arg0: BlockPos, arg1: Internal.BlockState, arg2: Internal.BlockState, arg3: number, arg4: Internal.CallbackInfo): void;
        invalidateCaps(): void;
        getLunarContext(): Internal.LunarContext;
        hashCode(): number;
        increaseMaxEntityRadius(arg0: number): number;
        redirect$zod000$redirectTick(blockEntity: Internal.TickingBlockEntity): void;
        removeEntityComplete(arg0: Internal.Entity, arg1: boolean): void;
        close(): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<net.minecraft.world.level.Level>): boolean;
        getMaxEntityRadius(): number;
        removeEntity(arg0: Internal.Entity): void;
        removeEntity(arg0: Internal.Entity, arg1: boolean): void;
        asKJS(): any;
        reviveCaps(): void;
        setNavigationInactive(mobEntity: Internal.Mob): void;
        getAnyChunkImmediately(arg0: number, arg1: number): Internal.ChunkAccess;
        equals(arg0: any): boolean;
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean;
        toString(): string;
        getRandomPosInChunk(x: number, y: number, z: number, mask: number, out: Internal.BlockPos$MutableBlockPos): void;
        setLunarContext(arg0: Internal.LunarContext): Internal.LunarContext;
        isConsistent(): boolean;
        restoringBlockSnapshots : boolean;
        capturedBlockSnapshots : Internal.ArrayList<Internal.BlockSnapshot>;
        captureBlockSnapshots : boolean;
        get lunarContext(): Internal.LunarContext;
        get entityManager(): Internal.PersistentEntitySectionManager<any>;
        get maxEntityRadius(): number;
        get consistent(): boolean;
        get class(): Internal.Class<any>;
        set lunarContext(arg0: Internal.LunarContext);
        set navigationInactive(mobEntity: Internal.Mob);
        set navigationActive(mobEntity: Internal.Mob);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ConsoleJS {
        getClass(): Internal.Class<any>;
        printObject(o: any, tree: boolean): void;
        printObject(o: any): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        infof(message: any, args: any[]): void;
        log(message: any): void;
        notifyAll(): void;
        errorf(message: string, args: any[]): void;
        setMuted(m: boolean): void;
        error(message: string, throwable: Internal.Throwable): void;
        error(message: any): void;
        error(message: string, throwable: Internal.Throwable, skip: Internal.Pattern): void;
        notify(): void;
        debugf(message: string, args: any[]): void;
        trace(): void;
        flush(): void;
        hashCode(): number;
        setWriteToFile(m: boolean): void;
        setLineNumber(b: boolean): void;
        getScriptLine(): number;
        warnf(message: string, args: any[]): void;
        info(message: any): void;
        group(): void;
        getMuted(): boolean;
        debug(message: any): void;
        printStackTrace(throwable: Internal.Throwable, skip: Internal.Pattern): void;
        getLogger(): Internal.Logger;
        shouldPrintDebug(): boolean;
        setDebugEnabled(m: boolean): void;
        resetFile(): void;
        warn(message: string, throwable: Internal.Throwable, skip: Internal.Pattern): void;
        warn(message: string, throwable: Internal.Throwable): void;
        warn(message: any): void;
        getDebugEnabled(): boolean;
        groupEnd(): void;
        printClass(className: string): void;
        printClass(className: string, tree: boolean): void;
        equals(arg0: any): boolean;
        toString(): string;
        getWriteToFile(): boolean;
        static SERVER : Internal.ConsoleJS;
        static STARTUP : Internal.ConsoleJS;
        static CLIENT : Internal.ConsoleJS;
        get scriptLine(): number;
        get writeToFile(): boolean;
        get logger(): Internal.Logger;
        get debugEnabled(): boolean;
        get class(): Internal.Class<any>;
        get muted(): boolean;
        set writeToFile(m: boolean);
        set debugEnabled(m: boolean);
        set lineNumber(b: boolean);
        set muted(m: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface StackedContentsCompatible {
    }
    class Products$P5 <F, T1, T2, T3, T4, T5> {
        t4(): Internal.App<F, T4>;
        getClass(): Internal.Class<any>;
        t5(): Internal.App<F, T5>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function5<T1, T2, T3, T4, T5, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function5<T1, T2, T3, T4, T5, R>>): Internal.App<F, R>;
        notifyAll(): void;
        notify(): void;
        hashCode(): number;
        and<T6, T7>(arg0: Internal.Products$P2<F, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        and<T6, T7, T8>(arg0: Internal.Products$P3<F, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        and<T6>(arg0: Internal.App<F, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class CreativeModeTab {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getLabelColor(): number;
        getSearchbarWidth(): number;
        setBackgroundImage(arg0: ResourceLocation): Internal.CreativeModeTab;
        static getGroupCountSafe(): number;
        notify(): void;
        hasSearchBar(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getBackgroundImage(): ResourceLocation;
        getSlotColor(): number;
        getTabPage(): number;
        getTabsImage(): ResourceLocation;
        get tabsImage(): ResourceLocation;
        get slotColor(): number;
        get backgroundImage(): ResourceLocation;
        get tabPage(): number;
        get searchbarWidth(): number;
        get groupCountSafe(): number;
        get class(): Internal.Class<any>;
        get labelColor(): number;
        set backgroundImage(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class PathNavigation {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Endimation$Builder {
        keyframes(arg0: Internal.Endimation$Builder$Keyframes): Internal.Endimation$Builder;
        keyframes(arg0: (arg0: string) => Internal.Endimation$PartKeyframes): Internal.Endimation$Builder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        effects(arg0: any[]): Internal.Endimation$Builder;
        build(): Internal.Endimation;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        blendWeight(arg0: number): Internal.Endimation$Builder;
        length(arg0: number): Internal.Endimation$Builder;
        toString(): string;
        addEffects(arg0: any[]): Internal.Endimation$Builder;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ClocheRenderFunction$ClocheRenderReference {
        getClass(): Internal.Class<any>;
        serialize(): Internal.JsonObject;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getBlock(): Internal.Block;
        static read(arg0: Internal.FriendlyByteBuf): Internal.ClocheRenderFunction$ClocheRenderReference;
        getType(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        write(arg0: Internal.FriendlyByteBuf): void;
        notify(): void;
        static deserialize(arg0: Internal.JsonObject): Internal.ClocheRenderFunction$ClocheRenderReference;
        get block(): Internal.Block;
        get type(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ParticleManagerAccess {
        invokeMakeParticle<T>(arg0: T, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Internal.Particle;
    }
    class MultipartBlockStateGenerator {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toJson(): Internal.JsonObject;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        part(when: string, model: string): void;
        part(when: string, consumer: (arg0: Internal.MultipartBlockStateGenerator$Part) => void): void;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ExplosionJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        strength(f: number): Internal.ExplosionJS;
        hashCode(): number;
        damagesTerrain(b: boolean): Internal.ExplosionJS;
        exploder(entity: Internal.EntityJS): Internal.ExplosionJS;
        explode(): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        causesFire(b: boolean): Internal.ExplosionJS;
        destroysTerrain(b: boolean): Internal.ExplosionJS;
        notify(): void;
        explosionMode : Internal.Explosion$BlockInteraction;
        readonly x : number;
        readonly y : number;
        readonly z : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface RenderTypeAccess {
        getName(): string;
    }
    class Products$P10 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CokeOvenRecipeJS extends Internal.IERecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter, action: Internal.IngredientAction): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS, newIngredient: Internal.IngredientJS): Internal.IngredientJS;
        getUniqueId(): string;
        parseIngredientItemIE(json: Internal.JsonElement): Internal.IngredientStackJS;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean, func: (arg0: Internal.ItemStackJS, arg1: Internal.ItemStackJS) => Internal.ItemStackJS): boolean;
        replaceOutput(i: Internal.IngredientJS, with_: Internal.ItemStackJS, exact: boolean): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation): Internal.RecipeJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        energy(e: number): Internal.IERecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean, func: (arg0: Internal.IngredientJS, arg1: Internal.IngredientJS) => Internal.IngredientJS): boolean;
        replaceInput(i: Internal.IngredientJS, with_: Internal.IngredientJS, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter, id: string): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS, newStack: Internal.ItemStackJS): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter, damage: number): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        creosote(c: number): Internal.CokeOvenRecipeJS;
        getOutputIndex(ingredient: Internal.IngredientJS, exact: boolean): number;
        resultFromRecipeJson(json: Internal.JsonObject): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS): Internal.JsonElement;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS): Internal.JsonElement;
        toString(): string;
        time(t: number): Internal.IERecipeJS;
        hasInput(ingredient: Internal.IngredientJS, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter, item: Internal.ItemStackJS): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        readonly inputItems : Internal.List<Internal.IngredientJS>;
        static itemErrors : false;
        type : Internal.RecipeTypeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        readonly outputFluids : Internal.List<net.minecraftforge.fluids.FluidStack>;
        originalRecipe : Internal.Recipe<any>;
        readonly inputFluids : Internal.List<(arg0: any) => boolean>;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface NonNullFunction <T, R> {
        apply(arg0: T): R;
    }
    interface Float2CharFunction extends it.unimi.dsi.fastutil.Function<number, string>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: number, arg1: string): string;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: string): string;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: string): string;
        remove(arg0: number): string;
        remove(arg0: any): string;
        remove(arg0: any): any;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): string;
        get(arg0: any): any;
        get(arg0: number): string;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): string;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => string;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface Function9 <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, (arg0: T8, arg1: T9) => R>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, (arg0: T9) => R>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function4<T6, T7, T8, T9, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function3<T7, T8, T9, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function6<T4, T5, T6, T7, T8, T9, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function5<T5, T6, T7, T8, T9, R>>;
        curry2(): (arg0: T1, arg1: T2) => Internal.Function7<T3, T4, T5, T6, T7, T8, T9, R>;
        curry(): (arg0: T1) => Internal.Function8<T2, T3, T4, T5, T6, T7, T8, T9, R>;
    }
    interface ObjDoubleConsumer <T> {
        accept(arg0: T, arg1: number): void;
    }
    class Proxy$Type extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Proxy$Type;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Proxy$Type[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Proxy$Type): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Proxy$Type>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Proxy$Type>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SOCKS : Internal.Proxy$Type;
        static readonly HTTP : Internal.Proxy$Type;
        static readonly DIRECT : Internal.Proxy$Type;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Proxy$Type>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class VariantBlockStateGenerator$Model {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toJson(): Internal.JsonObject;
        uvlock(): Internal.VariantBlockStateGenerator$Model;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        x(_x: number): Internal.VariantBlockStateGenerator$Model;
        y(_y: number): Internal.VariantBlockStateGenerator$Model;
        toString(): string;
        model(s: string): Internal.VariantBlockStateGenerator$Model;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Vector3d {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class RecipeManager extends Internal.SimpleJsonResourceReloadListener implements Internal.RecipeManagerAccessor, Internal.RecipeManagerKJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        customRecipesKJS(jsonMap: Internal.Map<ResourceLocation, Internal.JsonObject>): void;
        notifyAll(): void;
        setByNameKJS(arg0: Internal.Map<any, any>): void;
        notify(): void;
        setRecipesKJS(arg0: Internal.Map<any, any>): void;
        getRecipeMap(arg0: Internal.RecipeType<any>): Internal.Map<any, any>;
        getByNameKJS(): Internal.Map<any, any>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getGson(): Internal.Gson;
        getRecipesKJS(): Internal.Map<any, any>;
        get recipesKJS(): Internal.Map<any, any>;
        get byNameKJS(): Internal.Map<any, any>;
        get gson(): Internal.Gson;
        get class(): Internal.Class<any>;
        set recipesKJS(arg0: Internal.Map<any, any>);
        set byNameKJS(arg0: Internal.Map<any, any>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class IntOpenHashSet extends Internal.AbstractIntSet implements Internal.Serializable, Internal.Cloneable, Internal.Hash {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
        notify(): void;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        intStream(): Internal.IntStream;
        removeAll(arg0: Internal.IntCollection): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.IntIterator;
        iterator(): Internal.Iterator<any>;
        trim(): boolean;
        trim(arg0: number): boolean;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toIntArray(arg0: number[]): number[];
        toIntArray(): number[];
        static of(): Internal.IntOpenHashSet;
        static of(arg0: number): Internal.IntOpenHashSet;
        static of(arg0: number, arg1: number): Internal.IntOpenHashSet;
        static of(arg0: number[]): Internal.IntOpenHashSet;
        static of(arg0: number, arg1: number, arg2: number): Internal.IntOpenHashSet;
        toArray(arg0: number[]): number[];
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        add(arg0: number): boolean;
        add(arg0: any): boolean;
        spliterator(): Internal.Spliterator<any>;
        spliterator(): Internal.IntSpliterator;
        forEach(arg0: java_.util.function_.IntConsumer): void;
        forEach(arg0: (arg0: any) => void): void;
        forEach(arg0: (arg0: number) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        containsAll(arg0: Internal.IntCollection): boolean;
        isEmpty(): boolean;
        clear(): void;
        static toSetWithExpectedSize(arg0: Internal.IntStream, arg1: number): Internal.IntOpenHashSet;
        removeIf(arg0: (arg0: any) => boolean): boolean;
        removeIf(arg0: (arg0: number) => boolean): boolean;
        removeIf(arg0: Internal.IntPredicate): boolean;
        static toSet(arg0: Internal.IntStream): Internal.IntOpenHashSet;
        contains(arg0: number): boolean;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.IntCollection): boolean;
        addAll(arg0: Internal.Collection<number>): boolean;
        equals(arg0: any): boolean;
        clone(): Internal.IntOpenHashSet;
        clone(): any;
        toString(): string;
        intParallelStream(): Internal.IntStream;
        retainAll(arg0: Internal.Collection<any>): boolean;
        retainAll(arg0: Internal.IntCollection): boolean;
        static readonly DEFAULT_GROWTH_FACTOR : 16;
        static readonly FAST_LOAD_FACTOR : 0.5;
        static readonly DEFAULT_INITIAL_SIZE : 16;
        static readonly DEFAULT_LOAD_FACTOR : 0.75;
        static readonly OCCUPIED : -1;
        static readonly VERY_FAST_LOAD_FACTOR : 0.25;
        static readonly FREE : 0;
        static readonly PRIMES : number[];
        static readonly REMOVED : 1;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Spliterator$OfPrimitive <T, T_CONS, T_SPLITR> extends Internal.Spliterator<T> {
        trySplit(): Internal.Spliterator<any>;
        trySplit(): T_SPLITR;
        characteristics(): number;
        tryAdvance(arg0: T_CONS): boolean;
        tryAdvance(arg0: (arg0: T) => void): boolean;
        getComparator(): Internal.Comparator<T>;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: T_CONS): void;
        forEachRemaining(arg0: (arg0: T) => void): void;
    }
    interface ClientConnectionEncryptionExtension {
        setupEncryption(arg0: Internal.SecretKey): void;
    }
    abstract class LongBuffer extends Internal.Buffer implements Internal.Comparable<Internal.LongBuffer> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        compact(): Internal.LongBuffer;
        notifyAll(): void;
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.LongBuffer): number;
        notify(): void;
        asReadOnlyBuffer(): Internal.LongBuffer;
        put(arg0: number[]): Internal.LongBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.LongBuffer;
        put(arg0: number, arg1: number[]): Internal.LongBuffer;
        put(arg0: number[], arg1: number, arg2: number): Internal.LongBuffer;
        put(arg0: number, arg1: Internal.LongBuffer, arg2: number, arg3: number): Internal.LongBuffer;
        put(arg0: Internal.LongBuffer): Internal.LongBuffer;
        put(arg0: number, arg1: number): Internal.LongBuffer;
        put(arg0: number): Internal.LongBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        slice(): Internal.Buffer;
        slice(): Internal.LongBuffer;
        slice(arg0: number, arg1: number): Internal.Buffer;
        slice(arg0: number, arg1: number): Internal.LongBuffer;
        array(): number[];
        array(): any;
        hashCode(): number;
        get(): number;
        get(arg0: number, arg1: number[]): Internal.LongBuffer;
        get(arg0: number): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.LongBuffer;
        get(arg0: number[], arg1: number, arg2: number): Internal.LongBuffer;
        get(arg0: number[]): Internal.LongBuffer;
        limit(arg0: number): Internal.LongBuffer;
        limit(arg0: number): Internal.Buffer;
        limit(): number;
        arrayOffset(): number;
        flip(): Internal.Buffer;
        flip(): Internal.LongBuffer;
        order(): Internal.ByteOrder;
        hasArray(): boolean;
        hasRemaining(): boolean;
        clear(): Internal.Buffer;
        clear(): Internal.LongBuffer;
        duplicate(): Internal.LongBuffer;
        duplicate(): Internal.Buffer;
        remaining(): number;
        static allocate(arg0: number): Internal.LongBuffer;
        rewind(): Internal.Buffer;
        rewind(): Internal.LongBuffer;
        mismatch(arg0: Internal.LongBuffer): number;
        equals(arg0: any): boolean;
        reset(): Internal.Buffer;
        reset(): Internal.LongBuffer;
        toString(): string;
        position(arg0: number): Internal.LongBuffer;
        position(arg0: number): Internal.Buffer;
        position(): number;
        isDirect(): boolean;
        static wrap(arg0: number[]): Internal.LongBuffer;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.LongBuffer;
        mark(): Internal.Buffer;
        mark(): Internal.LongBuffer;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface IForgeBlockEntity extends Internal.ICapabilitySerializable<Internal.CompoundTag> {
        requestModelDataUpdate(): void;
        getModelData(): Internal.IModelData;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        getTileData(): Internal.CompoundTag;
        onChunkUnloaded(): void;
        getRenderBoundingBox(): Internal.AABB;
        onDataPacket(arg0: Internal.Connection, arg1: Internal.ClientboundBlockEntityDataPacket): void;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        onLoad(): void;
        handleUpdateTag(arg0: Internal.CompoundTag): void;
    }
    class MobCategory extends Internal.Enum<any> implements Internal.StringRepresentable, Internal.IExtensibleEnum {
        getClass(): Internal.Class<any>;
        init(): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.MobCategory;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.MobCategory[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.MobCategory): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.MobCategory>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.MobCategory>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        static create(arg0: string, arg1: string, arg2: number, arg3: boolean, arg4: boolean, arg5: number): Internal.MobCategory;
        toString(): string;
        ordinal(): number;
        static readonly UNDERGROUND_WATER_CREATURE : Internal.MobCategory;
        static readonly WATER_CREATURE : Internal.MobCategory;
        static readonly WATER_AMBIENT : Internal.MobCategory;
        static readonly AXOLOTLS : Internal.MobCategory;
        static readonly AMBIENT : Internal.MobCategory;
        static readonly CREATURE : Internal.MobCategory;
        static readonly MISC : Internal.MobCategory;
        static readonly MONSTER : Internal.MobCategory;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.MobCategory>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class AndCondition implements Internal.IExtendedLootCondition {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: (arg0: Internal.LootContext) => boolean): (arg0: Internal.LootContext) => boolean;
        test(arg0: Internal.LootContext): boolean;
        test(arg0: any): boolean;
        and(arg0: (arg0: Internal.LootContext) => boolean): (arg0: Internal.LootContext) => boolean;
        negate(): (arg0: Internal.LootContext) => boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class SetTag <T> implements net.minecraft.tags.Tag<T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Long2CharFunction extends it.unimi.dsi.fastutil.Function<number, string>, Internal.LongToIntFunction {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: number, arg1: string): string;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: string) => T_): (arg0: number) => T_;
        put(arg0: number, arg1: string): string;
        put(arg0: any, arg1: any): any;
        put(arg0: number, arg1: string): string;
        remove(arg0: number): string;
        remove(arg0: any): string;
        remove(arg0: any): any;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        get(arg0: any): string;
        get(arg0: any): any;
        get(arg0: number): string;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        applyAsInt(arg0: number): number;
        apply(arg0: number): string;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        size(): number;
        compose<T_>(arg0: (arg0: T_) => number): (arg0: T_) => string;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: any) => any;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    abstract class LootEventJS extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        addJson(id: ResourceLocation, json: Internal.JsonObject): void;
        notify(): void;
        modify(id: ResourceLocation, b: (arg0: Internal.LootBuilder) => void): void;
        removeAll(): void;
        post(t: Internal.ScriptType, id: string, sub: string): boolean;
        post(t: Internal.ScriptType, id: string): boolean;
        getType(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getDirectory(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get type(): string;
        get class(): Internal.Class<any>;
        get directory(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class LootTableEntry implements Internal.FunctionContainer, Internal.ConditionContainer {
        enchantWithLevels(levels: Internal.NumberProvider, treasure: boolean): Internal.FunctionContainer;
        damage(damage: Internal.NumberProvider): Internal.FunctionContainer;
        nbt(tag: Internal.CompoundTag): Internal.FunctionContainer;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        survivesExplosion(): Internal.ConditionContainer;
        notifyAll(): void;
        addConditionalFunction(func: (arg0: Internal.ConditionalFunction) => void): Internal.FunctionContainer;
        addCondition(arg0: Internal.JsonObject): Internal.ConditionContainer;
        addCondition(o: Internal.JsonObject): Internal.LootTableEntry;
        notify(): void;
        lootTable(table: ResourceLocation, seed: number): Internal.FunctionContainer;
        hashCode(): number;
        killedByPlayer(): Internal.ConditionContainer;
        randomChance(chance: number): Internal.ConditionContainer;
        addFunction(arg0: Internal.JsonObject): Internal.FunctionContainer;
        addFunction(o: Internal.JsonObject): Internal.LootTableEntry;
        count(count: Internal.NumberProvider): Internal.FunctionContainer;
        weight(weight: number): Internal.LootTableEntry;
        quality(quality: number): Internal.LootTableEntry;
        lootingEnchant(count: Internal.NumberProvider, limit: number): Internal.FunctionContainer;
        entityScores(entity: Internal.LootContext$EntityTarget, scores: Internal.Map<string, any>): Internal.ConditionContainer;
        copyName(source: Internal.CopyNameFunction$NameSource): Internal.FunctionContainer;
        equals(arg0: any): boolean;
        name(name: Internal.Text, entity: Internal.LootContext$EntityTarget): Internal.FunctionContainer;
        name(name: Internal.Text): Internal.FunctionContainer;
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer;
        furnaceSmelt(): Internal.FunctionContainer;
        toString(): string;
        enchantRandomly(enchantments: ResourceLocation[]): Internal.FunctionContainer;
        entityProperties(entity: Internal.LootContext$EntityTarget, properties: Internal.JsonObject): Internal.ConditionContainer;
        readonly json : Internal.JsonObject;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface FireworkRocketEntityKJS {
        setLifetimeKJS(arg0: number): void;
    }
    interface Enemy {
    }
    class BlockEntityWithoutLevelRenderer implements Internal.ResourceManagerReloadListener {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ChannelId extends Internal.Serializable, Internal.Comparable<Internal.ChannelId> {
        asShortText(): string;
        compareTo(arg0: Internal.ChannelId): number;
        asLongText(): string;
    }
    interface DoubleToIntFunction {
        applyAsInt(arg0: number): number;
    }
    interface BaseMapCodec <K, V> {
        encode<T>(arg0: Internal.Map<K, V>, arg1: Internal.DynamicOps<T>, arg2: Internal.RecordBuilder<T>): Internal.RecordBuilder<T>;
        elementCodec(): Internal.Codec<V>;
        keyCodec(): Internal.Codec<K>;
        decode<T>(arg0: Internal.DynamicOps<T>, arg1: Internal.MapLike<T>): Internal.DataResult<Internal.Map<K, V>>;
    }
    class Locale implements Internal.Cloneable, Internal.Serializable {
        stripExtensions(): Internal.Locale;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static forLanguageTag(arg0: string): Internal.Locale;
        getUnicodeLocaleAttributes(): Internal.Set<string>;
        getCountry(): string;
        notifyAll(): void;
        getUnicodeLocaleKeys(): Internal.Set<string>;
        notify(): void;
        getISO3Country(): string;
        static lookupTag(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<string>): string;
        getDisplayCountry(): string;
        getDisplayCountry(arg0: Internal.Locale): string;
        getISO3Language(): string;
        static getISOCountries(): string[];
        static getISOCountries(arg0: Internal.Locale$IsoCountryCode): Internal.Set<string>;
        hashCode(): number;
        getExtensionKeys(): Internal.Set<string>;
        getDisplayVariant(arg0: Internal.Locale): string;
        getDisplayVariant(): string;
        static filterTags(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<string>): Internal.List<string>;
        static filterTags(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<string>, arg2: Internal.Locale$FilteringMode): Internal.List<string>;
        static getISOLanguages(): string[];
        toLanguageTag(): string;
        static getAvailableLocales(): Internal.Locale[];
        getDisplayScript(arg0: Internal.Locale): string;
        getDisplayScript(): string;
        static lookup(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<Internal.Locale>): Internal.Locale;
        getLanguage(): string;
        getExtension(arg0: string): string;
        getVariant(): string;
        static getDefault(): Internal.Locale;
        static getDefault(arg0: Internal.Locale$Category): Internal.Locale;
        static setDefault(arg0: Internal.Locale$Category, arg1: Internal.Locale): void;
        static setDefault(arg0: Internal.Locale): void;
        hasExtensions(): boolean;
        static filter(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<Internal.Locale>, arg2: Internal.Locale$FilteringMode): Internal.List<Internal.Locale>;
        static filter(arg0: Internal.List<Internal.Locale$LanguageRange>, arg1: Internal.Collection<Internal.Locale>): Internal.List<Internal.Locale>;
        getDisplayName(arg0: Internal.Locale): string;
        getDisplayName(): string;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        getDisplayLanguage(arg0: Internal.Locale): string;
        getDisplayLanguage(): string;
        getScript(): string;
        getUnicodeLocaleType(arg0: string): string;
        static readonly PRC : Internal.Locale;
        static readonly CANADA : Internal.Locale;
        static readonly ENGLISH : Internal.Locale;
        static readonly ROOT : Internal.Locale;
        static readonly TAIWAN : Internal.Locale;
        static readonly CHINA : Internal.Locale;
        static readonly ITALY : Internal.Locale;
        static readonly CHINESE : Internal.Locale;
        static readonly KOREA : Internal.Locale;
        static readonly FRENCH : Internal.Locale;
        static readonly FRANCE : Internal.Locale;
        static readonly TRADITIONAL_CHINESE : Internal.Locale;
        static readonly CANADA_FRENCH : Internal.Locale;
        static readonly GERMANY : Internal.Locale;
        static readonly ITALIAN : Internal.Locale;
        static readonly PRIVATE_USE_EXTENSION : "x";
        static readonly UK : Internal.Locale;
        static readonly JAPAN : Internal.Locale;
        static readonly JAPANESE : Internal.Locale;
        static readonly UNICODE_LOCALE_EXTENSION : "u";
        static readonly SIMPLIFIED_CHINESE : Internal.Locale;
        static readonly GERMAN : Internal.Locale;
        static readonly US : Internal.Locale;
        static readonly KOREAN : Internal.Locale;
        get unicodeLocaleKeys(): Internal.Set<string>;
        get country(): string;
        get displayName(): string;
        get iSOLanguages(): string[];
        get displayVariant(): string;
        get language(): string;
        get displayLanguage(): string;
        get script(): string;
        get iSO3Country(): string;
        get availableLocales(): Internal.Locale[];
        get iSOCountries(): string[];
        get unicodeLocaleAttributes(): Internal.Set<string>;
        get default(): Internal.Locale;
        get displayCountry(): string;
        get variant(): string;
        get extensionKeys(): Internal.Set<string>;
        get displayScript(): string;
        get class(): Internal.Class<any>;
        get iSO3Language(): string;
        set default(arg0: Internal.Locale);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LongStream$LongMapMultiConsumer {
        accept(arg0: number, arg1: Internal.LongConsumer): void;
    }
    class NamedPackage {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LongBinaryOperator {
        applyAsLong(arg0: number, arg1: number): number;
    }
    interface CustomJavaObjectWrapper {
        wrapAsJavaObject(arg0: Internal.Context, arg1: Internal.Scriptable, arg2: Internal.Class<any>): Internal.Scriptable;
    }
    class Either$Mu <R> implements Internal.K1 {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class NetworkInterface {
        getClass(): Internal.Class<any>;
        getInterfaceAddresses(): Internal.List<Internal.InterfaceAddress>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        getIndex(): number;
        supportsMulticast(): boolean;
        getSubInterfaces(): Internal.Enumeration<Internal.NetworkInterface>;
        notifyAll(): void;
        inetAddresses(): Internal.Stream<Internal.InetAddress>;
        notify(): void;
        isPointToPoint(): boolean;
        isUp(): boolean;
        hashCode(): number;
        static getByName(arg0: string): Internal.NetworkInterface;
        isLoopback(): boolean;
        subInterfaces(): Internal.Stream<Internal.NetworkInterface>;
        getParent(): Internal.NetworkInterface;
        static getByIndex(arg0: number): Internal.NetworkInterface;
        static getByInetAddress(arg0: Internal.InetAddress): Internal.NetworkInterface;
        getMTU(): number;
        static networkInterfaces(): Internal.Stream<Internal.NetworkInterface>;
        getDisplayName(): string;
        equals(arg0: any): boolean;
        getHardwareAddress(): number[];
        toString(): string;
        isVirtual(): boolean;
        static getNetworkInterfaces(): Internal.Enumeration<Internal.NetworkInterface>;
        getInetAddresses(): Internal.Enumeration<Internal.InetAddress>;
        get parent(): Internal.NetworkInterface;
        get hardwareAddress(): number[];
        get virtual(): boolean;
        get displayName(): string;
        get pointToPoint(): boolean;
        get interfaceAddresses(): Internal.List<Internal.InterfaceAddress>;
        get name(): string;
        get index(): number;
        get up(): boolean;
        get class(): Internal.Class<any>;
        get loopback(): boolean;
        get mTU(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ResourceProvider {
    }
    interface PrimitiveIterator <T, T_CONS> extends Internal.Iterator<T> {
        next(): T;
        hasNext(): boolean;
        forEachRemaining(arg0: T_CONS): void;
        forEachRemaining(arg0: (arg0: T) => void): void;
        remove(): void;
    }
    class AccessControlContext {
        getClass(): Internal.Class<any>;
        checkPermission(arg0: Internal.Permission): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getDomainCombiner(): Internal.DomainCombiner;
        toString(): string;
        notify(): void;
        get domainCombiner(): Internal.DomainCombiner;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class BiomeDictionary$Type {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getAll(): Internal.Collection<Internal.BiomeDictionary$Type>;
        getName(): string;
        static getType(arg0: string, arg1: Internal.BiomeDictionary$Type[]): Internal.BiomeDictionary$Type;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        static fromVanilla(arg0: Internal.Biome$BiomeCategory): Internal.BiomeDictionary$Type;
        notify(): void;
        static hasType(arg0: string): boolean;
        static readonly SNOWY : Internal.BiomeDictionary$Type;
        static readonly BEACH : Internal.BiomeDictionary$Type;
        static readonly UNDERGROUND : Internal.BiomeDictionary$Type;
        static readonly SAVANNA : Internal.BiomeDictionary$Type;
        static readonly MESA : Internal.BiomeDictionary$Type;
        static readonly RARE : Internal.BiomeDictionary$Type;
        static readonly SPOOKY : Internal.BiomeDictionary$Type;
        static readonly WET : Internal.BiomeDictionary$Type;
        static readonly SPARSE : Internal.BiomeDictionary$Type;
        static readonly MOUNTAIN : Internal.BiomeDictionary$Type;
        static readonly DRY : Internal.BiomeDictionary$Type;
        static readonly RIVER : Internal.BiomeDictionary$Type;
        static readonly MAGICAL : Internal.BiomeDictionary$Type;
        static readonly NETHER : Internal.BiomeDictionary$Type;
        static readonly WATER : Internal.BiomeDictionary$Type;
        static readonly DENSE : Internal.BiomeDictionary$Type;
        static readonly JUNGLE : Internal.BiomeDictionary$Type;
        static readonly SANDY : Internal.BiomeDictionary$Type;
        static readonly OCEAN : Internal.BiomeDictionary$Type;
        static readonly HILLS : Internal.BiomeDictionary$Type;
        static readonly HOT : Internal.BiomeDictionary$Type;
        static readonly FOREST : Internal.BiomeDictionary$Type;
        static readonly MUSHROOM : Internal.BiomeDictionary$Type;
        static readonly OVERWORLD : Internal.BiomeDictionary$Type;
        static readonly PLATEAU : Internal.BiomeDictionary$Type;
        static readonly PLAINS : Internal.BiomeDictionary$Type;
        static readonly SWAMP : Internal.BiomeDictionary$Type;
        static readonly PEAK : Internal.BiomeDictionary$Type;
        static readonly END : Internal.BiomeDictionary$Type;
        static readonly COLD : Internal.BiomeDictionary$Type;
        static readonly DEAD : Internal.BiomeDictionary$Type;
        static readonly MODIFIED : Internal.BiomeDictionary$Type;
        static readonly VOID : Internal.BiomeDictionary$Type;
        static readonly LUSH : Internal.BiomeDictionary$Type;
        static readonly CONIFEROUS : Internal.BiomeDictionary$Type;
        static readonly SLOPE : Internal.BiomeDictionary$Type;
        static readonly WASTELAND : Internal.BiomeDictionary$Type;
        get all(): Internal.Collection<Internal.BiomeDictionary$Type>;
        get name(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class MutableUnit extends dev.latvian.mods.rhino.util.unit.Unit {
        getClass(): Internal.Class<any>;
        mod(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        log1p(): dev.latvian.mods.rhino.util.unit.Unit;
        cos(): dev.latvian.mods.rhino.util.unit.Unit;
        deg(): dev.latvian.mods.rhino.util.unit.Unit;
        lt(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        atan(): dev.latvian.mods.rhino.util.unit.Unit;
        getAsInt(): number;
        div(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        neg(): dev.latvian.mods.rhino.util.unit.Unit;
        shiftLeft(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        rad(): dev.latvian.mods.rhino.util.unit.Unit;
        sqrt(): dev.latvian.mods.rhino.util.unit.Unit;
        gte(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        neq(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        atan2(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        tan(): dev.latvian.mods.rhino.util.unit.Unit;
        add(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        toBool(): dev.latvian.mods.rhino.util.unit.Unit;
        ceil(): dev.latvian.mods.rhino.util.unit.Unit;
        eq(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        shiftRight(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        sub(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mul(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        log(): dev.latvian.mods.rhino.util.unit.Unit;
        log10(): dev.latvian.mods.rhino.util.unit.Unit;
        notifyAll(): void;
        notify(): void;
        not(): dev.latvian.mods.rhino.util.unit.Unit;
        min(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        hashCode(): number;
        and(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        get(): number;
        pow(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        sin(): dev.latvian.mods.rhino.util.unit.Unit;
        xor(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        lte(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        floor(): dev.latvian.mods.rhino.util.unit.Unit;
        isFixed(): boolean;
        sq(): dev.latvian.mods.rhino.util.unit.Unit;
        or(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        set(v: number): void;
        max(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        gt(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        abs(): dev.latvian.mods.rhino.util.unit.Unit;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        append(sb: Internal.StringBuilder): void;
        get asInt(): number;
        get fixed(): boolean;
        get class(): Internal.Class<any>;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class EntityDimensions {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MatchResult {
        groupCount(): number;
        start(arg0: number): number;
        start(): number;
        end(arg0: number): number;
        end(): number;
        group(): string;
        group(arg0: number): string;
    }
    interface Guard {
        checkGuard(arg0: any): void;
    }
    interface Function15 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, Internal.Function3<T13, T14, T15, R>>;
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function6<T10, T11, T12, T13, T14, T15, R>>;
        curry13(): Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, (arg0: T14, arg1: T15) => R>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13, arg13: T14, arg14: T15): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function8<T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry14(): Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, (arg0: T15) => R>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function7<T9, T10, T11, T12, T13, T14, T15, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function5<T11, T12, T13, T14, T15, R>>;
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function4<T12, T13, T14, T15, R>>;
        curry(): (arg0: T1) => Internal.Function14<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function10<T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function9<T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function12<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function11<T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry2(): (arg0: T1, arg1: T2) => Internal.Function13<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>;
    }
    interface IForgeRegistryEntry <V> {
        getRegistryType(): Internal.Class<V>;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation): V;
    }
    interface Spliterator$OfInt extends Internal.Spliterator$OfPrimitive<number, java_.util.function_.IntConsumer, Internal.Spliterator$OfInt> {
        trySplit(): Internal.Spliterator$OfPrimitive<any, any, any>;
        trySplit(): Internal.Spliterator<any>;
        trySplit(): Internal.Spliterator$OfInt;
        characteristics(): number;
        tryAdvance(arg0: java_.util.function_.IntConsumer): boolean;
        tryAdvance(arg0: (arg0: number) => void): boolean;
        tryAdvance(arg0: any): boolean;
        getComparator(): Internal.Comparator<number>;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: any): void;
        forEachRemaining(arg0: java_.util.function_.IntConsumer): void;
        forEachRemaining(arg0: (arg0: number) => void): void;
    }
    interface RemovableBlockEntity {
        increaseRemoveCounter(): void;
        getRemovedCountLithium(): number;
    }
    interface Recipe <C> {
    }
    class JsonNull extends Internal.JsonElement {
        getAsFloat(): number;
        getClass(): Internal.Class<any>;
        getAsByte(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAsBigDecimal(): Internal.BigDecimal;
        notifyAll(): void;
        getAsNumber(): Internal.Number;
        getAsCharacter(): string;
        getAsString(): string;
        isJsonArray(): boolean;
        notify(): void;
        getAsInt(): number;
        isJsonPrimitive(): boolean;
        getAsLong(): number;
        isJsonObject(): boolean;
        hashCode(): number;
        getAsBigInteger(): Internal.BigInteger;
        getAsJsonObject(): Internal.JsonObject;
        getAsJsonNull(): Internal.JsonNull;
        isJsonNull(): boolean;
        getAsDouble(): number;
        deepCopy(): Internal.JsonNull;
        deepCopy(): Internal.JsonElement;
        getAsJsonArray(): Internal.JsonArray;
        getAsJsonPrimitive(): Internal.JsonPrimitive;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getAsShort(): number;
        static readonly INSTANCE : Internal.JsonNull;
        get asByte(): number;
        get asBigInteger(): Internal.BigInteger;
        get asJsonObject(): Internal.JsonObject;
        get asCharacter(): string;
        get jsonPrimitive(): boolean;
        get asNumber(): Internal.Number;
        get asBigDecimal(): Internal.BigDecimal;
        get jsonNull(): boolean;
        get asFloat(): number;
        get asLong(): number;
        get asInt(): number;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get asJsonNull(): Internal.JsonNull;
        get asShort(): number;
        get asDouble(): number;
        get asJsonArray(): Internal.JsonArray;
        get asString(): string;
        get jsonObject(): boolean;
        get class(): Internal.Class<any>;
        get jsonArray(): boolean;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LongPredicate {
        or(arg0: Internal.LongPredicate): Internal.LongPredicate;
        test(arg0: number): boolean;
        and(arg0: Internal.LongPredicate): Internal.LongPredicate;
        negate(): Internal.LongPredicate;
    }
    class EntityType <T> extends Internal.ForgeRegistryEntry<any> implements Internal.EntityTypeTest<Internal.Entity, T>, Internal.EntityTypeExtension<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: string, arg1: string): Internal.EntityType<any>;
        setRegistryName(arg0: ResourceLocation): any;
        setRegistryName(arg0: ResourceLocation): Internal.EntityType<any>;
        setRegistryName(arg0: string): Internal.EntityType<any>;
        getTags(): Internal.Set<ResourceLocation>;
        notify(): void;
        flywheel$setInstancingController(arg0: Internal.EntityInstancingController<any>): void;
        flywheel$getInstancingController(): Internal.EntityInstancingController<any>;
        hashCode(): number;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.EntityType<any>>;
        toString(): string;
        customClientSpawn(arg0: Internal.PlayMessages$SpawnEntity, arg1: net.minecraft.world.level.Level): T;
        readonly delegate : () => Internal.EntityType<any>;
        get registryType(): Internal.Class<Internal.EntityType<any>>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Set<ResourceLocation>;
        set registryName(arg0: ResourceLocation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class CallbackInfo implements Internal.Cancellable {
        cancel(): void;
        getClass(): Internal.Class<any>;
        static getCallInfoClassName(arg0: Internal.Type): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        isCancellable(): boolean;
        getId(): string;
        toString(): string;
        notify(): void;
        get cancelled(): boolean;
        get id(): string;
        get class(): Internal.Class<any>;
        get cancellable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Scale <Self> {
        scale(arg0: number, arg1: number, arg2: number): Self;
        scale(arg0: number): Self;
    }
    abstract class RenderType extends Internal.RenderStateShard implements Internal.RenderTypeExtension {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        flywheel$getDrawBuffer(): Internal.DrawBuffer;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get name(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Reference2FloatFunction <K> extends it.unimi.dsi.fastutil.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: any, arg1: any): any;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        applyAsDouble(arg0: K): number;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        getFloat(arg0: any): number;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        andThen<T_>(arg0: (arg0: number) => T_): (arg0: K) => T_;
        put(arg0: K, arg1: number): number;
        put(arg0: K, arg1: number): number;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): any;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        get(arg0: any): number;
        get(arg0: any): any;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        removeFloat(arg0: any): number;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: any) => any;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => number;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: any) => any): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    interface ItemTooltipEventJS$StaticTooltipHandlerFromJS {
        accept(arg0: Internal.ItemStackJS, arg1: boolean, arg2: Internal.List<any>): void;
    }
    class MobSpawnSettings implements Internal.MobSpawnInfoAccess {
        getSpawners(): Internal.Map<any, any>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getEntityTypes(): Internal.Set<Internal.EntityType<any>>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getMobSpawnCosts(): Internal.Map<any, any>;
        toString(): string;
        static create_$md$dd73f7$0(arg0: number, arg1: Internal.Map<any, any>, arg2: Internal.Map<any, any>): Internal.MobSpawnSettings;
        notify(): void;
        getSpawnerTypes(): Internal.Set<Internal.MobCategory>;
        get mobSpawnCosts(): Internal.Map<any, any>;
        get spawnerTypes(): Internal.Set<Internal.MobCategory>;
        get entityTypes(): Internal.Set<Internal.EntityType<any>>;
        get spawners(): Internal.Map<any, any>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MutableComponent extends Internal.Component {
        getString(): string;
    }
    class ResolvedModule {
        reference(): Internal.ModuleReference;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        configuration(): Internal.Configuration;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        reads(): Internal.Set<Internal.ResolvedModule>;
        name(): string;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MessageSender {
        setStatusMessage(message: Internal.Component): void;
        getName(): Internal.Text;
        getDisplayName(): Internal.Text;
        tell(arg0: Internal.Component): void;
        runCommand(arg0: string): number;
        runCommandSilent(command: string): number;
    }
    interface Flushable {
        flush(): void;
    }
    class HoverEvent {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface INBTSerializable <T> {
        serializeNBT(): T;
        deserializeNBT(arg0: T): void;
    }
    class Collector$Characteristics extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Collector$Characteristics;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Collector$Characteristics[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.Collector$Characteristics): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Collector$Characteristics>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Collector$Characteristics>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly IDENTITY_FINISH : Internal.Collector$Characteristics;
        static readonly UNORDERED : Internal.Collector$Characteristics;
        static readonly CONCURRENT : Internal.Collector$Characteristics;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Collector$Characteristics>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Constructor <T> extends Internal.Executable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        getParameterCount(): number;
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean;
        notifyAll(): void;
        isSynthetic(): boolean;
        getAnnotatedParameterTypes(): Internal.AnnotatedType[];
        getParameterTypes(): Internal.Class<any>[];
        getGenericExceptionTypes(): java_.lang.reflect.Type[];
        notify(): void;
        getAnnotatedReceiverType(): Internal.AnnotatedType;
        getDeclaredAnnotations(): Internal.Annotation[];
        getDeclaringClass(): Internal.Class<T>;
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        hashCode(): number;
        canAccess(arg0: any): boolean;
        toGenericString(): string;
        getTypeParameters(): any[];
        getModifiers(): number;
        trySetAccessible(): boolean;
        isAccessible(): boolean;
        setAccessible(arg0: boolean): void;
        static setAccessible(arg0: Internal.AccessibleObject[], arg1: boolean): void;
        isVarArgs(): boolean;
        newInstance(arg0: any[]): T;
        getAnnotations(): Internal.Annotation[];
        getAnnotatedExceptionTypes(): Internal.AnnotatedType[];
        getExceptionTypes(): Internal.Class<any>[];
        getGenericParameterTypes(): java_.lang.reflect.Type[];
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        equals(arg0: any): boolean;
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        getParameters(): any[];
        toString(): string;
        getAnnotatedReturnType(): Internal.AnnotatedType;
        getParameterAnnotations(): Internal.Annotation[][];
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get declaredAnnotations(): Internal.Annotation[];
        get accessible(): boolean;
        get annotatedReturnType(): Internal.AnnotatedType;
        get parameterTypes(): Internal.Class<any>[];
        get parameterCount(): number;
        get annotations(): Internal.Annotation[];
        get modifiers(): number;
        get typeParameters(): any[];
        get declaringClass(): Internal.Class<T>;
        get varArgs(): boolean;
        get synthetic(): boolean;
        get genericParameterTypes(): java_.lang.reflect.Type[];
        get exceptionTypes(): Internal.Class<any>[];
        get name(): string;
        get annotatedReceiverType(): Internal.AnnotatedType;
        get genericExceptionTypes(): java_.lang.reflect.Type[];
        get parameterAnnotations(): Internal.Annotation[][];
        get class(): Internal.Class<any>;
        get parameters(): any[];
        get annotatedExceptionTypes(): Internal.AnnotatedType[];
        get annotatedParameterTypes(): Internal.AnnotatedType[];
        set accessible(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class PathfinderMob extends Internal.Mob {
        getClass(): Internal.Class<any>;
        backpackedMoved(): boolean;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        captureDrops(arg0: Internal.Collection<Internal.ItemEntity>): Internal.Collection<Internal.ItemEntity>;
        handler$zje000$onUpdateFluidOnEyeAssign(arg0: Internal.CallbackInfo): void;
        updateNavigationRegistration(): void;
        onEndimationEnd(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        canBeRiddenInWater(arg0: Internal.Entity): boolean;
        handler$zzo000$tickHead(arg0: Internal.CallbackInfo): void;
        setCitadelEntityData(arg0: Internal.CompoundTag): void;
        isEndimationPlaying(arg0: Internal.PlayableEndimation): boolean;
        isActive(): boolean;
        create$callSpawnItemParticles(arg0: Internal.ItemStack, arg1: number): void;
        changeDimension(arg0: Internal.ServerLevel, arg1: Internal.ITeleporter): Internal.Entity;
        getCachedFeetBlockState(): Internal.BlockState;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        handler$bfj000$tryShortcutFluidPushing(tag: net.minecraft.tags.Tag<any>, speed: number, cir: Internal.CallbackInfoReturnable<any>, box: Internal.AABB, x1: number, x2: number, y1: number, y2: number, z1: number, z2: number, zero: number): void;
        getPos(): Internal.Position;
        foodEatenKJS(is: Internal.ItemStack): void;
        revive(): void;
        static getDataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(arg0: boolean): void;
        canUpdate(): boolean;
        getEndimatedState(): Internal.Endimatable$EndimatedState;
        resetEndimation(): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<Internal.Entity>): boolean;
        getRegisteredNavigation(): Internal.PathNavigation;
        getEyeHeightAccess(arg0: Internal.Pose, arg1: Internal.EntityDimensions): number;
        reviveCaps(): void;
        lithiumOnBlockCacheDeleted(): void;
        canRiderInteract(): boolean;
        getEntries(arg0: boolean): Internal.Set<any>;
        getEffectHandler(): Internal.EndimationEffectHandler;
        onAddedToWorld(): void;
        setAnimationTick(arg0: number): void;
        isRegisteredToWorld(): boolean;
        canTrample(arg0: Internal.BlockState, arg1: BlockPos, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        static getDataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        getListener(): Internal.NearbyEntityListenerMulti;
        getClassification(arg0: boolean): Internal.MobCategory;
        isNoEndimationPlaying(): boolean;
        onEndimationStart(arg0: Internal.PlayableEndimation, arg1: Internal.PlayableEndimation): void;
        lithiumSetClimbingMobCachingSectionUpdateBehavior(listenForCachedBlockChanges: boolean): void;
        shouldRiderSit(): boolean;
        getIsInsidePortal(): boolean;
        getPickedResult(arg0: Internal.HitResult): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$zje000$onUpdateFluidOnEyes(arg0: Internal.CallbackInfo): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        handler$zcg000$read(arg0: Internal.CompoundTag, arg1: Internal.CallbackInfo): void;
        getRemainingFireTicks(): number;
        lithiumOnEquipmentChanged(): void;
        lithiumOnBlockCacheSet(newState: Internal.BlockState): void;
        notify(): void;
        getDataMap(): Internal.Map<any, any>;
        handler$zzo000$moveStep(arg0: Internal.MoverType, arg1: Vec3, arg2: Internal.CallbackInfo): void;
        getEntityChangeListener(): Internal.EntityInLevelCallback;
        endimateTick(): void;
        setDataMap(arg0: Internal.Map<any, any>): void;
        isDirty(): boolean;
        hashCode(): number;
        getLastPos(): BlockPos;
        isAddedToWorld(): boolean;
        setRegisteredToWorld(navigation: Internal.PathNavigation): void;
        getParts(): any[];
        addListener(listener: Internal.NearbyEntityListener): void;
        onRemovedFromWorld(): void;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        deserializeNBT(arg0: Internal.Tag): void;
        curePotionEffects(arg0: Internal.ItemStack): boolean;
        clean(): void;
        asKJS(): any;
        getPlayingEndimation(): Internal.PlayableEndimation;
        getDirtyEntries(): Internal.Set<any>;
        getValue(arg0: Internal.TrackedData<any>): any;
        shouldRiderFaceForward(arg0: Internal.Player): boolean;
        setPlayingEndimation(arg0: Internal.PlayableEndimation): void;
        setValue(arg0: Internal.TrackedData<any>, arg1: any): void;
        equals(arg0: any): boolean;
        getAnimationTick(): number;
        toString(): string;
        setRemainingFireTicks(arg0: number): void;
        handler$zgd001$tick(arg0: Internal.CallbackInfo): void;
        get citadelEntityData(): Internal.CompoundTag;
        get listener(): Internal.NearbyEntityListenerMulti;
        get addedToWorld(): boolean;
        get registeredNavigation(): Internal.PathNavigation;
        get animationTick(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get pos(): Internal.Position;
        get registeredToWorld(): boolean;
        get dataMap(): Internal.Map<any, any>;
        get noEndimationPlaying(): boolean;
        get class(): Internal.Class<any>;
        get dirty(): boolean;
        get dataEffectAmbienceId_$md$dd73f7$0(): Internal.EntityDataAccessor<any>;
        get isInsidePortal(): boolean;
        get persistentData(): Internal.CompoundTag;
        get remainingFireTicks(): number;
        get entityChangeListener(): Internal.EntityInLevelCallback;
        get multipartEntity(): boolean;
        get active(): boolean;
        get playingEndimation(): Internal.PlayableEndimation;
        get effectHandler(): Internal.EndimationEffectHandler;
        get cachedFeetBlockState(): Internal.BlockState;
        get lastPos(): BlockPos;
        get dirtyEntries(): Internal.Set<any>;
        get dataEffectColorId_$md$dd73f7$1(): Internal.EntityDataAccessor<any>;
        get parts(): any[];
        get endimatedState(): Internal.Endimatable$EndimatedState;
        set animationTick(arg0: number);
        set remainingFireTicks(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag);
        set dataMap(arg0: Internal.Map<any, any>);
        set playingEndimation(arg0: Internal.PlayableEndimation);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LayoutItem {
        size(): number;
        attributeCount(): number;
        vertexAttribPointer(arg0: number, arg1: number, arg2: number): void;
    }
    abstract class AbstractMultimap <K, V> implements Internal.Multimap<K, V> {
        getClass(): Internal.Class<any>;
        containsEntry(arg0: any, arg1: any): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        containsKey(arg0: any): boolean;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        asMap(): Internal.Map<K, Internal.Collection<V>>;
        keys(): Internal.Multiset<K>;
        notifyAll(): void;
        values(): Internal.Collection<V>;
        clear(): void;
        isEmpty(): boolean;
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.Collection<V>;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): boolean;
        remove(arg0: any, arg1: any): boolean;
        removeAll(arg0: any): Internal.Collection<V>;
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>;
        size(): number;
        hashCode(): number;
        get(arg0: K): Internal.Collection<V>;
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean;
        putAll(arg0: Internal.Multimap<K, V>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        keySet(): Internal.Set<K>;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface MinecraftClientAccess {
        getRecorder(): Internal.MetricsRecorder;
        setRecorder(arg0: Internal.MetricsRecorder): void;
    }
    class LunarEventSavedData extends Internal.SavedData {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static load(arg0: Internal.CompoundTag): Internal.LunarEventSavedData;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static get(arg0: Internal.LevelAccessor): Internal.LunarEventSavedData;
        setForecast(arg0: Internal.LunarForecast): void;
        toString(): string;
        getForecast(): Internal.LunarForecast;
        notify(): void;
        static readonly DATA_NAME : "enhancedcelestials:lunar_event_data";
        get forecast(): Internal.LunarForecast;
        get class(): Internal.Class<any>;
        set forecast(arg0: Internal.LunarForecast);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface CustomJavaObjectWrapper$AsList extends Internal.CustomJavaObjectWrapper {
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, staticType: Internal.Class<any>): Internal.Scriptable;
        wrapAsJavaList(): Internal.List<any>;
    }
    class ModelRegistryEvent extends Internal.Event implements Internal.IModBusEvent {
        setCanceled(arg0: boolean): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCanceled(): boolean;
        setResult(arg0: Internal.Event$Result): void;
        notifyAll(): void;
        hasResult(): boolean;
        notify(): void;
        getListenerList(): Internal.ListenerList;
        hashCode(): number;
        equals(arg0: any): boolean;
        getResult(): Internal.Event$Result;
        toString(): string;
        isCancelable(): boolean;
        getPhase(): Internal.EventPriority;
        setPhase(arg0: Internal.EventPriority): void;
        get result(): Internal.Event$Result;
        get phase(): Internal.EventPriority;
        get canceled(): boolean;
        get cancelable(): boolean;
        get listenerList(): Internal.ListenerList;
        get class(): Internal.Class<any>;
        set phase(arg0: Internal.EventPriority);
        set result(arg0: Internal.Event$Result);
        set canceled(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class NotConditionBuilder implements Internal.ConditionsContainer<Internal.NotConditionBuilder> {
        killerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): Internal.NotConditionBuilder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        survivesExplosion(): Internal.NotConditionBuilder;
        notifyAll(): void;
        addCondition(arg0: (arg0: any) => boolean): Internal.ConditionsContainer<any>;
        addCondition(arg0: (arg0: any) => boolean): Internal.NotConditionBuilder;
        addCondition(arg0: Internal.LootItemCondition$Builder): Internal.NotConditionBuilder;
        customDistanceToPlayer(arg0: (arg0: Internal.DistancePredicateBuilder) => void): Internal.NotConditionBuilder;
        matchFluid(arg0: string): Internal.NotConditionBuilder;
        notify(): void;
        not(arg0: (arg0: Internal.NotConditionBuilder) => void): Internal.NotConditionBuilder;
        directKillerPredicate(arg0: (arg0: Internal.EntityJS) => boolean): Internal.NotConditionBuilder;
        matchEquip(arg0: EquipmentSlot, arg1: Internal.IngredientJS): Internal.NotConditionBuilder;
        and(arg0: (arg0: Internal.AndConditionBuilder) => void): Internal.NotConditionBuilder;
        hashCode(): number;
        matchLoot(arg0: Internal.IngredientJS): Internal.NotConditionBuilder;
        matchLoot(arg0: Internal.IngredientJS, arg1: boolean): Internal.NotConditionBuilder;
        anyBiome(arg0: string[]): Internal.NotConditionBuilder;
        distanceToKiller(arg0: Internal.MinMaxBounds$Doubles): Internal.NotConditionBuilder;
        entityPredicate(arg0: (arg0: Internal.EntityJS) => boolean): Internal.NotConditionBuilder;
        matchEntity(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.NotConditionBuilder;
        anyDimension(arg0: ResourceLocation[]): Internal.NotConditionBuilder;
        killedByPlayer(): Internal.NotConditionBuilder;
        or(arg0: (arg0: Internal.OrConditionBuilder) => void): Internal.NotConditionBuilder;
        randomChance(arg0: number): Internal.NotConditionBuilder;
        timeCheck(arg0: number, arg1: number, arg2: number): Internal.NotConditionBuilder;
        timeCheck(arg0: number, arg1: number): Internal.NotConditionBuilder;
        matchOffHand(arg0: Internal.IngredientJS): Internal.NotConditionBuilder;
        playerPredicate(arg0: (arg0: Internal.PlayerJS<any>) => boolean): Internal.NotConditionBuilder;
        weatherCheck(arg0: Internal.Map<string, boolean>): Internal.NotConditionBuilder;
        matchDirectKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.NotConditionBuilder;
        matchBlockState(arg0: Internal.Block, arg1: Internal.Map<string, string>): Internal.NotConditionBuilder;
        matchMainHand(arg0: Internal.IngredientJS): Internal.NotConditionBuilder;
        matchPlayer(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.NotConditionBuilder;
        lightLevel(arg0: number, arg1: number): Internal.NotConditionBuilder;
        build(): (arg0: any) => boolean;
        biome(arg0: string[]): Internal.NotConditionBuilder;
        customCondition(arg0: Internal.JsonObject): Internal.NotConditionBuilder;
        equals(arg0: any): boolean;
        matchKiller(arg0: (arg0: Internal.EntityPredicateBuilderJS) => void): Internal.NotConditionBuilder;
        randomChanceWithLooting(arg0: number, arg1: number): Internal.NotConditionBuilder;
        hasAnyStage(arg0: string[]): Internal.NotConditionBuilder;
        toString(): string;
        randomChanceWithEnchantment(arg0: Internal.Enchantment, arg1: number[]): Internal.NotConditionBuilder;
        matchDamageSource(arg0: (arg0: Internal.DamageSourcePredicateBuilderJS) => void): Internal.NotConditionBuilder;
        anyStructure(arg0: ResourceLocation[], arg1: boolean): Internal.NotConditionBuilder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Reference2ReferenceFunction <K, V> extends it.unimi.dsi.fastutil.Function<K, V> {
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: (arg0: any) => any): (arg0: any) => any;
        composeByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenInt(arg0: (arg0: any) => any): (arg0: any) => any;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: K) => V_;
        composeReference<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        defaultReturnValue(): V;
        defaultReturnValue(arg0: V): void;
        andThenDouble(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenObject<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        get(arg0: any): V;
        andThenLong(arg0: (arg0: any) => any): (arg0: any) => any;
        composeLong(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenByte(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        apply(arg0: K): V;
        containsKey(arg0: any): boolean;
        composeInt(arg0: (arg0: any) => any): (arg0: any) => any;
        clear(): void;
        composeFloat(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeObject<T_>(arg0: (arg0: T_) => K): (arg0: T_) => V;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => V;
        composeShort(arg0: (arg0: any) => any): (arg0: any) => any;
        andThenReference<T_>(arg0: (arg0: V) => T_): (arg0: K) => T_;
        composeChar(arg0: (arg0: any) => any): (arg0: any) => any;
        composeDouble(arg0: (arg0: any) => any): (arg0: any) => any;
    }
    abstract class AbstractIntCollection extends Internal.AbstractCollection<any> implements Internal.IntCollection {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
        notify(): void;
        remove(arg0: any): boolean;
        intStream(): Internal.IntStream;
        removeAll(arg0: Internal.IntCollection): boolean;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.Iterator<any>;
        iterator(): Internal.IntIterator;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toIntArray(arg0: number[]): number[];
        toIntArray(): number[];
        toArray(arg0: number[]): number[];
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        add(arg0: number): boolean;
        add(arg0: any): boolean;
        spliterator(): Internal.Spliterator<any>;
        spliterator(): Internal.IntSpliterator;
        forEach(arg0: (arg0: any) => void): void;
        forEach(arg0: (arg0: number) => void): void;
        forEach(arg0: java_.util.function_.IntConsumer): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        containsAll(arg0: Internal.IntCollection): boolean;
        isEmpty(): boolean;
        clear(): void;
        removeIf(arg0: (arg0: any) => boolean): boolean;
        removeIf(arg0: (arg0: number) => boolean): boolean;
        removeIf(arg0: Internal.IntPredicate): boolean;
        contains(arg0: number): boolean;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.IntCollection): boolean;
        addAll(arg0: Internal.Collection<number>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        intParallelStream(): Internal.IntStream;
        retainAll(arg0: Internal.Collection<any>): boolean;
        retainAll(arg0: Internal.IntCollection): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class Field extends Internal.AccessibleObject implements Internal.Member {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setByte(arg0: any, arg1: number): void;
        getByte(arg0: any): number;
        getName(): string;
        isAnnotationPresent(arg0: Internal.Class<Internal.Annotation>): boolean;
        notifyAll(): void;
        isSynthetic(): boolean;
        getDouble(arg0: any): number;
        setShort(arg0: any, arg1: number): void;
        getFloat(arg0: any): number;
        notify(): void;
        getDeclaredAnnotations(): Internal.Annotation[];
        setDouble(arg0: any, arg1: number): void;
        setChar(arg0: any, arg1: string): void;
        getDeclaringClass(): Internal.Class<any>;
        getAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        hashCode(): number;
        canAccess(arg0: any): boolean;
        toGenericString(): string;
        get(arg0: any): any;
        getBoolean(arg0: any): boolean;
        getGenericType(): java_.lang.reflect.Type;
        getModifiers(): number;
        getAnnotatedType(): Internal.AnnotatedType;
        trySetAccessible(): boolean;
        setFloat(arg0: any, arg1: number): void;
        isAccessible(): boolean;
        set(arg0: any, arg1: any): void;
        setAccessible(arg0: boolean): void;
        static setAccessible(arg0: Internal.AccessibleObject[], arg1: boolean): void;
        getShort(arg0: any): number;
        getAnnotations(): Internal.Annotation[];
        setInt(arg0: any, arg1: number): void;
        getLong(arg0: any): number;
        getInt(arg0: any): number;
        getChar(arg0: any): string;
        setLong(arg0: any, arg1: number): void;
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class<T_>): T_[];
        getType(): Internal.Class<any>;
        getAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        equals(arg0: any): boolean;
        getDeclaredAnnotation<T_>(arg0: Internal.Class<T_>): T_;
        toString(): string;
        isEnumConstant(): boolean;
        setBoolean(arg0: any, arg1: boolean): void;
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get synthetic(): boolean;
        get declaredAnnotations(): Internal.Annotation[];
        get accessible(): boolean;
        get annotatedType(): Internal.AnnotatedType;
        get enumConstant(): boolean;
        get name(): string;
        get annotations(): Internal.Annotation[];
        get genericType(): java_.lang.reflect.Type;
        get modifiers(): number;
        get type(): Internal.Class<any>;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<any>;
        set accessible(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ExtendedEntityFlagsPredicate$IBuilder <T> {
        isBaby(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isIllegarMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isSwimming(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isInWater(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isWaterMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isCrouching(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isUnderWater(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isSprinting(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isUndeadMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isCreature(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        build(): T;
        isMonster(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isOnFire(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isOnGround(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isArthropodMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
    }
    class ParticleEngine implements Internal.PreparableReloadListener, Internal.ParticleManagerAccess, Internal.ParticleEngineAccessor {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        create$getProviders(): Internal.Map<any, any>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        addBlockHitEffects(arg0: BlockPos, arg1: Internal.BlockHitResult): void;
        toString(): string;
        invokeMakeParticle(arg0: Internal.ParticleOptions, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Internal.Particle;
        render(arg0: Internal.PoseStack, arg1: Internal.MultiBufferSource$BufferSource, arg2: Internal.LightTexture, arg3: Internal.Camera, arg4: number, arg5: Internal.Frustum): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface StorableItemStack {
        unregisterFromInventory(arg0: Internal.LithiumStackList): void;
        registerToInventory(arg0: Internal.LithiumStackList, arg1: number): void;
    }
    class CapabilityDispatcher implements Internal.INBTSerializable<Internal.CompoundTag>, Internal.ICapabilityProvider {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        serializeNBT(): Internal.Tag;
        serializeNBT(): Internal.CompoundTag;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        deserializeNBT(arg0: Internal.Tag): void;
        deserializeNBT(arg0: Internal.CompoundTag): void;
        toString(): string;
        invalidate(): void;
        areCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface ClassDesc extends Internal.ConstantDesc, Internal.TypeDescriptor$OfField<Internal.ClassDesc> {
        componentType(): Internal.TypeDescriptor$OfField<any>;
        componentType(): Internal.ClassDesc;
        arrayType(): Internal.TypeDescriptor$OfField<any>;
        arrayType(): Internal.ClassDesc;
        arrayType(arg0: number): Internal.ClassDesc;
        displayName(): string;
        equals(arg0: any): boolean;
        descriptorString(): string;
        isArray(): boolean;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup): any;
        packageName(): string;
        isClassOrInterface(): boolean;
        nested(arg0: string): Internal.ClassDesc;
        nested(arg0: string, arg1: string[]): Internal.ClassDesc;
        isPrimitive(): boolean;
    }
    class ClientWrapper {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.ClientPlayerJS;
        notifyAll(): void;
        getCurrentScreen(): Internal.Screen;
        setTitle(t: string): void;
        getMinecraft(): Internal.Minecraft;
        notify(): void;
        getLevel(): Internal.ClientLevelJS;
        hashCode(): number;
        equals(arg0: any): boolean;
        isKeyDown(key: number): boolean;
        getCurrentWorldName(): string;
        toString(): string;
        setCurrentScreen(gui: Internal.Screen): void;
        get minecraft(): Internal.Minecraft;
        get currentScreen(): Internal.Screen;
        get level(): Internal.ClientLevelJS;
        get class(): Internal.Class<any>;
        get player(): Internal.ClientPlayerJS;
        get currentWorldName(): string;
        set currentScreen(gui: Internal.Screen);
        set title(t: string);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class ImmutableMultimap <K, V> extends Internal.BaseImmutableMultimap<any, any> implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        asMap(): Internal.Map<any, any>;
        asMap(): Internal.ImmutableMap<K, Internal.Collection<V>>;
        keys(): Internal.ImmutableMultiset<K>;
        keys(): Internal.Multiset<any>;
        notifyAll(): void;
        values(): Internal.ImmutableCollection<V>;
        values(): Internal.Collection<any>;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): boolean;
        remove(arg0: any, arg1: any): boolean;
        removeAll(arg0: any): Internal.Collection<any>;
        removeAll(arg0: any): Internal.ImmutableCollection<V>;
        hashCode(): number;
        putAll(arg0: Internal.Multimap<K, V>): boolean;
        putAll(arg0: K, arg1: Internal.Iterable<V>): boolean;
        static of<K_, V_>(): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_): Internal.ImmutableMultimap<K_, V_>;
        get(arg0: any): Internal.Collection<any>;
        get(arg0: K): Internal.ImmutableCollection<V>;
        static builder<K_, V_>(): Internal.ImmutableMultimap$Builder<K_, V_>;
        keySet(): Internal.ImmutableSet<K>;
        keySet(): Internal.Set<any>;
        containsEntry(arg0: any, arg1: any): boolean;
        inverse(): Internal.ImmutableMultimap<V, K>;
        containsKey(arg0: any): boolean;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        isEmpty(): boolean;
        clear(): void;
        static copyOf<K_, V_>(arg0: Internal.Iterable<Internal.Map$Entry<K_, V_>>): Internal.ImmutableMultimap<K_, V_>;
        static copyOf<K_, V_>(arg0: Internal.Multimap<K_, V_>): Internal.ImmutableMultimap<K_, V_>;
        replaceValues(arg0: any, arg1: Internal.Iterable<any>): Internal.Collection<any>;
        replaceValues(arg0: K, arg1: Internal.Iterable<V>): Internal.ImmutableCollection<V>;
        entries(): Internal.Collection<any>;
        entries(): Internal.ImmutableCollection<Internal.Map$Entry<K, V>>;
        size(): number;
        equals(arg0: any): boolean;
        toString(): string;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    abstract class SavedData {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LootContextAccessor {
        repurposedstructures_setQueriedLootTableId(arg0: ResourceLocation): void;
    }
    interface Map <K, V> {
        getOrDefault(arg0: any, arg1: V): V;
        computeIfAbsent(arg0: K, arg1: (arg0: K) => V): V;
        values(): Internal.Collection<V>;
        replace(arg0: K, arg1: V): V;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replaceAll(arg0: (arg0: K, arg1: V) => V): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: any, arg1: any): boolean;
        compute(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        hashCode(): number;
        putAll(arg0: Internal.Map<K, V>): void;
        merge(arg0: K, arg1: V, arg2: (arg0: V, arg1: V) => V): V;
        get(arg0: any): V;
        keySet(): Internal.Set<K>;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        containsKey(arg0: any): boolean;
        forEach(arg0: (arg0: K, arg1: V) => void): void;
        isEmpty(): boolean;
        clear(): void;
        computeIfPresent(arg0: K, arg1: (arg0: K, arg1: V) => V): V;
        size(): number;
        equals(arg0: any): boolean;
        putIfAbsent(arg0: K, arg1: V): V;
    }
    class Connection extends Internal.SimpleChannelInboundHandler<any> implements Internal.ConfigurableAutoFlush, Internal.ClientConnectionEncryptionExtension {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setShouldAutoFlush(shouldAutoFlush: boolean): void;
        channelReadComplete(arg0: Internal.ChannelHandlerContext): void;
        getDirection(): Internal.PacketFlow;
        notifyAll(): void;
        channel(): io.netty.channel.Channel;
        exceptionCaught(arg0: Internal.ChannelHandlerContext, arg1: Internal.Throwable): void;
        isSharable(): boolean;
        notify(): void;
        handlerRemoved(arg0: Internal.ChannelHandlerContext): void;
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext): void;
        channelInactive(arg0: Internal.ChannelHandlerContext): void;
        hashCode(): number;
        userEventTriggered(arg0: Internal.ChannelHandlerContext, arg1: any): void;
        acceptInboundMessage(arg0: any): boolean;
        channelActive(arg0: Internal.ChannelHandlerContext): void;
        handlerAdded(arg0: Internal.ChannelHandlerContext): void;
        handler$zle000$setCompressionThreshold(compressionThreshold: number, validate: boolean, ci: Internal.CallbackInfo): void;
        channelRead(arg0: Internal.ChannelHandlerContext, arg1: any): void;
        channelUnregistered(arg0: Internal.ChannelHandlerContext): void;
        equals(arg0: any): boolean;
        setupEncryption(key: Internal.SecretKey): void;
        redirect$zko000$disableForcedFlushEveryTick(clientConnection: Internal.Connection): io.netty.channel.Channel;
        toString(): string;
        channelRegistered(arg0: Internal.ChannelHandlerContext): void;
        get sharable(): boolean;
        get class(): Internal.Class<any>;
        get direction(): Internal.PacketFlow;
        set shouldAutoFlush(shouldAutoFlush: boolean);
        set upEncryption(key: Internal.SecretKey);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface LootItemConditionMixin extends Internal.ILootHandler {
        or(arg0: (arg0: Internal.LootContext) => boolean): (arg0: Internal.LootContext) => boolean;
        test(arg0: Internal.LootContext): boolean;
        and(arg0: (arg0: Internal.LootContext) => boolean): (arg0: Internal.LootContext) => boolean;
        negate(): (arg0: Internal.LootContext) => boolean;
    }
    abstract class FileSystemProvider {
        getFileStore(arg0: Internal.Path): Internal.FileStore;
        isSameFile(arg0: Internal.Path, arg1: Internal.Path): boolean;
        newByteChannel(arg0: Internal.Path, arg1: Internal.Set<Internal.OpenOption>, arg2: any[]): Internal.SeekableByteChannel;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getFileAttributeView<V>(arg0: Internal.Path, arg1: Internal.Class<V>, arg2: any[]): V;
        newAsynchronousFileChannel(arg0: Internal.Path, arg1: Internal.Set<Internal.OpenOption>, arg2: Internal.ExecutorService, arg3: any[]): Internal.AsynchronousFileChannel;
        notifyAll(): void;
        createSymbolicLink(arg0: Internal.Path, arg1: Internal.Path, arg2: any[]): void;
        static installedProviders(): Internal.List<Internal.FileSystemProvider>;
        delete(arg0: Internal.Path): void;
        notify(): void;
        createLink(arg0: Internal.Path, arg1: Internal.Path): void;
        setAttribute(arg0: Internal.Path, arg1: string, arg2: any, arg3: any[]): void;
        newFileChannel(arg0: Internal.Path, arg1: Internal.Set<Internal.OpenOption>, arg2: any[]): Internal.FileChannel;
        newInputStream(arg0: Internal.Path, arg1: Internal.OpenOption[]): Internal.InputStream;
        hashCode(): number;
        readAttributes<A>(arg0: Internal.Path, arg1: Internal.Class<A>, arg2: any[]): A;
        readAttributes(arg0: Internal.Path, arg1: string, arg2: any[]): Internal.Map<string, any>;
        newOutputStream(arg0: Internal.Path, arg1: Internal.OpenOption[]): Internal.OutputStream;
        getPath(arg0: Internal.URI): Internal.Path;
        createDirectory(arg0: Internal.Path, arg1: any[]): void;
        copy(arg0: Internal.Path, arg1: Internal.Path, arg2: any[]): void;
        move(arg0: Internal.Path, arg1: Internal.Path, arg2: any[]): void;
        getScheme(): string;
        newFileSystem(arg0: Internal.URI, arg1: Internal.Map<string, any>): Internal.FileSystem;
        newFileSystem(arg0: Internal.Path, arg1: Internal.Map<string, any>): Internal.FileSystem;
        deleteIfExists(arg0: Internal.Path): boolean;
        newDirectoryStream(arg0: Internal.Path, arg1: Internal.DirectoryStream$Filter<Internal.Path>): Internal.DirectoryStream<Internal.Path>;
        getFileSystem(arg0: Internal.URI): Internal.FileSystem;
        checkAccess(arg0: Internal.Path, arg1: any[]): void;
        readSymbolicLink(arg0: Internal.Path): Internal.Path;
        isHidden(arg0: Internal.Path): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        get scheme(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ChannelOption <T> extends Internal.AbstractConstant<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf<T_>(arg0: string): Internal.ChannelOption<T_>;
        static valueOf<T_>(arg0: Internal.Class<any>, arg1: string): Internal.ChannelOption<T_>;
        notifyAll(): void;
        static newInstance<T_>(arg0: string): Internal.ChannelOption<T_>;
        compareTo(arg0: Internal.ChannelOption<Internal.ChannelOption<T>>): number;
        compareTo(arg0: any): number;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        static exists(arg0: string): boolean;
        toString(): string;
        id(): number;
        validate(arg0: Internal.ChannelOption<Internal.ChannelOption<T>>): void;
        static readonly WRITE_BUFFER_HIGH_WATER_MARK : Internal.ChannelOption<number>;
        static readonly WRITE_BUFFER_LOW_WATER_MARK : Internal.ChannelOption<number>;
        static readonly DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION : Internal.ChannelOption<boolean>;
        static readonly IP_TOS : Internal.ChannelOption<number>;
        static readonly SINGLE_EVENTEXECUTOR_PER_GROUP : Internal.ChannelOption<boolean>;
        static readonly SO_SNDBUF : Internal.ChannelOption<number>;
        static readonly IP_MULTICAST_IF : Internal.ChannelOption<Internal.NetworkInterface>;
        static readonly WRITE_BUFFER_WATER_MARK : Internal.ChannelOption<Internal.WriteBufferWaterMark>;
        static readonly TCP_NODELAY : Internal.ChannelOption<boolean>;
        static readonly TCP_FASTOPEN : Internal.ChannelOption<number>;
        static readonly SO_LINGER : Internal.ChannelOption<number>;
        static readonly SO_RCVBUF : Internal.ChannelOption<number>;
        static readonly SO_KEEPALIVE : Internal.ChannelOption<boolean>;
        static readonly ALLOCATOR : Internal.ChannelOption<Internal.ByteBufAllocator>;
        static readonly IP_MULTICAST_ADDR : Internal.ChannelOption<Internal.InetAddress>;
        static readonly IP_MULTICAST_LOOP_DISABLED : Internal.ChannelOption<boolean>;
        static readonly TCP_FASTOPEN_CONNECT : Internal.ChannelOption<boolean>;
        static readonly MESSAGE_SIZE_ESTIMATOR : Internal.ChannelOption<Internal.MessageSizeEstimator>;
        static readonly WRITE_SPIN_COUNT : Internal.ChannelOption<number>;
        static readonly SO_TIMEOUT : Internal.ChannelOption<number>;
        static readonly SO_REUSEADDR : Internal.ChannelOption<boolean>;
        static readonly CONNECT_TIMEOUT_MILLIS : Internal.ChannelOption<number>;
        static readonly ALLOW_HALF_CLOSURE : Internal.ChannelOption<boolean>;
        static readonly SO_BACKLOG : Internal.ChannelOption<number>;
        static readonly MAX_MESSAGES_PER_READ : Internal.ChannelOption<number>;
        static readonly AUTO_CLOSE : Internal.ChannelOption<boolean>;
        static readonly MAX_MESSAGES_PER_WRITE : Internal.ChannelOption<number>;
        static readonly SO_BROADCAST : Internal.ChannelOption<boolean>;
        static readonly AUTO_READ : Internal.ChannelOption<boolean>;
        static readonly IP_MULTICAST_TTL : Internal.ChannelOption<number>;
        static readonly RCVBUF_ALLOCATOR : Internal.ChannelOption<Internal.RecvByteBufAllocator>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface CustomJavaObjectWrapper$AsMap extends Internal.CustomJavaObjectWrapper {
        wrapAsJavaObject(cx: Internal.Context, scope: Internal.Scriptable, staticType: Internal.Class<any>): Internal.Scriptable;
        wrapAsJavaMap(): Internal.Map<any, any>;
    }
    interface IExtensibleEnum {
        init(): void;
    }
    class Products$P11 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative<F, any>, arg1: Internal.App<F, Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface StructType <S> {
        getLayout(): Internal.BufferLayout;
        create(): S;
    }
    class EventObject implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        getSource(): any;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get source(): any;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class InterfaceAddress {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getBroadcast(): Internal.InetAddress;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getNetworkPrefixLength(): number;
        getAddress(): Internal.InetAddress;
        toString(): string;
        notify(): void;
        get broadcast(): Internal.InetAddress;
        get address(): Internal.InetAddress;
        get class(): Internal.Class<any>;
        get networkPrefixLength(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class RecipeFunction extends Internal.BaseFunction implements Internal.WrappedJS {
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        setParentScope(m: Internal.Scriptable): void;
        static redefineProperty(obj: Internal.Scriptable, name: string, isConst: boolean): void;
        putConst(name: string, start: Internal.Scriptable, value: any): void;
        static getTypedProperty<T_>(s: Internal.Scriptable, index: number, type: Internal.Class<T_>): T_;
        static getTypedProperty<T_>(s: Internal.Scriptable, name: string, type: Internal.Class<T_>): T_;
        getIds(): any[];
        static getArrayPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        construct(cx: Internal.Context, scope: Internal.Scriptable, args: any[]): Internal.Scriptable;
        getAllIds(): any[];
        put(key: Internal.Symbol, start: Internal.Scriptable, value: any): void;
        put(name: string, start: Internal.Scriptable, value: any): void;
        put(index: number, start: Internal.Scriptable, value: any): void;
        getArity(): number;
        getDefaultValue(typeHint: Internal.Class<any>): any;
        static getDefaultValue(object: Internal.Scriptable, typeHint: Internal.Class<any>): any;
        defineOwnProperties(cx: Internal.Context, props: Internal.ScriptableObject): void;
        defineProperty(propertyName: string, clazz: Internal.Class<any>, attributes: number): void;
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method, setter: Internal.Method, attributes: number): void;
        defineProperty(propertyName: string, value: any, attributes: number): void;
        defineProperty(key: Internal.Symbol, value: any, attributes: number): void;
        static defineProperty(destination: Internal.Scriptable, propertyName: string, value: any, attributes: number): void;
        hasPrototypeMap(): boolean;
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable, isSetter: boolean): void;
        avoidObjectDetection(): boolean;
        has(key: Internal.Symbol, start: Internal.Scriptable): boolean;
        has(name: string, start: Internal.Scriptable): boolean;
        has(index: number, start: Internal.Scriptable): boolean;
        getFunctionName(): string;
        getExternalArrayLength(): any;
        getAttributes(name: string): number;
        getAttributes(key: Internal.Symbol): number;
        getAttributes(index: number): number;
        setImmunePrototypeProperty(value: any): void;
        hasInstance(instance: Internal.Scriptable): boolean;
        getAssociatedValue(key: any): any;
        execIdCall(f: Internal.IdFunctionObject, cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args: any[]): any;
        static getPropertyIds(obj: Internal.Scriptable): any[];
        static hasProperty(obj: Internal.Scriptable, index: number): boolean;
        static hasProperty(obj: Internal.Scriptable, name: string): boolean;
        static hasProperty(obj: Internal.Scriptable, key: Internal.Symbol): boolean;
        getExternalArrayData(): Internal.ExternalArrayData;
        size(): number;
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol, functionName: string, arity: number): Internal.IdFunctionObject;
        defineOwnProperty(cx: Internal.Context, key: any, desc: Internal.ScriptableObject): void;
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void;
        initPrototypeValue(id: number, key: Internal.Symbol, value: any, attributes: number): void;
        static getFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        preventExtensions(): void;
        setExternalArrayData(array: Internal.ExternalArrayData): void;
        static callMethod(obj: Internal.Scriptable, methodName: string, args: any[]): any;
        static callMethod(cx: Internal.Context, obj: Internal.Scriptable, methodName: string, args: any[]): any;
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        getTypeOf(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getTopScopeValue(scope: Internal.Scriptable, key: any): any;
        initPrototypeConstructor(f: Internal.IdFunctionObject): void;
        notifyAll(): void;
        sealObject(): void;
        setAttributes(name: string, attributes: number): void;
        setAttributes(index: number, attributes: number): void;
        setAttributes(key: Internal.Symbol, attributes: number): void;
        static putProperty(obj: Internal.Scriptable, index: number, value: any): void;
        static putProperty(obj: Internal.Scriptable, key: Internal.Symbol, value: any): void;
        static putProperty(obj: Internal.Scriptable, name: string, value: any): void;
        delete(key: Internal.Symbol): void;
        delete(name: string): void;
        delete(index: number): void;
        notify(): void;
        associateValue(key: any, value: any): any;
        static deleteProperty(obj: Internal.Scriptable, name: string): boolean;
        static deleteProperty(obj: Internal.Scriptable, index: number): boolean;
        getPrototype(): Internal.Scriptable;
        static getObjectPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        createRecipe(args0: any[]): Internal.RecipeJS;
        isExtensible(): boolean;
        hashCode(): number;
        isConst(name: string): boolean;
        get(name: string, start: Internal.Scriptable): any;
        get(key: Internal.Symbol, start: Internal.Scriptable): any;
        get(index: number, start: Internal.Scriptable): any;
        get(key: any): any;
        static putConstProperty(obj: Internal.Scriptable, name: string, value: any): void;
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any;
        static getTopLevelScope(obj: Internal.Scriptable): Internal.Scriptable;
        static getProperty(obj: Internal.Scriptable, name: string): any;
        static getProperty(obj: Internal.Scriptable, key: Internal.Symbol): any;
        static getProperty(obj: Internal.Scriptable, index: number): any;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean): void;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>): void;
        static defineClass<T_>(scope: Internal.Scriptable, clazz: Internal.Class<T_>, sealed: boolean, mapInheritance: boolean): string;
        activatePrototypeMap(maxPrototypeId: number): void;
        isEmpty(): boolean;
        defineFunctionProperties(names: string[], clazz: Internal.Class<any>, attributes: number): void;
        static getClassPrototype(scope: Internal.Scriptable, className: string): Internal.Scriptable;
        createObject(cx: Internal.Context, scope: Internal.Scriptable): Internal.Scriptable;
        setPrototype(m: Internal.Scriptable): void;
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable, sealed: boolean): Internal.IdFunctionObject;
        call(cx: Internal.Context, scope: Internal.Scriptable, thisObj: Internal.Scriptable, args0: any[]): Internal.RecipeJS;
        call(arg0: Internal.Context, arg1: Internal.Scriptable, arg2: Internal.Scriptable, arg3: any[]): any;
        defineConst(name: string, start: Internal.Scriptable): void;
        equals(arg0: any): boolean;
        static defineConstProperty(destination: Internal.Scriptable, propertyName: string): void;
        getLength(): number;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable): Internal.Scriptable;
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        readonly typeID : ResourceLocation;
        readonly type : Internal.RecipeTypeJS;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get functionName(): string;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get length(): number;
        get className(): string;
        get prototype(): Internal.Scriptable;
        get empty(): boolean;
        get arity(): number;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get externalArrayLength(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get extensible(): boolean;
        get typeOf(): string;
        set immunePrototypeProperty(value: any);
        set externalArrayData(array: Internal.ExternalArrayData);
        set parentScope(m: Internal.Scriptable);
        set prototype(m: Internal.Scriptable);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class SyncType extends Internal.Enum<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.SyncType;
        static valueOf<T_>(arg0: Internal.Class<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.SyncType[];
        compareTo(arg0: any): number;
        compareTo(arg0: Internal.SyncType): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.SyncType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.SyncType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly NOPE : Internal.SyncType;
        static readonly TO_CLIENT : Internal.SyncType;
        static readonly TO_CLIENTS : Internal.SyncType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.SyncType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class ColorSettings {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getGLMoonColor(): Internal.Vector3f;
        notify(): void;
        static tryParseColor(arg0: string): number;
        getMoonTextureColor(): number;
        getSkyLightColor(): number;
        hashCode(): number;
        getMoonTextureBlendStrength(): number;
        equals(arg0: any): boolean;
        getGLSkyLightColor(): Internal.Vector3f;
        toString(): string;
        getSkyLightBlendStrength(): number;
        static readonly CODEC : Internal.Codec<Internal.ColorSettings>;
        get gLSkyLightColor(): Internal.Vector3f;
        get skyLightBlendStrength(): number;
        get moonTextureBlendStrength(): number;
        get skyLightColor(): number;
        get gLMoonColor(): Internal.Vector3f;
        get class(): Internal.Class<any>;
        get moonTextureColor(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    class EntityArrayList extends Internal.ArrayList<any> implements Internal.MessageSender {
        getClass(): Internal.Class<any>;
        sendData(channel: string, data: Internal.CompoundTag): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getWorld(): Internal.LevelJS;
        getName(): Internal.Text;
        notifyAll(): void;
        tell(message: Internal.Component): void;
        replaceAll(arg0: (arg0: any) => any): void;
        notify(): void;
        remove(arg0: any): boolean;
        remove(arg0: number): Internal.EntityJS;
        runCommandSilent(command: string): number;
        removeAll(arg0: Internal.Collection<any>): boolean;
        iterator(): Internal.Iterator<Internal.EntityJS>;
        stream(): Internal.Stream<Internal.EntityJS>;
        hashCode(): number;
        getFirst(): Internal.EntityJS;
        get(arg0: number): Internal.EntityJS;
        playSound(id: Internal.SoundEvent, volume: number, pitch: number): void;
        playSound(id: Internal.SoundEvent): void;
        toArray<T_>(arg0: T_[]): T_[];
        toArray(): any[];
        toArray<T_>(arg0: Internal.IntFunction<T_[]>): T_[];
        parallelStream(): Internal.Stream<Internal.EntityJS>;
        runCommand(command: string): number;
        indexOf(arg0: any): number;
        add(arg0: Internal.EntityJS): boolean;
        add(arg0: number, arg1: Internal.EntityJS): void;
        subList(arg0: number, arg1: number): Internal.List<Internal.EntityJS>;
        setStatusMessage(message: Internal.Component): void;
        trimToSize(): void;
        set(arg0: number, arg1: Internal.EntityJS): Internal.EntityJS;
        spliterator(): Internal.Spliterator<Internal.EntityJS>;
        forEach(arg0: (arg0: Internal.EntityJS) => void): void;
        containsAll(arg0: Internal.Collection<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator<Internal.EntityJS>): void;
        kill(): void;
        removeIf(arg0: (arg0: Internal.EntityJS) => boolean): boolean;
        filter(filter: (arg0: Internal.EntityJS) => boolean): Internal.EntityArrayList;
        lastIndexOf(arg0: any): number;
        getLevel(): Internal.LevelJS;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.Collection<Internal.EntityJS>): boolean;
        addAll(arg0: number, arg1: Internal.Collection<Internal.EntityJS>): boolean;
        getDisplayName(): Internal.Text;
        equals(arg0: any): boolean;
        clone(): any;
        listIterator(): Internal.ListIterator<Internal.EntityJS>;
        listIterator(arg0: number): Internal.ListIterator<Internal.EntityJS>;
        toString(): string;
        ensureCapacity(arg0: number): void;
        retainAll(arg0: Internal.Collection<any>): boolean;
        get world(): Internal.LevelJS;
        get level(): Internal.LevelJS;
        get displayName(): Internal.Text;
        get name(): Internal.Text;
        get class(): Internal.Class<any>;
        get first(): Internal.EntityJS;
        get empty(): boolean;
        set statusMessage(message: Internal.Component);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    interface Principal {
        getName(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        implies(arg0: Internal.Subject): boolean;
    }
    interface Matrix4fExtended {
        rotate(arg0: Internal.Quaternion): void;
        transformVecZ(arg0: number, arg1: number, arg2: number): number;
        transformVecY(arg0: number, arg1: number, arg2: number): number;
        transformVecX(arg0: number, arg1: number, arg2: number): number;
        translate(arg0: number, arg1: number, arg2: number): void;
    }
}
declare namespace corgitaco.enhancedcelestials.mixin.access {
    interface ChunkAccess {
        getLevel(): net.minecraft.world.level.Level;
    }
}
declare namespace com.mojang.authlib.properties {
    class Property {
        getClass(): Internal.Class<any>;
        getValue(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getSignature(): string;
        toString(): string;
        isSignatureValid(arg0: Internal.PublicKey): boolean;
        notify(): void;
        hasSignature(): boolean;
        get signature(): string;
        get name(): string;
        get class(): Internal.Class<any>;
        get value(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace java_.util.function_ {
    interface IntConsumer {
        andThen(arg0: java_.util.function_.IntConsumer): java_.util.function_.IntConsumer;
        accept(arg0: number): void;
    }
    interface Supplier <T> {
        get(): T;
    }
}
declare namespace me.jellysquid.mods.lithium.mixin.block.hopper {
    interface EntityAccessor {
        getEntityChangeListener(): Internal.EntityInLevelCallback;
    }
}
declare namespace net.blay09.mods.balm.mixin {
    interface AbstractContainerScreenAccessor {
        callIsHovering(arg0: Internal.Slot, arg1: number, arg2: number): boolean;
        getHoveredSlot(): Internal.Slot;
        callRenderSlot(arg0: Internal.PoseStack, arg1: Internal.Slot): void;
        getImageWidth(): number;
        getTopPos(): number;
        getLeftPos(): number;
        getImageHeight(): number;
    }
}
declare namespace net.minecraft.world.level {
    abstract class Level extends Internal.CapabilityProvider<any> implements Internal.LevelAccessor, Internal.AutoCloseable, Internal.IForgeLevel, Internal.EnhancedCelestialsWorldData, Internal.LevelKJS, Internal.ChunkRandomSource, Internal.BlockEntityGetter, Internal.LevelHeightAccessor, Internal.ExtendedWorld {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getCapability<T_>(arg0: Internal.Capability<T_>, arg1: Internal.Direction): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability<T_>): Internal.LazyOptional<T_>;
        getChunkAtImmediately(arg0: number, arg1: number): Internal.LevelChunk;
        notifyAll(): void;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider<net.minecraft.world.level.Level>): boolean;
        getLoadedExistingBlockEntity(pos: BlockPos): Internal.BlockEntity;
        addFreshBlockEntities(arg0: Internal.Collection<Internal.BlockEntity>): void;
        getMaxEntityRadius(): number;
        asKJS(): any;
        notify(): void;
        reviveCaps(): void;
        markAndNotifyBlock(arg0: BlockPos, arg1: Internal.LevelChunk, arg2: Internal.BlockState, arg3: Internal.BlockState, arg4: number, arg5: number): void;
        invalidateCaps(): void;
        getLunarContext(): Internal.LunarContext;
        getAnyChunkImmediately(arg0: number, arg1: number): Internal.ChunkAccess;
        hashCode(): number;
        increaseMaxEntityRadius(arg0: number): number;
        equals(arg0: any): boolean;
        redirect$zod000$redirectTick(blockEntity: Internal.TickingBlockEntity): void;
        isAreaLoaded(arg0: BlockPos, arg1: number): boolean;
        toString(): string;
        getRandomPosInChunk(x: number, y: number, z: number, mask: number, out: Internal.BlockPos$MutableBlockPos): void;
        close(): void;
        setLunarContext(arg0: Internal.LunarContext): Internal.LunarContext;
        restoringBlockSnapshots : boolean;
        capturedBlockSnapshots : Internal.ArrayList<Internal.BlockSnapshot>;
        captureBlockSnapshots : boolean;
        get lunarContext(): Internal.LunarContext;
        get maxEntityRadius(): number;
        get class(): Internal.Class<any>;
        set lunarContext(arg0: Internal.LunarContext);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace com.mojang.brigadier {
    interface Message {
        getString(): string;
    }
}
declare namespace io.netty.channel {
    interface Channel extends Internal.AttributeMap, Internal.ChannelOutboundInvoker, Internal.Comparable<io.netty.channel.Channel> {
        disconnect(): Internal.ChannelFuture;
        disconnect(arg0: Internal.ChannelPromise): Internal.ChannelFuture;
        parent(): io.netty.channel.Channel;
        metadata(): Internal.ChannelMetadata;
        newProgressivePromise(): Internal.ChannelProgressivePromise;
        eventLoop(): Internal.EventLoop;
        compareTo(arg0: io.netty.channel.Channel): number;
        isWritable(): boolean;
        isActive(): boolean;
        unsafe(): Internal.Channel$Unsafe;
        writeAndFlush(arg0: any): Internal.ChannelFuture;
        writeAndFlush(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        flush(): io.netty.channel.Channel;
        flush(): Internal.ChannelOutboundInvoker;
        bytesBeforeWritable(): number;
        id(): Internal.ChannelId;
        attr<T_>(arg0: Internal.AttributeKey<T_>): io.netty.util.Attribute<T_>;
        close(arg0: Internal.ChannelPromise): Internal.ChannelFuture;
        close(): Internal.ChannelFuture;
        write(arg0: any, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        write(arg0: any): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress, arg2: Internal.ChannelPromise): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress, arg1: Internal.SocketAddress): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress, arg1: Internal.ChannelPromise): Internal.ChannelFuture;
        remoteAddress(): Internal.SocketAddress;
        newPromise(): Internal.ChannelPromise;
        read(): io.netty.channel.Channel;
        read(): Internal.ChannelOutboundInvoker;
        bytesBeforeUnwritable(): number;
        deregister(): Internal.ChannelFuture;
        deregister(arg0: Internal.ChannelPromise): Internal.ChannelFuture;
        newFailedFuture(arg0: Internal.Throwable): Internal.ChannelFuture;
        hasAttr<T_>(arg0: Internal.AttributeKey<T_>): boolean;
        pipeline(): Internal.ChannelPipeline;
        isOpen(): boolean;
        newSucceededFuture(): Internal.ChannelFuture;
        voidPromise(): Internal.ChannelPromise;
        closeFuture(): Internal.ChannelFuture;
        localAddress(): Internal.SocketAddress;
        isRegistered(): boolean;
        alloc(): Internal.ByteBufAllocator;
        config(): Internal.ChannelConfig;
    }
}
declare namespace net.minecraft.world.level.material {
    class Material {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace java_.lang.reflect {
    interface Type {
        getTypeName(): string;
    }
}
declare namespace net.blay09.mods.clienttweaks.mixin {
    interface LivingEntityAccessor {
    }
}
declare namespace net.minecraft.client.resources.model {
    class Material {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace it.unimi.dsi.fastutil {
    interface Function <K, V> extends Internal.Function<K, V> {
        getOrDefault(arg0: any, arg1: V): V;
        size(): number;
        compose<V_>(arg0: (arg0: V_) => K): (arg0: V_) => V;
        apply(arg0: K): V;
        containsKey(arg0: any): boolean;
        get(arg0: any): V;
        clear(): void;
        andThen<V_>(arg0: (arg0: V) => V_): (arg0: K) => V_;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
    }
}
declare namespace me.jellysquid.mods.lithium.mixin.ai.nearby_entity_tracking {
    interface ServerWorldAccessor {
        getEntityManager(): Internal.PersistentEntitySectionManager<Internal.Entity>;
    }
    interface ServerEntityManagerAccessor <T> {
        getCache(): Internal.EntitySectionStorage<T>;
    }
}
declare namespace io.netty.util {
    interface Attribute <T> {
        set(arg0: T): void;
        compareAndSet(arg0: T, arg1: T): boolean;
        setIfAbsent(arg0: T): T;
        get(): T;
        getAndSet(arg0: T): T;
        getAndRemove(): T;
        key(): Internal.AttributeKey<T>;
        remove(): void;
    }
}
declare namespace net.minecraftforge.fluids {
    class FluidStack {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRawFluid(): Internal.Fluid;
        notifyAll(): void;
        getOrCreateChildTag(arg0: string): Internal.CompoundTag;
        notify(): void;
        getChildTag(arg0: string): Internal.CompoundTag;
        static readFromPacket(arg0: Internal.FriendlyByteBuf): net.minecraftforge.fluids.FluidStack;
        containsFluid(arg0: net.minecraftforge.fluids.FluidStack): boolean;
        hashCode(): number;
        setTag(arg0: Internal.CompoundTag): void;
        copy(): net.minecraftforge.fluids.FluidStack;
        setAmount(arg0: number): void;
        isFluidEqual(arg0: Internal.ItemStack): boolean;
        isFluidEqual(arg0: net.minecraftforge.fluids.FluidStack): boolean;
        writeToNBT(arg0: Internal.CompoundTag): Internal.CompoundTag;
        getAmount(): number;
        removeChildTag(arg0: string): void;
        isFluidStackIdentical(arg0: net.minecraftforge.fluids.FluidStack): boolean;
        grow(arg0: number): void;
        hasTag(): boolean;
        static loadFluidStackFromNBT(arg0: Internal.CompoundTag): net.minecraftforge.fluids.FluidStack;
        shrink(arg0: number): void;
        getTranslationKey(): string;
        isEmpty(): boolean;
        getTag(): Internal.CompoundTag;
        getOrCreateTag(): Internal.CompoundTag;
        writeToPacket(arg0: Internal.FriendlyByteBuf): void;
        getDisplayName(): Internal.Component;
        equals(arg0: any): boolean;
        getFluid(): Internal.Fluid;
        toString(): string;
        static areFluidStackTagsEqual(arg0: net.minecraftforge.fluids.FluidStack, arg1: net.minecraftforge.fluids.FluidStack): boolean;
        static readonly CODEC : Internal.Codec<net.minecraftforge.fluids.FluidStack>;
        static readonly EMPTY : net.minecraftforge.fluids.FluidStack;
        get orCreateTag(): Internal.CompoundTag;
        get rawFluid(): Internal.Fluid;
        get amount(): number;
        get translationKey(): string;
        get displayName(): Internal.Component;
        get fluid(): Internal.Fluid;
        get tag(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        set amount(arg0: number);
        set tag(arg0: Internal.CompoundTag);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace it.unimi.dsi.fastutil.ints {
    interface IntBinaryOperator extends Internal.BinaryOperator<number>, Internal.IntBinaryOperator {
        applyAsInt(arg0: number, arg1: number): number;
        apply(arg0: any, arg1: any): any;
        apply(arg0: number, arg1: number): number;
        apply(arg0: number, arg1: number): number;
        andThen<V_>(arg0: (arg0: number) => V_): (arg0: number, arg1: number) => V_;
    }
    interface IntPredicate extends Internal.Predicate<number>, Internal.IntPredicate {
        or(arg0: (arg0: number) => boolean): (arg0: number) => boolean;
        or(arg0: Internal.IntPredicate): (arg0: any) => boolean;
        or(arg0: Internal.IntPredicate): Internal.IntPredicate;
        or(arg0: (arg0: any) => boolean): (arg0: any) => boolean;
        test(arg0: number): boolean;
        test(arg0: any): boolean;
        test(arg0: number): boolean;
        and(arg0: Internal.IntPredicate): Internal.IntPredicate;
        and(arg0: Internal.IntPredicate): (arg0: any) => boolean;
        and(arg0: (arg0: any) => boolean): (arg0: any) => boolean;
        and(arg0: (arg0: number) => boolean): (arg0: number) => boolean;
        negate(): Internal.IntPredicate;
        negate(): (arg0: any) => boolean;
        negate(): (arg0: any) => boolean;
    }
}
declare namespace org.apache.commons.lang3.tuple {
    abstract class Pair <L, R> implements Internal.Map$Entry<L, R>, Internal.Comparable<org.apache.commons.lang3.tuple.Pair<L, R>>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        getKey(): L;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        compareTo(arg0: any): number;
        compareTo(arg0: org.apache.commons.lang3.tuple.Pair<L, R>): number;
        notify(): void;
        getValue(): R;
        getRight(): R;
        hashCode(): number;
        setValue(arg0: R): R;
        static of<L_, R_>(arg0: Internal.Map$Entry<L_, R_>): org.apache.commons.lang3.tuple.Pair<L_, R_>;
        static of<L_, R_>(arg0: L_, arg1: R_): org.apache.commons.lang3.tuple.Pair<L_, R_>;
        equals(arg0: any): boolean;
        toString(arg0: string): string;
        toString(): string;
        static emptyArray<L_, R_>(): org.apache.commons.lang3.tuple.Pair<L_, R_>[];
        getLeft(): L;
        static readonly EMPTY_ARRAY : org.apache.commons.lang3.tuple.Pair<any, any>[];
        get left(): L;
        get right(): R;
        get class(): Internal.Class<any>;
        get value(): R;
        get key(): L;
        set value(arg0: R);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace blusunrize.immersiveengineering.mixin.accessors {
    interface EntityAccess {
        setRemainingFireTicks(arg0: number): void;
        getRemainingFireTicks(): number;
    }
}
declare namespace com.jozufozu.flywheel.api.vertex {
    interface VertexType {
        createWriter(arg0: Internal.ByteBuffer): Internal.VertexWriter;
        getLayout(): Internal.BufferLayout;
        getStride(): number;
        byteOffset(arg0: number): number;
        createReader(arg0: Internal.ByteBuffer, arg1: number): Internal.VertexList;
        getShaderHeader(): string;
    }
}
declare namespace dev.latvian.mods.rhino.util.unit {
    abstract class Unit {
        getClass(): Internal.Class<any>;
        sub(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mod(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        mul(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        log(): dev.latvian.mods.rhino.util.unit.Unit;
        log1p(): dev.latvian.mods.rhino.util.unit.Unit;
        log10(): dev.latvian.mods.rhino.util.unit.Unit;
        cos(): dev.latvian.mods.rhino.util.unit.Unit;
        notifyAll(): void;
        deg(): dev.latvian.mods.rhino.util.unit.Unit;
        lt(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        atan(): dev.latvian.mods.rhino.util.unit.Unit;
        notify(): void;
        getAsInt(): number;
        div(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        neg(): dev.latvian.mods.rhino.util.unit.Unit;
        not(): dev.latvian.mods.rhino.util.unit.Unit;
        shiftLeft(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        min(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        rad(): dev.latvian.mods.rhino.util.unit.Unit;
        sqrt(): dev.latvian.mods.rhino.util.unit.Unit;
        hashCode(): number;
        and(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        get(): number;
        gte(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        pow(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        sin(): dev.latvian.mods.rhino.util.unit.Unit;
        xor(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        neq(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        lte(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        floor(): dev.latvian.mods.rhino.util.unit.Unit;
        isFixed(): boolean;
        sq(): dev.latvian.mods.rhino.util.unit.Unit;
        atan2(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        tan(): dev.latvian.mods.rhino.util.unit.Unit;
        add(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        or(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        max(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        toBool(): dev.latvian.mods.rhino.util.unit.Unit;
        ceil(): dev.latvian.mods.rhino.util.unit.Unit;
        eq(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        gt(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        shiftRight(with_: dev.latvian.mods.rhino.util.unit.Unit): dev.latvian.mods.rhino.util.unit.Unit;
        abs(): dev.latvian.mods.rhino.util.unit.Unit;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        append(arg0: Internal.StringBuilder): void;
        get asInt(): number;
        get fixed(): boolean;
        get class(): Internal.Class<any>;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace me.jellysquid.mods.sodium.client.util.frustum {
    interface Frustum {
        isBoxVisible(minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number): boolean;
        testBox(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): Internal.Frustum$Visibility;
    }
}
declare namespace java_.util.concurrent {
    interface ScheduledFuture <V> extends Internal.Delayed, java_.util.concurrent.Future<V> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        getDelay(arg0: Internal.TimeUnit): number;
        get(arg0: number, arg1: Internal.TimeUnit): V;
        get(): V;
        compareTo(arg0: Internal.Delayed): number;
        isDone(): boolean;
    }
    interface Future <V> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        get(arg0: number, arg1: Internal.TimeUnit): V;
        get(): V;
        isDone(): boolean;
    }
    interface Callable <V> {
        call(): V;
    }
}
declare namespace net.minecraft.tags {
    interface Tag <T> {
    }
}
declare namespace dev.latvian.mods.rhino {
    interface Function extends Internal.Scriptable, Internal.Callable {
        enumerationIteratorNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        hasInstance(arg0: Internal.Scriptable): boolean;
        setParentScope(arg0: Internal.Scriptable): void;
        getIds(): any[];
        construct(arg0: Internal.Context, arg1: Internal.Scriptable, arg2: any[]): Internal.Scriptable;
        getAllIds(): any[];
        delete(arg0: string): void;
        delete(arg0: number): void;
        put(arg0: number, arg1: Internal.Scriptable, arg2: any): void;
        put(arg0: string, arg1: Internal.Scriptable, arg2: any): void;
        getDefaultValue(arg0: Internal.Class<any>): any;
        setPrototype(arg0: Internal.Scriptable): void;
        getPrototype(): Internal.Scriptable;
        call(arg0: Internal.Context, arg1: Internal.Scriptable, arg2: Internal.Scriptable, arg3: any[]): any;
        get(arg0: number, arg1: Internal.Scriptable): any;
        get(arg0: string, arg1: Internal.Scriptable): any;
        enumerationIteratorHasNext(cx: Internal.Context, currentId: (arg0: any) => void): boolean;
        has(arg0: number, arg1: Internal.Scriptable): boolean;
        has(arg0: string, arg1: Internal.Scriptable): boolean;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
    }
}
declare namespace net.minecraft.core {
    abstract class RegistryAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
}
declare namespace Document {
    class CreateRecipes {
        /**
        * Creates a recipe for Crushing Wheels.
        *
        * Specifying chances on outputs will make them output with chance.
        */
        crushing(outputs: Internal.ItemStackJS[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Millstone.
        *
        * Specifying chances on outputs will make them output with chance.
        */
        milling(outputs: Internal.ItemStackJS[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Compacting.
        */
        compacting(output: Type.ItemStackOrFluid, inputs: Type.IngredientOrFluid[]): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Mixing.
        */
        mixing(output: Type.ItemStackOrFluid, inputs: Type.IngredientOrFluid[]): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Pressing.
        *
        * Pressing uses Depot or Belt as container, and can only have 1 item slot as input.
        *
        * Pressing is available as an Assembly step.
        */
        pressing(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Deploying.
        *
        * Deploying is available as an Assembly step.
        */
        deploying(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Cutting.
        *
        * Cutting is available as an Assembly step.
        */
        cutting(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Filling.
        *
        * Filling is available as an Assembly step.
        */
        filling(output: Internal.ItemStackJS, input: Type.IngredientOrFluid[]): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Sequenced Assembly.
        *
        * The sequnce must use recipes which is available for Assembly.
        */
        sequenced_assembly(output: Internal.ItemStackJS[], input: Internal.IngredientJS, sequence: Internal.ProcessingRecipeJS[]): Internal.SequencedAssemblyRecipeJS;
        /**
        * Creates a recipe for Splashing.
        */
        splashing(output: Internal.ItemStackJS[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Haunting.
        */
        haunting(output: Internal.ItemStackJS[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Sandpaper Polishing.
        */
        sandpaper_polishing(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Mechanical Crafting.
        */
        mechanical_crafting(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ProcessingRecipeJS;
        /**
        * Creates a recipe for Emptying.
        */
        emptying(output: Type.ItemStackOrFluid[], input: Internal.IngredientJS): Internal.ProcessingRecipeJS;
    }
    class RecipeHolder {
        /**
        * All recipes from Create.
        */
        readonly create: Document.CreateRecipes;
        /**
        * All recipes from Minecraft.
        */
        readonly minecraft: Document.MinecraftRecipes;
    }
    class MinecraftRecipes {
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Furnaces.
        */
        smelting(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Smokers.
        */
        smoking(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Blast Furnaces.
        */
        blasting(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a shaped crafting recipe.
        */
        crafting_shaped(output: Internal.ItemStackJS, pattern: string[], items: Internal.Map<string, Internal.IngredientJS>): Internal.ShapedRecipeJS;
        /**
        * Adds a shapeless crafting recipe.
        */
        crafting_shapeless(output: Internal.ItemStackJS, inputs: Internal.IngredientJS[]): Internal.ShapelessRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Camefire.
        */
        camefire_cooking(output: Internal.ItemStackJS, input: Internal.IngredientJS): Internal.CookingRecipeJS;
        /**
        * Adds a stonecutting recipe.
        */
        stonecutting(output: Internal.ItemStackJS, inputs: Internal.IngredientJS): Internal.StonecuttingRecipeJS;
        /**
        * Adds a smithing recipe.
        */
        smithing(output: Internal.ItemStackJS, base: Internal.IngredientJS, addition: Internal.IngredientJS): Internal.SmithingRecipeJS;
    }
}
declare namespace Type {
    type ItemStackOrFluid = Internal.ItemStackJS | Internal.FluidStackJS;
    type IngredientOrFluid = Internal.IngredientJS | Internal.FluidStackJS;
}
